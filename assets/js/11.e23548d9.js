(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{371:function(t,a,v){"use strict";v.r(a);var _=v(1),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("img",{staticClass:"lazy",attrs:{alt:"image","data-src":"https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.2bfuvnqxdqtc.webp",loading:"lazy"}})]),t._v(" "),a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[t._v("数据结构是计算机科学的关键内容，也是构建高效算法的必要基础。本话题旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧。")]),t._v(" "),a("p",[t._v("数据结构是计算机存储、组织数据的方式，指相互之间存在"),a("strong",[t._v("一种或多种特定关系的数据元素的集合")]),t._v("。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。")]),t._v(" "),a("p",[t._v("数据结构往往同高效的检索算法和索引技术有关。数据结构可以分为"),a("strong",[t._v("逻辑结构")]),t._v("和"),a("strong",[t._v("存储结构")]),t._v("，有四类基本逻辑结构：集合、线性结构、树形结构、图状结构。这几类结构有以下几个特点：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("集合结构：除了同属于一种类型外，别无其它关系。")])]),t._v(" "),a("li",[a("p",[t._v("线性结构：元素之间存在一对一关系。常见类型有：数组、链表、队列、栈。它们之间在操作上有所区别。例如：链表可在任意位置插入或删除元素，而队列在队尾插入元素、队头删除元素，栈只能在栈顶进行插入，删除操作。")])]),t._v(" "),a("li",[a("p",[t._v("树形结构：元素之间存在一对多关系。常见类型有：树 (有许多特例：二叉树、平衡二叉树、查找树等)。")])]),t._v(" "),a("li",[a("p",[t._v("图形结构：元素之间存在多对多关系，图形结构中每个结点的前驱结点数和后续结点多个数可以任意。")])])]),t._v(" "),a("h2",{attrs:{id:"数据结构的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的类型"}},[t._v("#")]),t._v(" 数据结构的类型")]),t._v(" "),a("p",[t._v("有两种类型的数据结构：原始（Primitive）数据结构、非原始（Non-primitive）数据结构。")]),t._v(" "),a("p",[t._v("原始数据结构：原始数据结构是原始的数据类型。int、char、float、double 和 pointer 是可以保存单个值的原始数据结构。")]),t._v(" "),a("p",[t._v("非原始数据结构：非原始数据结构分为两种类型。线性数据结构、非线性数据结构。")]),t._v(" "),a("p",[t._v("线性数据结构：")]),t._v(" "),a("p",[t._v("以顺序方式排列的数据被称为线性数据结构。基于此原则的数据结构是数组、链表、堆栈和队列。在这些数据结构中，一个元素只与另一个元素以线性方式连接。")]),t._v(" "),a("p",[t._v('当一个元素与 "n" 个元素相连时，被称为非线性数据结构。最好的例子是树和图。在这种情况下，元素是以随机方式排列的。')]),t._v(" "),a("p",[t._v("数据结构也可以分为以下几种：")]),t._v(" "),a("ul",[a("li",[t._v("静态数据结构。这是一种数据结构，其大小是在编译时分配的。因此，最大尺寸是固定的。")]),t._v(" "),a("li",[t._v("动态数据结构。它是一种数据结构类型，其大小在运行时分配。因此，最大尺寸是灵活的。")])]),t._v(" "),a("h2",{attrs:{id:"主要操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要操作"}},[t._v("#")]),t._v(" 主要操作")]),t._v(" "),a("p",[t._v("可以在数据结构上进行的主要或常见的操作是：")]),t._v(" "),a("ul",[a("li",[t._v("搜索：可以在一个数据结构中搜索任何元素。")]),t._v(" "),a("li",[t._v("排序。可以按照升序或降序对数据结构中的元素进行排序。")]),t._v(" "),a("li",[t._v("插入。也可以在一个数据结构中插入新的元素。")]),t._v(" "),a("li",[t._v("更新。也可以更新元素，也就是说，我们可以用另一个元素替换这个元素。")]),t._v(" "),a("li",[t._v("删除。也可以执行删除操作，将该元素从数据结构中删除。")])]),t._v(" "),a("h2",{attrs:{id:"如何选择数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择数据结构"}},[t._v("#")]),t._v(" 如何选择数据结构")]),t._v(" "),a("p",[t._v("数据结构是一种组织数据的方式，以便能够有效地使用它。在这里，我们使用了高效这个词，从空间和时间两方面来说。例如，堆栈是一个 ADT（"),a("strong",[t._v("抽象数据类型")]),t._v("），它使用数组或链接列表数据结构来实现。因此，我们得出结论，我们需要一些数据结构来实现一个特定的 ADT。")]),t._v(" "),a("p",[t._v("一个 ADT 告诉我们要做什么，而数据结构告诉我们如何去做。换句话说，我们可以说 ADT 给了我们蓝图，而数据结构提供了实现部分。现在问题来了：如何才能知道哪种数据结构可用于某个特定的 ADT？")]),t._v(" "),a("p",[t._v("因为不同的数据结构可以在一个特定的 ADT 中实现，但不同的实现方式要在时间和空间上进行比较。例如，堆栈 ADT 可以由数组和链表来实现。假设数组提供的是时间效率，而链表提供的是空间效率，那么就会选择最适合当前用户需求的那一种。")]),t._v(" "),a("h2",{attrs:{id:"数据结构的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的优点"}},[t._v("#")]),t._v(" 数据结构的优点")]),t._v(" "),a("p",[t._v("以下是数据结构的优点：")]),t._v(" "),a("ul",[a("li",[t._v("效率。如果为实现一个特定的 ADT 而选择的数据结构是恰当的，那么它将使程序在时间和空间上非常有效。")]),t._v(" "),a("li",[t._v("可重用性。数据结构提供了重用性，意味着多个客户程序可以使用该数据结构。")]),t._v(" "),a("li",[t._v("抽象性。ADT 所指定的数据结构也提供了抽象的层次。客户端不能看到数据结构的内部工作，所以它不必担心实现部分的问题。客户端只能看到接口。")])]),t._v(" "),a("h2",{attrs:{id:"常见数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见数据结构"}},[t._v("#")]),t._v(" 常见数据结构")]),t._v(" "),a("h3",{attrs:{id:"数组-array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组-array"}},[t._v("#")]),t._v(" 数组（Array）")]),t._v(" "),a("p",[t._v("数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。")]),t._v(" "),a("h3",{attrs:{id:"栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[t._v("#")]),t._v(" 栈（Stack）")]),t._v(" "),a("p",[t._v("栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。")]),t._v(" "),a("h3",{attrs:{id:"队列-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列-queue"}},[t._v("#")]),t._v(" 队列（Queue）")]),t._v(" "),a("p",[t._v("队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。")]),t._v(" "),a("h3",{attrs:{id:"链表-linked-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表-linked-list"}},[t._v("#")]),t._v(" 链表（Linked List）")]),t._v(" "),a("p",[t._v("链表是一种数据元素按照"),a("strong",[t._v("链式存储结构")]),t._v("进行存储的数据结构，这种存储结构具有在物理上存在"),a("strong",[t._v("非连续")]),t._v("的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。")]),t._v(" "),a("h3",{attrs:{id:"树-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#树-tree"}},[t._v("#")]),t._v(" 树（Tree）")]),t._v(" "),a("p",[t._v("树是典型的"),a("strong",[t._v("非线性结构")]),t._v("，它是包括，"),a("strong",[t._v("2 个结点的有穷集合 K")]),t._v("。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点。")]),t._v(" "),a("ul",[a("li",[t._v("二叉树")]),t._v(" "),a("li",[t._v("遍历二叉树：前序（先中间，再左边，后右边）；中序（先左边，再中间，后右边）；后序（先左边，再右边，后中间）。")]),t._v(" "),a("li",[t._v("线索二叉树：用二插链表实现的二叉树，将那些没有使用的左右指针指向前驱和后继（前驱和后继就是遍历后（例如用中序遍历）的数据序列某一个数据的前面和后面的数据），形成的二叉树为线索二叉树。一般用在经常遍历和利用前驱和后继查找结构的情况。")]),t._v(" "),a("li",[t._v("赫夫曼树：用于压缩。")]),t._v(" "),a("li",[t._v("二叉排序树：根节点的左子树若不为空，则左子树所有节点都小于根节点。根节点的右子树若不为空，则右子树所有节点都大于根结点。根节点的左右子树不为空，则其都是二叉平衡树。")]),t._v(" "),a("li",[t._v("平衡二叉树：一颗左右子树高度差至多等于 1 的二叉排序树。添加节点的时候，根据不平衡子树左旋右，保证最后的树是平衡的。优点：查找，插入，删除时间复杂度都是：O（logn）。")]),t._v(" "),a("li",[t._v("多路查找树：结点的孩子不止为两个，结点存的值补位一个。如 2-3 树，2-3-4 树，B 树，B + 树")]),t._v(" "),a("li",[t._v("红黑树：也是二叉排序树。利用一个结点的属性表明这个结点是红是黑。查找等同于二叉排序树。插入和删除利用这个颜色属性来保证操作之后树还是平衡的。所以查找，插入和删除的时间复杂度都是：O（logn）。统计性能比平衡二叉树好。")]),t._v(" "),a("li",[t._v("堆：二叉树，分为大顶堆，小顶堆。大顶堆的要求是每个节点的值都不大于其父节点的值，小顶堆反过来。")])]),t._v(" "),a("h3",{attrs:{id:"图-graph"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图-graph"}},[t._v("#")]),t._v(" 图（Graph）")]),t._v(" "),a("p",[t._v("图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。")]),t._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"image","data-src":"https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.5hv3kskozyo0.webp",loading:"lazy"}})]),t._v(" "),a("p",[t._v("五种构造图的方式：")]),t._v(" "),a("ul",[a("li",[t._v("遍历：")])]),t._v(" "),a("p",[t._v("深度优先：一个劲的朝一个方向使劲，当重复了就返回。")]),t._v(" "),a("p",[t._v("广度优先：先从一个顶点触发，拿到这个顶点，再把与这个顶点相关的顶点放入队列，再从队列取数据，再把与这个新取的顶点相关的顶点（非重复过的顶点）放入队列，依次同理操作")]),t._v(" "),a("ul",[a("li",[t._v("最小生成树：")])]),t._v(" "),a("p",[t._v("普里姆（Prim）算法：O (n2)")]),t._v(" "),a("p",[t._v("克鲁斯卡尔（Kruskal）算法：O (e*loge)")]),t._v(" "),a("ul",[a("li",[t._v("最短路径：")])]),t._v(" "),a("p",[t._v("迪杰斯特拉（Dijkstra）算法 O (n3)")]),t._v(" "),a("p",[t._v("弗洛伊德（Floyd）算法 O (n3)")]),t._v(" "),a("ul",[a("li",[t._v("拓扑排序：AOV 网：用顶点表示活动，用弧表示优先关系的有向图。")])]),t._v(" "),a("p",[t._v("拓扑排序算法：O (n+e)  n 个顶点 e 条边")]),t._v(" "),a("ul",[a("li",[t._v("关键路径：AOE 网：用顶点表示时间，用有向边表示活动，用边的权值表示持续的时间的有向图。")])]),t._v(" "),a("p",[t._v("关键算法路径：O (n+e)")]),t._v(" "),a("h3",{attrs:{id:"堆-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[t._v("#")]),t._v(" 堆（Heap）")]),t._v(" "),a("p",[t._v("堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。")]),t._v(" "),a("h3",{attrs:{id:"散列表-hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#散列表-hash"}},[t._v("#")]),t._v(" 散列表 (Hash）")]),t._v(" "),a("p",[t._v("散列表源自于散列函数 (Hash function)，其思想是如果在结构中存在关键字和 T 相等的记录，那么必定在 F (T) 的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/datastructures-js",target:"_blank",rel:"noopener noreferrer"}},[t._v("datastructures-js"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://docs.jonsam.site/project-17/",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构与算法（DSA）"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://source.jonsam.site/immutable/index/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ImmutableJs 源码解读"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.geeksforgeeks.org/data-structures/?ref=shm",target:"_blank",rel:"noopener noreferrer"}},[t._v("Data Structures - GeeksforGeeks"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-basic-overview.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("♥数据结构基础知识体系详解♥ | Java 全栈知识体系"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);