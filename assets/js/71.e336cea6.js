(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{431:function(s,t,n){"use strict";n.r(t);var a=n(1),e=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[s._v("#")]),s._v(" 介绍")]),s._v(" "),t("p",[s._v("子集之和问题是指从一个给定的集合中找到元素的子集，这些元素的总和等于一个给定的数字 K，我们考虑的是这个集合只包含非负值。假设输入的集合是唯一的（没有重复的）。")]),s._v(" "),t("p",[s._v("子集之和的穷举式搜索算法：")]),s._v(" "),t("p",[s._v("寻找和为 K 的子集的一种方法是考虑所有可能的子集。一个幂集包含了从一个给定的集合产生的所有子集。这样一个"),t("a",{attrs:{href:"https://www.wikiwand.com/zh-hans/%E5%86%AA%E9%9B%86",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[s._v("幂集")]),t("OutboundLink")],1),s._v("的大小是 2"),t("sup",[s._v("N")]),s._v("。集合的幂集（英语：power set），定义为由该集合全部子集为元素构成的集合。")]),s._v(" "),t("p",[s._v("子集之和的回溯算法：")]),s._v(" "),t("p",[s._v("使用穷举搜索，我们考虑所有的子集，不管它们是否满足给定的约束。回溯算法（Backtracking）可以用来对要选择的元素进行系统的考虑。\n假设给定的 4 个元素的集合，例如 "),t("code",[s._v("w[1]...w[4]")]),s._v(" 。树可以用来设计回溯算法。下面的树描述了生成可变大小元组（tuple）的方法。")]),s._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"image","data-src":"https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.2t6ox5bbss80.webp",loading:"lazy"}})]),s._v(" "),t("p",[s._v("当我们沿着树的深度往下走时，我们会添加到目前为止的元素，如果添加的总和满足明确的约束，我们将继续进一步生成子节点。只要不满足约束条件，我们就停止进一步生成该节点的子树，并回溯到前一个节点，探索尚未探索的节点。在许多情况下，它可以节省大量的处理时间。")]),s._v(" "),t("p",[s._v("伪代码：")]),s._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-txt"}},[t("code",[s._v("if(subset is satisfying the constraint)\n    print the subset\n    exclude the current element and consider next element\nelse\n    generate the nodes of present level along breadth of tree and\n    recur for next levels\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("当我们结合显性和隐性约束（constraints）时，回溯的力量就出现了，当这些检查失败时，我们就停止生成节点。我们可以通过加强约束检查和对数据进行预排序（presorting）来改进上述算法。通过对初始数组进行排序，一旦到目前为止的总和大于目标数，我们就不需要考虑数组的其他部分（如果子树不满足约束条件，它就会修剪子树）。我们可以回溯并检查其他的可能性。")]),s._v(" "),t("p",[s._v("同样地，假设数组被预排序，我们找到了一个子集。只有当下一个节点满足约束条件时，我们才能生成排除当前节点的下一个节点。")]),s._v(" "),t("h2",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[s._v("#")]),s._v(" 实现")]),s._v(" "),t("h3",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[s._v("#")]),s._v(" JavaScript")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n *\n *  Sum of Subset problem\n *\n *  Given an ordered set W of non-negative integers and a value K,\n *  determine all possible subsets from the given set W whose sum\n *  of its elements equals to the given value K.\n *\n *  More info: https://www.geeksforgeeks.org/subset-sum-backtracking-4/\n */")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n * @param {number[]} set Original set of numbers\n * @param {number[]} subset Subset being evaluated\n * @param {number} setIndex Index from set of last element in subset\n * @param {number} Sum of elements from subset\n * @param {targetSum} The target sum on which the subset sum is compared to\n * @returns {number[][]} Subsets whose elements add up to targetSum\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("sumOfSubset")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("set"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" subset"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" setindex"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" sum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" targetSum")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Base case where the subset sum is equal to target sum")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Evaluation of following subsets on this path will always add up to")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// greater than targetSum, so no need to continue")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("===")]),s._v(" targetSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("subset"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// This and following subsets on this path will always add up to")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// greater than targetSum, so no need to continue")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" targetSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Initialize results array. Will contain only valid subsets")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" results "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Slice gets from the set all the elements at the right of the last element")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// to be evaluated (last element of subset)")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// forEach iterated on the resulting array")]),s._v("\n  set"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("slice")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("setindex"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("forEach")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" index")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// The next subset to be evaluated, current subset plus next element")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" nextSubset "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("subset"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Next index from the set. Current set index plus iteration index")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// index starts at 0, so a + 1 is required")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" nextSetIndex "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" setindex "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" index "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Sum of elements from the next subset to be evaluated")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" nextSum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" num\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Call recursively the sumOfSubset for the nextSubset")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" subsetResult "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("sumOfSubset")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("\n      set"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n      nextSubset"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n      nextSetIndex"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n      nextSum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n      targetSum\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Concat the recursive result with current result array")]),s._v("\n    results "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("results"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("subsetResult"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// Return results")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" results\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br"),t("span",{staticClass:"line-number"},[s._v("36")]),t("br"),t("span",{staticClass:"line-number"},[s._v("37")]),t("br"),t("span",{staticClass:"line-number"},[s._v("38")]),t("br"),t("span",{staticClass:"line-number"},[s._v("39")]),t("br"),t("span",{staticClass:"line-number"},[s._v("40")]),t("br"),t("span",{staticClass:"line-number"},[s._v("41")]),t("br"),t("span",{staticClass:"line-number"},[s._v("42")]),t("br"),t("span",{staticClass:"line-number"},[s._v("43")]),t("br"),t("span",{staticClass:"line-number"},[s._v("44")]),t("br"),t("span",{staticClass:"line-number"},[s._v("45")]),t("br"),t("span",{staticClass:"line-number"},[s._v("46")]),t("br"),t("span",{staticClass:"line-number"},[s._v("47")]),t("br"),t("span",{staticClass:"line-number"},[s._v("48")]),t("br"),t("span",{staticClass:"line-number"},[s._v("49")]),t("br"),t("span",{staticClass:"line-number"},[s._v("50")]),t("br"),t("span",{staticClass:"line-number"},[s._v("51")]),t("br"),t("span",{staticClass:"line-number"},[s._v("52")]),t("br"),t("span",{staticClass:"line-number"},[s._v("53")]),t("br"),t("span",{staticClass:"line-number"},[s._v("54")]),t("br"),t("span",{staticClass:"line-number"},[s._v("55")]),t("br"),t("span",{staticClass:"line-number"},[s._v("56")]),t("br"),t("span",{staticClass:"line-number"},[s._v("57")]),t("br"),t("span",{staticClass:"line-number"},[s._v("58")]),t("br"),t("span",{staticClass:"line-number"},[s._v("59")]),t("br"),t("span",{staticClass:"line-number"},[s._v("60")]),t("br"),t("span",{staticClass:"line-number"},[s._v("61")]),t("br"),t("span",{staticClass:"line-number"},[s._v("62")]),t("br")])]),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.geeksforgeeks.org/subset-sum-backtracking-4/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Subset Sum | Backtracking-4 - GeeksforGeeks"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=e.exports}}]);