(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],u=0,d=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&d.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(h&&h(e);d.length;)d.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"99f70505",3:"d1c1b263",4:"0809c88f",5:"1008edee",6:"aae8cd39",7:"f8bb4c6b",8:"3e1ca7f2",9:"19b9d5ce",10:"ee4dc233",11:"e23548d9",12:"8f5dd883",13:"28c6f799",14:"d0d8ded1",15:"37bbbdf1",16:"9440e6ba",17:"3ee29780",18:"d496c696",19:"25d8619c",20:"510c51e1",21:"34018f1d",22:"a5ab48d2",23:"657ac09a",24:"618c06e4",25:"a0b64b6b",26:"600f5da0",27:"5f8c4483",28:"d69ef5b8",29:"67bf3468",30:"ce63c1bf",31:"df0328db",32:"51e55bd2",33:"9d31fd5f",34:"742f8e7e",35:"bc09eb93",36:"641ed9ee",37:"c96daa8f",38:"538049fa",39:"3cb61da5",40:"13df92ac",41:"c0b613a0",42:"4a298b47",43:"446b39fc",44:"36c5426e",45:"5b3b5200",46:"5ef95bd0",47:"504b76f5",48:"160df44b",49:"2ee91a38",50:"c26a2438",51:"d6b1e9df",52:"dfeb7c77",53:"d6372740",54:"2f7f534b",55:"e1ada02e",56:"21ed8f61",57:"ab760561",58:"b8d060c7",59:"8448d4a3",60:"5ef15155",61:"ca3374a3",62:"31891110",63:"4449d1e7",64:"0100b79b",65:"9d8cf504",66:"8a2920a5",67:"26730556",68:"8fd84cbf",69:"e16a8b0c",70:"37a112ac",71:"e336cea6",72:"f45223b4",73:"736a7ee0",74:"cf064580",75:"5dbb38f0",76:"fbf9a06c",77:"af70dfa8",78:"97678333",79:"2e4ccbe1",80:"18a2c53a",81:"b6bb9de5",82:"c4b54d94",83:"fb714f89",84:"af13bd3f",85:"77950023",86:"53468a5f",87:"153a5f78",88:"fabe930e",89:"5ced3531",90:"62e199d2",91:"b7b26275",92:"ef23522e",93:"7f84fa86",94:"4eb1ab11",95:"d9a9fbe1",96:"e1543385",97:"204b7119",98:"7de17124",99:"c485fbc5",100:"f451641b",101:"3cda3408",102:"699c7ad7",103:"c87fcec3",104:"9e7a10d1",105:"574f860f",106:"35ee8757",107:"94d2a74a",108:"8cb63ad5",109:"0dca844e",110:"cf2942fe",111:"b88f9220",112:"8a7925be",113:"5cb1f241",114:"2d5067d4",115:"ebfb16bc",116:"8e79aa04",117:"c791df25",118:"02371379",119:"7f5ffbe1",120:"893b8ea4",121:"0acbf820",122:"efb479b6",123:"c725f2d1",124:"47798259",125:"d5d9808a",126:"23924ba6",127:"3b09f9e9",128:"57f987a6",129:"460619a8",130:"a20d0d99",131:"00bbea0a",132:"984c8199",133:"f0c5696b",134:"e9311d75",135:"1c1f4395",136:"314c81a6",137:"d67476b6",138:"309ec48a",139:"38294883",140:"5cab5463",141:"999ccb91",142:"43cefb48",143:"69d1d419",144:"9eb1f7e8",145:"5e6f127a",146:"eb72396e",147:"e9a8d6f8",148:"a5c4f1f4",149:"f315c5a7",150:"0d1d4ee3",151:"3497faec",152:"c147c701",153:"7fcacd42",154:"2a401d31",155:"d10993e5",156:"f86e9d84",157:"ee5ed6c9",158:"6d841cbd",159:"35b72084",160:"e27343b7",161:"124a9479",162:"f5380ebb",163:"c52cc92d",164:"b7cc6ef4",165:"36ad44a8",166:"a035405a",167:"8d2c55a5",168:"7aeb0ca7",169:"79f3c4da",170:"d35522bc",171:"6f53eecd",172:"5b3454d7",173:"59282cc6",174:"278704fb",175:"f9006a4d",176:"1ffce20c",177:"9837a6c3",178:"a16db77b",179:"d8f70a36",180:"84a4d27f",181:"6637f17c",182:"88c1a4b5",183:"f2edd18c",184:"d6facabc",185:"f637e3b5",186:"f6c9ff5b",187:"fda04c72",188:"56bdea83",189:"6875a763",190:"efd660a2",191:"cc23e09d",192:"f2354b8d",193:"031ab785",194:"fe990cb2",195:"aa0fc924",196:"e988c14b",197:"86907415",198:"3d113936",199:"e7e4d88f",200:"f3784613"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var h=l;a.push([113,0]),t()}([function(n,e,t){"use strict";t.r(e),function(n){t.d(e,"EffectScope",(function(){return be})),t.d(e,"computed",(function(){return se})),t.d(e,"customRef",(function(){return ne})),t.d(e,"default",(function(){return Zr})),t.d(e,"defineAsyncComponent",(function(){return It})),t.d(e,"defineComponent",(function(){return Ht})),t.d(e,"del",(function(){return Ln})),t.d(e,"effectScope",(function(){return ye})),t.d(e,"getCurrentInstance",(function(){return dn})),t.d(e,"getCurrentScope",(function(){return we})),t.d(e,"h",(function(){return dt})),t.d(e,"inject",(function(){return je})),t.d(e,"isProxy",(function(){return Vn})),t.d(e,"isReactive",(function(){return Rn})),t.d(e,"isReadonly",(function(){return Un})),t.d(e,"isRef",(function(){return $n})),t.d(e,"isShallow",(function(){return Fn})),t.d(e,"markRaw",(function(){return Hn})),t.d(e,"mergeDefaults",(function(){return st})),t.d(e,"nextTick",(function(){return Tt})),t.d(e,"onActivated",(function(){return Dt})),t.d(e,"onBeforeMount",(function(){return At})),t.d(e,"onBeforeUnmount",(function(){return Lt})),t.d(e,"onBeforeUpdate",(function(){return Ot})),t.d(e,"onDeactivated",(function(){return Bt})),t.d(e,"onErrorCaptured",(function(){return Vt})),t.d(e,"onMounted",(function(){return Pt})),t.d(e,"onRenderTracked",(function(){return Rt})),t.d(e,"onRenderTriggered",(function(){return Ft})),t.d(e,"onScopeDispose",(function(){return xe})),t.d(e,"onServerPrefetch",(function(){return Mt})),t.d(e,"onUnmounted",(function(){return Nt})),t.d(e,"onUpdated",(function(){return qt})),t.d(e,"provide",(function(){return ke})),t.d(e,"proxyRefs",(function(){return Xn})),t.d(e,"reactive",(function(){return Dn})),t.d(e,"readonly",(function(){return re})),t.d(e,"ref",(function(){return Gn})),t.d(e,"set",(function(){return qn})),t.d(e,"shallowReactive",(function(){return Bn})),t.d(e,"shallowReadonly",(function(){return oe})),t.d(e,"shallowRef",(function(){return Wn})),t.d(e,"toRaw",(function(){return Jn})),t.d(e,"toRef",(function(){return te})),t.d(e,"toRefs",(function(){return ee})),t.d(e,"triggerRef",(function(){return Qn})),t.d(e,"unref",(function(){return Zn})),t.d(e,"useAttrs",(function(){return it})),t.d(e,"useCssModule",(function(){return Et})),t.d(e,"useCssVars",(function(){return Ct})),t.d(e,"useListeners",(function(){return at})),t.d(e,"useSlots",(function(){return rt})),t.d(e,"version",(function(){return Jt})),t.d(e,"watch",(function(){return ge})),t.d(e,"watchEffect",(function(){return ue})),t.d(e,"watchPostEffect",(function(){return de})),t.d(e,"watchSyncEffect",(function(){return pe}));
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),i=Array.isArray;function a(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function h(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var x=Object.prototype.hasOwnProperty;function k(n,e){return x.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,_=S((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),T=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,C=S((function(n){return n.replace(E,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function A(n,e){for(var t in e)n[t]=e[t];return n}function P(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function O(n,e,t){}var q=function(n,e,t){return!1},L=function(n){return n};function N(n,e){if(n===e)return!0;var t=h(n),r=h(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return N(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return N(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(N(n[t],e))return t;return-1}function B(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function M(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var R=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:q,isReservedAttr:q,isUnknownElement:q,getTagNamespace:O,parsePlatformTagName:L,mustUseProp:q,async:!0,_lifecycleHooks:F},V=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function J(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var $=new RegExp("[^".concat(V.source,".$_\\d]"));var G="__proto__"in{},W="undefined"!=typeof window,K=W&&window.navigator.userAgent.toLowerCase(),Q=K&&/msie|trident/.test(K),Z=K&&K.indexOf("msie 9.0")>0,X=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Y=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(W)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!W&&void 0!==n&&(n.process&&"server"===n.process.env.VUE_ENV)),nn},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,hn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function dn(){return un&&{proxy:un}}function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,i,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function vn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,yn=[],wn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,yn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();wn.target=null;var xn=[];function kn(n){xn.push(n),wn.target=n}function Sn(){xn.pop(),wn.target=xn[xn.length-1]}var jn=Array.prototype,_n=Object.create(jn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=jn[n];H(_n,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var Tn=Object.getOwnPropertyNames(_n),En={},Cn=!0;function In(n){Cn=n}var zn={notify:O,depend:O,addSub:O,removeSub:O},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new wn,this.vmCount=0,H(n,"__ob__",this),i(n)){if(!t)if(G)n.__proto__=_n;else for(var r=0,a=Tn.length;r<a;r++){H(n,s=Tn[r],_n[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;On(n,s=o[r],En,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!Cn||!t&&on()||!i(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||$n(n)||n instanceof mn?void 0:new An(n,e,t)}function On(n,e,t,r,a,o){var s=new wn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,h=l&&l.set;c&&!h||t!==En&&2!==arguments.length||(t=n[e]);var u=!a&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return wn.target&&(s.depend(),u&&(u.dep.depend(),i(e)&&Nn(e))),$n(e)&&!a?e.value:e},set:function(e){var r=c?c.call(n):t;if(M(r,e)){if(h)h.call(n,e);else{if(c)return;if(!a&&$n(r)&&!$n(e))return void(r.value=e);t=e}u=!a&&Pn(e,!1,o),s.notify()}}}),s}}function qn(n,e,t){if(!Un(n)){var r=n.__ob__;return i(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(On(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Ln(n,e){if(i(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Un(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function Nn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Nn(e)}function Dn(n){return Mn(n,!1),n}function Bn(n){return Mn(n,!0),H(n,"__v_isShallow",!0),n}function Mn(n,e){if(!Un(n)){Pn(n,e,on());0}}function Rn(n){return Un(n)?Rn(n.__v_raw):!(!n||!n.__ob__)}function Fn(n){return!(!n||!n.__v_isShallow)}function Un(n){return!(!n||!n.__v_isReadonly)}function Vn(n){return Rn(n)||Un(n)}function Jn(n){var e=n&&n.__v_raw;return e?Jn(e):n}function Hn(n){return Object.isExtensible(n)&&H(n,"__v_skip",!0),n}function $n(n){return!(!n||!0!==n.__v_isRef)}function Gn(n){return Kn(n,!1)}function Wn(n){return Kn(n,!0)}function Kn(n,e){if($n(n))return n;var t={};return H(t,"__v_isRef",!0),H(t,"__v_isShallow",e),H(t,"dep",On(t,"value",n,null,e,on())),t}function Qn(n){n.dep&&n.dep.notify()}function Zn(n){return $n(n)?n.value:n}function Xn(n){if(Rn(n))return n;for(var e={},t=Object.keys(n),r=0;r<t.length;r++)Yn(e,n,t[r]);return e}function Yn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if($n(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];$n(r)&&!$n(n)?r.value=n:e[t]=n}})}function ne(n){var e=new wn,t=n((function(){e.depend()}),(function(){e.notify()})),r=t.get,i=t.set,a={get value(){return r()},set value(n){i(n)}};return H(a,"__v_isRef",!0),a}function ee(n){var e=i(n)?new Array(n.length):{};for(var t in n)e[t]=te(n,t);return e}function te(n,e,t){var r=n[e];if($n(r))return r;var i={get value(){var r=n[e];return void 0===r?t:r},set value(t){n[e]=t}};return H(i,"__v_isRef",!0),i}function re(n){return ie(n,!1)}function ie(n,e){if(!d(n))return n;if(Un(n))return n;var t=e?"__v_rawToShallowReadonly":"__v_rawToReadonly",r=n[t];if(r)return r;var i=Object.create(Object.getPrototypeOf(n));H(n,t,i),H(i,"__v_isReadonly",!0),H(i,"__v_raw",n),$n(n)&&H(i,"__v_isRef",!0),(e||Fn(n))&&H(i,"__v_isShallow",!0);for(var a=Object.keys(n),o=0;o<a.length;o++)ae(i,n,a[o],e);return i}function ae(n,e,t,r){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];return r||!d(n)?n:re(n)},set:function(){}})}function oe(n){return ie(n,!0)}function se(n,e){var t,r,i=c(n);i?(t=n,r=O):(t=n.get,r=n.set);var a=on()?null:new Qt(un,t,O,{lazy:!0});var o={effect:a,get value(){return a?(a.dirty&&a.evaluate(),wn.target&&a.depend(),a.value):t()},set value(n){r(n)}};return H(o,"__v_isRef",!0),H(o,"__v_isReadonly",i),o}var le="".concat("watcher"," callback"),ce="".concat("watcher"," getter"),he="".concat("watcher"," cleanup");function ue(n,e){return ve(n,null,e)}function de(n,e){return ve(n,null,{flush:"post"})}function pe(n,e){return ve(n,null,{flush:"sync"})}var me,fe={};function ge(n,e,t){return ve(n,e,t)}function ve(n,e,t){var a=void 0===t?r:t,o=a.immediate,s=a.deep,l=a.flush,h=void 0===l?"pre":l;a.onTrack,a.onTrigger;var u,d,p=un,m=function(n,e,t){return void 0===t&&(t=null),mt(n,null,t,p,e)},f=!1,g=!1;if($n(n)?(u=function(){return n.value},f=Fn(n)):Rn(n)?(u=function(){return n.__ob__.dep.depend(),n},s=!0):i(n)?(g=!0,f=n.some((function(n){return Rn(n)||Fn(n)})),u=function(){return n.map((function(n){return $n(n)?n.value:Rn(n)?Gt(n):c(n)?m(n,ce):void 0}))}):u=c(n)?e?function(){return m(n,ce)}:function(){if(!p||!p._isDestroyed)return d&&d(),m(n,"watcher",[b])}:O,e&&s){var v=u;u=function(){return Gt(v())}}var b=function(n){d=y.onStop=function(){m(n,he)}};if(on())return b=O,e?o&&m(e,le,[u(),g?[]:void 0,b]):u(),O;var y=new Qt(un,u,O,{lazy:!0});y.noRecurse=!e;var w=g?[]:fe;return y.run=function(){if(y.active)if(e){var n=y.get();(s||f||(g?n.some((function(n,e){return M(n,w[e])})):M(n,w)))&&(d&&d(),m(e,le,[n,w===fe?void 0:w,b]),w=n)}else y.get()},"sync"===h?y.update=y.run:"post"===h?(y.post=!0,y.update=function(){return vr(y)}):y.update=function(){if(p&&p===un&&!p._isMounted){var n=p._preWatchers||(p._preWatchers=[]);n.indexOf(y)<0&&n.push(y)}else vr(y)},e?o?y.run():w=y.get():"post"===h&&p?p.$once("hook:mounted",(function(){return y.get()})):y.get(),function(){y.teardown()}}var be=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=me,!n&&me&&(this.index=(me.scopes||(me.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=me;try{return me=this,n()}finally{me=e}}else 0},n.prototype.on=function(){me=this},n.prototype.off=function(){me=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function ye(n){return new be(n)}function we(){return me}function xe(n){me&&me.cleanups.push(n)}function ke(n,e){un&&(Se(un)[n]=e)}function Se(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}function je(n,e,t){void 0===t&&(t=!1);var r=un;if(r){var i=r.$parent&&r.$parent._provided;if(i&&n in i)return i[n];if(arguments.length>1)return t&&c(e)?e.call(r):e}else 0}var _e=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Te(n,e){function t(){var n=t.fns;if(!i(n))return mt(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)mt(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Ee(n,e,t,r,i,o){var l,c,h,u;for(l in n)c=n[l],h=e[l],u=_e(l),a(c)||(a(h)?(a(c.fns)&&(c=n[l]=Te(c,o)),s(u.once)&&(c=n[l]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==h&&(h.fns=c,n[l]=h));for(l in e)a(n[l])&&r((u=_e(l)).name,e[l],u.capture)}function Ce(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),w(r.fns,l)}a(i)?r=Te([l]):o(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=Te([i,l]),r.merged=!0,n[e]=r}function Ie(n,e,t,r,i){if(o(e)){if(k(e,t))return n[t]=e[t],i||delete e[t],!0;if(k(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function ze(n){return l(n)?[gn(n)]:i(n)?function n(e,t){var r,c,h,u,d=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(h=d.length-1,u=d[h],i(c)?c.length>0&&(Ae((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Ae(u)&&(d[h]=gn(u.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Ae(u)?d[h]=gn(u.text+c):""!==c&&d.push(gn(c)):Ae(c)&&Ae(u)?d[h]=gn(u.text+c.text):(s(e._isVList)&&o(c.tag)&&a(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Ae(n){return o(n)&&o(n.text)&&!1===n.isComment}function Pe(n,e){var t,r,a,s,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(h(n))if(hn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Oe(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=A(A({},r),t)),i=a(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function qe(n){return Lr(this.$options,"filters",n,!0)||L}function Le(n,e){return i(n)?-1===n.indexOf(e):n!==e}function Ne(n,e,t,r,i){var a=U.keyCodes[e]||t;return i&&r&&!U.keyCodes[e]?Le(i,r):a?Le(a,n):r?C(r)!==e:void 0===n}function De(n,e,t,r,a){if(t)if(h(t)){i(t)&&(t=P(t));var o=void 0,s=function(i){if("class"===i||"style"===i||y(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||U.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=_(i),c=C(i);l in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)s(l)}else;return n}function Be(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Re(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function Me(n,e,t){return Re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function Re(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Fe(n[r],"".concat(e,"_").concat(r),t);else Fe(n,e,t)}function Fe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ue(n,e){if(e)if(d(e)){var t=n.on=n.on?A({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function Ve(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];i(o)?Ve(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function Je(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function He(n,e){return"string"==typeof n?e+n:n}function $e(n){n._o=Me,n._n=v,n._s=g,n._l=Pe,n._t=Oe,n._q=N,n._i=D,n._m=Be,n._f=qe,n._k=Ne,n._b=De,n._v=gn,n._e=fn,n._u=Ve,n._g=Ue,n._d=Je,n._p=He}function Ge(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(We)&&delete t[c];return t}function We(n){return n.isComment&&!n.asyncFactory||" "===n.text}function Ke(n){return n.isComment&&n.asyncFactory}function Qe(n,e,t,i){var a,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&i&&i!==r&&l===i.$key&&!o&&!i.$hasNormal)return i;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=Ze(n,t,c,e[c]))}else a={};for(var h in t)h in a||(a[h]=Xe(t,h));return e&&Object.isExtensible(e)&&(e._normalized=a),H(a,"$stable",s),H(a,"$key",l),H(a,"$hasNormal",o),a}function Ze(n,e,t,r){var a=function(){var e=un;pn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!i(t)?[t]:ze(t))&&t[0];return pn(e),t&&(!a||1===t.length&&a.isComment&&!Ke(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function Xe(n,e){return function(){return n[e]}}function Ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),nt(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||nt(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||tt(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Yn(n,e,t)}))}}}function nt(n,e,t,r,i){var a=!1;for(var o in e)o in n?e[o]!==t[o]&&(a=!0):(a=!0,et(n,o,r,i));for(var o in n)o in e||(a=!0,delete n[o]);return a}function et(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function tt(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}function rt(){return ot().slots}function it(){return ot().attrs}function at(){return ot().listeners}function ot(){var n=un;return n._setupContext||(n._setupContext=Ye(n))}function st(n,e){var t=i(n)?n.reduce((function(n,e){return n[e]={},n}),{}):n;for(var r in e){var a=t[r];a?i(a)||c(a)?t[r]={type:a,default:e[r]}:a.default=e[r]:null===a&&(t[r]={default:e[r]})}return t}var lt=null;function ct(n,e){return(n.__esModule||hn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),h(n)?e.extend(n):n}function ht(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||Ke(t)))return t}}function ut(n,e,t,r,u,d){return(i(t)||l(t))&&(u=r,r=t,t=void 0),s(d)&&(u=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return fn();o(t)&&o(t.is)&&(e=t.is);if(!e)return fn();0;i(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=ze(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,d;if("string"==typeof e){var p=void 0;d=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),u=U.isReservedTag(e)?new mn(U.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(p=Lr(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):_r(p,t,n,r,e)}else u=_r(e,t,n,r);return i(u)?u:o(u)?(o(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(u,d),o(t)&&function(n){h(n.style)&&Gt(n.style);h(n.class)&&Gt(n.class)}(t),u):fn()}(n,e,t,r,u)}function dt(n,e,t){return ut(un,n,e,t,2,!0)}function pt(n,e,t){kn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){ft(n,r,"errorCaptured hook")}}ft(n,e,t)}finally{Sn()}}function mt(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return pt(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){pt(n,r,i)}return a}function ft(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&gt(e,null,"config.errorHandler")}gt(n,e,t)}function gt(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var vt,bt=!1,yt=[],wt=!1;function xt(){wt=!1;var n=yt.slice(0);yt.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var kt=Promise.resolve();vt=function(){kt.then(xt),Y&&setTimeout(O)},bt=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())vt="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(xt)}:function(){setTimeout(xt,0)};else{var St=1,jt=new MutationObserver(xt),_t=document.createTextNode(String(St));jt.observe(_t,{characterData:!0}),vt=function(){St=(St+1)%2,_t.data=String(St)},bt=!0}function Tt(n,e){var t;if(yt.push((function(){if(n)try{n.call(e)}catch(n){pt(n,e,"nextTick")}else t&&t(e)})),wt||(wt=!0,vt()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Et(n){if(void 0===n&&(n="$style"),!un)return r;var e=un[n];return e||r}function Ct(n){if(W){var e=un;e&&de((function(){var t=e.$el,r=n(e,e._setupProxy);if(t&&1===t.nodeType){var i=t.style;for(var a in r)i.setProperty("--".concat(a),r[a])}}))}}function It(n){c(n)&&(n={loader:n});var e=n.loader,t=n.loadingComponent,r=n.errorComponent,i=n.delay,a=void 0===i?200:i,o=n.timeout,s=(n.suspensible,n.onError);var l=null,h=0,u=function(){var n;return l||(n=l=e().catch((function(n){if(n=n instanceof Error?n:new Error(String(n)),s)return new Promise((function(e,t){s(n,(function(){return e((h++,l=null,u()))}),(function(){return t(n)}),h+1)}));throw n})).then((function(e){return n!==l&&l?l:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e)})))};return function(){return{component:u(),delay:a,timeout:o,error:r,loading:t}}}function zt(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=Ar(r[e],t)}(t,n,e)}}var At=zt("beforeMount"),Pt=zt("mounted"),Ot=zt("beforeUpdate"),qt=zt("updated"),Lt=zt("beforeDestroy"),Nt=zt("destroyed"),Dt=zt("activated"),Bt=zt("deactivated"),Mt=zt("serverPrefetch"),Rt=zt("renderTracked"),Ft=zt("renderTriggered"),Ut=zt("errorCaptured");function Vt(n,e){void 0===e&&(e=un),Ut(n,e)}var Jt="2.7.14";function Ht(n){return n}var $t=new cn;function Gt(n){return function n(e,t){var r,a,o=i(e);if(!o&&!h(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if($n(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,$t),$t.clear(),n}var Wt,Kt=0,Qt=function(){function n(n,e,t,r,i){var a,o;a=this,void 0===(o=me&&!me._vm?me:n?n._scope:void 0)&&(o=me),o&&o.active&&o.effects.push(a),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Kt,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!$.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;pt(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Gt(n),Sn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():vr(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||h(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');mt(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Zt(n,e){Wt.$on(n,e)}function Xt(n,e){Wt.$off(n,e)}function Yt(n,e){var t=Wt;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function nr(n,e,t){Wt=n,Ee(e,t||{},Zt,Xt,Yt,n),Wt=void 0}var er=null;function tr(n){var e=er;return er=n,function(){er=e}}function rr(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function ir(n,e){if(e){if(n._directInactive=!1,rr(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)ir(n.$children[t]);ar(n,"activated")}}function ar(n,e,t,r){void 0===r&&(r=!0),kn();var i=un;r&&pn(n);var a=n.$options[e],o="".concat(e," hook");if(a)for(var s=0,l=a.length;s<l;s++)mt(a[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&pn(i),Sn()}var or=[],sr=[],lr={},cr=!1,hr=!1,ur=0;var dr=0,pr=Date.now;if(W&&!Q){var mr=window.performance;mr&&"function"==typeof mr.now&&pr()>document.createEvent("Event").timeStamp&&(pr=function(){return mr.now()})}var fr=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function gr(){var n,e;for(dr=pr(),hr=!0,or.sort(fr),ur=0;ur<or.length;ur++)(n=or[ur]).before&&n.before(),e=n.id,lr[e]=null,n.run();var t=sr.slice(),r=or.slice();ur=or.length=sr.length=0,lr={},cr=hr=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,ir(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&ar(r,"updated")}}(r),function(){for(var n=0;n<yn.length;n++){var e=yn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}yn.length=0}(),sn&&U.devtools&&sn.emit("flush")}function vr(n){var e=n.id;if(null==lr[e]&&(n!==wn.target||!n.noRecurse)){if(lr[e]=!0,hr){for(var t=or.length-1;t>ur&&or[t].id>n.id;)t--;or.splice(t+1,0,n)}else or.push(n);cr||(cr=!0,Tt(gr))}}function br(n,e){if(n){for(var t=Object.create(null),r=hn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){var o=n[a].from;if(o in e._provided)t[a]=e._provided[o];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function yr(n,e,t,a,o){var l,c=this,h=o.options;k(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var u=s(h._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=br(h.inject,a),this.slots=function(){return c.$slots||Qe(a,n.scopedSlots,c.$slots=Ge(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return Qe(a,n.scopedSlots,this.slots())}}),u&&(this.$options=h,this.$slots=this.slots(),this.$scopedSlots=Qe(a,n.scopedSlots,this.$slots)),h._scopeId?this._c=function(n,e,t,r){var o=ut(l,n,e,t,r,d);return o&&!i(o)&&(o.fnScopeId=h._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return ut(l,n,e,t,r,d)}}function wr(n,e,t,r,i){var a=vn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function xr(n,e){for(var t in e)n[_(t)]=e[t]}function kr(n){return n.name||n.__name||n._componentTag}$e(yr.prototype);var Sr={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Sr.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,er)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,a){var o=i.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),h=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=a;var u=i.data.attrs||r;n._attrsProxy&&nt(n._attrsProxy,u,h.data&&h.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&nt(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,nr(n,t,d),e&&n.$options.props){In(!1);for(var p=n._props,m=n.$options._propKeys||[],f=0;f<m.length;f++){var g=m[f],v=n.$options.props;p[g]=Nr(g,v,e,n)}In(!0),n.$options.propsData=e}c&&(n.$slots=Ge(a,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,ar(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,sr.push(e)):ir(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,rr(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);ar(e,"deactivated")}}(e,!0):e.$destroy())}},jr=Object.keys(Sr);function _r(n,e,t,l,c){if(!a(n)){var u=t.$options._base;if(h(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=lt;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=B((function(t){n.resolved=ct(t,e),i?r.length=0:u(!0)})),p=B((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),m=n(d,p);return h(m)&&(f(m)?a(n.resolved)&&m.then(d,p):f(m.component)&&(m.component.then(d,p),o(m.error)&&(n.errorComp=ct(m.error,e)),o(m.loading)&&(n.loadingComp=ct(m.loading,e),0===m.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),m.delay||200)),o(m.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&p(null)}),m.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,i){var a=fn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(d,e,t,l,c);e=e||{},Qr(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;o(s)?(i(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var h=C(c);Ie(i,l,c,h,!0)||Ie(i,s,c,h,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},h=l.props;if(o(h))for(var u in h)c[u]=Nr(u,h,e||r);else o(t.attrs)&&xr(c,t.attrs),o(t.props)&&xr(c,t.props);var d=new yr(t,c,s,a,n),p=l.render.call(null,d._c,d);if(p instanceof mn)return wr(p,t,d.parent,l,d);if(i(p)){for(var m=ze(p)||[],f=new Array(m.length),g=0;g<m.length;g++)f[g]=wr(m[g],t,d.parent,l,d);return f}}(n,p,e,t,l);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<jr.length;t++){var r=jr[t],i=e[r],a=Sr[r];i===a||i&&i._merged||(e[r]=i?Tr(a,i):a)}}(e);var v=kr(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:c,children:l},d)}}}function Tr(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Er=O,Cr=U.optionMergeStrategies;function Ir(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,a,o=hn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(i=n[r],a=e[r],t&&k(n,r)?i!==a&&d(i)&&d(a)&&Ir(i,a):qn(n,r,a));return n}function zr(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return r?Ir(r,i):i}:e?n?function(){return Ir(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ar(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Pr(n,e,t,r){var i=Object.create(n||null);return e?A(i,e):i}Cr.data=function(n,e,t){return t?zr(n,e,t):e&&"function"!=typeof e?n:zr(n,e)},F.forEach((function(n){Cr[n]=Ar})),R.forEach((function(n){Cr[n+"s"]=Pr})),Cr.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in A(a,n),e){var s=a[o],l=e[o];s&&!i(s)&&(s=[s]),a[o]=s?s.concat(l):i(l)?l:[l]}return a},Cr.props=Cr.methods=Cr.inject=Cr.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return A(i,n),e&&A(i,e),i},Cr.provide=function(n,e){return n?function(){var t=Object.create(null);return Ir(t,c(n)?n.call(this):n),e&&Ir(t,c(e)?e.call(this):e,!1),t}:e};var Or=function(n,e){return void 0===e?n:e};function qr(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(i(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[_(a)]={type:null});else if(d(t))for(var s in t)a=t[s],o[_(s)]=d(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(d(t))for(var o in t){var s=t[o];r[o]=d(s)?A({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=qr(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=qr(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)k(n,o)||l(o);function l(r){var i=Cr[r]||Or;s[r]=i(n[r],e[r],t,r)}return s}function Lr(n,e,t,r){if("string"==typeof t){var i=n[e];if(k(i,t))return i[t];var a=_(t);if(k(i,a))return i[a];var o=T(a);return k(i,o)?i[o]:i[t]||i[a]||i[o]}}function Nr(n,e,t,r){var i=e[n],a=!k(t,n),o=t[n],s=Rr(Boolean,i.type);if(s>-1)if(a&&!k(i,"default"))o=!1;else if(""===o||o===C(n)){var l=Rr(String,i.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Br(e.type)?r.call(n):r}(r,i,n);var h=Cn;In(!0),Pn(o),In(h)}return o}var Dr=/^\s*function (\w+)/;function Br(n){var e=n&&n.toString().match(Dr);return e?e[1]:""}function Mr(n,e){return Br(n)===Br(e)}function Rr(n,e){if(!i(e))return Mr(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Mr(e[t],n))return t;return-1}var Fr={enumerable:!0,configurable:!0,get:O,set:O};function Ur(n,e,t){Fr.get=function(){return this[e][t]},Fr.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Fr)}function Vr(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Bn({}),i=n.$options._propKeys=[];n.$parent&&In(!1);var a=function(a){i.push(a);var o=Nr(a,e,t,n);On(r,a,o),a in n||Ur(n,"_props",a)};for(var o in e)a(o);In(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=Ye(n);pn(n),kn();var i=mt(t,null,[n._props||Bn({}),r],n,"setup");if(Sn(),pn(),c(i))e.render=i;else if(h(i))if(n._setupState=i,i.__sfc){var a=n._setupProxy={};for(var o in i)"__sfc"!==o&&Yn(a,i,o)}else for(var o in i)J(o)||Yn(n,i,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?O:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return pt(n,e,"data()"),{}}finally{Sn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&k(r,a)||J(a)||Ur(n,"_data",a)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var i in e){var a=e[i],o=c(a)?a:a.get;0,r||(t[i]=new Qt(n,o||O,O,Jr)),i in n||Hr(n,i,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var a=0;a<r.length;a++)Wr(n,t,r[a]);else Wr(n,t,r)}}(n,e.watch)}var Jr={lazy:!0};function Hr(n,e,t){var r=!on();c(t)?(Fr.get=r?$r(e):Gr(t),Fr.set=O):(Fr.get=t.get?r&&!1!==t.cache?$r(e):Gr(t.get):O,Fr.set=t.set||O),Object.defineProperty(n,e,Fr)}function $r(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),wn.target&&e.depend(),e.value}}function Gr(n){return function(){return n.call(this,this)}}function Wr(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Kr=0;function Qr(n){var e=n.options;if(n.super){var t=Qr(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&A(n.extendOptions,r),(e=n.options=qr(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Zr(n){this._init(n)}function Xr(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=kr(n)||kr(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=qr(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Ur(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Hr(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=A({},o.options),i[r]=o,o}}function Yr(n){return n&&(kr(n.Ctor.options)||n.tag)}function ni(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function ei(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var a in t){var o=t[a];if(o){var s=o.name;s&&!e(s)&&ti(t,a,r,i)}}}function ti(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,w(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Kr++,e._isVue=!0,e.__v_skip=!0,e._scope=new be(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=qr(Qr(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&nr(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=Ge(e._renderChildren,i),n.$scopedSlots=t?Qe(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return ut(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return ut(n,e,t,r,i,!0)};var a=t&&t.data;On(n,"$attrs",a&&a.attrs||r,null,!0),On(n,"$listeners",e._parentListeners||r,null,!0)}(e),ar(e,"beforeCreate",void 0,!1),function(n){var e=br(n.$options.inject,n);e&&(In(!1),Object.keys(e).forEach((function(t){On(n,t,e[t])})),In(!0))}(e),Vr(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!h(t))return;for(var r=Se(n),i=hn?Reflect.ownKeys(t):Object.keys(t),a=0;a<i.length;a++){var o=i[a];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),ar(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Zr),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=qn,n.prototype.$delete=Ln,n.prototype.$watch=function(n,e,t){if(d(e))return Wr(this,n,e,t);(t=t||{}).user=!0;var r=new Qt(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');kn(),mt(e,this,[r.value],this,i),Sn()}return function(){r.teardown()}}}(Zr),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var r=z(arguments,1),i='event handler for "'.concat(n,'"'),a=0,o=t.length;a<o;a++)mt(t[a],e,r,e,i)}return e}}(Zr),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=tr(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){ar(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),ar(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Zr),function(n){$e(n.prototype),n.prototype.$nextTick=function(n){return Tt(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=Qe(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&tt(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{pn(e),lt=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){pt(t,e,"render"),n=e._vnode}finally{lt=null,pn()}return i(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=fn()),n.parent=a,n}}(Zr);var ri=[String,RegExp,Array],ii={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:ri,exclude:ri,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:Yr(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&ti(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)ti(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){ei(n,(function(n){return ni(e,n)}))})),this.$watch("exclude",(function(e){ei(n,(function(n){return!ni(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=ht(n),t=e&&e.componentOptions;if(t){var r=Yr(t),i=this.include,a=this.exclude;if(i&&(!r||!ni(i,r))||a&&r&&ni(a,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:Er,extend:A,mergeOptions:qr,defineReactive:On},n.set=qn,n.delete=Ln,n.nextTick=Tt,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,ii),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=qr(this.options,n),this}}(n),Xr(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Zr),Object.defineProperty(Zr.prototype,"$isServer",{get:on}),Object.defineProperty(Zr.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Zr,"FunctionalRenderContext",{value:yr}),Zr.version=Jt;var ai=b("style,class"),oi=b("input,textarea,option,select,progress"),si=b("contenteditable,draggable,spellcheck"),li=b("events,caret,typing,plaintext-only"),ci=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),hi="http://www.w3.org/1999/xlink",ui=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},di=function(n){return ui(n)?n.slice(6,n.length):""},pi=function(n){return null==n||!1===n};function mi(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=fi(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=fi(e,t.data));return function(n,e){if(o(n)||o(e))return gi(n,vi(e));return""}(e.staticClass,e.class)}function fi(n,e){return{staticClass:gi(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function gi(n,e){return n?e?n+" "+e:n:e||""}function vi(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=vi(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):h(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var bi={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},yi=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),wi=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),xi=function(n){return yi(n)||wi(n)};var ki=Object.create(null);var Si=b("text,number,password,search,email,tel,url");var ji=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(bi[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),_i={create:function(n,e){Ti(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Ti(n,!0),Ti(e))},destroy:function(n){Ti(n,!0)}};function Ti(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))mt(t,r,[s],r,"template ref function");else{var h=n.data.refInFor,u="string"==typeof t||"number"==typeof t,d=$n(t),p=r.$refs;if(u||d)if(h){var m=u?p[t]:t.value;e?i(m)&&w(m,a):i(m)?m.includes(a)||m.push(a):u?(p[t]=[a],Ei(r,t,p[t])):t.value=[a]}else if(u){if(e&&p[t]!==a)return;p[t]=l,Ei(r,t,s)}else if(d){if(e&&t.value!==a)return;t.value=s}else 0}}}function Ei(n,e,t){var r=n._setupState;r&&k(r,e)&&($n(r[e])?r[e].value=t:r[e]=t)}var Ci=new mn("",{},[]),Ii=["create","activate","update","remove","destroy"];function zi(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||Si(r)&&Si(i)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Ai(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var Pi={create:Oi,update:Oi,destroy:function(n){Oi(n,Ci)}};function Oi(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===Ci,o=e===Ci,s=Li(n.data.directives,n.context),l=Li(e.data.directives,e.context),c=[],h=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,Di(i,"update",e,n),i.def&&i.def.componentUpdated&&h.push(i)):(Di(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Di(c[t],"inserted",e,n)};a?Ce(e,"insert",u):u()}h.length&&Ce(e,"postpatch",(function(){for(var t=0;t<h.length;t++)Di(h[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||Di(s[t],"unbind",n,n,o)}(n,e)}var qi=Object.create(null);function Li(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=qi),i[Ni(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||Lr(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||Lr(e.$options,"directives",r.name)}return i}function Ni(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Di(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){pt(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Bi=[_i,Pi];function Mi(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,l=e.elm,c=n.data.attrs||{},h=e.data.attrs||{};for(r in(o(h.__ob__)||s(h._v_attr_proxy))&&(h=e.data.attrs=A({},h)),h)i=h[r],c[r]!==i&&Ri(l,r,i,e.data.pre);for(r in(Q||X)&&h.value!==c.value&&Ri(l,"value",h.value),c)a(h[r])&&(ui(r)?l.removeAttributeNS(hi,di(r)):si(r)||l.removeAttribute(r))}}function Ri(n,e,t,r){r||n.tagName.indexOf("-")>-1?Fi(n,e,t):ci(e)?pi(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):si(e)?n.setAttribute(e,function(n,e){return pi(e)||"false"===e?"false":"contenteditable"===n&&li(e)?e:"true"}(e,t)):ui(e)?pi(t)?n.removeAttributeNS(hi,di(e)):n.setAttributeNS(hi,e,t):Fi(n,e,t)}function Fi(n,e,t){if(pi(t))n.removeAttribute(e);else{if(Q&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Ui={create:Mi,update:Mi};function Vi(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var s=mi(e),l=t._transitionClasses;o(l)&&(s=gi(s,vi(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ji,Hi={create:Vi,update:Vi};function $i(n,e,t){var r=Ji;return function i(){var a=e.apply(null,arguments);null!==a&&Ki(n,i,t,r)}}var Gi=bt&&!(en&&Number(en[1])<=53);function Wi(n,e,t,r){if(Gi){var i=dr,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Ji.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Ki(n,e,t,r){(r||Ji).removeEventListener(n,e._wrapper||e,t)}function Qi(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Ji=e.elm||n.elm,function(n){if(o(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Ee(t,r,Wi,Ki,$i,e.context),Ji=void 0}}var Zi,Xi={create:Qi,update:Qi,destroy:function(n){return Qi(n,Ci)}};function Yi(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=A({},c)),l)t in c||(i[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var h=a(r)?"":String(r);na(i,h)&&(i.value=h)}else if("innerHTML"===t&&wi(i.tagName)&&a(i.innerHTML)){(Zi=Zi||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Zi.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function na(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var ea={create:Yi,update:Yi},ta=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function ra(n){var e=ia(n.style);return n.staticStyle?A(n.staticStyle,e):e}function ia(n){return Array.isArray(n)?P(n):"string"==typeof n?ta(n):n}var aa,oa=/^--/,sa=/\s*!important$/,la=function(n,e,t){if(oa.test(e))n.style.setProperty(e,t);else if(sa.test(t))n.style.setProperty(C(e),t.replace(sa,""),"important");else{var r=ha(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},ca=["Webkit","Moz","ms"],ha=S((function(n){if(aa=aa||document.createElement("div").style,"filter"!==(n=_(n))&&n in aa)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ca.length;t++){var r=ca[t]+e;if(r in aa)return r}}));function ua(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,s,l=e.elm,c=r.staticStyle,h=r.normalizedStyle||r.style||{},u=c||h,d=ia(e.data.style)||{};e.data.normalizedStyle=o(d.__ob__)?A({},d):d;var p=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=ra(i.data))&&A(r,t);(t=ra(n.data))&&A(r,t);for(var a=n;a=a.parent;)a.data&&(t=ra(a.data))&&A(r,t);return r}(e,!0);for(s in u)a(p[s])&&la(l,s,"");for(s in p)(i=p[s])!==u[s]&&la(l,s,null==i?"":i)}}var da={create:ua,update:ua},pa=/\s+/;function ma(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(pa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function fa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(pa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ga(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,va(n.name||"v")),A(e,n),e}return"string"==typeof n?va(n):void 0}}var va=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ba=W&&!Z,ya="transition",wa="transitionend",xa="animation",ka="animationend";ba&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ya="WebkitTransition",wa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(xa="WebkitAnimation",ka="webkitAnimationEnd"));var Sa=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ja(n){Sa((function(){Sa(n)}))}function _a(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ma(n,e))}function Ta(n,e){n._transitionClasses&&w(n._transitionClasses,e),fa(n,e)}function Ea(n,e,t){var r=Ia(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var s="transition"===i?wa:ka,l=0,c=function(){n.removeEventListener(s,h),t()},h=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),a+1),n.addEventListener(s,h)}var Ca=/\b(transform|all)(,|$)/;function Ia(n,e){var t,r=window.getComputedStyle(n),i=(r[ya+"Delay"]||"").split(", "),a=(r[ya+"Duration"]||"").split(", "),o=za(i,a),s=(r[xa+"Delay"]||"").split(", "),l=(r[xa+"Duration"]||"").split(", "),c=za(s,l),h=0,u=0;return"transition"===e?o>0&&(t="transition",h=o,u=a.length):"animation"===e?c>0&&(t="animation",h=c,u=l.length):u=(t=(h=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:h,propCount:u,hasTransform:"transition"===t&&Ca.test(r[ya+"Property"])}}function za(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Aa(e)+Aa(n[t])})))}function Aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Pa(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ga(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,p=r.appearClass,m=r.appearToClass,f=r.appearActiveClass,g=r.beforeEnter,b=r.enter,y=r.afterEnter,w=r.enterCancelled,x=r.beforeAppear,k=r.appear,S=r.afterAppear,j=r.appearCancelled,_=r.duration,T=er,E=er.$vnode;E&&E.parent;)T=E.context,E=E.parent;var C=!T._isMounted||!n.isRootInsert;if(!C||k||""===k){var I=C&&p?p:l,z=C&&f?f:d,A=C&&m?m:u,P=C&&x||g,O=C&&c(k)?k:b,q=C&&S||y,L=C&&j||w,N=v(h(_)?_.enter:_);0;var D=!1!==i&&!Z,M=La(O),R=t._enterCb=B((function(){D&&(Ta(t,A),Ta(t,z)),R.cancelled?(D&&Ta(t,I),L&&L(t)):q&&q(t),t._enterCb=null}));n.data.show||Ce(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),O&&O(t,R)})),P&&P(t),D&&(_a(t,I),_a(t,z),ja((function(){Ta(t,I),R.cancelled||(_a(t,A),M||(qa(N)?setTimeout(R,N):Ea(t,s,R)))}))),n.data.show&&(e&&e(),O&&O(t,R)),D||M||R()}}}function Oa(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ga(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,d=r.beforeLeave,p=r.leave,m=r.afterLeave,f=r.leaveCancelled,g=r.delayLeave,b=r.duration,y=!1!==i&&!Z,w=La(p),x=v(h(b)?b.leave:b);0;var k=t._leaveCb=B((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Ta(t,c),Ta(t,u)),k.cancelled?(y&&Ta(t,l),f&&f(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(S):S()}function S(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),y&&(_a(t,l),_a(t,u),ja((function(){Ta(t,l),k.cancelled||(_a(t,c),w||(qa(x)?setTimeout(k,x):Ea(t,s,k)))}))),p&&p(t,k),y||w||k())}}function qa(n){return"number"==typeof n&&!isNaN(n)}function La(n){if(a(n))return!1;var e=n.fns;return o(e)?La(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Na(n,e){!0!==e.data.show&&Pa(e)}var Da=function(n){var e,t,r={},c=n.modules,h=n.nodeOps;for(e=0;e<Ii.length;++e)for(r[Ii[e]]=[],t=0;t<c.length;++t)o(c[t][Ii[e]])&&r[Ii[e]].push(c[t][Ii[e]]);function u(n){var e=h.parentNode(n);o(e)&&h.removeChild(e,n)}function d(n,e,t,i,a,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=vn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var l=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return p(n,e),m(t,n.elm,i),s(l)&&function(n,e,t,i){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(a=s.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Ci,s);e.push(s);break}m(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,d=n.children,g=n.tag;o(g)?(n.elm=n.ns?h.createElementNS(n.ns,g):h.createElement(g,n),y(n),f(n,d,e),o(u)&&v(n,e),m(t,n.elm,i)):s(n.isComment)?(n.elm=h.createComment(n.text),m(t,n.elm,i)):(n.elm=h.createTextNode(n.text),m(t,n.elm,i))}}function p(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(Ti(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?h.parentNode(t)===n&&h.insertBefore(n,e,t):h.appendChild(n,e))}function f(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&h.appendChild(n.elm,h.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var i=0;i<r.create.length;++i)r.create[i](Ci,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Ci,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))h.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&h.setStyleScope(n.elm,e),t=t.parent;o(e=er)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&h.setStyleScope(n.elm,e)}function w(n,e,t,r,i,a){for(;r<=i;++r)d(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(S(r),x(r)):u(r.elm))}}function S(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&S(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function j(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&zi(n,a))return i}}function _(n,e,t,i,l,c){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=vn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var p,m=e.data;o(m)&&o(p=m.hook)&&o(p=p.prepatch)&&p(n,e);var f=n.children,v=e.children;if(o(m)&&g(e)){for(p=0;p<r.update.length;++p)r.update[p](n,e);o(p=m.hook)&&o(p=p.update)&&p(n,e)}a(e.text)?o(f)&&o(v)?f!==v&&function(n,e,t,r,i){var s,l,c,u=0,p=0,m=e.length-1,f=e[0],g=e[m],v=t.length-1,b=t[0],y=t[v],x=!i;for(0;u<=m&&p<=v;)a(f)?f=e[++u]:a(g)?g=e[--m]:zi(f,b)?(_(f,b,r,t,p),f=e[++u],b=t[++p]):zi(g,y)?(_(g,y,r,t,v),g=e[--m],y=t[--v]):zi(f,y)?(_(f,y,r,t,v),x&&h.insertBefore(n,f.elm,h.nextSibling(g.elm)),f=e[++u],y=t[--v]):zi(g,b)?(_(g,b,r,t,p),x&&h.insertBefore(n,g.elm,f.elm),g=e[--m],b=t[++p]):(a(s)&&(s=Ai(e,u,m)),a(l=o(b.key)?s[b.key]:j(b,e,u,m))?d(b,r,n,f.elm,!1,t,p):zi(c=e[l],b)?(_(c,b,r,t,p),e[l]=void 0,x&&h.insertBefore(n,c.elm,f.elm)):d(b,r,n,f.elm,!1,t,p),b=t[++p]);u>m?w(n,a(t[v+1])?null:t[v+1].elm,t,p,v,r):p>v&&k(e,u,m)}(u,f,v,t,c):o(v)?(o(n.text)&&h.setTextContent(u,""),w(u,null,v,0,v.length-1,t)):o(f)?k(f,0,f.length-1):o(n.text)&&h.setTextContent(u,""):n.text!==e.text&&h.setTextContent(u,e.text),o(m)&&o(p=m.hook)&&o(p=p.postpatch)&&p(n,e)}}}function T(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var E=b("attrs,class,staticClass,staticStyle,key");function C(n,e,t,r){var i,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return p(e,t),!0;if(o(a)){if(o(c))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var h=!0,u=n.firstChild,d=0;d<c.length;d++){if(!u||!C(u,c[d],t,r)){h=!1;break}u=u.nextSibling}if(!h||u)return!1}else f(e,c,t);if(o(l)){var m=!1;for(var g in l)if(!E(g)){m=!0,v(e,t);break}!m&&l.class&&Gt(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,c=!1,u=[];if(a(n))c=!0,d(e,u);else{var p=o(n.nodeType);if(!p&&zi(n,e))_(n,e,u,null,null,i);else{if(p){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,u))return T(e,u,!0),n;l=n,n=new mn(h.tagName(l).toLowerCase(),{},[],void 0,l)}var m=n.elm,f=h.parentNode(m);if(d(e,u,m._leaveCb?null:f,h.nextSibling(m)),o(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var w=0;w<r.create.length;++w)r.create[w](Ci,v);var S=v.data.hook.insert;if(S.merged)for(var j=1;j<S.fns.length;j++)S.fns[j]()}else Ti(v);v=v.parent}o(f)?k([n],0,0):o(n.tag)&&x(n)}}return T(e,u,c),e.elm}o(n)&&x(n)}}({nodeOps:ji,modules:[Ui,Hi,Xi,ea,da,W?{create:Na,activate:Na,remove:function(n,e){!0!==n.data.show?Oa(n,e):e()}}:{}].concat(Bi)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ha(n,"input")}));var Ba={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Ce(t,"postpatch",(function(){Ba.componentUpdated(n,e,t)})):Ma(n,e,t.context),n._vOptions=[].map.call(n.options,Ua)):("textarea"===t.tag||Si(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Va),n.addEventListener("compositionend",Ja),n.addEventListener("change",Ja),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ma(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Ua);if(i.some((function(n,e){return!N(n,r[e])})))(n.multiple?e.value.some((function(n){return Fa(n,i)})):e.value!==e.oldValue&&Fa(e.value,i))&&Ha(n,"change")}}};function Ma(n,e,t){Ra(n,e,t),(Q||X)&&setTimeout((function(){Ra(n,e,t)}),0)}function Ra(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],i)a=D(r,Ua(o))>-1,o.selected!==a&&(o.selected=a);else if(N(Ua(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function Fa(n,e){return e.every((function(e){return!N(e,n)}))}function Ua(n){return"_value"in n?n._value:n.value}function Va(n){n.target.composing=!0}function Ja(n){n.target.composing&&(n.target.composing=!1,Ha(n.target,"input"))}function Ha(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function $a(n){return!n.componentInstance||n.data&&n.data.transition?n:$a(n.componentInstance._vnode)}var Ga={model:Ba,show:{bind:function(n,e,t){var r=e.value,i=(t=$a(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,Pa(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=$a(t)).data&&t.data.transition?(t.data.show=!0,r?Pa(t,(function(){n.style.display=n.__vOriginalDisplay})):Oa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Wa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ka(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ka(ht(e.children)):n}function Qa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[_(r)]=i[r];return e}function Za(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Xa=function(n){return n.tag||Ke(n)},Ya=function(n){return"show"===n.name},no={name:"transition",props:Wa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Xa)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Ka(i);if(!a)return i;if(this._leaving)return Za(n,i);var o="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?o+"comment":o+a.tag:l(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=Qa(this),c=this._vnode,h=Ka(c);if(a.data.directives&&a.data.directives.some(Ya)&&(a.data.show=!0),h&&h.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,h)&&!Ke(h)&&(!h.componentInstance||!h.componentInstance._vnode.isComment)){var u=h.data.transition=A({},s);if("out-in"===r)return this._leaving=!0,Ce(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Za(n,i);if("in-out"===r){if(Ke(a))return c;var d,p=function(){d()};Ce(s,"afterEnter",p),Ce(s,"enterCancelled",p),Ce(u,"delayLeave",(function(n){d=n}))}}return i}}},eo=A({tag:String,moveClass:String},Wa);function to(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function ro(n){n.data.newPos=n.elm.getBoundingClientRect()}function io(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),a.transitionDuration="0s"}}delete eo.mode;var ao={Transition:no,TransitionGroup:{props:eo,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=tr(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=Qa(this),s=0;s<i.length;s++){if((h=i[s]).tag)if(null!=h.key&&0!==String(h.key).indexOf("__vlist"))a.push(h),t[h.key]=h,(h.data||(h.data={})).transition=o;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var h;(h=r[s]).data.transition=o,h.data.pos=h.elm.getBoundingClientRect(),t[h.key]?l.push(h):c.push(h)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(to),n.forEach(ro),n.forEach(io),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;_a(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(wa,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(wa,n),t._moveCb=null,Ta(t,e))})}})))},methods:{hasMove:function(n,e){if(!ba)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){fa(t,n)})),ma(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ia(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Zr.config.mustUseProp=function(n,e,t){return"value"===t&&oi(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Zr.config.isReservedTag=xi,Zr.config.isReservedAttr=ai,Zr.config.getTagNamespace=function(n){return wi(n)?"svg":"math"===n?"math":void 0},Zr.config.isUnknownElement=function(n){if(!W)return!0;if(xi(n))return!1;if(n=n.toLowerCase(),null!=ki[n])return ki[n];var e=document.createElement(n);return n.indexOf("-")>-1?ki[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ki[n]=/HTMLUnknownElement/.test(e.toString())},A(Zr.options.directives,Ga),A(Zr.options.components,ao),Zr.prototype.__patch__=W?Da:O,Zr.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=fn),ar(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Qt(n,r,O,{before:function(){n._isMounted&&!n._isDestroyed&&ar(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var a=0;a<i.length;a++)i[a].run();return null==n.$vnode&&(n._isMounted=!0,ar(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){U.devtools&&sn&&sn.emit("init",Zr)}),0)}.call(this,t(18))},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):i&&(l=s?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var h=c.render;c.render=function(n,e){return l.call(e),h(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(60),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e,t){(function(e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof e&&e)||function(){return this}()||Function("return this")()}).call(this,t(18))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(32),i=Function.prototype,a=i.call,o=r&&i.bind.bind(a,a);n.exports=r?o:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){var r=t(4);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(5),i=t(34),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){var r=t(74),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){var r=t(2),i=t(60),a=i.all;n.exports=i.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===a}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(172),i=t(175);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return h})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return p})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return w}));t(17);const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function h(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=s(n);return a.test(i)?n:i+".html"+t}function d(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return s(n.path)===s(e)}function p(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,r){const{pages:i,themeConfig:a}=t,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return f(n);const s=o.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?f(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return p(t,e,r);if(Array.isArray(e))return Object.assign(p(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(p(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function w(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(6),i=t(69),a=t(108),o=t(31),s=t(59),l=TypeError,c=Object.defineProperty,h=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=h(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(16),i=t(157),a=t(158),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(9).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(19),i=t(34),a=t(35),o=t(138),s=t(140),l=t(4)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),c=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();r({target:"Array",proto:!0,arity:1,forced:l||c},{push:function(n){var e=i(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e,t){var r=t(3),i=t(56).f,a=t(23),o=t(121),s=t(39),l=t(70),c=t(134);n.exports=function(n,e){var t,h,u,d,p,m=n.target,f=n.global,g=n.stat;if(t=f?r:g?r[m]||s(m,{}):(r[m]||{}).prototype)for(h in e){if(d=e[h],u=n.dontCallGetSet?(p=i(t,h))&&p.value:t[h],!c(f?h:m+(g?".":"#")+h,n.forced)&&void 0!==u){if(typeof d==typeof u)continue;l(d,u)}(n.sham||u&&u.sham)&&a(d,"sham",!0),o(t,h,d,n)}}},function(n,e,t){var r=t(5),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(3),i=t(2),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(3),i=t(66),a=t(8),o=t(68),s=t(64),l=t(63),c=i("wks"),h=r.Symbol,u=h&&h.for,d=l?h:h&&h.withoutSetter||o;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(h,n)?c[n]=h[n]:c[n]=l&&u?u(e):d(e)}return c[n]}},function(n,e,t){var r=t(6),i=t(14),a=t(37);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(162),i=t(163),a=t(164),o=t(165),s=t(166);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(76);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(11)(Object,"create");n.exports=r},function(n,e,t){var r=t(184);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(47);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),h=r.speed,u=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,h,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+h+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),h)}),h)):setTimeout(e,h)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),h=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&d(i),h!=document.body&&c(h,"nprogress-custom-parent"),h.appendChild(e),e},t.remove=function(){h(document.documentElement,"nprogress-busy"),h(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function h(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){var r=t(10),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(51),i=t(57);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(57),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){var r=t(132);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(32),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(3),i=t(39),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(3),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(156),i=t(13),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(11)(t(9),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(176),i=t(183),a=t(185),o=t(186),s=t(187);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(7),i=t(47),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(15),i=t(13);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.r(e);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}const i=new class{constructor(){r(this,"TABEL","fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF"),r(this,"TR",{}),r(this,"S",[11,10,3,8,4,6]),r(this,"XOR",177451812),r(this,"ADD",8728348608),this.init()}init(){const n=this.TABEL.length;for(let e=0;e<n;e++)this.TR[this.TABEL[e]]=e}av2bv(n){const e=(n^this.XOR)+this.ADD,t=["B","V","1",,,"4",,"1",,"7"];for(let n=0;n<6;n++)t[this.S[n]]=this.TABEL[Math.floor(e/58**n)%58];return t.join("")}bv2av(n){let e=0;for(let t=0;t<6;t++)e+=this.TR[n[this.S[t]]]*58**t;return"av"+String(e-this.ADD^this.XOR)}};var a={name:"Bilibili",data(){return{afs:!![!0,"true","allowfullscreen"].includes(this.allowfullscreen)}},props:{id:{type:String,required:!0},danmaku:{type:Boolean,default:!1,required:!1},page:{type:Number,default:1,required:!1},sandbox:{type:String,default:"allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups",required:!1},allowfullscreen:{type:[String,Boolean],required:!1,default:"allowfullscreen"},width:{type:String,required:!1,default:"100%"},height:{type:Array,required:!1,default:()=>[9/16,70]}},computed:{bvid(){if(!this.id||this.id.toLowerCase().startsWith("bv"))return this.id;const n=this.id.toLowerCase().startsWith("av")?this.id.slice(2):this.id;return i.av2bv(n)},avid(){return i.bv2av(this.bvid)},src(){return`//player.bilibili.com/player.html?bvid=${this.bvid}&page=${this.page}&danmaku=${this.danmaku}`}},mounted(){this.$nextTick(()=>{let n=this.$refs.sbplayer;n&&(n.style.height=n.scrollWidth*this.height[0]+this.height[1]+"px")})}},o=(t(252),t(1)),s=Object(o.a)(a,(function(){var n=this._self._c;return n("div",{staticClass:"biliPlayer"},[n("iframe",{ref:"sbplayer",staticClass:"player",style:{width:this.width},attrs:{src:this.src,allowfullscreen:this.afs,scrolling:"no",frameborder:"0",sandbox:this.sandbox}})])}),[],!1,null,"36ae663a",null);e.default=s.exports},function(n,e,t){"use strict";t.r(e);var r={name:"LastReadingPopup",data:()=>({lastReading:null,show:!1}),computed:{popupConfig(){const n={"/":{message:"检测到您上一次阅读的位置，是否移至该位置？",sureButtonText:"确定",cancelButtonText:"取消"},"/zh/":{message:"检测到您上一次阅读的位置，是否移至该位置？",sureButtonText:"前往",cancelButtonText:"取消"}};return n[`/${this.$lang.split("-")[0]}/`]||n[this.$localePath]||n},message(){const n=this.popupConfig;return n&&n.message||n["/"].message},sureButtonText(){const n=this.popupConfig;return n&&n.sureButtonText||n["/"].sureButtonText},cancelButtonText(){const n=this.popupConfig;return n&&n.cancelButtonText||n["/"].cancelButtonText}},mounted(){window.ActiveXObject||"ActiveXObject"in window?setTimeout(()=>{window.addEventListener("load",this.init())},1e3):setTimeout(()=>{window.addEventListener("load",this.init)},1e3)},methods:{init(){this.lastReading=JSON.parse(localStorage.getItem("lastReading")),this.lastReading&&(this.$route.path===this.lastReading.path?this.goto():(this.show=!0,setTimeout(this.clean,1e4)))},goto(){this.$route.path!==this.lastReading.path?this.$router.replace(this.lastReading.path).then(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop,this.clean()}):this.$nextTick(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop})},dontgoto(){this.clean()},clean(){this.show=!1,localStorage.removeItem("lastReading")}}},i=(t(250),t(1)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("transition",{attrs:{name:"sw-update-popup"}},[n.show?e("div",{staticClass:"sw-update-popup"},[n._v("\n    "+n._s(n.message)+"\n\n    "),e("br"),n._v(" "),e("button",{on:{click:n.goto}},[n._v("\n      "+n._s(n.sureButtonText)+"\n    ")]),n._v(" "),e("button",{on:{click:n.dontgoto}},[n._v("\n      "+n._s(n.cancelButtonText)+"\n    ")])]):n._e()])}),[],!1,null,"181714f2",null);e.default=a.exports},function(n,e,t){var r=t(5),i=t(4),a=t(20),o=Object,s=r("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):o(n)}:o},function(n,e,t){var r=t(2),i=t(119),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){(function(e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof e&&e&&e.Object===Object&&e,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),h=Object.prototype.toString,u=Math.max,d=Math.min,p=function(){return c.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==h.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,s,l,c=0,h=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function y(n){return c=n,s=setTimeout(x,e),h?b(n):o}function w(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function x(){var n=p();if(w(n))return k(n);s=setTimeout(x,function(n){var t=e-(n-l);return g?d(t,a-(n-c)):t}(n))}function k(n){return s=void 0,v&&r?b(n):(r=i=void 0,o)}function S(){var n=p(),t=w(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return y(l);if(g)return s=setTimeout(x,e),b(l)}return void 0===s&&(s=setTimeout(x,e)),o}return e=f(e)||0,m(t)&&(h=!!t.leading,a=(g="maxWait"in t)?u(f(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=i=s=void 0},S.flush=function(){return void 0===s?o:k(p())},S}}).call(this,t(18))},function(n,e,t){var r=t(6),i=t(36),a=t(115),o=t(37),s=t(33),l=t(59),c=t(8),h=t(69),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=l(e),h)try{return u(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){var r=t(58),i=TypeError;n.exports=function(n){if(r(n))throw i("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(116),i=t(61);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(21),i=t(2),a=t(62),o=t(63),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&a(e.prototype,s(n))}},function(n,e,t){var r=t(5);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(64);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(65),i=t(4);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,i,a=t(3),o=t(117),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,h=c&&c.v8;h&&(i=(r=h.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){var r=t(67),i=t(38);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.26.1",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(5),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){var r=t(6),i=t(4),a=t(107);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(8),i=t(127),a=t(56),o=t(14);n.exports=function(n,e,t){for(var s=i(e),l=o.f,c=a.f,h=0;h<s.length;h++){var u=s[h];r(n,u)||t&&r(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var r=t(131);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(5),i=t(31),a=t(144);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e,t){(function(e){var t="object"==typeof e&&e&&e.Object===Object&&e;n.exports=t}).call(this,t(18))},function(n,e,t){var r=t(24),i=t(167),a=t(168),o=t(169),s=t(170),l=t(171);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(15),i=t(42);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(188),i=t(13);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,s))}},function(n,e,t){var r=t(81),i=t(191),a=t(82);n.exports=function(n,e,t,o,s,l){var c=1&t,h=n.length,u=e.length;if(h!=u&&!(c&&u>h))return!1;var d=l.get(n),p=l.get(e);if(d&&p)return d==e&&p==n;var m=-1,f=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++m<h;){var v=n[m],b=e[m];if(o)var y=c?o(b,v,m,e,n,l):o(v,b,m,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!i(e,(function(n,e){if(!a(g,e)&&(v===n||s(v,n,t,o,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(43),i=t(189),a=t(190);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(201),i=t(207),a=t(87);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(9),i=t(203),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(54)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(204),i=t(205),a=t(206),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,e,t){var r=t(77),i=t(45);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(11)(t(9),"Set");n.exports=r},function(n,e,t){var r=t(42);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(92),i=t(28);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(7),i=t(46),a=t(218),o=t(221);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(154),i=t(159),a=t(230),o=t(238),s=t(247),l=t(111),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",o=0,s=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(a+=t.substring(s,o)),s=o+1,a+=e}return s!==o?a+t.substring(s,o):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(259),i=t(260),a=t(261),o=!1,s=t(262).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),h=/^\uFEFF/;function u(n,t){var i,a,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)i=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(i=a)),i||Array.isArray(o)&&o.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(i=a),!i)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return i}function d(n,t){var r,i=n.filename,a=arguments.length>1;if(n.cache){if(!i)throw new Error("cache option requires a filename");if(r=e.cache.get(i))return r;a||(t=m(i).toString().replace(h,""))}else if(!a){if(!i)throw new Error("Internal EJS error: no file name or template provided");t=m(i).toString().replace(h,"")}return r=e.compile(t,n),n.cache&&e.cache.set(i,r),r}function p(n,t,r){var i;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(i=d(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{i=d(n)(t)}catch(n){return r(n)}r(null,i)}function m(n){return e.fileLoader(n)}function f(n,e,t,r,i){var a=e.split("\n"),o=Math.max(r-3,0),s=Math.min(a.length,r+3),l=i(t),c=a.slice(o,s).map((function(n,e){var t=e+o+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=i.dirname,a=i.extname,o=(0,i.resolve)(t?e:r(e),n);return a(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var r=e||{},i=t||{};return 2==arguments.length&&a.shallowCopyFromList(i,r,l),d(i,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),i=r.shift(),o={filename:i};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(o,r.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(o,t)),a.shallowCopyFromList(o,e,c)),o.filename=i):e={},p(o,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,o="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(o+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",h=0;h<r.destructuredLocals.length;h++){var p=r.destructuredLocals[h];h>0&&(c+=",\n  "),c+=p+" = __locals."+p}o+=c+";\n"}!1!==r._with&&(o+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var m=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var i=a.shallowCopy({},n);return t&&(i=a.shallowCopy(i,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=u(n,t),d(t)}(e,r)(i)},f])};if(m.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var g=r.filename,v=i.basename(g,i.extname(g));try{Object.defineProperty(m,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return m},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),i=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var d,p,f,g,b,y;if(0===l.indexOf(o+i)&&0!==l.indexOf(o+i+i)&&(p=r[c+2])!=i+s&&p!="-"+i+s&&p!="_"+i+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(d=r[c-1])&&(d==o+i||d==o+i+"-"||d==o+i+"_"))return g=a.shallowCopy({},t.opts),b=function(n,e){var t,r,i=a.shallowCopy({},e);r=m(t=u(n,i)).toString().replace(h,""),i.filename=t;var o=new v(r,i);return o.generateSource(),{source:o.source,filename:t,template:r}}(f[1],g),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),i=[];r;)0!==(n=r.index)&&(i.push(e.substring(0,n)),e=e.slice(n)),i.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&i.push(e),i},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,i=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=v.modes.EVAL;break;case r+t+"=":this.mode=v.modes.ESCAPED;break;case r+t+"-":this.mode=v.modes.RAW;break;case r+t+"#":this.mode=v.modes.COMMENT;break;case r+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+i:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+i,t+i)+'")\n';break;case t+i:case"-"+t+i:case"_"+t+i:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r=1,i=2,a=4,o=8;function s(n){this.mode=a,this.data=n}s.prototype={getLength:function(n){return this.data.length},write:function(n){for(var e=0;e<this.data.length;e++)n.put(this.data.charCodeAt(e),8)}};var l=s,c={L:1,M:0,Q:3,H:2};function h(n,e){this.totalCount=n,this.dataCount=e}h.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],h.getRSBlocks=function(n,e){var t=h.getRsBlockTable(n,e);if(null==t)throw new Error("bad rs block @ typeNumber:"+n+"/errorCorrectLevel:"+e);for(var r=t.length/3,i=new Array,a=0;a<r;a++)for(var o=t[3*a+0],s=t[3*a+1],l=t[3*a+2],c=0;c<o;c++)i.push(new h(s,l));return i},h.getRsBlockTable=function(n,e){switch(e){case c.L:return h.RS_BLOCK_TABLE[4*(n-1)+0];case c.M:return h.RS_BLOCK_TABLE[4*(n-1)+1];case c.Q:return h.RS_BLOCK_TABLE[4*(n-1)+2];case c.H:return h.RS_BLOCK_TABLE[4*(n-1)+3];default:return}};var u=h;function d(){this.buffer=new Array,this.length=0}d.prototype={get:function(n){var e=Math.floor(n/8);return 1==(this.buffer[e]>>>7-n%8&1)},put:function(n,e){for(var t=0;t<e;t++)this.putBit(1==(n>>>e-t-1&1))},getLengthInBits:function(){return this.length},putBit:function(n){var e=Math.floor(this.length/8);this.buffer.length<=e&&this.buffer.push(0),n&&(this.buffer[e]|=128>>>this.length%8),this.length++}};for(var p=d,m={glog:function(n){if(n<1)throw new Error("glog("+n+")");return m.LOG_TABLE[n]},gexp:function(n){for(;n<0;)n+=255;for(;n>=256;)n-=255;return m.EXP_TABLE[n]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},f=0;f<8;f++)m.EXP_TABLE[f]=1<<f;for(f=8;f<256;f++)m.EXP_TABLE[f]=m.EXP_TABLE[f-4]^m.EXP_TABLE[f-5]^m.EXP_TABLE[f-6]^m.EXP_TABLE[f-8];for(f=0;f<255;f++)m.LOG_TABLE[m.EXP_TABLE[f]]=f;var g=m;function v(n,e){if(null==n.length)throw new Error(n.length+"/"+e);for(var t=0;t<n.length&&0==n[t];)t++;this.num=new Array(n.length-t+e);for(var r=0;r<n.length-t;r++)this.num[r]=n[r+t]}v.prototype={get:function(n){return this.num[n]},getLength:function(){return this.num.length},multiply:function(n){for(var e=new Array(this.getLength()+n.getLength()-1),t=0;t<this.getLength();t++)for(var r=0;r<n.getLength();r++)e[t+r]^=g.gexp(g.glog(this.get(t))+g.glog(n.get(r)));return new v(e,0)},mod:function(n){if(this.getLength()-n.getLength()<0)return this;for(var e=g.glog(this.get(0))-g.glog(n.get(0)),t=new Array(this.getLength()),r=0;r<this.getLength();r++)t[r]=this.get(r);for(r=0;r<n.getLength();r++)t[r]^=g.gexp(g.glog(n.get(r))+e);return new v(t,0).mod(n)}};var b=v,y=0,w=1,x=2,k=3,S=4,j=5,_=6,T=7,E={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(n){for(var e=n<<10;E.getBCHDigit(e)-E.getBCHDigit(E.G15)>=0;)e^=E.G15<<E.getBCHDigit(e)-E.getBCHDigit(E.G15);return(n<<10|e)^E.G15_MASK},getBCHTypeNumber:function(n){for(var e=n<<12;E.getBCHDigit(e)-E.getBCHDigit(E.G18)>=0;)e^=E.G18<<E.getBCHDigit(e)-E.getBCHDigit(E.G18);return n<<12|e},getBCHDigit:function(n){for(var e=0;0!=n;)e++,n>>>=1;return e},getPatternPosition:function(n){return E.PATTERN_POSITION_TABLE[n-1]},getMask:function(n,e,t){switch(n){case y:return(e+t)%2==0;case w:return e%2==0;case x:return t%3==0;case k:return(e+t)%3==0;case S:return(Math.floor(e/2)+Math.floor(t/3))%2==0;case j:return e*t%2+e*t%3==0;case _:return(e*t%2+e*t%3)%2==0;case T:return(e*t%3+(e+t)%2)%2==0;default:throw new Error("bad maskPattern:"+n)}},getErrorCorrectPolynomial:function(n){for(var e=new b([1],0),t=0;t<n;t++)e=e.multiply(new b([1,g.gexp(t)],0));return e},getLengthInBits:function(n,e){if(1<=e&&e<10)switch(n){case r:return 10;case i:return 9;case a:case o:return 8;default:throw new Error("mode:"+n)}else if(e<27)switch(n){case r:return 12;case i:return 11;case a:return 16;case o:return 10;default:throw new Error("mode:"+n)}else{if(!(e<41))throw new Error("type:"+e);switch(n){case r:return 14;case i:return 13;case a:return 16;case o:return 12;default:throw new Error("mode:"+n)}}},getLostPoint:function(n){for(var e=n.getModuleCount(),t=0,r=0;r<e;r++)for(var i=0;i<e;i++){for(var a=0,o=n.isDark(r,i),s=-1;s<=1;s++)if(!(r+s<0||e<=r+s))for(var l=-1;l<=1;l++)i+l<0||e<=i+l||0==s&&0==l||o==n.isDark(r+s,i+l)&&a++;a>5&&(t+=3+a-5)}for(r=0;r<e-1;r++)for(i=0;i<e-1;i++){var c=0;n.isDark(r,i)&&c++,n.isDark(r+1,i)&&c++,n.isDark(r,i+1)&&c++,n.isDark(r+1,i+1)&&c++,0!=c&&4!=c||(t+=3)}for(r=0;r<e;r++)for(i=0;i<e-6;i++)n.isDark(r,i)&&!n.isDark(r,i+1)&&n.isDark(r,i+2)&&n.isDark(r,i+3)&&n.isDark(r,i+4)&&!n.isDark(r,i+5)&&n.isDark(r,i+6)&&(t+=40);for(i=0;i<e;i++)for(r=0;r<e-6;r++)n.isDark(r,i)&&!n.isDark(r+1,i)&&n.isDark(r+2,i)&&n.isDark(r+3,i)&&n.isDark(r+4,i)&&!n.isDark(r+5,i)&&n.isDark(r+6,i)&&(t+=40);var h=0;for(i=0;i<e;i++)for(r=0;r<e;r++)n.isDark(r,i)&&h++;return t+=10*(Math.abs(100*h/e/e-50)/5)}},C=E;function I(n,e){this.typeNumber=n,this.errorCorrectLevel=e,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var z=I.prototype;z.addData=function(n){var e=new l(n);this.dataList.push(e),this.dataCache=null},z.isDark=function(n,e){if(n<0||this.moduleCount<=n||e<0||this.moduleCount<=e)throw new Error(n+","+e);return this.modules[n][e]},z.getModuleCount=function(){return this.moduleCount},z.make=function(){if(this.typeNumber<1){var n=1;for(n=1;n<40;n++){for(var e=u.getRSBlocks(n,this.errorCorrectLevel),t=new p,r=0,i=0;i<e.length;i++)r+=e[i].dataCount;for(i=0;i<this.dataList.length;i++){var a=this.dataList[i];t.put(a.mode,4),t.put(a.getLength(),C.getLengthInBits(a.mode,n)),a.write(t)}if(t.getLengthInBits()<=8*r)break}this.typeNumber=n}this.makeImpl(!1,this.getBestMaskPattern())},z.makeImpl=function(n,e){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var t=0;t<this.moduleCount;t++){this.modules[t]=new Array(this.moduleCount);for(var r=0;r<this.moduleCount;r++)this.modules[t][r]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(n,e),this.typeNumber>=7&&this.setupTypeNumber(n),null==this.dataCache&&(this.dataCache=I.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,e)},z.setupPositionProbePattern=function(n,e){for(var t=-1;t<=7;t++)if(!(n+t<=-1||this.moduleCount<=n+t))for(var r=-1;r<=7;r++)e+r<=-1||this.moduleCount<=e+r||(this.modules[n+t][e+r]=0<=t&&t<=6&&(0==r||6==r)||0<=r&&r<=6&&(0==t||6==t)||2<=t&&t<=4&&2<=r&&r<=4)},z.getBestMaskPattern=function(){for(var n=0,e=0,t=0;t<8;t++){this.makeImpl(!0,t);var r=C.getLostPoint(this);(0==t||n>r)&&(n=r,e=t)}return e},z.createMovieClip=function(n,e,t){var r=n.createEmptyMovieClip(e,t);this.make();for(var i=0;i<this.modules.length;i++)for(var a=1*i,o=0;o<this.modules[i].length;o++){var s=1*o;this.modules[i][o]&&(r.beginFill(0,100),r.moveTo(s,a),r.lineTo(s+1,a),r.lineTo(s+1,a+1),r.lineTo(s,a+1),r.endFill())}return r},z.setupTimingPattern=function(){for(var n=8;n<this.moduleCount-8;n++)null==this.modules[n][6]&&(this.modules[n][6]=n%2==0);for(var e=8;e<this.moduleCount-8;e++)null==this.modules[6][e]&&(this.modules[6][e]=e%2==0)},z.setupPositionAdjustPattern=function(){for(var n=C.getPatternPosition(this.typeNumber),e=0;e<n.length;e++)for(var t=0;t<n.length;t++){var r=n[e],i=n[t];if(null==this.modules[r][i])for(var a=-2;a<=2;a++)for(var o=-2;o<=2;o++)this.modules[r+a][i+o]=-2==a||2==a||-2==o||2==o||0==a&&0==o}},z.setupTypeNumber=function(n){for(var e=C.getBCHTypeNumber(this.typeNumber),t=0;t<18;t++){var r=!n&&1==(e>>t&1);this.modules[Math.floor(t/3)][t%3+this.moduleCount-8-3]=r}for(t=0;t<18;t++){r=!n&&1==(e>>t&1);this.modules[t%3+this.moduleCount-8-3][Math.floor(t/3)]=r}},z.setupTypeInfo=function(n,e){for(var t=this.errorCorrectLevel<<3|e,r=C.getBCHTypeInfo(t),i=0;i<15;i++){var a=!n&&1==(r>>i&1);i<6?this.modules[i][8]=a:i<8?this.modules[i+1][8]=a:this.modules[this.moduleCount-15+i][8]=a}for(i=0;i<15;i++){a=!n&&1==(r>>i&1);i<8?this.modules[8][this.moduleCount-i-1]=a:i<9?this.modules[8][15-i-1+1]=a:this.modules[8][15-i-1]=a}this.modules[this.moduleCount-8][8]=!n},z.mapData=function(n,e){for(var t=-1,r=this.moduleCount-1,i=7,a=0,o=this.moduleCount-1;o>0;o-=2)for(6==o&&o--;;){for(var s=0;s<2;s++)if(null==this.modules[r][o-s]){var l=!1;a<n.length&&(l=1==(n[a]>>>i&1)),C.getMask(e,r,o-s)&&(l=!l),this.modules[r][o-s]=l,-1==--i&&(a++,i=7)}if((r+=t)<0||this.moduleCount<=r){r-=t,t=-t;break}}},I.PAD0=236,I.PAD1=17,I.createData=function(n,e,t){for(var r=u.getRSBlocks(n,e),i=new p,a=0;a<t.length;a++){var o=t[a];i.put(o.mode,4),i.put(o.getLength(),C.getLengthInBits(o.mode,n)),o.write(i)}var s=0;for(a=0;a<r.length;a++)s+=r[a].dataCount;if(i.getLengthInBits()>8*s)throw new Error("code length overflow. ("+i.getLengthInBits()+">"+8*s+")");for(i.getLengthInBits()+4<=8*s&&i.put(0,4);i.getLengthInBits()%8!=0;)i.putBit(!1);for(;!(i.getLengthInBits()>=8*s||(i.put(I.PAD0,8),i.getLengthInBits()>=8*s));)i.put(I.PAD1,8);return I.createBytes(i,r)},I.createBytes=function(n,e){for(var t=0,r=0,i=0,a=new Array(e.length),o=new Array(e.length),s=0;s<e.length;s++){var l=e[s].dataCount,c=e[s].totalCount-l;r=Math.max(r,l),i=Math.max(i,c),a[s]=new Array(l);for(var h=0;h<a[s].length;h++)a[s][h]=255&n.buffer[h+t];t+=l;var u=C.getErrorCorrectPolynomial(c),d=new b(a[s],u.getLength()-1).mod(u);o[s]=new Array(u.getLength()-1);for(h=0;h<o[s].length;h++){var p=h+d.getLength()-o[s].length;o[s][h]=p>=0?d.get(p):0}}var m=0;for(h=0;h<e.length;h++)m+=e[h].totalCount;var f=new Array(m),g=0;for(h=0;h<r;h++)for(s=0;s<e.length;s++)h<a[s].length&&(f[g++]=a[s][h]);for(h=0;h<i;h++)for(s=0;s<e.length;s++)h<o[s].length&&(f[g++]=o[s][h]);return f};var A=I;var P={components:{QrcodeVue:{props:{value:{type:String,required:!0,default:""},className:{type:String,default:""},size:{type:[Number,String],default:100,validator:function(n){return!0!==isNaN(Number(n))}},level:{type:String,default:"L",validator:function(n){return["L","Q","M","H"].indexOf(n)>-1}},background:{type:String,default:"#fff"},foreground:{type:String,default:"#000"},renderAs:{type:String,required:!1,default:"canvas",validator:function(n){return["canvas","svg"].indexOf(n)>-1}}},data:function(){return{numCells:0,fgPath:""}},updated:function(){this.render()},mounted:function(){this.render()},methods:{render:function(){var n=this.value,e=this.size,t=this.level,r=this.background,i=this.foreground,a=this.renderAs,o=e>>>0,s=new A(-1,c[t]);s.addData(function(n){for(var e="",t=0;t<n.length;t++){var r=n.charCodeAt(t);r<128?e+=String.fromCharCode(r):r<2048?(e+=String.fromCharCode(192|r>>6),e+=String.fromCharCode(128|63&r)):r<55296||r>=57344?(e+=String.fromCharCode(224|r>>12),e+=String.fromCharCode(128|r>>6&63),e+=String.fromCharCode(128|63&r)):(t++,r=65536+((1023&r)<<10|1023&n.charCodeAt(t)),e+=String.fromCharCode(240|r>>18),e+=String.fromCharCode(128|r>>12&63),e+=String.fromCharCode(128|r>>6&63),e+=String.fromCharCode(128|63&r))}return e}(n)),s.make();var l=s.modules,h=o/l.length,u=o/l.length,d=window.devicePixelRatio||1;if("svg"===a)this.numCells=l.length,this.fgPath=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=[];return n.forEach((function(n,r){var i=null;n.forEach((function(a,o){if(!a&&null!==i)return t.push("M".concat(i+e," ").concat(r+e,"h").concat(o-i,"v1H").concat(i+e,"z")),void(i=null);if(o!==n.length-1)a&&null===i&&(i=o);else{if(!a)return;null===i?t.push("M".concat(o+e,",").concat(r+e," h1v1H").concat(o+e,"z")):t.push("M".concat(i+e,",").concat(r+e," h").concat(o+1-i,"v1H").concat(i+e,"z"))}}))})),t.join("")}(l);else{var p=this.$refs["qrcode-vue"],m=p.getContext("2d");p.height=p.width=o*d,m.scale(d,d),l.forEach((function(n,e){n.forEach((function(n,t){m.fillStyle=n?i:r;var a=Math.ceil((t+1)*h)-Math.floor(t*h),o=Math.ceil((e+1)*u)-Math.floor(e*u);m.fillRect(Math.round(t*h),Math.round(e*u),a,o)}))}))}}},render:function(n){var e=this.className,t=this.value,r=this.level,i=this.background,a=this.foreground,o=this.size,s=this.renderAs,l=this.numCells,c=this.fgPath;return n("div",{class:this.class||e,attrs:{value:t,level:r,background:i,foreground:a}},["svg"===s?n("svg",{attrs:{height:o,width:o,shapeRendering:"crispEdges",viewBox:"0 0 ".concat(l," ").concat(l)},style:{width:o+"px",height:o+"px"}},[n("path",{attrs:{fill:i,d:"M0,0 h".concat(l,"v").concat(l,"H0z")}}),n("path",{attrs:{fill:a,d:c}})]):n("canvas",{attrs:{height:o,width:o},style:{width:o+"px",height:o+"px"},ref:"qrcode-vue"},[])])}}},data:()=>({show:!1,qrcodeText:"",qrSize:100,channelQR:""}),props:{size:{type:[String,Number],default:"small"},channel:{type:Boolean,default:!1}},mounted(){let n=this.size,e="";switch(n){case"small":e=100;break;case"medium":e=150;break;case"big":e=200;break;default:if(null==(t=n)||""===t.toString().replace(/\s/g,"")||""==typeof t||isNaN(t))e=100;else{const t=Math.min(window.innerHeight,window.innerWidth);n=~~n,e=n<10?10:n>t?t:n}}var t;this.qrSize=e,this.channel&&(this.channelQR=location.href.indexOf("?")>-1?"&channel=qrcode":"?channel=qrcode"),document.documentElement.addEventListener("mousedown",()=>{this.show=!1})},methods:{showQrCode(){this.show=!this.show,this.show&&this.$nextTick(()=>{this.qrcodeText=location.href+this.channelQR})}}},O=(t(251),t(1)),q=Object(O.a)(P,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"qrcodeBtn",attrs:{title:"手机查看"},on:{mousedown:function(e){return e.stopPropagation(),n.showQrCode.apply(null,arguments)}}},[n._v("\n\t🎛️\n\t"),n.show?e("qrcode-vue",{ref:"qrcodeContainer",attrs:{id:"qrcodeContainer",value:n.qrcodeText,size:n.qrSize,level:"H"}}):n._e()],1)}),[],!1,null,null,null);e.default=q.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(253),t(1)),a=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"1e7dd946",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(254),t(1)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"9a3094b0",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(3),i=t(10),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var r=t(6),i=t(4);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(66),i=t(68),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){var r=t(5),i=t(8),a=t(33),o=t(129).indexOf,s=t(53),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,h=[];for(t in r)!i(s,t)&&i(r,t)&&l(h,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(h,t)||l(h,t));return h}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e){var t,r,i=n.exports={};function a(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function s(n){if(t===setTimeout)return setTimeout(n,0);if((t===a||!t)&&setTimeout)return t=setTimeout,setTimeout(n,0);try{return t(n,0)}catch(e){try{return t.call(null,n,0)}catch(e){return t.call(this,n,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:a}catch(n){t=a}try{r="function"==typeof clearTimeout?clearTimeout:o}catch(n){r=o}}();var l,c=[],h=!1,u=-1;function d(){h&&l&&(h=!1,l.length?c=l.concat(c):u=-1,c.length&&p())}function p(){if(!h){var n=s(d);h=!0;for(var e=c.length;e;){for(l=c,c=[];++u<e;)l&&l[u].run();u=-1,e=c.length}l=null,h=!1,function(n){if(r===clearTimeout)return clearTimeout(n);if((r===o||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(n);try{r(n)}catch(e){try{return r.call(null,n)}catch(e){return r.call(this,n)}}}(n)}}function m(n,e){this.fun=n,this.array=e}function f(){}i.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];c.push(new m(n,e)),1!==c.length||h||s(p)},m.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=f,i.addListener=f,i.once=f,i.off=f,i.removeListener=f,i.removeAllListeners=f,i.emit=f,i.prependListener=f,i.prependOnceListener=f,i.listeners=function(n){return[]},i.binding=function(n){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(n){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(n,e,t){n.exports=t(267)},function(n,e,t){"use strict";var r=t(19),i=t(135).left,a=t(136),o=t(65),s=t(137);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(36),i=t(10),a=t(61),o=t(118),s=t(120),l=t(22),c=TypeError,h=l("toPrimitive");n.exports=function(n,e){if(!i(n)||a(n))return n;var t,l=o(n,h);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!i(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(21);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(52),i=t(58);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(36),i=t(2),a=t(10),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&i(t=n.toString)&&!a(s=r(t,n)))return s;if(i(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&i(t=n.toString)&&!a(s=r(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var r=t(2),i=t(14),a=t(122),o=t(39);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&a(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(4),i=t(2),a=t(8),o=t(6),s=t(123).CONFIGURABLE,l=t(124),c=t(125),h=c.enforce,u=c.get,d=Object.defineProperty,p=o&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),m=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&(o?d(n,"name",{value:e,configurable:!0}):n.name=e),p&&t&&a(t,"arity")&&n.length!==t.arity&&d(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?o&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=h(n);return a(r,"source")||(r.source=m.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return i(this)&&u(this).source||l(this)}),"toString")},function(n,e,t){var r=t(6),i=t(8),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(5),i=t(2),a=t(38),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e,t){var r,i,a,o=t(126),s=t(3),l=t(10),c=t(23),h=t(8),u=t(38),d=t(109),p=t(53),m=s.TypeError,f=s.WeakMap;if(o||u.state){var g=u.state||(u.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw m("Object already initialized");return e.facade=n,g.set(n,e),e},i=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var v=d("state");p[v]=!0,r=function(n,e){if(h(n,v))throw m("Object already initialized");return e.facade=n,c(n,v,e),e},i=function(n){return h(n,v)?n[v]:{}},a=function(n){return h(n,v)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(3),i=t(2),a=r.WeakMap;n.exports=i(a)&&/native code/.test(String(a))},function(n,e,t){var r=t(21),i=t(5),a=t(128),o=t(133),s=t(31),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(110),i=t(106).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){var r=t(33),i=t(130),a=t(35),o=function(n){return function(e,t,o){var s,l=r(e),c=a(l),h=i(o,c);if(n&&t!=t){for(;c>h;)if((s=l[h++])!=s)return!0}else for(;c>h;h++)if((n||h in l)&&l[h]===t)return n||h||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(71),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(71),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(4),i=t(2),a=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==h||t!=c&&(i(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",h=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(52),i=t(34),a=t(51),o=t(35),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var h=i(e),u=a(h),d=o(h),p=n?d-1:0,m=n?-1:1;if(l<2)for(;;){if(p in u){c=u[p],p+=m;break}if(p+=m,n?p<0:d<=p)throw s("Reduce of empty array with no initial value")}for(;n?p>=0:d>p;p+=m)p in u&&(c=t(c,u[p],p,h));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(20),i=t(3);n.exports="process"==r(i.process)},function(n,e,t){"use strict";var r=t(6),i=t(139),a=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(i(n)&&!o(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(20);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(19),i=t(3),a=t(142),o=t(143),s=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},h=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),h("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),h("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),h("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(32),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(21),i=t(8),a=t(23),o=t(62),s=t(72),l=t(70),c=t(145),h=t(146),u=t(147),d=t(151),p=t(152),m=t(153),f=t(6),g=t(67);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),w=y[y.length-1],x=r.apply(null,y);if(x){var k=x.prototype;if(!g&&i(k,"cause")&&delete k.cause,!t)return x;var S=r("Error"),j=e((function(n,e){var t=u(v?e:n,void 0),r=v?new x(n):new x;return void 0!==t&&a(r,"message",t),m&&a(r,"stack",p(r.stack,2)),this&&o(k,this)&&h(r,this,j),arguments.length>b&&d(r,arguments[b]),r}));if(j.prototype=k,"Error"!==w?s?s(j,S):l(j,S,{name:!0}):f&&"stackTraceLimit"in x&&(c(j,x,"stackTraceLimit"),c(j,x,"prepareStackTrace")),l(j,x),!g)try{k.name!==w&&a(k,"name",w),k.constructor=j}catch(n){}return j}}},function(n,e,t){var r=t(2),i=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+i(n)+" as a prototype")}},function(n,e,t){var r=t(14).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(2),i=t(10),a=t(72);n.exports=function(n,e,t){var o,s;return a&&r(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var r=t(148);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(149),i=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var r=t(150),i=t(2),a=t(20),o=t(22)("toStringTag"),s=Object,l="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?a(e):"Object"==(r=a(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(22)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(10),i=t(23);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var r=t(5),i=Error,a=r("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(4),i=t(37);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(73),i=t(155);n.exports=function n(e,t,a,o,s){var l=-1,c=e.length;for(a||(a=i),s||(s=[]);++l<c;){var h=e[l];t>0&&a(h)?t>1?n(h,t-1,a,o,s):r(s,h):o||(s[s.length]=h)}return s}},function(n,e,t){var r=t(16),i=t(40),a=t(7),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(15),i=t(13);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(16),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(160),i=t(216),a=t(48),o=t(7),s=t(227);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(161),i=t(215),a=t(90);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(75),i=t(79);n.exports=function(n,e,t,a){var o=t.length,s=o,l=!a;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var h=(c=t[o])[0],u=n[h],d=c[1];if(l&&c[2]){if(void 0===u&&!(h in n))return!1}else{var p=new r;if(a)var m=a(u,d,h,n,e,p);if(!(void 0===m?i(d,u,3,a,p):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(25),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(25);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(25);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(25);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(24);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(24),i=t(41),a=t(43);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(77),i=t(173),a=t(42),o=t(78),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,h=l.toString,u=c.hasOwnProperty,d=RegExp("^"+h.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?d:s).test(o(n))}},function(n,e,t){var r,i=t(174),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(9)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(177),i=t(24),a=t(41);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(178),i=t(179),a=t(180),o=t(181),s=t(182);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(26);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(26),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(26),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(26);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(27);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(27);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(27);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(27);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(75),i=t(80),a=t(192),o=t(195),s=t(211),l=t(7),c=t(84),h=t(86),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,p,m,f){var g=l(n),v=l(e),b=g?"[object Array]":s(n),y=v?"[object Array]":s(e),w=(b="[object Arguments]"==b?u:b)==u,x=(y="[object Arguments]"==y?u:y)==u,k=b==y;if(k&&c(n)){if(!c(e))return!1;g=!0,w=!1}if(k&&!w)return f||(f=new r),g||h(n)?i(n,e,t,p,m,f):a(n,e,b,t,p,m,f);if(!(1&t)){var S=w&&d.call(n,"__wrapped__"),j=x&&d.call(e,"__wrapped__");if(S||j){var _=S?n.value():n,T=j?e.value():e;return f||(f=new r),m(_,T,t,p,f)}}return!!k&&(f||(f=new r),o(n,e,t,p,m,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(16),i=t(193),a=t(76),o=t(80),s=t(194),l=t(44),c=r?r.prototype:void 0,h=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var p=s;case"[object Set]":var m=1&r;if(p||(p=l),n.size!=e.size&&!m)return!1;var f=d.get(n);if(f)return f==e;r|=2,d.set(n,e);var g=o(p(n),p(e),r,c,u,d);return d.delete(n),g;case"[object Symbol]":if(h)return h.call(n)==h.call(e)}return!1}},function(n,e,t){var r=t(9).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(196),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var l=1&t,c=r(n),h=c.length;if(h!=r(e).length&&!l)return!1;for(var u=h;u--;){var d=c[u];if(!(l?d in e:i.call(e,d)))return!1}var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++u<h;){var v=n[d=c[u]],b=e[d];if(a)var y=l?a(b,v,d,e,n,s):a(v,b,d,n,e,s);if(!(void 0===y?v===b||o(v,b,t,a,s):y)){f=!1;break}g||(g="constructor"==d)}if(f&&!g){var w=n.constructor,x=e.constructor;w==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof w&&w instanceof w&&"function"==typeof x&&x instanceof x||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(197),i=t(198),a=t(83);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(73),i=t(7);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(199),i=t(200),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(202),i=t(40),a=t(7),o=t(84),s=t(85),l=t(86),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),h=!t&&i(n),u=!t&&!h&&o(n),d=!t&&!h&&!u&&l(n),p=t||h||u||d,m=p?r(n.length,String):[],f=m.length;for(var g in n)!e&&!c.call(n,g)||p&&("length"==g||u&&("offset"==g||"parent"==g)||d&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||m.push(g);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(15),i=t(45),a=t(13),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(74),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(54)(n))},function(n,e,t){var r=t(208),i=t(209),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(210)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(212),i=t(41),a=t(213),o=t(88),s=t(214),l=t(15),c=t(78),h=c(r),u=c(i),d=c(a),p=c(o),m=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=f(new i)||a&&"[object Promise]"!=f(a.resolve())||o&&"[object Set]"!=f(new o)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case h:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case p:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(11)(t(9),"DataView");n.exports=r},function(n,e,t){var r=t(11)(t(9),"Promise");n.exports=r},function(n,e,t){var r=t(11)(t(9),"WeakMap");n.exports=r},function(n,e,t){var r=t(89),i=t(83);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(79),i=t(217),a=t(224),o=t(46),s=t(89),l=t(90),c=t(28);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(91);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(219),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(220);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(43);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(222);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(16),i=t(223),a=t(7),o=t(47),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(225),i=t(226);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(92),i=t(40),a=t(7),o=t(85),s=t(45),l=t(28);n.exports=function(n,e,t){for(var c=-1,h=(e=r(e,n)).length,u=!1;++c<h;){var d=l(e[c]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++c!=h?u:!!(h=null==n?0:n.length)&&s(h)&&o(d,h)&&(a(n)||i(n))}},function(n,e,t){var r=t(228),i=t(229),a=t(46),o=t(28);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(91);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(48),i=t(231),a=t(233);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(232),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=i(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(234),i=t(237)(r);n.exports=i},function(n,e,t){var r=t(235),i=t(236),a=t(48),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(11),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(81),i=t(239),a=t(244),o=t(82),s=t(245),l=t(44);n.exports=function(n,e,t){var c=-1,h=i,u=n.length,d=!0,p=[],m=p;if(t)d=!1,h=a;else if(u>=200){var f=e?null:s(n);if(f)return l(f);d=!1,h=o,m=new r}else m=e?[]:p;n:for(;++c<u;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,d&&v==v){for(var b=m.length;b--;)if(m[b]===v)continue n;e&&m.push(v),p.push(g)}else h(m,v,t)||(m!==p&&m.push(v),p.push(g))}return p}},function(n,e,t){var r=t(240);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(241),i=t(242),a=t(243);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(88),i=t(246),a=t(44),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(87),i=t(13);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";t(94)},function(n,e,t){"use strict";t(95)},function(n,e,t){"use strict";t(96)},function(n,e,t){"use strict";t(97)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(19),i=t(3),a=t(258);r({global:!0},{Reflect:{}}),a(i.Reflect,"Reflect",!0)},function(n,e,t){var r=t(14).f,i=t(8),a=t(22)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e,t){(function(n){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var i=n[r];"."===i?n.splice(r,1):".."===i?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var e="",i=!1,a=arguments.length-1;a>=-1&&!i;a--){var o=a>=0?arguments[a]:n.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(e=o+"/"+e,i="/"===o.charAt(0))}return(i?"/":"")+(e=t(r(e.split("/"),(function(n){return!!n})),!i).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),o="/"===i(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&o&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var i=r(n.split("/")),a=r(t.split("/")),o=Math.min(i.length,a.length),s=o,l=0;l<o;l++)if(i[l]!==a[l]){s=l;break}var c=[];for(l=s;l<i.length;l++)c.push("..");return(c=c.concat(a.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,i=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!i){r=a;break}}else i=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,i=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!i){t=e+1;break}}else-1===r&&(i=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,i=!0,a=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===r&&(i=!1,r=o+1),46===s?-1===e?e=o:1!==a&&(a=1):-1!==e&&(a=-1);else if(!i){t=o+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var i="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}}).call(this,t(112))},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function o(n){return i[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var i=t[r];void 0!==e[i]&&(n[i]=e[i])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(98)},function(n,e,t){"use strict";t(99)},function(n,e,t){"use strict";t.r(e);var r=t(0);
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */function i(n,e){for(var t in e)n[t]=e[t];return n}var a=/[!'()*]/g,o=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(a,o).replace(s,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var h=function(n){return null==n||"object"==typeof n?n:String(n)};function u(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=c(t.shift()),i=t.length>0?c(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function d(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(l(e)):r.push(l(e)+"="+l(n)))})),r.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var p=/\/?$/;function m(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=f(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:b(e,i),matched:n?v(n):[]};return t&&(o.redirectedFrom=b(t,i)),Object.freeze(o)}function f(n){if(Array.isArray(n))return n.map(f);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=f(n[t]);return e}return n}var g=m(null,{path:"/"});function v(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function b(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||d)(r)+i}function y(n,e,t){return e===g?n===e:!!e&&(n.path&&e.path?n.path.replace(p,"")===e.path.replace(p,"")&&(t||n.hash===e.hash&&w(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&w(n.query,e.query)&&w(n.params,e.params))))}function w(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?w(a,o):String(a)===String(o)}))}function x(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var k={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var s=a.$createElement,l=t.name,c=a.$route,h=a._routerViewCache||(a._routerViewCache={}),u=0,d=!1;a&&a._routerRoot!==a;){var p=a.$vnode?a.$vnode.data:{};p.routerView&&u++,p.keepAlive&&a._directInactive&&a._inactive&&(d=!0),a=a.$parent}if(o.routerViewDepth=u,d){var m=h[l],f=m&&m.component;return f?(m.configProps&&S(f,o,m.route,m.configProps),s(f,o,r)):s()}var g=c.matched[u],v=g&&g.components[l];if(!g||!v)return h[l]=null,s();h[l]={component:v},o.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),x(c)};var b=g.props&&g.props[l];return b&&(i(h[l],{route:c,configProps:b}),S(v,o,c,b)),s(v,o,r)}};function S(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=i({},a);var o=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(o[s]=a[s],delete a[s])}}function j(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function _(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var T=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},E=F,C=O,I=function(n,e){return L(O(n,e),e)},z=L,A=R,P=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function O(n,e){for(var t,r=[],i=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=P.exec(n));){var l=t[0],c=t[1],h=t.index;if(o+=n.slice(a,h),a=h+l.length,c)o+=c[1];else{var u=n[a],d=t[2],p=t[3],m=t[4],f=t[5],g=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=d&&null!=u&&u!==d,y="+"===g||"*"===g,w="?"===g||"*"===g,x=t[2]||s,k=m||f;r.push({name:p||i++,prefix:d||"",delimiter:x,optional:w,repeat:y,partial:b,asterisk:!!v,pattern:k?D(k):v?".*":"[^"+N(x)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function q(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function L(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",M(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?q:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,h=a[l.name];if(null==h){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(T(h)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(h)+"`");if(0===h.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<h.length;u++){if(c=o(h[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(h).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(h),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function N(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function D(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function B(n,e){return n.keys=e,n}function M(n){return n&&n.sensitive?"":"i"}function R(n,e,t){T(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=N(s);else{var l=N(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var h=N(t.delimiter||"/"),u=a.slice(-h.length)===h;return r||(a=(u?a.slice(0,-h.length):a)+"(?:"+h+"(?=$))?"),a+=i?"$":r&&u?"":"(?="+h+"|$)",B(new RegExp("^"+a,M(t)),e)}function F(n,e,t){return T(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return B(n,e)}(n,e):T(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(F(n[i],e,t).source);return B(new RegExp("(?:"+r.join("|")+")",M(t)),e)}(n,e,t):function(n,e,t){return R(O(n,t),e,t)}(n,e,t)}E.parse=C,E.compile=I,E.tokensToFunction=z,E.tokensToRegExp=A;var U=Object.create(null);function V(n,e,t){e=e||{};try{var r=U[n]||(U[n]=E.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function J(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=i({},n)).params;return o&&"object"==typeof o&&(a.params=i({},o)),a}if(!a.path&&a.params&&e){(a=i({},a))._normalized=!0;var s=i(i({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=V(l,s,e.path)}else 0;return a}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(a.path||""),d=e&&e.path||"/",p=c.path?j(c.path,d,t||a.append):d,m=function(n,e,t){void 0===e&&(e={});var r,i=t||u;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(h):h(o)}return r}(c.query,a.query,r&&r.options.parseQuery),f=a.hash||c.hash;return f&&"#"!==f.charAt(0)&&(f="#"+f),{_normalized:!0,path:p,query:m,hash:f}}var H,$=function(){},G={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,s=a.route,l=a.href,c={},h=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==h?"router-link-active":h,f=null==u?"router-link-exact-active":u,g=null==this.activeClass?d:this.activeClass,v=null==this.exactActiveClass?f:this.exactActiveClass,b=s.redirectedFrom?m(null,J(s.redirectedFrom),null,t):s;c[v]=y(r,b,this.exactPath),c[g]=this.exact||this.exactPath?c[v]:function(n,e){return 0===n.path.replace(p,"/").indexOf(e.path.replace(p,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,b);var w=c[v]?this.ariaCurrentValue:null,x=function(n){W(n)&&(e.replace?t.replace(o,$):t.push(o,$))},k={click:W};Array.isArray(this.event)?this.event.forEach((function(n){k[n]=x})):k[this.event]=x;var S={class:c},j=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:x,isActive:c[g],isExactActive:c[v]});if(j){if(1===j.length)return j[0];if(j.length>1||!j.length)return 0===j.length?n():n("span",{},j)}if("a"===this.tag)S.on=k,S.attrs={href:l,"aria-current":w};else{var _=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(_){_.isStatic=!1;var T=_.data=i({},_.data);for(var E in T.on=T.on||{},T.on){var C=T.on[E];E in k&&(T.on[E]=Array.isArray(C)?C:[C])}for(var I in k)I in T.on?T.on[I].push(k[I]):T.on[I]=x;var z=_.data.attrs=i({},_.data.attrs);z.href=l,z["aria-current"]=w}else S.on=k}return n(this.tag,S,this.$slots.default)}};function W(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var K="undefined"!=typeof window;function Q(n,e,t,r,i){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var s=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},h=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return _(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:h,regex:Z(h,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?_(o+"/"+i.path):void 0;n(e,t,r,i,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],p=0;p<d.length;++p){0;var m={path:d[p],children:i.children};n(e,t,r,m,a,u.path||"/")}l&&(r[l]||(r[l]=u))}(a,o,s,n,i)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:o,nameMap:s}}function Z(n,e){return E(n,[],e)}function X(n,e){var t=Q(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var s=J(n,t,!1,e),c=s.name;if(c){var h=a[c];if(!h)return l(null,s);var u=h.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&u.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=V(h.path,s.params),l(h,s,o)}if(s.path){s.params={};for(var p=0;p<r.length;p++){var m=r[p],f=i[m];if(Y(f.regex,s.path,s.params))return l(f,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(m(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,c=s.name,h=s.path,u=t.query,d=t.hash,p=t.params;if(u=s.hasOwnProperty("query")?s.query:u,d=s.hasOwnProperty("hash")?s.hash:d,p=s.hasOwnProperty("params")?s.params:p,c){a[c];return o({_normalized:!0,name:c,query:u,hash:d,params:p},void 0,t)}if(h){var f=function(n,e){return j(n,e.parent?e.parent.path:"/",!0)}(h,n);return o({_normalized:!0,path:V(f,p),query:u,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:V(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):m(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Q([e||n],r,i,a,t),t&&t.alias.length&&Q(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Q(n,r,i,a)}}}function Y(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?c(r[i]):r[i])}return!0}var nn=K&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function rn(){return tn}function an(n){return tn=n}var on=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=i({},window.history.state);return t.key=rn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",hn),function(){window.removeEventListener("popstate",hn)}}function ln(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=rn();if(n)return on[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){fn(n,a)})).catch((function(n){0})):fn(o,a))}))}}function cn(){var n=rn();n&&(on[n]={x:window.pageXOffset,y:window.pageYOffset})}function hn(n){cn(),n.state&&n.state.key&&an(n.state.key)}function un(n){return pn(n.x)||pn(n.y)}function dn(n){return{x:pn(n.x)?n.x:window.pageXOffset,y:pn(n.y)?n.y:window.pageYOffset}}function pn(n){return"number"==typeof n}var mn=/^#\d/;function fn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=mn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:pn((t=a).x)?t.x:0,y:pn(t.y)?t.y:0})}else un(n)&&(e=dn(n))}else r&&un(n)&&(e=dn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var gn,vn=K&&((-1===(gn=window.navigator.userAgent).indexOf("Android 2.")&&-1===gn.indexOf("Android 4.0")||-1===gn.indexOf("Mobile Safari")||-1!==gn.indexOf("Chrome")||-1!==gn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function bn(n,e){cn();var t=window.history;try{if(e){var r=i({},t.state);r.key=rn(),t.replaceState(r,"",n)}else t.pushState({key:an(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function yn(n){bn(n,!0)}var wn={redirected:2,aborted:4,cancelled:8,duplicated:16};function xn(n,e){return Sn(n,e,wn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return jn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function kn(n,e){return Sn(n,e,wn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Sn(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var jn=["params","query","hash"];function _n(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Tn(n,e){return _n(n)&&n._isRouter&&(null==e||n.type===e)}function En(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Cn(n){return function(e,t,r){var i=!1,a=0,o=null;In(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,c=Pn((function(e){var i;((i=e).__esModule||An&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:H.extend(e),t.components[s]=e,--a<=0&&r()})),h=Pn((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=_n(n)?n:new Error(e),r(o))}));try{l=n(c,h)}catch(n){h(n)}if(l)if("function"==typeof l.then)l.then(c,h);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,h)}}})),i||r()}}function In(n,e){return zn(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function zn(n){return Array.prototype.concat.apply([],n)}var An="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Pn(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var On=function(n,e){this.router=n,this.base=function(n){if(!n)if(K){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=g,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function qn(n,e,t,r){var i=In(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=H.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return zn(r?i.reverse():i)}function Ln(n,e){if(e)return function(){return n.apply(e,arguments)}}On.prototype.listen=function(n){this.cb=n},On.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},On.prototype.onError=function(n){this.errorCbs.push(n)},On.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(Tn(n,wn.redirected)&&a===g||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},On.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!Tn(n)&&_n(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(y(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&ln(this.router,i,n,!1),s(((o=Sn(a=i,n,wn.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var h=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=h.updated,d=h.deactivated,p=h.activated,m=[].concat(function(n){return qn(n,"beforeRouteLeave",Ln,!0)}(d),this.router.beforeHooks,function(n){return qn(n,"beforeRouteUpdate",Ln)}(u),p.map((function(n){return n.beforeEnter})),Cn(p)),f=function(e,t){if(r.pending!==n)return s(kn(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return Sn(n,e,wn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):_n(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(xn(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};En(m,f,(function(){En(function(n){return qn(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(p).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return s(kn(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){x(n)}))}))}))},On.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},On.prototype.setupListeners=function(){},On.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=g,this.pending=null};var Nn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Dn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=vn&&t;r&&this.listeners.push(sn());var i=function(){var t=n.current,i=Dn(n.base);n.current===g&&i===n._startLocation||n.transitionTo(i,(function(n){r&&ln(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){bn(_(r.base+n.fullPath)),ln(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){yn(_(r.base+n.fullPath)),ln(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Dn(this.base)!==this.current.fullPath){var e=_(this.base+this.current.fullPath);n?bn(e):yn(e)}},e.prototype.getCurrentLocation=function(){return Dn(this.base)},e}(On);function Dn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(_(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Bn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Dn(n);if(!/^\/#/.test(e))return window.location.replace(_(n+"/#"+e)),!0}(this.base)||Mn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=vn&&e;t&&this.listeners.push(sn());var r=function(){var e=n.current;Mn()&&n.transitionTo(Rn(),(function(r){t&&ln(n.router,r,e,!0),vn||Vn(r.fullPath)}))},i=vn?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Un(n.fullPath),ln(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Vn(n.fullPath),ln(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Rn()!==e&&(n?Un(e):Vn(e))},e.prototype.getCurrentLocation=function(){return Rn()},e}(On);function Mn(){var n=Rn();return"/"===n.charAt(0)||(Vn("/"+n),!1)}function Rn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Fn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Un(n){vn?bn(Fn(n)):window.location.hash=n}function Vn(n){vn?yn(Fn(n)):window.location.replace(Fn(n))}var Jn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Tn(n,wn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(On),Hn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=X(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!vn&&!1!==n.fallback,this.fallback&&(e="hash"),K||(e="abstract"),this.mode=e,e){case"history":this.history=new Nn(this,n.base);break;case"hash":this.history=new Bn(this,n.base,this.fallback);break;case"abstract":this.history=new Jn(this,n.base);break;default:0}},$n={currentRoute:{configurable:!0}};Hn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},$n.currentRoute.get=function(){return this.history&&this.history.current},Hn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Nn||t instanceof Bn){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;vn&&i&&"fullPath"in n&&ln(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Hn.prototype.beforeEach=function(n){return Wn(this.beforeHooks,n)},Hn.prototype.beforeResolve=function(n){return Wn(this.resolveHooks,n)},Hn.prototype.afterEach=function(n){return Wn(this.afterHooks,n)},Hn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Hn.prototype.onError=function(n){this.history.onError(n)},Hn.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Hn.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Hn.prototype.go=function(n){this.history.go(n)},Hn.prototype.back=function(){this.go(-1)},Hn.prototype.forward=function(){this.go(1)},Hn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Hn.prototype.resolve=function(n,e,t){var r=J(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?_(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},Hn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Hn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Hn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Hn.prototype,$n);var Gn=Hn;function Wn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Hn.install=function n(e){if(!n.installed||H!==e){n.installed=!0,H=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",k),e.component("RouterLink",G);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Hn.version="3.6.5",Hn.isNavigationFailure=Tn,Hn.NavigationFailureType=wn,Hn.START_LOCATION=g,K&&window.Vue&&window.Vue.use(Hn);t(114);t(17),t(141);var Kn={NotFound:()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,365)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,364))},Qn={"v-486da2db":()=>t.e(11).then(t.bind(null,371)),"v-2b6c279e":()=>t.e(13).then(t.bind(null,372)),"v-05f4bc51":()=>t.e(12).then(t.bind(null,373)),"v-6d3cde30":()=>t.e(14).then(t.bind(null,374)),"v-b8d450b8":()=>t.e(15).then(t.bind(null,375)),"v-aee07d78":()=>t.e(16).then(t.bind(null,376)),"v-00ca2008":()=>t.e(17).then(t.bind(null,377)),"v-139bd2e6":()=>t.e(18).then(t.bind(null,378)),"v-482f803c":()=>t.e(20).then(t.bind(null,379)),"v-3712a3c0":()=>t.e(19).then(t.bind(null,380)),"v-131a8800":()=>t.e(21).then(t.bind(null,381)),"v-0ba4d67b":()=>t.e(22).then(t.bind(null,382)),"v-1ae8a7a5":()=>t.e(23).then(t.bind(null,383)),"v-c59b6bb6":()=>t.e(24).then(t.bind(null,384)),"v-34625985":()=>t.e(25).then(t.bind(null,385)),"v-4a6a90eb":()=>t.e(26).then(t.bind(null,386)),"v-2955bc57":()=>t.e(27).then(t.bind(null,387)),"v-266e70f7":()=>t.e(28).then(t.bind(null,388)),"v-5f2c0b7c":()=>t.e(29).then(t.bind(null,389)),"v-50ca6409":()=>t.e(30).then(t.bind(null,390)),"v-7e089229":()=>t.e(31).then(t.bind(null,391)),"v-4da18530":()=>t.e(32).then(t.bind(null,392)),"v-3fb26e0a":()=>t.e(33).then(t.bind(null,393)),"v-3a0c73d0":()=>t.e(34).then(t.bind(null,394)),"v-7d2299f8":()=>t.e(35).then(t.bind(null,395)),"v-08c0f6d6":()=>t.e(36).then(t.bind(null,396)),"v-7c919012":()=>t.e(37).then(t.bind(null,397)),"v-58cd83de":()=>t.e(38).then(t.bind(null,398)),"v-ec80aaaa":()=>t.e(39).then(t.bind(null,399)),"v-3ee6121d":()=>t.e(40).then(t.bind(null,400)),"v-27f6e919":()=>t.e(41).then(t.bind(null,401)),"v-c42c0f0a":()=>t.e(42).then(t.bind(null,402)),"v-3d00a37d":()=>t.e(43).then(t.bind(null,403)),"v-01cb1163":()=>t.e(44).then(t.bind(null,404)),"v-226b6aaa":()=>t.e(45).then(t.bind(null,405)),"v-2419e8d6":()=>t.e(46).then(t.bind(null,406)),"v-0250e5f5":()=>t.e(47).then(t.bind(null,407)),"v-715e4442":()=>t.e(48).then(t.bind(null,408)),"v-7fb2d211":()=>t.e(49).then(t.bind(null,409)),"v-526958bd":()=>t.e(50).then(t.bind(null,410)),"v-79404cc6":()=>t.e(51).then(t.bind(null,411)),"v-db6ed89a":()=>t.e(52).then(t.bind(null,412)),"v-0fbcee25":()=>t.e(53).then(t.bind(null,413)),"v-77378f5f":()=>t.e(54).then(t.bind(null,414)),"v-103bfede":()=>t.e(55).then(t.bind(null,415)),"v-301e60cb":()=>t.e(56).then(t.bind(null,416)),"v-6133e59d":()=>t.e(57).then(t.bind(null,417)),"v-a164921e":()=>t.e(58).then(t.bind(null,418)),"v-e701027e":()=>t.e(59).then(t.bind(null,419)),"v-0902897a":()=>t.e(60).then(t.bind(null,420)),"v-11223575":()=>t.e(61).then(t.bind(null,421)),"v-b55c4a5e":()=>t.e(62).then(t.bind(null,422)),"v-695ad56b":()=>t.e(63).then(t.bind(null,423)),"v-0dd76b46":()=>t.e(64).then(t.bind(null,424)),"v-4078729f":()=>t.e(66).then(t.bind(null,425)),"v-0ad06882":()=>t.e(65).then(t.bind(null,426)),"v-fa1be2c2":()=>t.e(67).then(t.bind(null,427)),"v-23d00e9f":()=>t.e(68).then(t.bind(null,428)),"v-1214d082":()=>t.e(69).then(t.bind(null,429)),"v-e5a79402":()=>t.e(70).then(t.bind(null,430)),"v-322335c9":()=>t.e(71).then(t.bind(null,431)),"v-2b567a55":()=>t.e(72).then(t.bind(null,432)),"v-016423d6":()=>t.e(73).then(t.bind(null,433)),"v-2a5dea95":()=>t.e(74).then(t.bind(null,434)),"v-4bb15016":()=>t.e(75).then(t.bind(null,435)),"v-65cde415":()=>t.e(76).then(t.bind(null,436)),"v-f5c59296":()=>t.e(77).then(t.bind(null,437)),"v-2d1854f5":()=>t.e(78).then(t.bind(null,438)),"v-1058a9ab":()=>t.e(79).then(t.bind(null,439)),"v-1b91e26f":()=>t.e(80).then(t.bind(null,440)),"v-d2c44896":()=>t.e(81).then(t.bind(null,441)),"v-0bb20215":()=>t.e(82).then(t.bind(null,442)),"v-1dc711f5":()=>t.e(83).then(t.bind(null,443)),"v-7c5caa77":()=>t.e(84).then(t.bind(null,444)),"v-3b854396":()=>t.e(85).then(t.bind(null,445)),"v-494ae7f9":()=>t.e(86).then(t.bind(null,446)),"v-93bae096":()=>t.e(87).then(t.bind(null,447)),"v-12469ad5":()=>t.e(88).then(t.bind(null,448)),"v-530e2e09":()=>t.e(89).then(t.bind(null,449)),"v-7664ccdf":()=>t.e(90).then(t.bind(null,450)),"v-419c9df5":()=>t.e(91).then(t.bind(null,451)),"v-053459e1":()=>t.e(92).then(t.bind(null,452)),"v-66abb195":()=>t.e(93).then(t.bind(null,453)),"v-12bb2bb5":()=>t.e(94).then(t.bind(null,454)),"v-3fa51bdc":()=>t.e(95).then(t.bind(null,455)),"v-65099590":()=>t.e(96).then(t.bind(null,456)),"v-2f5c6694":()=>t.e(97).then(t.bind(null,457)),"v-25b6b26f":()=>t.e(98).then(t.bind(null,458)),"v-07b0187e":()=>t.e(99).then(t.bind(null,459)),"v-1427bb22":()=>t.e(100).then(t.bind(null,460)),"v-6518312d":()=>t.e(101).then(t.bind(null,461)),"v-07e554e7":()=>t.e(102).then(t.bind(null,462)),"v-66bee10f":()=>t.e(103).then(t.bind(null,463)),"v-9d467b7a":()=>t.e(104).then(t.bind(null,464)),"v-756849ef":()=>t.e(105).then(t.bind(null,465)),"v-4c429b26":()=>t.e(106).then(t.bind(null,466)),"v-48ac3ae5":()=>t.e(107).then(t.bind(null,467)),"v-d30cf890":()=>t.e(108).then(t.bind(null,468)),"v-59830d4b":()=>t.e(109).then(t.bind(null,469)),"v-5dd047ef":()=>t.e(110).then(t.bind(null,470)),"v-1bef17ee":()=>t.e(111).then(t.bind(null,471)),"v-e75db5c2":()=>t.e(112).then(t.bind(null,472)),"v-19abda42":()=>t.e(113).then(t.bind(null,473)),"v-76aa68ff":()=>t.e(114).then(t.bind(null,474)),"v-423e3e69":()=>t.e(115).then(t.bind(null,475)),"v-7f1bcab9":()=>t.e(116).then(t.bind(null,476)),"v-46c7f282":()=>t.e(117).then(t.bind(null,477)),"v-23204e4c":()=>t.e(120).then(t.bind(null,478)),"v-48c1e216":()=>t.e(121).then(t.bind(null,479)),"v-16a18680":()=>t.e(122).then(t.bind(null,480)),"v-fb132384":()=>t.e(123).then(t.bind(null,481)),"v-58bc8820":()=>t.e(124).then(t.bind(null,482)),"v-4b1c1560":()=>t.e(125).then(t.bind(null,483)),"v-42ab0b9c":()=>t.e(126).then(t.bind(null,484)),"v-9165af80":()=>t.e(127).then(t.bind(null,485)),"v-0a82273e":()=>t.e(128).then(t.bind(null,486)),"v-61e6541c":()=>t.e(129).then(t.bind(null,487)),"v-b378a200":()=>t.e(130).then(t.bind(null,488)),"v-6e5ede56":()=>t.e(131).then(t.bind(null,489)),"v-f5d9ba7a":()=>t.e(132).then(t.bind(null,490)),"v-552817ee":()=>t.e(133).then(t.bind(null,491)),"v-ad60b07a":()=>t.e(134).then(t.bind(null,492)),"v-272cc03f":()=>t.e(135).then(t.bind(null,493)),"v-40614603":()=>t.e(136).then(t.bind(null,494)),"v-f2614c1e":()=>t.e(137).then(t.bind(null,495)),"v-5adb5772":()=>t.e(138).then(t.bind(null,496)),"v-69d870f7":()=>t.e(139).then(t.bind(null,497)),"v-9e12a0fa":()=>t.e(140).then(t.bind(null,498)),"v-428975fa":()=>t.e(141).then(t.bind(null,499)),"v-65f4a9ad":()=>t.e(142).then(t.bind(null,500)),"v-55d448e7":()=>t.e(143).then(t.bind(null,501)),"v-38f0ff9a":()=>t.e(144).then(t.bind(null,502)),"v-7679b8ac":()=>t.e(145).then(t.bind(null,503)),"v-45074848":()=>t.e(146).then(t.bind(null,504)),"v-383bae3e":()=>t.e(147).then(t.bind(null,505)),"v-582593b7":()=>t.e(148).then(t.bind(null,506)),"v-4a4644fb":()=>t.e(149).then(t.bind(null,507)),"v-1cc688c1":()=>t.e(150).then(t.bind(null,508)),"v-48760081":()=>t.e(151).then(t.bind(null,509)),"v-0577e13e":()=>t.e(153).then(t.bind(null,510)),"v-081d8441":()=>t.e(152).then(t.bind(null,511)),"v-450c7701":()=>t.e(154).then(t.bind(null,512)),"v-cbd4108e":()=>t.e(155).then(t.bind(null,513)),"v-e0ba9d36":()=>t.e(156).then(t.bind(null,514)),"v-deef02fe":()=>t.e(157).then(t.bind(null,515)),"v-3b8ac9a1":()=>t.e(158).then(t.bind(null,516)),"v-3c64c701":()=>t.e(159).then(t.bind(null,517)),"v-d713c7fe":()=>t.e(160).then(t.bind(null,518)),"v-1d93c406":()=>t.e(161).then(t.bind(null,519)),"v-ecd8ca7e":()=>t.e(162).then(t.bind(null,520)),"v-41f1b873":()=>t.e(163).then(t.bind(null,521)),"v-c004732e":()=>t.e(164).then(t.bind(null,522)),"v-59ae4823":()=>t.e(165).then(t.bind(null,523)),"v-55adfde7":()=>t.e(166).then(t.bind(null,524)),"v-8efdaeca":()=>t.e(167).then(t.bind(null,525)),"v-681a7687":()=>t.e(168).then(t.bind(null,526)),"v-4152d2a7":()=>t.e(169).then(t.bind(null,527)),"v-3b9e07eb":()=>t.e(170).then(t.bind(null,528)),"v-28aa3f32":()=>t.e(171).then(t.bind(null,529)),"v-747281c7":()=>t.e(172).then(t.bind(null,530)),"v-2a0c2c87":()=>t.e(174).then(t.bind(null,531)),"v-5bb0c3c7":()=>t.e(173).then(t.bind(null,532)),"v-1d2b4432":()=>t.e(175).then(t.bind(null,533)),"v-893b45f2":()=>t.e(176).then(t.bind(null,534)),"v-4d5125c7":()=>t.e(177).then(t.bind(null,535)),"v-e1939732":()=>t.e(178).then(t.bind(null,536)),"v-2873fe66":()=>t.e(179).then(t.bind(null,537)),"v-12feff1b":()=>t.e(180).then(t.bind(null,538)),"v-67591296":()=>t.e(181).then(t.bind(null,539)),"v-0eb091a8":()=>t.e(182).then(t.bind(null,540)),"v-4fe20720":()=>t.e(183).then(t.bind(null,541)),"v-24ef5527":()=>t.e(184).then(t.bind(null,542)),"v-5da85e95":()=>t.e(185).then(t.bind(null,543)),"v-613274e4":()=>t.e(186).then(t.bind(null,544)),"v-71af493c":()=>t.e(187).then(t.bind(null,545)),"v-9f87cf32":()=>t.e(188).then(t.bind(null,546)),"v-5e4325fb":()=>t.e(189).then(t.bind(null,547)),"v-503fa995":()=>t.e(190).then(t.bind(null,548)),"v-5d3b6f37":()=>t.e(191).then(t.bind(null,549)),"v-7efc0d27":()=>t.e(192).then(t.bind(null,550)),"v-725b30f2":()=>t.e(193).then(t.bind(null,551)),"v-79f396b2":()=>t.e(194).then(t.bind(null,552)),"v-4b1f61a7":()=>t.e(195).then(t.bind(null,553)),"v-bba02680":()=>t.e(196).then(t.bind(null,554)),"v-7912cf1b":()=>t.e(119).then(t.bind(null,555)),"v-7d885782":()=>t.e(118).then(t.bind(null,556))};function Zn(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xn=/-(\w)/g,Yn=Zn(n=>n.replace(Xn,(n,e)=>e?e.toUpperCase():"")),ne=/\B([A-Z])/g,ee=Zn(n=>n.replace(ne,"-$1").toLowerCase()),te=Zn(n=>n.charAt(0).toUpperCase()+n.slice(1));function re(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(te(Yn(e))):n(te(e))||n(ee(e))}const ie=Object.assign({},Kn,Qn),ae=n=>ie[n],oe=n=>Qn[n],se=n=>Kn[n],le=n=>r.default.component(n);function ce(n){return re(oe,n)}function he(n){return re(se,n)}function ue(n){return re(ae,n)}function de(n){return re(le,n)}function pe(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!de(n)&&ue(n)){const e=await ue(n)();r.default.component(n,e.default)}}))}function me(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var fe=t(100),ge=t.n(fe),ve=t(101),be=t.n(ve),ye={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${be()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=xe(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ke(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ge()([{name:"description",content:this.$description}],n,this.siteMeta,Se)},updateCanonicalLink(){we(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",xe(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ke(null,this.currentMetaTags),we()}};function we(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function xe(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ke(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Se(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var je=t(55),_e={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(je)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],o=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(i===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Te=t(29),Ee=t.n(Te),Ce={mounted(){Ee.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||r.default.component(n.name)||Ee.a.start(),t()}),this.$router.afterEach(()=>{Ee.a.done(),this.isSidebarOpen=!1})}};t(248),t(249);class Ie{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var ze={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ie).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ae={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Pe={},Oe=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},qe=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ae[n]},Le=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;i.appendChild(n(t,r,a))})),i},Ne=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},De=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Oe(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=e,a}(s.js,s.html);var l=qe("vue");return s.jsLib.unshift(l),s},Be=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Me=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Re(){var n=Ne(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ne(n,"vuepress-plugin-demo-block__code"),t=Ne(n,"vuepress-plugin-demo-block__display"),r=Ne(n,"vuepress-plugin-demo-block__footer"),i=Ne(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Me(n),htmlTpl:Oe("")},o=qe("react"),s=qe("reactDOM");return a.jsLib.unshift(o,s),a}(a,o):"vanilla"===s?Be(a,o):De(a,o),h=Le("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(h),h.addEventListener("click",Fe.bind(null,h,l,e,r)),qe("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(qe("cssLib")).concat(qe("jsLib")).join(",");return Le("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),qe("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(qe("jsLib")).join(";"),css_external:a.concat(qe("cssLib")).join(";"),layout:qe("codepenLayout"),js_pre_processor:qe("codepenJsProcessor"),editors:qe("codepenEditors")});return Le("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:qe("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Pe[n]){var e=Le("style",{innerHTML:n});document.body.appendChild(e),Pe[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),i);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();i.appendChild(d.$el)}else"vanilla"===s&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Re()}),300)}function Fe(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Ue={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Re()},updated:function(){Re()}},Ve="auto",Je="zoom-in",He="zoom-out",$e="grab",Ge="move";function We(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Ke(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Qe(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ze(n,e,t){!function(n){var e=Xe,t=Ye;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Xe="transition",Ye="transform",nt="transform",et="transitionend";var tt=function(){},rt={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:tt,onClose:tt,onGrab:tt,onMove:tt,onRelease:tt,onBeforeOpen:tt,onBeforeClose:tt,onBeforeGrab:tt,onBeforeRelease:tt,onImageLoading:tt,onImageLoaded:tt},it={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),ot(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(at(n)&&!ot(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){at(n)&&!ot(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function at(n){return 0===n.button}function ot(n){return n.metaKey||n.ctrlKey}var st={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ze(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),We(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ze(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},lt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ct=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),ht=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ut={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Qe(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?$e:He,transition:nt+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ze(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ze(this.el,{transform:"none"})},grab:function(n,e,t){var r=dt(),i=r.x-n,a=r.y-e;Ze(this.el,{cursor:Ge,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=dt(),i=r.x-n,a=r.y-e;Ze(this.el,{transition:nt,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ze(this.el,this.styleClose)},restoreOpenStyle:function(){Ze(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=dt(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":lt(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=dt(),c={x:l.x-o,y:l.y-s},h=c.x/o,u=c.y/s,d=a+Math.min(h,u);if(i&&"string"==typeof i){var p=t||this.el.naturalWidth,m=e||this.el.naturalHeight,f=parseFloat(i)*p/(100*this.rect.width),g=parseFloat(i)*m/(100*this.rect.height);if(d>f||d>g)return{x:f,y:g}}return{x:d,y:d}}};function dt(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pt(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){We(n,r,e[r],t)}))}var mt=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ut),this.overlay=Object.create(st),this.handler=Object.create(it),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ht({},rt,e),this.overlay.init(this),this.handler.init(this)}return ct(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Je,We(n,"click",this.handler.click),this.options.preloadImage&&Ke(Qe(n)));return this}},{key:"config",value:function(n){return n?(ht(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Ke(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),We(document,"scroll",this.handler.scroll),We(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&We(window,"resize",this.handler.resizeWindow);var a=function n(){We(r,et,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pt(document,e.handler,!0),t(r)};return We(r,et,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ve,this.overlay.fadeOut(),this.target.zoomOut(),We(document,"scroll",this.handler.scroll,!1),We(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&We(window,"resize",this.handler.resizeWindow,!1);var r=function r(){We(t,et,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pt(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return We(t,et,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){We(i,et,n,!1),r(i)};return We(i,et,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ge,this.target.move(n,e,t);var i=this.target.el,a=function n(){We(i,et,n,!1),r(i)};return We(i,et,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ve,this.target.restoreOpenStyle();var r=function r(){We(t,et,r,!1),n.lock=!1,n.released=!0,e(t)};return We(t,et,r),this}}}]),n}();const ft=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),gt=Number("500");class vt{constructor(){this.instance=new mt(ft)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=gt){setTimeout(()=>this.update(n),e)}}var bt=[ye,_e,Ce,ze,Ue,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new vt,this.$vuepress.zooming.updateDelay()}}],yt={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return me("layout",n),r.default.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},wt=t(1),xt=Object(wt.a)(yt,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(xt,"mixins",bt);const kt=[{name:"v-486da2db",path:"/ds/index/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-486da2db").then(t)}},{path:"/ds/index/index.html",redirect:"/ds/index/"},{path:"/10.数据结构/0.index.html",redirect:"/ds/index/"},{name:"v-2b6c279e",path:"/ds/queue/queue/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2b6c279e").then(t)}},{path:"/ds/queue/queue/index.html",redirect:"/ds/queue/queue/"},{path:"/10.数据结构/10.queue 队列/10.queue.html",redirect:"/ds/queue/queue/"},{name:"v-05f4bc51",path:"/ds/plan/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-05f4bc51").then(t)}},{path:"/ds/plan/index.html",redirect:"/ds/plan/"},{path:"/10.数据结构/1.plan.html",redirect:"/ds/plan/"},{name:"v-6d3cde30",path:"/ds/queue/priorityQueue/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-6d3cde30").then(t)}},{path:"/ds/queue/priorityQueue/index.html",redirect:"/ds/queue/priorityQueue/"},{path:"/10.数据结构/10.queue 队列/20.priorityQueue.html",redirect:"/ds/queue/priorityQueue/"},{name:"v-b8d450b8",path:"/ds/queue/minPriorityQueue/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-b8d450b8").then(t)}},{path:"/ds/queue/minPriorityQueue/index.html",redirect:"/ds/queue/minPriorityQueue/"},{path:"/10.数据结构/10.queue 队列/30.minPriorityQueue.html",redirect:"/ds/queue/minPriorityQueue/"},{name:"v-aee07d78",path:"/ds/queue/maxPriorityQueue/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-aee07d78").then(t)}},{path:"/ds/queue/maxPriorityQueue/index.html",redirect:"/ds/queue/maxPriorityQueue/"},{path:"/10.数据结构/10.queue 队列/40.maxPriorityQueue.html",redirect:"/ds/queue/maxPriorityQueue/"},{name:"v-00ca2008",path:"/ds/queue/deque/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-00ca2008").then(t)}},{path:"/ds/queue/deque/index.html",redirect:"/ds/queue/deque/"},{path:"/10.数据结构/10.queue 队列/50.deque.html",redirect:"/ds/queue/deque/"},{name:"v-139bd2e6",path:"/pages/694de4/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-139bd2e6").then(t)}},{path:"/pages/694de4/index.html",redirect:"/pages/694de4/"},{path:"/10.数据结构/10.queue 队列/60.CircularQueue.html",redirect:"/pages/694de4/"},{name:"v-482f803c",path:"/ds/heap/minHeap/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-482f803c").then(t)}},{path:"/ds/heap/minHeap/index.html",redirect:"/ds/heap/minHeap/"},{path:"/10.数据结构/20.heap 堆/20.minHeap.html",redirect:"/ds/heap/minHeap/"},{name:"v-3712a3c0",path:"/ds/heap/heap/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3712a3c0").then(t)}},{path:"/ds/heap/heap/index.html",redirect:"/ds/heap/heap/"},{path:"/10.数据结构/20.heap 堆/10.heap.html",redirect:"/ds/heap/heap/"},{name:"v-131a8800",path:"/ds/heap/maxHeap/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-131a8800").then(t)}},{path:"/ds/heap/maxHeap/index.html",redirect:"/ds/heap/maxHeap/"},{path:"/10.数据结构/20.heap 堆/30.maxHeap.html",redirect:"/ds/heap/maxHeap/"},{name:"v-0ba4d67b",path:"/ds/roadmap/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0ba4d67b").then(t)}},{path:"/ds/roadmap/index.html",redirect:"/ds/roadmap/"},{path:"/10.数据结构/3.roadmap.html",redirect:"/ds/roadmap/"},{name:"v-1ae8a7a5",path:"/ds/linked-list/linkedList/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1ae8a7a5").then(t)}},{path:"/ds/linked-list/linkedList/index.html",redirect:"/ds/linked-list/linkedList/"},{path:"/10.数据结构/30.linked-list 链表/10.linkedList.html",redirect:"/ds/linked-list/linkedList/"},{name:"v-c59b6bb6",path:"/ds/linked-list/doublyLinkedList/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-c59b6bb6").then(t)}},{path:"/ds/linked-list/doublyLinkedList/index.html",redirect:"/ds/linked-list/doublyLinkedList/"},{path:"/10.数据结构/30.linked-list 链表/20.doublyLinkedList.html",redirect:"/ds/linked-list/doublyLinkedList/"},{name:"v-34625985",path:"/pages/c35641/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-34625985").then(t)}},{path:"/pages/c35641/index.html",redirect:"/pages/c35641/"},{path:"/10.数据结构/30.linked-list 链表/30.SinglyCircularLinkedList.html",redirect:"/pages/c35641/"},{name:"v-4a6a90eb",path:"/ds/term/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4a6a90eb").then(t)}},{path:"/ds/term/index.html",redirect:"/ds/term/"},{path:"/10.数据结构/4.术语表.html",redirect:"/ds/term/"},{name:"v-2955bc57",path:"/ds/stack/stack/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2955bc57").then(t)}},{path:"/ds/stack/stack/index.html",redirect:"/ds/stack/stack/"},{path:"/10.数据结构/40.stack 栈/10.stack.html",redirect:"/ds/stack/stack/"},{name:"v-266e70f7",path:"/ds/introduction/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-266e70f7").then(t)}},{path:"/ds/introduction/index.html",redirect:"/ds/introduction/"},{path:"/10.数据结构/5.introduction.html",redirect:"/ds/introduction/"},{name:"v-5f2c0b7c",path:"/ds/set/enhancedSet/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5f2c0b7c").then(t)}},{path:"/ds/set/enhancedSet/index.html",redirect:"/ds/set/enhancedSet/"},{path:"/10.数据结构/50.set 集合/10.enhancedSet.html",redirect:"/ds/set/enhancedSet/"},{name:"v-50ca6409",path:"/ds/graph/graph/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-50ca6409").then(t)}},{path:"/ds/graph/graph/index.html",redirect:"/ds/graph/graph/"},{path:"/10.数据结构/60.graph 图/10.graph.html",redirect:"/ds/graph/graph/"},{name:"v-7e089229",path:"/ds/graph/directedGraph/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7e089229").then(t)}},{path:"/ds/graph/directedGraph/index.html",redirect:"/ds/graph/directedGraph/"},{path:"/10.数据结构/60.graph 图/20.directedGraph.html",redirect:"/ds/graph/directedGraph/"},{name:"v-4da18530",path:"/ds/tree/binarySearchTree/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4da18530").then(t)}},{path:"/ds/tree/binarySearchTree/index.html",redirect:"/ds/tree/binarySearchTree/"},{path:"/10.数据结构/80.tree 树/10.binarySearchTree.html",redirect:"/ds/tree/binarySearchTree/"},{name:"v-3fb26e0a",path:"/ds/tree/avlTree/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3fb26e0a").then(t)}},{path:"/ds/tree/avlTree/index.html",redirect:"/ds/tree/avlTree/"},{path:"/10.数据结构/80.tree 树/20.avlTree.html",redirect:"/ds/tree/avlTree/"},{name:"v-3a0c73d0",path:"/ds/tree/trie/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3a0c73d0").then(t)}},{path:"/ds/tree/trie/index.html",redirect:"/ds/tree/trie/"},{path:"/10.数据结构/80.tree 树/30.trie.html",redirect:"/ds/tree/trie/"},{name:"v-7d2299f8",path:"/pages/44805c/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7d2299f8").then(t)}},{path:"/pages/44805c/index.html",redirect:"/pages/44805c/"},{path:"/10.数据结构/90.vectors 矢量/10.vector.html",redirect:"/pages/44805c/"},{name:"v-08c0f6d6",path:"/algorithm/index/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-08c0f6d6").then(t)}},{path:"/algorithm/index/index.html",redirect:"/algorithm/index/"},{path:"/20.算法/0.index.html",redirect:"/algorithm/index/"},{name:"v-7c919012",path:"/algorithm/plan/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7c919012").then(t)}},{path:"/algorithm/plan/index.html",redirect:"/algorithm/plan/"},{path:"/20.算法/1.plan.html",redirect:"/algorithm/plan/"},{name:"v-58cd83de",path:"/algorithm/sort/index/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-58cd83de").then(t)}},{path:"/algorithm/sort/index/index.html",redirect:"/algorithm/sort/index/"},{path:"/20.算法/10.Sort 排序/0.index.html",redirect:"/algorithm/sort/index/"},{name:"v-ec80aaaa",path:"/algorithm/sort/alphaNumericalSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-ec80aaaa").then(t)}},{path:"/algorithm/sort/alphaNumericalSort/index.html",redirect:"/algorithm/sort/alphaNumericalSort/"},{path:"/20.算法/10.Sort 排序/10.alphaNumericalSort.html",redirect:"/algorithm/sort/alphaNumericalSort/"},{name:"v-3ee6121d",path:"/algorithm/sort/fisherYatesShuffle/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3ee6121d").then(t)}},{path:"/algorithm/sort/fisherYatesShuffle/index.html",redirect:"/algorithm/sort/fisherYatesShuffle/"},{path:"/20.算法/10.Sort 排序/100.fisherYatesShuffle.html",redirect:"/algorithm/sort/fisherYatesShuffle/"},{name:"v-27f6e919",path:"/algorithm/sort/flashSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-27f6e919").then(t)}},{path:"/algorithm/sort/flashSort/index.html",redirect:"/algorithm/sort/flashSort/"},{path:"/20.算法/10.Sort 排序/110.flashSort.html",redirect:"/algorithm/sort/flashSort/"},{name:"v-c42c0f0a",path:"/algorithm/sort/gnomeSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-c42c0f0a").then(t)}},{path:"/algorithm/sort/gnomeSort/index.html",redirect:"/algorithm/sort/gnomeSort/"},{path:"/20.算法/10.Sort 排序/120.gnomeSort.html",redirect:"/algorithm/sort/gnomeSort/"},{name:"v-3d00a37d",path:"/algorithm/sort/heapSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3d00a37d").then(t)}},{path:"/algorithm/sort/heapSort/index.html",redirect:"/algorithm/sort/heapSort/"},{path:"/20.算法/10.Sort 排序/130.heapSort.html",redirect:"/algorithm/sort/heapSort/"},{name:"v-01cb1163",path:"/algorithm/sort/insertionSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-01cb1163").then(t)}},{path:"/algorithm/sort/insertionSort/index.html",redirect:"/algorithm/sort/insertionSort/"},{path:"/20.算法/10.Sort 排序/150.insertionSort.html",redirect:"/algorithm/sort/insertionSort/"},{name:"v-226b6aaa",path:"/algorithm/sort/introSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-226b6aaa").then(t)}},{path:"/algorithm/sort/introSort/index.html",redirect:"/algorithm/sort/introSort/"},{path:"/20.算法/10.Sort 排序/160.introSort.html",redirect:"/algorithm/sort/introSort/"},{name:"v-2419e8d6",path:"/algorithm/sort/mergeSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2419e8d6").then(t)}},{path:"/algorithm/sort/mergeSort/index.html",redirect:"/algorithm/sort/mergeSort/"},{path:"/20.算法/10.Sort 排序/170.mergeSort.html",redirect:"/algorithm/sort/mergeSort/"},{name:"v-0250e5f5",path:"/algorithm/sort/oddEvenSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0250e5f5").then(t)}},{path:"/algorithm/sort/oddEvenSort/index.html",redirect:"/algorithm/sort/oddEvenSort/"},{path:"/20.算法/10.Sort 排序/180.oddEvenSort.html",redirect:"/algorithm/sort/oddEvenSort/"},{name:"v-715e4442",path:"/algorithm/sort/pancakeSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-715e4442").then(t)}},{path:"/algorithm/sort/pancakeSort/index.html",redirect:"/algorithm/sort/pancakeSort/"},{path:"/20.算法/10.Sort 排序/190.pancakeSort.html",redirect:"/algorithm/sort/pancakeSort/"},{name:"v-7fb2d211",path:"/algorithm/sort/beadSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7fb2d211").then(t)}},{path:"/algorithm/sort/beadSort/index.html",redirect:"/algorithm/sort/beadSort/"},{path:"/20.算法/10.Sort 排序/20.beadSort.html",redirect:"/algorithm/sort/beadSort/"},{name:"v-526958bd",path:"/algorithm/sort/pigeonHoleSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-526958bd").then(t)}},{path:"/algorithm/sort/pigeonHoleSort/index.html",redirect:"/algorithm/sort/pigeonHoleSort/"},{path:"/20.算法/10.Sort 排序/200.pigeonHoleSort.html",redirect:"/algorithm/sort/pigeonHoleSort/"},{name:"v-79404cc6",path:"/algorithm/sort/quickSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-79404cc6").then(t)}},{path:"/algorithm/sort/quickSort/index.html",redirect:"/algorithm/sort/quickSort/"},{path:"/20.算法/10.Sort 排序/210.quickSort.html",redirect:"/algorithm/sort/quickSort/"},{name:"v-db6ed89a",path:"/algorithm/sort/radixSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-db6ed89a").then(t)}},{path:"/algorithm/sort/radixSort/index.html",redirect:"/algorithm/sort/radixSort/"},{path:"/20.算法/10.Sort 排序/230.radixSort.html",redirect:"/algorithm/sort/radixSort/"},{name:"v-0fbcee25",path:"/algorithm/sort/selectionSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0fbcee25").then(t)}},{path:"/algorithm/sort/selectionSort/index.html",redirect:"/algorithm/sort/selectionSort/"},{path:"/20.算法/10.Sort 排序/240.selectionSort.html",redirect:"/algorithm/sort/selectionSort/"},{name:"v-77378f5f",path:"/algorithm/sort/shellSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-77378f5f").then(t)}},{path:"/algorithm/sort/shellSort/index.html",redirect:"/algorithm/sort/shellSort/"},{path:"/20.算法/10.Sort 排序/250.shellSort.html",redirect:"/algorithm/sort/shellSort/"},{name:"v-103bfede",path:"/algorithm/sort/timSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-103bfede").then(t)}},{path:"/algorithm/sort/timSort/index.html",redirect:"/algorithm/sort/timSort/"},{path:"/20.算法/10.Sort 排序/260.timSort.html",redirect:"/algorithm/sort/timSort/"},{name:"v-301e60cb",path:"/algorithm/sort/topologicalSorter/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-301e60cb").then(t)}},{path:"/algorithm/sort/topologicalSorter/index.html",redirect:"/algorithm/sort/topologicalSorter/"},{path:"/20.算法/10.Sort 排序/270.topologicalSorter.html",redirect:"/algorithm/sort/topologicalSorter/"},{name:"v-6133e59d",path:"/algorithm/sort/wiggleSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-6133e59d").then(t)}},{path:"/algorithm/sort/wiggleSort/index.html",redirect:"/algorithm/sort/wiggleSort/"},{path:"/20.算法/10.Sort 排序/280.wiggleSort.html",redirect:"/algorithm/sort/wiggleSort/"},{name:"v-a164921e",path:"/algorithm/sort/bogoSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-a164921e").then(t)}},{path:"/algorithm/sort/bogoSort/index.html",redirect:"/algorithm/sort/bogoSort/"},{path:"/20.算法/10.Sort 排序/30.bogoSort.html",redirect:"/algorithm/sort/bogoSort/"},{name:"v-e701027e",path:"/algorithm/sort/bubbleSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-e701027e").then(t)}},{path:"/algorithm/sort/bubbleSort/index.html",redirect:"/algorithm/sort/bubbleSort/"},{path:"/20.算法/10.Sort 排序/40.bubbleSort.html",redirect:"/algorithm/sort/bubbleSort/"},{name:"v-0902897a",path:"/algorithm/sort/bucketSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0902897a").then(t)}},{path:"/algorithm/sort/bucketSort/index.html",redirect:"/algorithm/sort/bucketSort/"},{path:"/20.算法/10.Sort 排序/50.bucketSort.html",redirect:"/algorithm/sort/bucketSort/"},{name:"v-11223575",path:"/algorithm/sort/cocktailShakerSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-11223575").then(t)}},{path:"/algorithm/sort/cocktailShakerSort/index.html",redirect:"/algorithm/sort/cocktailShakerSort/"},{path:"/20.算法/10.Sort 排序/60.cocktailShakerSort.html",redirect:"/algorithm/sort/cocktailShakerSort/"},{name:"v-b55c4a5e",path:"/algorithm/sort/combSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-b55c4a5e").then(t)}},{path:"/algorithm/sort/combSort/index.html",redirect:"/algorithm/sort/combSort/"},{path:"/20.算法/10.Sort 排序/70.combSort.html",redirect:"/algorithm/sort/combSort/"},{name:"v-695ad56b",path:"/algorithm/sort/countingSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-695ad56b").then(t)}},{path:"/algorithm/sort/countingSort/index.html",redirect:"/algorithm/sort/countingSort/"},{path:"/20.算法/10.Sort 排序/80.countingSort.html",redirect:"/algorithm/sort/countingSort/"},{name:"v-0dd76b46",path:"/algorithm/sort/cycleSort/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0dd76b46").then(t)}},{path:"/algorithm/sort/cycleSort/index.html",redirect:"/algorithm/sort/cycleSort/"},{path:"/20.算法/10.Sort 排序/90.cycleSort.html",redirect:"/algorithm/sort/cycleSort/"},{name:"v-4078729f",path:"/algorithm/backtracking/generatePermutations/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4078729f").then(t)}},{path:"/algorithm/backtracking/generatePermutations/index.html",redirect:"/algorithm/backtracking/generatePermutations/"},{path:"/20.算法/100.Backtracking 回溯/20.GeneratePermutations.html",redirect:"/algorithm/backtracking/generatePermutations/"},{name:"v-0ad06882",path:"/algorithm/backtracking/allCombinationsOfSizeK/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0ad06882").then(t)}},{path:"/algorithm/backtracking/allCombinationsOfSizeK/index.html",redirect:"/algorithm/backtracking/allCombinationsOfSizeK/"},{path:"/20.算法/100.Backtracking 回溯/10.AllCombinationsOfSizeK.html",redirect:"/algorithm/backtracking/allCombinationsOfSizeK/"},{name:"v-fa1be2c2",path:"/algorithm/backtracking/knightTour/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-fa1be2c2").then(t)}},{path:"/algorithm/backtracking/knightTour/index.html",redirect:"/algorithm/backtracking/knightTour/"},{path:"/20.算法/100.Backtracking 回溯/30.KnightTour.html",redirect:"/algorithm/backtracking/knightTour/"},{name:"v-23d00e9f",path:"/algorithm/backtracking/nQueens/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-23d00e9f").then(t)}},{path:"/algorithm/backtracking/nQueens/index.html",redirect:"/algorithm/backtracking/nQueens/"},{path:"/20.算法/100.Backtracking 回溯/40.NQueen.html",redirect:"/algorithm/backtracking/nQueens/"},{name:"v-1214d082",path:"/algorithm/backtracking/ratInAMaze/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1214d082").then(t)}},{path:"/algorithm/backtracking/ratInAMaze/index.html",redirect:"/algorithm/backtracking/ratInAMaze/"},{path:"/20.算法/100.Backtracking 回溯/50.RatInAMaze.html",redirect:"/algorithm/backtracking/ratInAMaze/"},{name:"v-e5a79402",path:"/algorithm/backtracking/sudoku/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-e5a79402").then(t)}},{path:"/algorithm/backtracking/sudoku/index.html",redirect:"/algorithm/backtracking/sudoku/"},{path:"/20.算法/100.Backtracking 回溯/60.Sudoku.html",redirect:"/algorithm/backtracking/sudoku/"},{name:"v-322335c9",path:"/algorithm/backtracking/sumOfSubset/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-322335c9").then(t)}},{path:"/algorithm/backtracking/sumOfSubset/index.html",redirect:"/algorithm/backtracking/sumOfSubset/"},{path:"/20.算法/100.Backtracking 回溯/70.SumOfSubset.html",redirect:"/algorithm/backtracking/sumOfSubset/"},{name:"v-2b567a55",path:"/algorithm/dp/climbingStairs/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2b567a55").then(t)}},{path:"/algorithm/dp/climbingStairs/index.html",redirect:"/algorithm/dp/climbingStairs/"},{path:"/20.算法/110.DynamicProgramming 动态规划/10.ClimbingStairs.html",redirect:"/algorithm/dp/climbingStairs/"},{name:"v-016423d6",path:"/algorithm/dp/longestPalindromicSubsequence/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-016423d6").then(t)}},{path:"/algorithm/dp/longestPalindromicSubsequence/index.html",redirect:"/algorithm/dp/longestPalindromicSubsequence/"},{path:"/20.算法/110.DynamicProgramming 动态规划/100.LongestPalindromicSubsequence.html",redirect:"/algorithm/dp/longestPalindromicSubsequence/"},{name:"v-2a5dea95",path:"/algorithm/dp/longestValidParentheses/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2a5dea95").then(t)}},{path:"/algorithm/dp/longestValidParentheses/index.html",redirect:"/algorithm/dp/longestValidParentheses/"},{path:"/20.算法/110.DynamicProgramming 动态规划/110.LongestValidParentheses.html",redirect:"/algorithm/dp/longestValidParentheses/"},{name:"v-4bb15016",path:"/algorithm/dp/maxNonAdjacentSum/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4bb15016").then(t)}},{path:"/algorithm/dp/maxNonAdjacentSum/index.html",redirect:"/algorithm/dp/maxNonAdjacentSum/"},{path:"/20.算法/110.DynamicProgramming 动态规划/120.MaxNonAdjacentSum.html",redirect:"/algorithm/dp/maxNonAdjacentSum/"},{name:"v-65cde415",path:"/algorithm/dp/maxProductOfThree/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-65cde415").then(t)}},{path:"/algorithm/dp/maxProductOfThree/index.html",redirect:"/algorithm/dp/maxProductOfThree/"},{path:"/20.算法/110.DynamicProgramming 动态规划/130.MaxProductOfThree.html",redirect:"/algorithm/dp/maxProductOfThree/"},{name:"v-f5c59296",path:"/algorithm/dp/minimumCostPath/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-f5c59296").then(t)}},{path:"/algorithm/dp/minimumCostPath/index.html",redirect:"/algorithm/dp/minimumCostPath/"},{path:"/20.算法/110.DynamicProgramming 动态规划/140.MinimumCostPath.html",redirect:"/algorithm/dp/minimumCostPath/"},{name:"v-2d1854f5",path:"/algorithm/dp/numberOfSubsetEqualToGivenSum/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2d1854f5").then(t)}},{path:"/algorithm/dp/numberOfSubsetEqualToGivenSum/index.html",redirect:"/algorithm/dp/numberOfSubsetEqualToGivenSum/"},{path:"/20.算法/110.DynamicProgramming 动态规划/150.NumberOfSubsetEqualToGivenSum.html",redirect:"/algorithm/dp/numberOfSubsetEqualToGivenSum/"},{name:"v-1058a9ab",path:"/algorithm/dp/rodCutting/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1058a9ab").then(t)}},{path:"/algorithm/dp/rodCutting/index.html",redirect:"/algorithm/dp/rodCutting/"},{path:"/20.算法/110.DynamicProgramming 动态规划/160.RodCutting.html",redirect:"/algorithm/dp/rodCutting/"},{name:"v-1b91e26f",path:"/algorithm/dp/shuf/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1b91e26f").then(t)}},{path:"/algorithm/dp/shuf/index.html",redirect:"/algorithm/dp/shuf/"},{path:"/20.算法/110.DynamicProgramming 动态规划/170.Shuf.html",redirect:"/algorithm/dp/shuf/"},{name:"v-d2c44896",path:"/algorithm/dp/180SieveOfEratosthenes/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-d2c44896").then(t)}},{path:"/algorithm/dp/180SieveOfEratosthenes/index.html",redirect:"/algorithm/dp/180SieveOfEratosthenes/"},{path:"/20.算法/110.DynamicProgramming 动态规划/180.SieveOfEratosthenes.html",redirect:"/algorithm/dp/180SieveOfEratosthenes/"},{name:"v-0bb20215",path:"/algorithm/dp/slidingWindow/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0bb20215").then(t)}},{path:"/algorithm/dp/slidingWindow/index.html",redirect:"/algorithm/dp/slidingWindow/"},{path:"/20.算法/110.DynamicProgramming 动态规划/190.SlidingWindow.html",redirect:"/algorithm/dp/slidingWindow/"},{name:"v-1dc711f5",path:"/algorithm/dp/coinChange/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1dc711f5").then(t)}},{path:"/algorithm/dp/coinChange/index.html",redirect:"/algorithm/dp/coinChange/"},{path:"/20.算法/110.DynamicProgramming 动态规划/20.CoinChange.html",redirect:"/algorithm/dp/coinChange/"},{name:"v-7c5caa77",path:"/algorithm/dp/sudokuSolver/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7c5caa77").then(t)}},{path:"/algorithm/dp/sudokuSolver/index.html",redirect:"/algorithm/dp/sudokuSolver/"},{path:"/20.算法/110.DynamicProgramming 动态规划/200.SudokuSolver.html",redirect:"/algorithm/dp/sudokuSolver/"},{name:"v-3b854396",path:"/algorithm/dp/trappingRainWater/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3b854396").then(t)}},{path:"/algorithm/dp/trappingRainWater/index.html",redirect:"/algorithm/dp/trappingRainWater/"},{path:"/20.算法/110.DynamicProgramming 动态规划/210.TrappingRainWater.html",redirect:"/algorithm/dp/trappingRainWater/"},{name:"v-494ae7f9",path:"/algorithm/dp/tribonacciNumber/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-494ae7f9").then(t)}},{path:"/algorithm/dp/tribonacciNumber/index.html",redirect:"/algorithm/dp/tribonacciNumber/"},{path:"/20.算法/110.DynamicProgramming 动态规划/220.TribonacciNumber.html",redirect:"/algorithm/dp/tribonacciNumber/"},{name:"v-93bae096",path:"/algorithm/dp/zeroOneKnapsack/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-93bae096").then(t)}},{path:"/algorithm/dp/zeroOneKnapsack/index.html",redirect:"/algorithm/dp/zeroOneKnapsack/"},{path:"/20.算法/110.DynamicProgramming 动态规划/230.ZeroOneKnapsack.html",redirect:"/algorithm/dp/zeroOneKnapsack/"},{name:"v-12469ad5",path:"/algorithm/dp/editDistance/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-12469ad5").then(t)}},{path:"/algorithm/dp/editDistance/index.html",redirect:"/algorithm/dp/editDistance/"},{path:"/20.算法/110.DynamicProgramming 动态规划/30.EditDistance.html",redirect:"/algorithm/dp/editDistance/"},{name:"v-530e2e09",path:"/algorithm/dp/fibonacciNumber/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-530e2e09").then(t)}},{path:"/algorithm/dp/fibonacciNumber/index.html",redirect:"/algorithm/dp/fibonacciNumber/"},{path:"/20.算法/110.DynamicProgramming 动态规划/40.FibonacciNumber.html",redirect:"/algorithm/dp/fibonacciNumber/"},{name:"v-7664ccdf",path:"/algorithm/dp/findMonthCalendar/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7664ccdf").then(t)}},{path:"/algorithm/dp/findMonthCalendar/index.html",redirect:"/algorithm/dp/findMonthCalendar/"},{path:"/20.算法/110.DynamicProgramming 动态规划/50.FindMonthCalendar.html",redirect:"/algorithm/dp/findMonthCalendar/"},{name:"v-419c9df5",path:"/algorithm/dp/kadaneAlgo/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-419c9df5").then(t)}},{path:"/algorithm/dp/kadaneAlgo/index.html",redirect:"/algorithm/dp/kadaneAlgo/"},{path:"/20.算法/110.DynamicProgramming 动态规划/60.KadaneAlgo.html",redirect:"/algorithm/dp/kadaneAlgo/"},{name:"v-053459e1",path:"/algorithm/dp/levenshteinDistance/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-053459e1").then(t)}},{path:"/algorithm/dp/levenshteinDistance/index.html",redirect:"/algorithm/dp/levenshteinDistance/"},{path:"/20.算法/110.DynamicProgramming 动态规划/70.LevenshteinDistance.html",redirect:"/algorithm/dp/levenshteinDistance/"},{name:"v-66abb195",path:"/algorithm/dp/longestCommonSubsequence/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-66abb195").then(t)}},{path:"/algorithm/dp/longestCommonSubsequence/index.html",redirect:"/algorithm/dp/longestCommonSubsequence/"},{path:"/20.算法/110.DynamicProgramming 动态规划/80.LongestCommonSubsequence.html",redirect:"/algorithm/dp/longestCommonSubsequence/"},{name:"v-12bb2bb5",path:"/algorithm/dp/longestIncreasingSubsequence/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-12bb2bb5").then(t)}},{path:"/algorithm/dp/longestIncreasingSubsequence/index.html",redirect:"/algorithm/dp/longestIncreasingSubsequence/"},{path:"/20.算法/110.DynamicProgramming 动态规划/90.LongestIncreasingSubsequence.html",redirect:"/algorithm/dp/longestIncreasingSubsequence/"},{name:"v-3fa51bdc",path:"/algorithm/cache/LFUCache/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3fa51bdc").then(t)}},{path:"/algorithm/cache/LFUCache/index.html",redirect:"/algorithm/cache/LFUCache/"},{path:"/20.算法/120.Cache 缓存/10.LFUCache.html",redirect:"/algorithm/cache/LFUCache/"},{name:"v-65099590",path:"/algorithm/cache/LRUCache/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-65099590").then(t)}},{path:"/algorithm/cache/LRUCache/index.html",redirect:"/algorithm/cache/LRUCache/"},{path:"/20.算法/120.Cache 缓存/20.LRUCache.html",redirect:"/algorithm/cache/LRUCache/"},{name:"v-2f5c6694",path:"/algorithm/cache/memoize/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2f5c6694").then(t)}},{path:"/algorithm/cache/memoize/index.html",redirect:"/algorithm/cache/memoize/"},{path:"/20.算法/120.Cache 缓存/30.Memoize.html",redirect:"/algorithm/cache/memoize/"},{name:"v-25b6b26f",path:"/algorithm/array/localMaxPoint/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-25b6b26f").then(t)}},{path:"/algorithm/array/localMaxPoint/index.html",redirect:"/algorithm/array/localMaxPoint/"},{path:"/20.算法/130.Array 数组/10.LocalMaxPoint.html",redirect:"/algorithm/array/localMaxPoint/"},{name:"v-07b0187e",path:"/algorithm/array/quickSelect/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-07b0187e").then(t)}},{path:"/algorithm/array/quickSelect/index.html",redirect:"/algorithm/array/quickSelect/"},{path:"/20.算法/130.Array 数组/140.QuickSelect.html",redirect:"/algorithm/array/quickSelect/"},{name:"v-1427bb22",path:"/algorithm/cipher/atbash/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1427bb22").then(t)}},{path:"/algorithm/cipher/atbash/index.html",redirect:"/algorithm/cipher/atbash/"},{path:"/20.算法/140.Ciphers 密码学/10.Atbash.html",redirect:"/algorithm/cipher/atbash/"},{name:"v-6518312d",path:"/algorithm/cipher/caesarsCipher/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-6518312d").then(t)}},{path:"/algorithm/cipher/caesarsCipher/index.html",redirect:"/algorithm/cipher/caesarsCipher/"},{path:"/20.算法/140.Ciphers 密码学/20.CaesarsCipher.html",redirect:"/algorithm/cipher/caesarsCipher/"},{name:"v-07e554e7",path:"/algorithm/cipher/keyFinder/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-07e554e7").then(t)}},{path:"/algorithm/cipher/keyFinder/index.html",redirect:"/algorithm/cipher/keyFinder/"},{path:"/20.算法/140.Ciphers 密码学/30.KeyFinder.html",redirect:"/algorithm/cipher/keyFinder/"},{name:"v-66bee10f",path:"/algorithm/cipher/keywordShiftedAlphabet/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-66bee10f").then(t)}},{path:"/algorithm/cipher/keywordShiftedAlphabet/index.html",redirect:"/algorithm/cipher/keywordShiftedAlphabet/"},{path:"/20.算法/140.Ciphers 密码学/40.KeywordShiftedAlphabet.html",redirect:"/algorithm/cipher/keywordShiftedAlphabet/"},{name:"v-9d467b7a",path:"/algorithm/cipher/ROT13/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-9d467b7a").then(t)}},{path:"/algorithm/cipher/ROT13/index.html",redirect:"/algorithm/cipher/ROT13/"},{path:"/20.算法/140.Ciphers 密码学/50.ROT13.html",redirect:"/algorithm/cipher/ROT13/"},{name:"v-756849ef",path:"/algorithm/cipher/vigenereCipher/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-756849ef").then(t)}},{path:"/algorithm/cipher/vigenereCipher/index.html",redirect:"/algorithm/cipher/vigenereCipher/"},{path:"/20.算法/140.Ciphers 密码学/60.VigenereCipher.html",redirect:"/algorithm/cipher/vigenereCipher/"},{name:"v-4c429b26",path:"/algorithm/cipher/XORCipher/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4c429b26").then(t)}},{path:"/algorithm/cipher/XORCipher/index.html",redirect:"/algorithm/cipher/XORCipher/"},{path:"/20.算法/140.Ciphers 密码学/70.XORCipher.html",redirect:"/algorithm/cipher/XORCipher/"},{name:"v-48ac3ae5",path:"/algorithm/conversion/p1/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-48ac3ae5").then(t)}},{path:"/algorithm/conversion/p1/index.html",redirect:"/algorithm/conversion/p1/"},{path:"/20.算法/150.Conversions 转换/10.Part1.html",redirect:"/algorithm/conversion/p1/"},{name:"v-d30cf890",path:"/algorithm/euler/index/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-d30cf890").then(t)}},{path:"/algorithm/euler/index/index.html",redirect:"/algorithm/euler/index/"},{path:"/20.算法/160.ProjectEuler 欧拉计划/0.index.html",redirect:"/algorithm/euler/index/"},{name:"v-59830d4b",path:"/algorithm/search/binarySearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-59830d4b").then(t)}},{path:"/algorithm/search/binarySearch/index.html",redirect:"/algorithm/search/binarySearch/"},{path:"/20.算法/20.Search 搜索/10.BinarySearch.html",redirect:"/algorithm/search/binarySearch/"},{name:"v-5dd047ef",path:"/algorithm/search/ternarySearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5dd047ef").then(t)}},{path:"/algorithm/search/ternarySearch/index.html",redirect:"/algorithm/search/ternarySearch/"},{path:"/20.算法/20.Search 搜索/100.TernarySearch.html",redirect:"/algorithm/search/ternarySearch/"},{name:"v-1bef17ee",path:"/algorithm/search/unionSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1bef17ee").then(t)}},{path:"/algorithm/search/unionSearch/index.html",redirect:"/algorithm/search/unionSearch/"},{path:"/20.算法/20.Search 搜索/110.UnionSearch.html",redirect:"/algorithm/search/unionSearch/"},{name:"v-e75db5c2",path:"/algorithm/search/exponentialSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-e75db5c2").then(t)}},{path:"/algorithm/search/exponentialSearch/index.html",redirect:"/algorithm/search/exponentialSearch/"},{path:"/20.算法/20.Search 搜索/20.ExponentialSearch.html",redirect:"/algorithm/search/exponentialSearch/"},{name:"v-19abda42",path:"/algorithm/search/fibonacciSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-19abda42").then(t)}},{path:"/algorithm/search/fibonacciSearch/index.html",redirect:"/algorithm/search/fibonacciSearch/"},{path:"/20.算法/20.Search 搜索/30.FibonacciSearch.html",redirect:"/algorithm/search/fibonacciSearch/"},{name:"v-76aa68ff",path:"/algorithm/search/interpolationSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-76aa68ff").then(t)}},{path:"/algorithm/search/interpolationSearch/index.html",redirect:"/algorithm/search/interpolationSearch/"},{path:"/20.算法/20.Search 搜索/40.InterpolationSearch.html",redirect:"/algorithm/search/interpolationSearch/"},{name:"v-423e3e69",path:"/algorithm/search/jumpSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-423e3e69").then(t)}},{path:"/algorithm/search/jumpSearch/index.html",redirect:"/algorithm/search/jumpSearch/"},{path:"/20.算法/20.Search 搜索/50.JumpSearch.html",redirect:"/algorithm/search/jumpSearch/"},{name:"v-7f1bcab9",path:"/algorithm/search/linearSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7f1bcab9").then(t)}},{path:"/algorithm/search/linearSearch/index.html",redirect:"/algorithm/search/linearSearch/"},{path:"/20.算法/20.Search 搜索/60.LinearSearch.html",redirect:"/algorithm/search/linearSearch/"},{name:"v-46c7f282",path:"/algorithm/search/quickSelectSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-46c7f282").then(t)}},{path:"/algorithm/search/quickSelectSearch/index.html",redirect:"/algorithm/search/quickSelectSearch/"},{path:"/20.算法/20.Search 搜索/70.QuickSelectSearch.html",redirect:"/algorithm/search/quickSelectSearch/"},{name:"v-23204e4c",path:"/algorithm/more/conwaysGameOfLife/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-23204e4c").then(t)}},{path:"/algorithm/more/conwaysGameOfLife/index.html",redirect:"/algorithm/more/conwaysGameOfLife/"},{path:"/20.算法/200.其他/10.ConwaysGameOfLife.html",redirect:"/algorithm/more/conwaysGameOfLife/"},{name:"v-48c1e216",path:"/algorithm/roadmap/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-48c1e216").then(t)}},{path:"/algorithm/roadmap/index.html",redirect:"/algorithm/roadmap/"},{path:"/20.算法/3.roadmap.html",redirect:"/algorithm/roadmap/"},{name:"v-16a18680",path:"/algorithm/recursive/binaryEquivalent/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-16a18680").then(t)}},{path:"/algorithm/recursive/binaryEquivalent/index.html",redirect:"/algorithm/recursive/binaryEquivalent/"},{path:"/20.算法/30.Recursive 递归/10.BinaryEquivalent.html",redirect:"/algorithm/recursive/binaryEquivalent/"},{name:"v-fb132384",path:"/algorithm/recursive/towerOfHanoi/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-fb132384").then(t)}},{path:"/algorithm/recursive/towerOfHanoi/index.html",redirect:"/algorithm/recursive/towerOfHanoi/"},{path:"/20.算法/30.Recursive 递归/110.TowerOfHanoi.html",redirect:"/algorithm/recursive/towerOfHanoi/"},{name:"v-58bc8820",path:"/algorithm/recursive/binarySearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-58bc8820").then(t)}},{path:"/algorithm/recursive/binarySearch/index.html",redirect:"/algorithm/recursive/binarySearch/"},{path:"/20.算法/30.Recursive 递归/20.BinarySearch.html",redirect:"/algorithm/recursive/binarySearch/"},{name:"v-4b1c1560",path:"/algorithm/recursive/euclideanGCD/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4b1c1560").then(t)}},{path:"/algorithm/recursive/euclideanGCD/index.html",redirect:"/algorithm/recursive/euclideanGCD/"},{path:"/20.算法/30.Recursive 递归/30.EucledianGCD.html",redirect:"/algorithm/recursive/euclideanGCD/"},{name:"v-42ab0b9c",path:"/algorithm/recursive/factorial/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-42ab0b9c").then(t)}},{path:"/algorithm/recursive/factorial/index.html",redirect:"/algorithm/recursive/factorial/"},{path:"/20.算法/30.Recursive 递归/40.Factorial.html",redirect:"/algorithm/recursive/factorial/"},{name:"v-9165af80",path:"/algorithm/recursive/fibonacci/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-9165af80").then(t)}},{path:"/algorithm/recursive/fibonacci/index.html",redirect:"/algorithm/recursive/fibonacci/"},{path:"/20.算法/30.Recursive 递归/50.FibonacciNumberRecursive.html",redirect:"/algorithm/recursive/fibonacci/"},{name:"v-0a82273e",path:"/algorithm/recursive/floodFill/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0a82273e").then(t)}},{path:"/algorithm/recursive/floodFill/index.html",redirect:"/algorithm/recursive/floodFill/"},{path:"/20.算法/30.Recursive 递归/60.FloodFill.html",redirect:"/algorithm/recursive/floodFill/"},{name:"v-61e6541c",path:"/algorithm/recursive/kochSnowflake/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-61e6541c").then(t)}},{path:"/algorithm/recursive/kochSnowflake/index.html",redirect:"/algorithm/recursive/kochSnowflake/"},{path:"/20.算法/30.Recursive 递归/80.KochSnowflake.html",redirect:"/algorithm/recursive/kochSnowflake/"},{name:"v-b378a200",path:"/algorithm/recursive/palindrome/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-b378a200").then(t)}},{path:"/algorithm/recursive/palindrome/index.html",redirect:"/algorithm/recursive/palindrome/"},{path:"/20.算法/30.Recursive 递归/90.Palindrome.html",redirect:"/algorithm/recursive/palindrome/"},{name:"v-6e5ede56",path:"/algorithm/introduction/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-6e5ede56").then(t)}},{path:"/algorithm/introduction/index.html",redirect:"/algorithm/introduction/"},{path:"/20.算法/4.intro.html",redirect:"/algorithm/introduction/"},{name:"v-f5d9ba7a",path:"/algorithm/graph/bellmanFord/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-f5d9ba7a").then(t)}},{path:"/algorithm/graph/bellmanFord/index.html",redirect:"/algorithm/graph/bellmanFord/"},{path:"/20.算法/40.Graph 图/10.BellmanFord.html",redirect:"/algorithm/graph/bellmanFord/"},{name:"v-552817ee",path:"/algorithm/graph/floydWarshall/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-552817ee").then(t)}},{path:"/algorithm/graph/floydWarshall/index.html",redirect:"/algorithm/graph/floydWarshall/"},{path:"/20.算法/40.Graph 图/100.FloydWarshall.html",redirect:"/algorithm/graph/floydWarshall/"},{name:"v-ad60b07a",path:"/algorithm/graph/kruskalMST/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-ad60b07a").then(t)}},{path:"/algorithm/graph/kruskalMST/index.html",redirect:"/algorithm/graph/kruskalMST/"},{path:"/20.算法/40.Graph 图/110.KruskalMST.html",redirect:"/algorithm/graph/kruskalMST/"},{name:"v-272cc03f",path:"/algorithm/graph/nodeNeighbors/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-272cc03f").then(t)}},{path:"/algorithm/graph/nodeNeighbors/index.html",redirect:"/algorithm/graph/nodeNeighbors/"},{path:"/20.算法/40.Graph 图/120.NodeNeighbors.html",redirect:"/algorithm/graph/nodeNeighbors/"},{name:"v-40614603",path:"/algorithm/graph/numberOfIslands/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-40614603").then(t)}},{path:"/algorithm/graph/numberOfIslands/index.html",redirect:"/algorithm/graph/numberOfIslands/"},{path:"/20.算法/40.Graph 图/130.NumberOfIslands.html",redirect:"/algorithm/graph/numberOfIslands/"},{name:"v-f2614c1e",path:"/algorithm/graph/primMST/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-f2614c1e").then(t)}},{path:"/algorithm/graph/primMST/index.html",redirect:"/algorithm/graph/primMST/"},{path:"/20.算法/40.Graph 图/140.PrimMST.html",redirect:"/algorithm/graph/primMST/"},{name:"v-5adb5772",path:"/algorithm/graph/breadthFirstSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5adb5772").then(t)}},{path:"/algorithm/graph/breadthFirstSearch/index.html",redirect:"/algorithm/graph/breadthFirstSearch/"},{path:"/20.算法/40.Graph 图/20.BreadthFirstSearch.html",redirect:"/algorithm/graph/breadthFirstSearch/"},{name:"v-69d870f7",path:"/algorithm/graph/breadthFirstShortestPath/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-69d870f7").then(t)}},{path:"/algorithm/graph/breadthFirstShortestPath/index.html",redirect:"/algorithm/graph/breadthFirstShortestPath/"},{path:"/20.算法/40.Graph 图/30.BreadthFirstShortestPath.html",redirect:"/algorithm/graph/breadthFirstShortestPath/"},{name:"v-9e12a0fa",path:"/algorithm/graph/connectedComponents/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-9e12a0fa").then(t)}},{path:"/algorithm/graph/connectedComponents/index.html",redirect:"/algorithm/graph/connectedComponents/"},{path:"/20.算法/40.Graph 图/40.ConnectedComponents.html",redirect:"/algorithm/graph/connectedComponents/"},{name:"v-428975fa",path:"/algorithm/graph/density/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-428975fa").then(t)}},{path:"/algorithm/graph/density/index.html",redirect:"/algorithm/graph/density/"},{path:"/20.算法/40.Graph 图/50.Density.html",redirect:"/algorithm/graph/density/"},{name:"v-65f4a9ad",path:"/algorithm/graph/depthFirstSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-65f4a9ad").then(t)}},{path:"/algorithm/graph/depthFirstSearch/index.html",redirect:"/algorithm/graph/depthFirstSearch/"},{path:"/20.算法/40.Graph 图/60.DepthFirstSearch.html",redirect:"/algorithm/graph/depthFirstSearch/"},{name:"v-55d448e7",path:"/algorithm/graph/dijkstra/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-55d448e7").then(t)}},{path:"/algorithm/graph/dijkstra/index.html",redirect:"/algorithm/graph/dijkstra/"},{path:"/20.算法/40.Graph 图/80.Dijkstra.html",redirect:"/algorithm/graph/dijkstra/"},{name:"v-38f0ff9a",path:"/algorithm/tree/breadthFirstTreeTraversal/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-38f0ff9a").then(t)}},{path:"/algorithm/tree/breadthFirstTreeTraversal/index.html",redirect:"/algorithm/tree/breadthFirstTreeTraversal/"},{path:"/20.算法/50.Tree 树/10.BreadthFirstTreeTraversal.html",redirect:"/algorithm/tree/breadthFirstTreeTraversal/"},{name:"v-7679b8ac",path:"/algorithm/tree/depthFirstSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7679b8ac").then(t)}},{path:"/algorithm/tree/depthFirstSearch/index.html",redirect:"/algorithm/tree/depthFirstSearch/"},{path:"/20.算法/50.Tree 树/20.DepthFirstSearch.html",redirect:"/algorithm/tree/depthFirstSearch/"},{name:"v-45074848",path:"/algorithm/tree/fenwickTree/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-45074848").then(t)}},{path:"/algorithm/tree/fenwickTree/index.html",redirect:"/algorithm/tree/fenwickTree/"},{path:"/20.算法/50.Tree 树/30.FenwickTree.html",redirect:"/algorithm/tree/fenwickTree/"},{name:"v-383bae3e",path:"/algorithm/math/abs/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-383bae3e").then(t)}},{path:"/algorithm/math/abs/index.html",redirect:"/algorithm/math/abs/"},{path:"/20.算法/60.Math 数学/10.Abs.html",redirect:"/algorithm/math/abs/"},{name:"v-582593b7",path:"/algorithm/math/binaryConvert/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-582593b7").then(t)}},{path:"/algorithm/math/binaryConvert/index.html",redirect:"/algorithm/math/binaryConvert/"},{path:"/20.算法/60.Math 数学/100.BinaryConvert.html",redirect:"/algorithm/math/binaryConvert/"},{name:"v-4a4644fb",path:"/algorithm/math/checkKishnamurthyNumber/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4a4644fb").then(t)}},{path:"/algorithm/math/checkKishnamurthyNumber/index.html",redirect:"/algorithm/math/checkKishnamurthyNumber/"},{path:"/20.算法/60.Math 数学/120.CheckKishnamurthyNumber.html",redirect:"/algorithm/math/checkKishnamurthyNumber/"},{name:"v-1cc688c1",path:"/algorithm/math/coordinate/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1cc688c1").then(t)}},{path:"/algorithm/math/coordinate/index.html",redirect:"/algorithm/math/coordinate/"},{path:"/20.算法/60.Math 数学/130.Coordinate.html",redirect:"/algorithm/math/coordinate/"},{name:"v-48760081",path:"/algorithm/math/coPrimeCheck/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-48760081").then(t)}},{path:"/algorithm/math/coPrimeCheck/index.html",redirect:"/algorithm/math/coPrimeCheck/"},{path:"/20.算法/60.Math 数学/140.CoPrimeCheck.html",redirect:"/algorithm/math/coPrimeCheck/"},{name:"v-0577e13e",path:"/algorithm/math/degreeToRadian/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0577e13e").then(t)}},{path:"/algorithm/math/degreeToRadian/index.html",redirect:"/algorithm/math/degreeToRadian/"},{path:"/20.算法/60.Math 数学/160.DegreeToRadian.html",redirect:"/algorithm/math/degreeToRadian/"},{name:"v-081d8441",path:"/algorithm/math/decimalIsolate/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-081d8441").then(t)}},{path:"/algorithm/math/decimalIsolate/index.html",redirect:"/algorithm/math/decimalIsolate/"},{path:"/20.算法/60.Math 数学/150.DecimalIsolate.html",redirect:"/algorithm/math/decimalIsolate/"},{name:"v-450c7701",path:"/algorithm/math/decimalExpansion/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-450c7701").then(t)}},{path:"/algorithm/math/decimalExpansion/index.html",redirect:"/algorithm/math/decimalExpansion/"},{path:"/20.算法/60.Math 数学/170.DecimalExpansion.html",redirect:"/algorithm/math/decimalExpansion/"},{name:"v-cbd4108e",path:"/algorithm/math/aliquotSum/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-cbd4108e").then(t)}},{path:"/algorithm/math/aliquotSum/index.html",redirect:"/algorithm/math/aliquotSum/"},{path:"/20.算法/60.Math 数学/20.AliquotSum.html",redirect:"/algorithm/math/aliquotSum/"},{name:"v-e0ba9d36",path:"/algorithm/math/area/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-e0ba9d36").then(t)}},{path:"/algorithm/math/area/index.html",redirect:"/algorithm/math/area/"},{path:"/20.算法/60.Math 数学/30.Area.html",redirect:"/algorithm/math/area/"},{name:"v-deef02fe",path:"/algorithm/math/arithmeticGeometricMean/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-deef02fe").then(t)}},{path:"/algorithm/math/arithmeticGeometricMean/index.html",redirect:"/algorithm/math/arithmeticGeometricMean/"},{path:"/20.算法/60.Math 数学/40.ArithmeticGeometricMean.html",redirect:"/algorithm/math/arithmeticGeometricMean/"},{name:"v-3b8ac9a1",path:"/algorithm/math/armstrongNumber/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3b8ac9a1").then(t)}},{path:"/algorithm/math/armstrongNumber/index.html",redirect:"/algorithm/math/armstrongNumber/"},{path:"/20.算法/60.Math 数学/50.ArmstrongNumber.html",redirect:"/algorithm/math/armstrongNumber/"},{name:"v-3c64c701",path:"/algorithm/math/averageMean/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3c64c701").then(t)}},{path:"/algorithm/math/averageMean/index.html",redirect:"/algorithm/math/averageMean/"},{path:"/20.算法/60.Math 数学/60.AverageMean.html",redirect:"/algorithm/math/averageMean/"},{name:"v-d713c7fe",path:"/algorithm/math/averageMedian/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-d713c7fe").then(t)}},{path:"/algorithm/math/averageMedian/index.html",redirect:"/algorithm/math/averageMedian/"},{path:"/20.算法/60.Math 数学/70.AverageMedian.html",redirect:"/algorithm/math/averageMedian/"},{name:"v-1d93c406",path:"/algorithm/math/binaryExponentiation/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1d93c406").then(t)}},{path:"/algorithm/math/binaryExponentiation/index.html",redirect:"/algorithm/math/binaryExponentiation/"},{path:"/20.算法/60.Math 数学/80.BinaryExponentiation.html",redirect:"/algorithm/math/binaryExponentiation/"},{name:"v-ecd8ca7e",path:"/algorithm/math/bisectionMethod/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-ecd8ca7e").then(t)}},{path:"/algorithm/math/bisectionMethod/index.html",redirect:"/algorithm/math/bisectionMethod/"},{path:"/20.算法/60.Math 数学/90.BisectionMethod.html",redirect:"/algorithm/math/bisectionMethod/"},{name:"v-41f1b873",path:"/pages/c3f9cf/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-41f1b873").then(t)}},{path:"/pages/c3f9cf/index.html",redirect:"/pages/c3f9cf/"},{path:"/20.算法/60.Math 数学/Haversine.html",redirect:"/pages/c3f9cf/"},{name:"v-c004732e",path:"/algorithm/hash/sha1/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-c004732e").then(t)}},{path:"/algorithm/hash/sha1/index.html",redirect:"/algorithm/hash/sha1/"},{path:"/20.算法/70.Hash 哈希/10.SHA1.html",redirect:"/algorithm/hash/sha1/"},{name:"v-59ae4823",path:"/algorithm/hash/sha256/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-59ae4823").then(t)}},{path:"/algorithm/hash/sha256/index.html",redirect:"/algorithm/hash/sha256/"},{path:"/20.算法/70.Hash 哈希/20.SHA256.html",redirect:"/algorithm/hash/sha256/"},{name:"v-55adfde7",path:"/algorithm/string/alphaNumericPalindrome/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-55adfde7").then(t)}},{path:"/algorithm/string/alphaNumericPalindrome/index.html",redirect:"/algorithm/string/alphaNumericPalindrome/"},{path:"/20.算法/80.String 字符串/10.AlphaNumericPalindrome.html",redirect:"/algorithm/string/alphaNumericPalindrome/"},{name:"v-8efdaeca",path:"/algorithm/string/createPermutations/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-8efdaeca").then(t)}},{path:"/algorithm/string/createPermutations/index.html",redirect:"/algorithm/string/createPermutations/"},{path:"/20.算法/80.String 字符串/100.CreatePermutations.html",redirect:"/algorithm/string/createPermutations/"},{name:"v-681a7687",path:"/algorithm/string/diceCoefficient/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-681a7687").then(t)}},{path:"/algorithm/string/diceCoefficient/index.html",redirect:"/algorithm/string/diceCoefficient/"},{path:"/20.算法/80.String 字符串/110.DiceCoefficient.html",redirect:"/algorithm/string/diceCoefficient/"},{name:"v-4152d2a7",path:"/algorithm/string/formatPhoneNumber/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4152d2a7").then(t)}},{path:"/algorithm/string/formatPhoneNumber/index.html",redirect:"/algorithm/string/formatPhoneNumber/"},{path:"/20.算法/80.String 字符串/120.FormatPhoneNumber.html",redirect:"/algorithm/string/formatPhoneNumber/"},{name:"v-3b9e07eb",path:"/algorithm/string/generateGUID/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-3b9e07eb").then(t)}},{path:"/algorithm/string/generateGUID/index.html",redirect:"/algorithm/string/generateGUID/"},{path:"/20.算法/80.String 字符串/130.GenerateGuid.html",redirect:"/algorithm/string/generateGUID/"},{name:"v-28aa3f32",path:"/algorithm/string/hammingDistance/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-28aa3f32").then(t)}},{path:"/algorithm/string/hammingDistance/index.html",redirect:"/algorithm/string/hammingDistance/"},{path:"/20.算法/80.String 字符串/140.HammingDistance.html",redirect:"/algorithm/string/hammingDistance/"},{name:"v-747281c7",path:"/algorithm/string/KMPPatternSearching/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-747281c7").then(t)}},{path:"/algorithm/string/KMPPatternSearching/index.html",redirect:"/algorithm/string/KMPPatternSearching/"},{path:"/20.算法/80.String 字符串/150.KMPPatternSearching.html",redirect:"/algorithm/string/KMPPatternSearching/"},{name:"v-2a0c2c87",path:"/algorithm/string/boyerMoore/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2a0c2c87").then(t)}},{path:"/algorithm/string/boyerMoore/index.html",redirect:"/algorithm/string/boyerMoore/"},{path:"/20.算法/80.String 字符串/30.BoyerMoore.html",redirect:"/algorithm/string/boyerMoore/"},{name:"v-5bb0c3c7",path:"/algorithm/string/alternativeStringArrange/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5bb0c3c7").then(t)}},{path:"/algorithm/string/alternativeStringArrange/index.html",redirect:"/algorithm/string/alternativeStringArrange/"},{path:"/20.算法/80.String 字符串/20.AlternativeStringArrange.html",redirect:"/algorithm/string/alternativeStringArrange/"},{name:"v-1d2b4432",path:"/algorithm/string/checkAnagram/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-1d2b4432").then(t)}},{path:"/algorithm/string/checkAnagram/index.html",redirect:"/algorithm/string/checkAnagram/"},{path:"/20.算法/80.String 字符串/40.CheckAnagram.html",redirect:"/algorithm/string/checkAnagram/"},{name:"v-893b45f2",path:"/algorithm/string/namingConvention/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-893b45f2").then(t)}},{path:"/algorithm/string/namingConvention/index.html",redirect:"/algorithm/string/namingConvention/"},{path:"/20.算法/80.String 字符串/50.NamingConvention.html",redirect:"/algorithm/string/namingConvention/"},{name:"v-4d5125c7",path:"/algorithm/string/checkExceeding/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4d5125c7").then(t)}},{path:"/algorithm/string/checkExceeding/index.html",redirect:"/algorithm/string/checkExceeding/"},{path:"/20.算法/80.String 字符串/60.CheckExceeding.html",redirect:"/algorithm/string/checkExceeding/"},{name:"v-e1939732",path:"/algorithm/string/checkPangram/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-e1939732").then(t)}},{path:"/algorithm/string/checkPangram/index.html",redirect:"/algorithm/string/checkPangram/"},{path:"/20.算法/80.String 字符串/70.CheckPangram.html",redirect:"/algorithm/string/checkPangram/"},{name:"v-2873fe66",path:"/algorithm/string/checkWordOccurrence/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-2873fe66").then(t)}},{path:"/algorithm/string/checkWordOccurrence/index.html",redirect:"/algorithm/string/checkWordOccurrence/"},{path:"/20.算法/80.String 字符串/80.CheckWordOccurrence.html",redirect:"/algorithm/string/checkWordOccurrence/"},{name:"v-12feff1b",path:"/algorithm/string/countVowels/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-12feff1b").then(t)}},{path:"/algorithm/string/countVowels/index.html",redirect:"/algorithm/string/countVowels/"},{path:"/20.算法/80.String 字符串/90.CountVowels.html",redirect:"/algorithm/string/countVowels/"},{name:"v-67591296",path:"/algorithm/bit/binaryCountSetBits/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-67591296").then(t)}},{path:"/algorithm/bit/binaryCountSetBits/index.html",redirect:"/algorithm/bit/binaryCountSetBits/"},{path:"/20.算法/90.BitManipulation 位操纵/10.BinaryCountSetBits.html",redirect:"/algorithm/bit/binaryCountSetBits/"},{name:"v-0eb091a8",path:"/algorithm/bit/powerOfTwo/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-0eb091a8").then(t)}},{path:"/algorithm/bit/powerOfTwo/index.html",redirect:"/algorithm/bit/powerOfTwo/"},{path:"/20.算法/90.BitManipulation 位操纵/20.PowerOfTwo.html",redirect:"/algorithm/bit/powerOfTwo/"},{name:"v-4fe20720",path:"/algorithm/bit/setBit/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4fe20720").then(t)}},{path:"/algorithm/bit/setBit/index.html",redirect:"/algorithm/bit/setBit/"},{path:"/20.算法/90.BitManipulation 位操纵/30.SetBit.html",redirect:"/algorithm/bit/setBit/"},{name:"v-24ef5527",path:"/leetcode/index/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-24ef5527").then(t)}},{path:"/leetcode/index/index.html",redirect:"/leetcode/index/"},{path:"/30.LeetCode/0.index.html",redirect:"/leetcode/index/"},{name:"v-5da85e95",path:"/leetcode/plan/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5da85e95").then(t)}},{path:"/leetcode/plan/index.html",redirect:"/leetcode/plan/"},{path:"/30.LeetCode/1.plan.html",redirect:"/leetcode/plan/"},{name:"v-613274e4",path:"/leetcode/problems/index/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-613274e4").then(t)}},{path:"/leetcode/problems/index/index.html",redirect:"/leetcode/problems/index/"},{path:"/30.LeetCode/10.力扣习题集/0.index.html",redirect:"/leetcode/problems/index/"},{name:"v-71af493c",path:"/leetcode/problems/0/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-71af493c").then(t)}},{path:"/leetcode/problems/0/index.html",redirect:"/leetcode/problems/0/"},{path:"/30.LeetCode/10.力扣习题集/10.0-20.html",redirect:"/leetcode/problems/0/"},{name:"v-9f87cf32",path:"/leetcode/roadmap/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-9f87cf32").then(t)}},{path:"/leetcode/roadmap/index.html",redirect:"/leetcode/roadmap/"},{path:"/30.LeetCode/2.roadmap.html",redirect:"/leetcode/roadmap/"},{name:"v-5e4325fb",path:"/ds/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5e4325fb").then(t)}},{path:"/ds/index.html",redirect:"/ds/"},{path:"/999.目录/10.数据结构.html",redirect:"/ds/"},{name:"v-503fa995",path:"/algorithm/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-503fa995").then(t)}},{path:"/algorithm/index.html",redirect:"/algorithm/"},{path:"/999.目录/20.算法.html",redirect:"/algorithm/"},{name:"v-5d3b6f37",path:"/leetcode/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-5d3b6f37").then(t)}},{path:"/leetcode/index.html",redirect:"/leetcode/"},{path:"/999.目录/30.LeetCode.html",redirect:"/leetcode/"},{name:"v-7efc0d27",path:"/archives/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7efc0d27").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-725b30f2",path:"/categories/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-725b30f2").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-79f396b2",path:"/tags/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-79f396b2").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-4b1f61a7",path:"/about/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-4b1f61a7").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/about.html",redirect:"/about/"},{name:"v-bba02680",path:"/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-bba02680").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-7912cf1b",path:"/algorithm/search/stringSearch/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7912cf1b").then(t)}},{path:"/algorithm/search/stringSearch/index.html",redirect:"/algorithm/search/stringSearch/"},{path:"/20.算法/20.Search 搜索/90.StringSearch.html",redirect:"/algorithm/search/stringSearch/"},{name:"v-7d885782",path:"/algorithm/search/slidingWindow/",component:xt,beforeEnter:(n,e,t)=>{pe("Layout","v-7d885782").then(t)}},{path:"/algorithm/search/slidingWindow/index.html",redirect:"/algorithm/search/slidingWindow/"},{path:"/20.算法/20.Search 搜索/80.SlidingWindow.html",redirect:"/algorithm/search/slidingWindow/"},{path:"*",component:xt}],St={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["meta",{name:"keywords",content:"机器学习,深度学习"}],["meta",{name:"theme-color",content:"#06403F"}],["link",{rel:"stylesheet",href:"//at.alicdn.com/t/font_3314748_9xij1pv3h4i.css"}],["link",{rel:"icon",href:"/img/favicon.ico",type:"image/x-icon"}],["link",{rel:"manifest",href:"/img/manifest.json"}],["meta",{name:"theme-color",content:"#E86E2C"}],["meta",{name:"apple-mobile-web-app-capable",content:"yes"}],["meta",{name:"apple-mobile-web-app-status-bar-style",content:"black"}],["link",{rel:"apple-touch-icon",href:"/img/android-chrome-192x192.png"}],["link",{rel:"mask-icon",href:"/icons/safari-pinned-tab.svg",color:"#3eaf7c"}],["meta",{name:"msapplication-TileImage",content:"/icons/msapplication-icon-144x144.png"}],["meta",{name:"msapplication-TileColor",content:"#000000"}]],pages:[{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-16T16:43:23.000Z",permalink:"/ds/index/",categories:["数据结构"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0.index.html",relativePath:"10.数据结构/0.index.md",key:"v-486da2db",path:"/ds/index/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"数据结构的类型",slug:"数据结构的类型",normalizedTitle:"数据结构的类型",charIndex:472},{level:2,title:"主要操作",slug:"主要操作",normalizedTitle:"主要操作",charIndex:896},{level:2,title:"如何选择数据结构",slug:"如何选择数据结构",normalizedTitle:"如何选择数据结构",charIndex:1075},{level:2,title:"数据结构的优点",slug:"数据结构的优点",normalizedTitle:"数据结构的优点",charIndex:1430},{level:2,title:"常见数据结构",slug:"常见数据结构",normalizedTitle:"常见数据结构",charIndex:1621},{level:3,title:"数组（Array）",slug:"数组-array",normalizedTitle:"数组（array）",charIndex:1632},{level:3,title:"栈（Stack）",slug:"栈-stack",normalizedTitle:"栈（stack）",charIndex:1795},{level:3,title:"队列（Queue）",slug:"队列-queue",normalizedTitle:"队列（queue）",charIndex:1947},{level:3,title:"链表（Linked List）",slug:"链表-linked-list",normalizedTitle:"链表（linked list）",charIndex:2065},{level:3,title:"树（Tree）",slug:"树-tree",normalizedTitle:"树（tree）",charIndex:2224},{level:3,title:"图（Graph）",slug:"图-graph",normalizedTitle:"图（graph）",charIndex:2922},{level:3,title:"堆（Heap）",slug:"堆-heap",normalizedTitle:"堆（heap）",charIndex:3388},{level:3,title:"散列表(Hash）",slug:"散列表-hash",normalizedTitle:"散列表 (hash）",charIndex:3471},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3588}],headersStr:"简介 数据结构的类型 主要操作 如何选择数据结构 数据结构的优点 常见数据结构 数组（Array） 栈（Stack） 队列（Queue） 链表（Linked List） 树（Tree） 图（Graph） 堆（Heap） 散列表(Hash） 参考",content:'# 简介\n\n数据结构是计算机科学的关键内容，也是构建高效算法的必要基础。本话题旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧。\n\n数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。\n\n数据结构往往同高效的检索算法和索引技术有关。数据结构可以分为逻辑结构和存储结构，有四类基本逻辑结构：集合、线性结构、树形结构、图状结构。这几类结构有以下几个特点：\n\n * 集合结构：除了同属于一种类型外，别无其它关系。\n\n * 线性结构：元素之间存在一对一关系。常见类型有：数组、链表、队列、栈。它们之间在操作上有所区别。例如：链表可在任意位置插入或删除元素，而队列在队尾插入元素、队头删除元素，栈只能在栈顶进行插入，删除操作。\n\n * 树形结构：元素之间存在一对多关系。常见类型有：树 (有许多特例：二叉树、平衡二叉树、查找树等)。\n\n * 图形结构：元素之间存在多对多关系，图形结构中每个结点的前驱结点数和后续结点多个数可以任意。\n\n\n# 数据结构的类型\n\n有两种类型的数据结构：原始（Primitive）数据结构、非原始（Non-primitive）数据结构。\n\n原始数据结构：原始数据结构是原始的数据类型。int、char、float、double 和 pointer 是可以保存单个值的原始数据结构。\n\n非原始数据结构：非原始数据结构分为两种类型。线性数据结构、非线性数据结构。\n\n线性数据结构：\n\n以顺序方式排列的数据被称为线性数据结构。基于此原则的数据结构是数组、链表、堆栈和队列。在这些数据结构中，一个元素只与另一个元素以线性方式连接。\n\n当一个元素与 "n" 个元素相连时，被称为非线性数据结构。最好的例子是树和图。在这种情况下，元素是以随机方式排列的。\n\n数据结构也可以分为以下几种：\n\n * 静态数据结构。这是一种数据结构，其大小是在编译时分配的。因此，最大尺寸是固定的。\n * 动态数据结构。它是一种数据结构类型，其大小在运行时分配。因此，最大尺寸是灵活的。\n\n\n# 主要操作\n\n可以在数据结构上进行的主要或常见的操作是：\n\n * 搜索：可以在一个数据结构中搜索任何元素。\n * 排序。可以按照升序或降序对数据结构中的元素进行排序。\n * 插入。也可以在一个数据结构中插入新的元素。\n * 更新。也可以更新元素，也就是说，我们可以用另一个元素替换这个元素。\n * 删除。也可以执行删除操作，将该元素从数据结构中删除。\n\n\n# 如何选择数据结构\n\n数据结构是一种组织数据的方式，以便能够有效地使用它。在这里，我们使用了高效这个词，从空间和时间两方面来说。例如，堆栈是一个 ADT（抽象数据类型），它使用数组或链接列表数据结构来实现。因此，我们得出结论，我们需要一些数据结构来实现一个特定的 ADT。\n\n一个 ADT 告诉我们要做什么，而数据结构告诉我们如何去做。换句话说，我们可以说 ADT 给了我们蓝图，而数据结构提供了实现部分。现在问题来了：如何才能知道哪种数据结构可用于某个特定的 ADT？\n\n因为不同的数据结构可以在一个特定的 ADT 中实现，但不同的实现方式要在时间和空间上进行比较。例如，堆栈 ADT 可以由数组和链表来实现。假设数组提供的是时间效率，而链表提供的是空间效率，那么就会选择最适合当前用户需求的那一种。\n\n\n# 数据结构的优点\n\n以下是数据结构的优点：\n\n * 效率。如果为实现一个特定的 ADT 而选择的数据结构是恰当的，那么它将使程序在时间和空间上非常有效。\n * 可重用性。数据结构提供了重用性，意味着多个客户程序可以使用该数据结构。\n * 抽象性。ADT 所指定的数据结构也提供了抽象的层次。客户端不能看到数据结构的内部工作，所以它不必担心实现部分的问题。客户端只能看到接口。\n\n\n# 常见数据结构\n\n\n# 数组（Array）\n\n数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。\n\n\n# 栈（Stack）\n\n栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。\n\n\n# 队列（Queue）\n\n队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。\n\n\n# 链表（Linked List）\n\n链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。\n\n\n# 树（Tree）\n\n树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点。\n\n * 二叉树\n * 遍历二叉树：前序（先中间，再左边，后右边）；中序（先左边，再中间，后右边）；后序（先左边，再右边，后中间）。\n * 线索二叉树：用二插链表实现的二叉树，将那些没有使用的左右指针指向前驱和后继（前驱和后继就是遍历后（例如用中序遍历）的数据序列某一个数据的前面和后面的数据），形成的二叉树为线索二叉树。一般用在经常遍历和利用前驱和后继查找结构的情况。\n * 赫夫曼树：用于压缩。\n * 二叉排序树：根节点的左子树若不为空，则左子树所有节点都小于根节点。根节点的右子树若不为空，则右子树所有节点都大于根结点。根节点的左右子树不为空，则其都是二叉平衡树。\n * 平衡二叉树：一颗左右子树高度差至多等于 1 的二叉排序树。添加节点的时候，根据不平衡子树左旋右，保证最后的树是平衡的。优点：查找，插入，删除时间复杂度都是：O（logn）。\n * 多路查找树：结点的孩子不止为两个，结点存的值补位一个。如 2-3 树，2-3-4 树，B 树，B + 树\n * 红黑树：也是二叉排序树。利用一个结点的属性表明这个结点是红是黑。查找等同于二叉排序树。插入和删除利用这个颜色属性来保证操作之后树还是平衡的。所以查找，插入和删除的时间复杂度都是：O（logn）。统计性能比平衡二叉树好。\n * 堆：二叉树，分为大顶堆，小顶堆。大顶堆的要求是每个节点的值都不大于其父节点的值，小顶堆反过来。\n\n\n# 图（Graph）\n\n图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。\n\n\n\n五种构造图的方式：\n\n * 遍历：\n\n深度优先：一个劲的朝一个方向使劲，当重复了就返回。\n\n广度优先：先从一个顶点触发，拿到这个顶点，再把与这个顶点相关的顶点放入队列，再从队列取数据，再把与这个新取的顶点相关的顶点（非重复过的顶点）放入队列，依次同理操作\n\n * 最小生成树：\n\n普里姆（Prim）算法：O (n2)\n\n克鲁斯卡尔（Kruskal）算法：O (e*loge)\n\n * 最短路径：\n\n迪杰斯特拉（Dijkstra）算法 O (n3)\n\n弗洛伊德（Floyd）算法 O (n3)\n\n * 拓扑排序：AOV 网：用顶点表示活动，用弧表示优先关系的有向图。\n\n拓扑排序算法：O (n+e) n 个顶点 e 条边\n\n * 关键路径：AOE 网：用顶点表示时间，用有向边表示活动，用边的权值表示持续的时间的有向图。\n\n关键算法路径：O (n+e)\n\n\n# 堆（Heap）\n\n堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。\n\n\n# 散列表 (Hash）\n\n散列表源自于散列函数 (Hash function)，其思想是如果在结构中存在关键字和 T 相等的记录，那么必定在 F (T) 的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。\n\n\n# 参考\n\n * datastructures-js\n * 数据结构与算法（DSA）\n * ImmutableJs 源码解读\n * Data Structures - GeeksforGeeks\n * ♥数据结构基础知识体系详解♥ | Java 全栈知识体系',normalizedContent:'# 简介\n\n数据结构是计算机科学的关键内容，也是构建高效算法的必要基础。本话题旨在围绕各类数据结构的设计与实现，揭示其中的规律原理与方法技巧。\n\n数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。\n\n数据结构往往同高效的检索算法和索引技术有关。数据结构可以分为逻辑结构和存储结构，有四类基本逻辑结构：集合、线性结构、树形结构、图状结构。这几类结构有以下几个特点：\n\n * 集合结构：除了同属于一种类型外，别无其它关系。\n\n * 线性结构：元素之间存在一对一关系。常见类型有：数组、链表、队列、栈。它们之间在操作上有所区别。例如：链表可在任意位置插入或删除元素，而队列在队尾插入元素、队头删除元素，栈只能在栈顶进行插入，删除操作。\n\n * 树形结构：元素之间存在一对多关系。常见类型有：树 (有许多特例：二叉树、平衡二叉树、查找树等)。\n\n * 图形结构：元素之间存在多对多关系，图形结构中每个结点的前驱结点数和后续结点多个数可以任意。\n\n\n# 数据结构的类型\n\n有两种类型的数据结构：原始（primitive）数据结构、非原始（non-primitive）数据结构。\n\n原始数据结构：原始数据结构是原始的数据类型。int、char、float、double 和 pointer 是可以保存单个值的原始数据结构。\n\n非原始数据结构：非原始数据结构分为两种类型。线性数据结构、非线性数据结构。\n\n线性数据结构：\n\n以顺序方式排列的数据被称为线性数据结构。基于此原则的数据结构是数组、链表、堆栈和队列。在这些数据结构中，一个元素只与另一个元素以线性方式连接。\n\n当一个元素与 "n" 个元素相连时，被称为非线性数据结构。最好的例子是树和图。在这种情况下，元素是以随机方式排列的。\n\n数据结构也可以分为以下几种：\n\n * 静态数据结构。这是一种数据结构，其大小是在编译时分配的。因此，最大尺寸是固定的。\n * 动态数据结构。它是一种数据结构类型，其大小在运行时分配。因此，最大尺寸是灵活的。\n\n\n# 主要操作\n\n可以在数据结构上进行的主要或常见的操作是：\n\n * 搜索：可以在一个数据结构中搜索任何元素。\n * 排序。可以按照升序或降序对数据结构中的元素进行排序。\n * 插入。也可以在一个数据结构中插入新的元素。\n * 更新。也可以更新元素，也就是说，我们可以用另一个元素替换这个元素。\n * 删除。也可以执行删除操作，将该元素从数据结构中删除。\n\n\n# 如何选择数据结构\n\n数据结构是一种组织数据的方式，以便能够有效地使用它。在这里，我们使用了高效这个词，从空间和时间两方面来说。例如，堆栈是一个 adt（抽象数据类型），它使用数组或链接列表数据结构来实现。因此，我们得出结论，我们需要一些数据结构来实现一个特定的 adt。\n\n一个 adt 告诉我们要做什么，而数据结构告诉我们如何去做。换句话说，我们可以说 adt 给了我们蓝图，而数据结构提供了实现部分。现在问题来了：如何才能知道哪种数据结构可用于某个特定的 adt？\n\n因为不同的数据结构可以在一个特定的 adt 中实现，但不同的实现方式要在时间和空间上进行比较。例如，堆栈 adt 可以由数组和链表来实现。假设数组提供的是时间效率，而链表提供的是空间效率，那么就会选择最适合当前用户需求的那一种。\n\n\n# 数据结构的优点\n\n以下是数据结构的优点：\n\n * 效率。如果为实现一个特定的 adt 而选择的数据结构是恰当的，那么它将使程序在时间和空间上非常有效。\n * 可重用性。数据结构提供了重用性，意味着多个客户程序可以使用该数据结构。\n * 抽象性。adt 所指定的数据结构也提供了抽象的层次。客户端不能看到数据结构的内部工作，所以它不必担心实现部分的问题。客户端只能看到接口。\n\n\n# 常见数据结构\n\n\n# 数组（array）\n\n数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。\n\n\n# 栈（stack）\n\n栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。\n\n\n# 队列（queue）\n\n队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。\n\n\n# 链表（linked list）\n\n链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。\n\n\n# 树（tree）\n\n树是典型的非线性结构，它是包括，2 个结点的有穷集合 k。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点。\n\n * 二叉树\n * 遍历二叉树：前序（先中间，再左边，后右边）；中序（先左边，再中间，后右边）；后序（先左边，再右边，后中间）。\n * 线索二叉树：用二插链表实现的二叉树，将那些没有使用的左右指针指向前驱和后继（前驱和后继就是遍历后（例如用中序遍历）的数据序列某一个数据的前面和后面的数据），形成的二叉树为线索二叉树。一般用在经常遍历和利用前驱和后继查找结构的情况。\n * 赫夫曼树：用于压缩。\n * 二叉排序树：根节点的左子树若不为空，则左子树所有节点都小于根节点。根节点的右子树若不为空，则右子树所有节点都大于根结点。根节点的左右子树不为空，则其都是二叉平衡树。\n * 平衡二叉树：一颗左右子树高度差至多等于 1 的二叉排序树。添加节点的时候，根据不平衡子树左旋右，保证最后的树是平衡的。优点：查找，插入，删除时间复杂度都是：o（logn）。\n * 多路查找树：结点的孩子不止为两个，结点存的值补位一个。如 2-3 树，2-3-4 树，b 树，b + 树\n * 红黑树：也是二叉排序树。利用一个结点的属性表明这个结点是红是黑。查找等同于二叉排序树。插入和删除利用这个颜色属性来保证操作之后树还是平衡的。所以查找，插入和删除的时间复杂度都是：o（logn）。统计性能比平衡二叉树好。\n * 堆：二叉树，分为大顶堆，小顶堆。大顶堆的要求是每个节点的值都不大于其父节点的值，小顶堆反过来。\n\n\n# 图（graph）\n\n图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。\n\n\n\n五种构造图的方式：\n\n * 遍历：\n\n深度优先：一个劲的朝一个方向使劲，当重复了就返回。\n\n广度优先：先从一个顶点触发，拿到这个顶点，再把与这个顶点相关的顶点放入队列，再从队列取数据，再把与这个新取的顶点相关的顶点（非重复过的顶点）放入队列，依次同理操作\n\n * 最小生成树：\n\n普里姆（prim）算法：o (n2)\n\n克鲁斯卡尔（kruskal）算法：o (e*loge)\n\n * 最短路径：\n\n迪杰斯特拉（dijkstra）算法 o (n3)\n\n弗洛伊德（floyd）算法 o (n3)\n\n * 拓扑排序：aov 网：用顶点表示活动，用弧表示优先关系的有向图。\n\n拓扑排序算法：o (n+e) n 个顶点 e 条边\n\n * 关键路径：aoe 网：用顶点表示时间，用有向边表示活动，用边的权值表示持续的时间的有向图。\n\n关键算法路径：o (n+e)\n\n\n# 堆（heap）\n\n堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。\n\n\n# 散列表 (hash）\n\n散列表源自于散列函数 (hash function)，其思想是如果在结构中存在关键字和 t 相等的记录，那么必定在 f (t) 的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。\n\n\n# 参考\n\n * datastructures-js\n * 数据结构与算法（dsa）\n * immutablejs 源码解读\n * data structures - geeksforgeeks\n * ♥数据结构基础知识体系详解♥ | java 全栈知识体系',charsets:{cjk:!0},lastUpdated:"2022/09/26, 19:49:08",lastUpdatedTimestamp:1664192948e3},{title:"Queue [队列]",frontmatter:{title:"Queue [队列]",date:"2022-04-26T21:47:01.000Z",permalink:"/ds/queue/queue/",categories:["数据结构","queue队列"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.queue%20%E9%98%9F%E5%88%97/10.queue.html",relativePath:"10.数据结构/10.queue 队列/10.queue.md",key:"v-2b6c279e",path:"/ds/queue/queue/",headers:[{level:2,title:"什么是队列？",slug:"什么是队列",normalizedTitle:"什么是队列？",charIndex:2},{level:2,title:"队列的 FIFO 原则",slug:"队列的-fifo-原则",normalizedTitle:"队列的 fifo 原则",charIndex:128},{level:2,title:"队列的特点",slug:"队列的特点",normalizedTitle:"队列的特点",charIndex:307},{level:2,title:"队列的表示方法",slug:"队列的表示方法",normalizedTitle:"队列的表示方法",charIndex:360},{level:2,title:"队列的类型",slug:"队列的类型",normalizedTitle:"队列的类型",charIndex:733},{level:2,title:"队列的基本操作",slug:"队列的基本操作",normalizedTitle:"队列的基本操作",charIndex:1433},{level:2,title:"队列的应用",slug:"队列的应用",normalizedTitle:"队列的应用",charIndex:1984},{level:2,title:"复杂度分析（数组实现）",slug:"复杂度分析-数组实现",normalizedTitle:"复杂度分析（数组实现）",charIndex:2484},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:401},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3092}],headersStr:"什么是队列？ 队列的 FIFO 原则 队列的特点 队列的表示方法 队列的类型 队列的基本操作 队列的应用 复杂度分析（数组实现） 实现 JavaScript",content:"# 什么是队列？\n\n队列被定义为一个两端开放的线性数据结构，操作以先进先出（FIFO）顺序进行。\n\n我们把队列定义为一个列表，在这个列表中，所有对列表的添加都在一端进行，所有对列表的删除都在另一端进行。首先被推入顺序的元素，首先对其进行操作。\n\n\n\n\n# 队列的 FIFO 原则\n\n * 队列就像等待购票的队伍，排在第一位的人就是第一个被服务的人。(即先到先得）。\n * 队列中准备服务的条目的位置，即第一个将从队列中移除的条目，被称为队列的前部（front）（有时是队列的头部（head）），同样，队列中最后一个条目的位置，即最近增加的一个条目，被称为队列的后部（rear）（或尾部（tail））。\n\n\n\n\n# 队列的特点\n\n * 队列可以处理多个数据。\n * 队列可以访问两端。\n * 队列是快速和灵活的。\n\n\n# 队列的表示方法\n\n像堆栈一样，队列也可以用数组来表示。在这种表示法中，队列是用数组实现的。在这种情况下使用的变量有：\n\n * Queue：存储队列元素的数组名称。\n * Front：在代表队列的数组中存储第一个元素的索引。\n * Rear：在代表队列的数组中存储最后一个元素的索引。\n\n数组实现的优点：\n\n * 易于实现。\n * 可以轻松有效地管理大量的数据。\n * 由于它遵循先入先出的规则，所以可以轻松地进行插入和删除等操作。\n\n数组实现的缺点：\n\n * 静态数据结构，固定大小。\n * 如果队列有大量的 enqueue 和 dequeue 操作，在某些时候（在前后索引线性递增的情况下）我们可能无法在队列中插入元素，即使队列是空的（这个问题可以通过使用循环队列来避免）。\n\n链表表示法：一个队列也可以用链接列表、指针和结构来表示。\n\n\n# 队列的类型\n\n有不同类型的队列。\n\n * 简单队列。简单队列也被称为线性队列，是队列的最基本版本。在这里，插入一个元素，即 Enqueue 操作发生在后端，删除一个元素，即 Dequeue 操作发生在前端。\n * 输入受限队列（Input Restricted Queue）：这是一个简单的队列。在这种类型的队列中，输入只能从一端进行，但删除可以从任何一端进行。\n * 输出受限队列（Output Restricted Queue）：这也是一个简单的队列。在这种类型的队列中，输入可以从两端进行，但删除只能从一端进行。\n * 环形队列（Circular Queue）：这是一种特殊类型的队列，最后一个位置被连接到第一个位置。这里的操作也是按先进先出的顺序进行的。在环形队列中，队列中的元素就像一个圆形的环。除了最后一个元素与第一个元素相连外，环形队列的工作与线性队列相似。它的优点是可以更好地利用内存。这是因为如果有一个空的空间，即如果在队列的某个位置没有元素，那么可以很容易地在该位置添加一个元素。\n * 双端队列 (Double-Ended Queue，Dequeue)：在双端队列中，插入和删除操作，都可以从两端进行。因为这个属性，它可能不服从先进先出的原则。\n * 优先级队列（Priority Queue）：优先级队列是一个特殊的队列，其中元素的访问是基于分配给它们的优先级。它的特点是，它根据一些优先级安排队列中的元素。优先级可以是具有最高值的元素具有优先权，所以它创建了一个数值递减的队列。优先级也可以是具有最低值的元素获得最高的优先级，所以它反过来创建了一个数值递增的队列。\n\n\n# 队列的基本操作\n\n * front ()：该操作返回前端的元素，而不删除它。\n\n * rear ()：该操作返回后端的元素，但不删除它。\n\n * isEmpty ()：该操作返回一个布尔值，表明队列是否为空。\n\n * isFull ()：该操作返回一个布尔值，表明队列是否已满。\n\n * size ()：该操作返回队列的大小，即它包含的元素总数。\n\n * Enqueue ()：将一个元素添加（或存储）到队列的末端。应采取以下步骤将数据 enqueue（插入）到一个队列中：\n   \n   * 检查队列是否已满。\n   * 如果队列已满，返回溢出（overflow）错误并退出。\n   * 如果队列未满，递增后方指针以指向下一个空位。\n   * 将数据元素添加到队列中的位置，即 rear 所指向的位置。\n   * 返回成功。\n\n * Dequeue ()：移除（或访问）队列中的第一个元素。执行 Dequeue 操作需要采取以下步骤：\n   \n   * 检查队列是否为空。\n   * 如果队列是空的，返回下溢（underflow）错误并退出。\n   * 如果队列不是空的，访问 front 指向的数据。\n   * 递增 front 指针，使其指向下一个可用的数据元素。\n   * 返回成功。\n\n\n# 队列的应用\n\n队列的应用很普遍。在计算机系统中，可能有等待打印机、访问磁盘存储的任务队列，甚至在一个分时系统中，也可能有使用 CPU 的任务队列。在一个程序中，可能有多个请求被保留在队列中，或者一个任务可能创建其他任务，这些任务必须通过保留在队列中来依次完成。当事情不必立即处理，但必须按照先入先出的顺序进行处理时，就会用到队列，如广度优先搜索。队列的这一特性使它在以下情况下也很有用：\n\n * 它有一个单一的资源和多个消费者。\n * 它在慢速和快速设备之间进行同步。\n * 在网络中，队列用于诸如路由器 / 交换机和邮件队列等设备中。\n * 变种：dequeue、优先队列和双端优先队列等。\n\n以及更多的应用场景：\n\n * 队列被广泛用作单一共享资源的等待列表，如打印机、磁盘、CPU。\n * 队列用于数据的异步传输（数据在两个进程之间不以相同的速度传输），例如管道、文件 IO、套接字。\n * 在大多数应用程序中，队列被用作缓冲器，如 MP3 媒体播放器、CD 播放器等。\n * 队列用于维护媒体播放器中的播放列表，以便从播放列表中添加和删除歌曲。\n * 队列在操作系统中用于处理中断。\n\n\n# 复杂度分析（数组实现）\n\n时间复杂度：\n\n操作                 复杂度\nEnqueue (插入)       O(1)\nDequeue (删除)       O(1)\nFront (获取 front)   O(1)\nRear (获取 Rear)     O(1)\n\n辅助空间：O (N)，其中 N 是用于存储元素的数组的大小。\n\nDATA STRUCTURE   TIME COMPLEXITY                                                                   SPACE COMPLEITY\n                 Average                                  Worst                                    Worst\n                 Access   Search   Insertion   Deletion   Access   Search   Insertion   Deletion   \nQueue            θ(n)     θ(n)     θ(1)        θ(1)       O(n)     O(n)     O(1)        O(1)       O(n)\n\n\n# 实现\n\n\n# JavaScript\n\nclass Queue {\n  /**\n   * Creates a queue.\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._elements = Array.isArray(elements) ? elements : [];\n    this._offset = 0;\n  }\n\n  /**\n   * Adds an element at the back of the queue.\n   * @public\n   * @param {any} element\n   */\n  enqueue(element) {\n    this._elements.push(element);\n    return this;\n  }\n\n  /**\n   * Dequeues the front element in the queue.\n   * @public\n   * @returns {any}\n   */\n  dequeue() {\n    if (this.size() === 0) return null;\n\n    const first = this.front();\n    this._offset += 1;\n\n    if (this._offset * 2 < this._elements.length) return first;\n\n    // only remove dequeued elements when reaching half size\n    // to decrease latency of shifting elements.\n    this._elements = this._elements.slice(this._offset);\n    this._offset = 0;\n    return first;\n  }\n\n  /**\n   * Returns the front element of the queue.\n   * @public\n   * @returns {any}\n   */\n  front() {\n    return this.size() > 0 ? this._elements[this._offset] : null;\n  }\n\n  /**\n   * Returns the back element of the queue.\n   * @public\n   * @returns {any}\n   */\n  back() {\n    return this.size() > 0 ? this._elements[this._elements.length - 1] : null;\n  }\n\n  /**\n   * Returns the number of elements in the queue.\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._elements.length - this._offset;\n  }\n\n  /**\n   * Checks if the queue is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Returns the remaining elements in the queue as an array.\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._elements.slice(this._offset);\n  }\n\n  /**\n   * Clears the queue.\n   * @public\n   */\n  clear() {\n    this._elements = [];\n    this._offset = 0;\n  }\n\n  /**\n   * Creates a shallow copy of the queue.\n   * @public\n   * @return {Queue}\n   */\n  clone() {\n    return new Queue(this._elements.slice(this._offset));\n  }\n\n  /**\n   * Creates a queue from an existing array.\n   * @public\n   * @static\n   * @param {array} elements\n   * @return {Queue}\n   */\n  static fromArray(elements) {\n    return new Queue(elements);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n\n\n使用 push 和 shift：\n\n/* Queue\n* A Queue is a data structure that allows you to add an element to the end of\n* a list and remove the item at the front. A queue follows a \"First In First Out\"\n* system, where the first item to enter the queue is the first to be removed. This\n* implementation uses an array to store the queue.\n*/\n\n// Functions: enqueue, dequeue, peek, view, length, empty\nclass Queue {\n  // constructor\n  constructor () {\n    // This is the array representation of the queue\n    this.queue = []\n  }\n\n  // methods\n  // Add a value to the end of the queue\n  enqueue (item) {\n    this.queue.push(item)\n  }\n\n  // Removes the value at the front of the queue\n  dequeue () {\n    if (this.empty()) {\n      throw new Error('Queue is Empty')\n    }\n\n    return this.queue.shift() // remove the item at position 0 from the array and return it\n  }\n\n  // Return the length of the queue\n  length () {\n    return this.queue.length\n  }\n\n  // Return the item at the front of the queue\n  peek () {\n    if (this.empty()) {\n      throw new Error('Queue is Empty')\n    }\n\n    return this.queue[0]\n  }\n\n  // List all the items in the queue\n  view (output = value => console.log(value)) {\n    output(this.queue)\n  }\n\n  // Return Is queue empty ?\n  empty () {\n    return this.queue.length === 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n利用两个栈实现队列：\n\n// implementation of Queue using 2 stacks\n// contribution made by hamza chabchoub for a university project\n\nclass Queue {\n  constructor () {\n    this.inputStack = []\n    this.outputStack = []\n  }\n\n  // Push item into the inputstack\n  enqueue (item) {\n    this.inputStack.push(item)\n  }\n\n  dequeue () {\n    // push all items to outputstack\n    this.outputStack = []\n    while (this.inputStack.length > 0) {\n      this.outputStack.push(this.inputStack.pop())\n    }\n    // return the top element of the outputstack if any\n    if (this.outputStack.length > 0) {\n      const top = this.outputStack.pop()\n      // repush all the items to the inputstack\n      this.inputStack = []\n      while (this.outputStack.length > 0) {\n        this.inputStack.push(this.outputStack.pop())\n      }\n      return top\n    }\n  }\n\n  // display elements of the inputstack\n  listIn (output = value => console.log(value)) {\n    let i = 0\n    while (i < this.inputStack.length) {\n      output(this.inputStack[i])\n      i++\n    }\n  }\n\n  // display element of the outputstack\n  listOut (output = value => console.log(value)) {\n    let i = 0\n    while (i < this.outputStack.length) {\n      output(this.outputStack[i])\n      i++\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n参考：\n\n * Queue using Stacks - GeeksforGeeks",normalizedContent:"# 什么是队列？\n\n队列被定义为一个两端开放的线性数据结构，操作以先进先出（fifo）顺序进行。\n\n我们把队列定义为一个列表，在这个列表中，所有对列表的添加都在一端进行，所有对列表的删除都在另一端进行。首先被推入顺序的元素，首先对其进行操作。\n\n\n\n\n# 队列的 fifo 原则\n\n * 队列就像等待购票的队伍，排在第一位的人就是第一个被服务的人。(即先到先得）。\n * 队列中准备服务的条目的位置，即第一个将从队列中移除的条目，被称为队列的前部（front）（有时是队列的头部（head）），同样，队列中最后一个条目的位置，即最近增加的一个条目，被称为队列的后部（rear）（或尾部（tail））。\n\n\n\n\n# 队列的特点\n\n * 队列可以处理多个数据。\n * 队列可以访问两端。\n * 队列是快速和灵活的。\n\n\n# 队列的表示方法\n\n像堆栈一样，队列也可以用数组来表示。在这种表示法中，队列是用数组实现的。在这种情况下使用的变量有：\n\n * queue：存储队列元素的数组名称。\n * front：在代表队列的数组中存储第一个元素的索引。\n * rear：在代表队列的数组中存储最后一个元素的索引。\n\n数组实现的优点：\n\n * 易于实现。\n * 可以轻松有效地管理大量的数据。\n * 由于它遵循先入先出的规则，所以可以轻松地进行插入和删除等操作。\n\n数组实现的缺点：\n\n * 静态数据结构，固定大小。\n * 如果队列有大量的 enqueue 和 dequeue 操作，在某些时候（在前后索引线性递增的情况下）我们可能无法在队列中插入元素，即使队列是空的（这个问题可以通过使用循环队列来避免）。\n\n链表表示法：一个队列也可以用链接列表、指针和结构来表示。\n\n\n# 队列的类型\n\n有不同类型的队列。\n\n * 简单队列。简单队列也被称为线性队列，是队列的最基本版本。在这里，插入一个元素，即 enqueue 操作发生在后端，删除一个元素，即 dequeue 操作发生在前端。\n * 输入受限队列（input restricted queue）：这是一个简单的队列。在这种类型的队列中，输入只能从一端进行，但删除可以从任何一端进行。\n * 输出受限队列（output restricted queue）：这也是一个简单的队列。在这种类型的队列中，输入可以从两端进行，但删除只能从一端进行。\n * 环形队列（circular queue）：这是一种特殊类型的队列，最后一个位置被连接到第一个位置。这里的操作也是按先进先出的顺序进行的。在环形队列中，队列中的元素就像一个圆形的环。除了最后一个元素与第一个元素相连外，环形队列的工作与线性队列相似。它的优点是可以更好地利用内存。这是因为如果有一个空的空间，即如果在队列的某个位置没有元素，那么可以很容易地在该位置添加一个元素。\n * 双端队列 (double-ended queue，dequeue)：在双端队列中，插入和删除操作，都可以从两端进行。因为这个属性，它可能不服从先进先出的原则。\n * 优先级队列（priority queue）：优先级队列是一个特殊的队列，其中元素的访问是基于分配给它们的优先级。它的特点是，它根据一些优先级安排队列中的元素。优先级可以是具有最高值的元素具有优先权，所以它创建了一个数值递减的队列。优先级也可以是具有最低值的元素获得最高的优先级，所以它反过来创建了一个数值递增的队列。\n\n\n# 队列的基本操作\n\n * front ()：该操作返回前端的元素，而不删除它。\n\n * rear ()：该操作返回后端的元素，但不删除它。\n\n * isempty ()：该操作返回一个布尔值，表明队列是否为空。\n\n * isfull ()：该操作返回一个布尔值，表明队列是否已满。\n\n * size ()：该操作返回队列的大小，即它包含的元素总数。\n\n * enqueue ()：将一个元素添加（或存储）到队列的末端。应采取以下步骤将数据 enqueue（插入）到一个队列中：\n   \n   * 检查队列是否已满。\n   * 如果队列已满，返回溢出（overflow）错误并退出。\n   * 如果队列未满，递增后方指针以指向下一个空位。\n   * 将数据元素添加到队列中的位置，即 rear 所指向的位置。\n   * 返回成功。\n\n * dequeue ()：移除（或访问）队列中的第一个元素。执行 dequeue 操作需要采取以下步骤：\n   \n   * 检查队列是否为空。\n   * 如果队列是空的，返回下溢（underflow）错误并退出。\n   * 如果队列不是空的，访问 front 指向的数据。\n   * 递增 front 指针，使其指向下一个可用的数据元素。\n   * 返回成功。\n\n\n# 队列的应用\n\n队列的应用很普遍。在计算机系统中，可能有等待打印机、访问磁盘存储的任务队列，甚至在一个分时系统中，也可能有使用 cpu 的任务队列。在一个程序中，可能有多个请求被保留在队列中，或者一个任务可能创建其他任务，这些任务必须通过保留在队列中来依次完成。当事情不必立即处理，但必须按照先入先出的顺序进行处理时，就会用到队列，如广度优先搜索。队列的这一特性使它在以下情况下也很有用：\n\n * 它有一个单一的资源和多个消费者。\n * 它在慢速和快速设备之间进行同步。\n * 在网络中，队列用于诸如路由器 / 交换机和邮件队列等设备中。\n * 变种：dequeue、优先队列和双端优先队列等。\n\n以及更多的应用场景：\n\n * 队列被广泛用作单一共享资源的等待列表，如打印机、磁盘、cpu。\n * 队列用于数据的异步传输（数据在两个进程之间不以相同的速度传输），例如管道、文件 io、套接字。\n * 在大多数应用程序中，队列被用作缓冲器，如 mp3 媒体播放器、cd 播放器等。\n * 队列用于维护媒体播放器中的播放列表，以便从播放列表中添加和删除歌曲。\n * 队列在操作系统中用于处理中断。\n\n\n# 复杂度分析（数组实现）\n\n时间复杂度：\n\n操作                 复杂度\nenqueue (插入)       o(1)\ndequeue (删除)       o(1)\nfront (获取 front)   o(1)\nrear (获取 rear)     o(1)\n\n辅助空间：o (n)，其中 n 是用于存储元素的数组的大小。\n\ndata structure   time complexity                                                                   space compleity\n                 average                                  worst                                    worst\n                 access   search   insertion   deletion   access   search   insertion   deletion   \nqueue            θ(n)     θ(n)     θ(1)        θ(1)       o(n)     o(n)     o(1)        o(1)       o(n)\n\n\n# 实现\n\n\n# javascript\n\nclass queue {\n  /**\n   * creates a queue.\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._elements = array.isarray(elements) ? elements : [];\n    this._offset = 0;\n  }\n\n  /**\n   * adds an element at the back of the queue.\n   * @public\n   * @param {any} element\n   */\n  enqueue(element) {\n    this._elements.push(element);\n    return this;\n  }\n\n  /**\n   * dequeues the front element in the queue.\n   * @public\n   * @returns {any}\n   */\n  dequeue() {\n    if (this.size() === 0) return null;\n\n    const first = this.front();\n    this._offset += 1;\n\n    if (this._offset * 2 < this._elements.length) return first;\n\n    // only remove dequeued elements when reaching half size\n    // to decrease latency of shifting elements.\n    this._elements = this._elements.slice(this._offset);\n    this._offset = 0;\n    return first;\n  }\n\n  /**\n   * returns the front element of the queue.\n   * @public\n   * @returns {any}\n   */\n  front() {\n    return this.size() > 0 ? this._elements[this._offset] : null;\n  }\n\n  /**\n   * returns the back element of the queue.\n   * @public\n   * @returns {any}\n   */\n  back() {\n    return this.size() > 0 ? this._elements[this._elements.length - 1] : null;\n  }\n\n  /**\n   * returns the number of elements in the queue.\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._elements.length - this._offset;\n  }\n\n  /**\n   * checks if the queue is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * returns the remaining elements in the queue as an array.\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    return this._elements.slice(this._offset);\n  }\n\n  /**\n   * clears the queue.\n   * @public\n   */\n  clear() {\n    this._elements = [];\n    this._offset = 0;\n  }\n\n  /**\n   * creates a shallow copy of the queue.\n   * @public\n   * @return {queue}\n   */\n  clone() {\n    return new queue(this._elements.slice(this._offset));\n  }\n\n  /**\n   * creates a queue from an existing array.\n   * @public\n   * @static\n   * @param {array} elements\n   * @return {queue}\n   */\n  static fromarray(elements) {\n    return new queue(elements);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n\n\n使用 push 和 shift：\n\n/* queue\n* a queue is a data structure that allows you to add an element to the end of\n* a list and remove the item at the front. a queue follows a \"first in first out\"\n* system, where the first item to enter the queue is the first to be removed. this\n* implementation uses an array to store the queue.\n*/\n\n// functions: enqueue, dequeue, peek, view, length, empty\nclass queue {\n  // constructor\n  constructor () {\n    // this is the array representation of the queue\n    this.queue = []\n  }\n\n  // methods\n  // add a value to the end of the queue\n  enqueue (item) {\n    this.queue.push(item)\n  }\n\n  // removes the value at the front of the queue\n  dequeue () {\n    if (this.empty()) {\n      throw new error('queue is empty')\n    }\n\n    return this.queue.shift() // remove the item at position 0 from the array and return it\n  }\n\n  // return the length of the queue\n  length () {\n    return this.queue.length\n  }\n\n  // return the item at the front of the queue\n  peek () {\n    if (this.empty()) {\n      throw new error('queue is empty')\n    }\n\n    return this.queue[0]\n  }\n\n  // list all the items in the queue\n  view (output = value => console.log(value)) {\n    output(this.queue)\n  }\n\n  // return is queue empty ?\n  empty () {\n    return this.queue.length === 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n利用两个栈实现队列：\n\n// implementation of queue using 2 stacks\n// contribution made by hamza chabchoub for a university project\n\nclass queue {\n  constructor () {\n    this.inputstack = []\n    this.outputstack = []\n  }\n\n  // push item into the inputstack\n  enqueue (item) {\n    this.inputstack.push(item)\n  }\n\n  dequeue () {\n    // push all items to outputstack\n    this.outputstack = []\n    while (this.inputstack.length > 0) {\n      this.outputstack.push(this.inputstack.pop())\n    }\n    // return the top element of the outputstack if any\n    if (this.outputstack.length > 0) {\n      const top = this.outputstack.pop()\n      // repush all the items to the inputstack\n      this.inputstack = []\n      while (this.outputstack.length > 0) {\n        this.inputstack.push(this.outputstack.pop())\n      }\n      return top\n    }\n  }\n\n  // display elements of the inputstack\n  listin (output = value => console.log(value)) {\n    let i = 0\n    while (i < this.inputstack.length) {\n      output(this.inputstack[i])\n      i++\n    }\n  }\n\n  // display element of the outputstack\n  listout (output = value => console.log(value)) {\n    let i = 0\n    while (i < this.outputstack.length) {\n      output(this.outputstack[i])\n      i++\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n参考：\n\n * queue using stacks - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"Plan 计划",frontmatter:{title:"Plan 计划",date:"2022-04-16T16:44:07.000Z",permalink:"/ds/plan/",categories:["数据结构"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.plan.html",relativePath:"10.数据结构/1.plan.md",key:"v-05f4bc51",path:"/ds/plan/",headers:[{level:2,title:"TODO",slug:"todo",normalizedTitle:"todo",charIndex:2},{level:3,title:"添加几个数据结构",slug:"添加几个数据结构",normalizedTitle:"添加几个数据结构",charIndex:11}],headersStr:"TODO 添加几个数据结构",content:"# TODO\n\n\n# 添加几个数据结构\n\nToday is Friday, October 28, 2022\n\n * 动态数组\n * 阻塞队列\n * 并发队列\n * 双向循环链表\n * 散列表\n * 红黑树\n * 完全二叉树\n * B 树\n * B + 树\n * 2-3 树\n * 2-3-4 树\n * 斐波那契堆",normalizedContent:"# todo\n\n\n# 添加几个数据结构\n\ntoday is friday, october 28, 2022\n\n * 动态数组\n * 阻塞队列\n * 并发队列\n * 双向循环链表\n * 散列表\n * 红黑树\n * 完全二叉树\n * b 树\n * b + 树\n * 2-3 树\n * 2-3-4 树\n * 斐波那契堆",charsets:{cjk:!0},lastUpdated:"2022/11/01, 18:11:55",lastUpdatedTimestamp:1667297515e3},{title:"PriorityQueue [优先队列]",frontmatter:{title:"PriorityQueue [优先队列]",date:"2022-04-26T21:51:55.000Z",permalink:"/ds/queue/priorityQueue/",categories:["数据结构","queue队列"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.queue%20%E9%98%9F%E5%88%97/20.priorityQueue.html",relativePath:"10.数据结构/10.queue 队列/20.priorityQueue.md",key:"v-6d3cde30",path:"/ds/queue/priorityQueue/",headers:[{level:2,title:"什么是优先级队列？",slug:"什么是优先级队列",normalizedTitle:"什么是优先级队列？",charIndex:2},{level:2,title:"优先级队列的特点",slug:"优先级队列的特点",normalizedTitle:"优先级队列的特点",charIndex:245},{level:2,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:466},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:946},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1500}],headersStr:"什么是优先级队列？ 优先级队列的特点 操作 实现 JavaScript",content:"# 什么是优先级队列？\n\n优先级队列是一种抽象的数据类型，其行为类似于普通队列，只是每个元素都有一定的优先级，也就是说，在优先级队列中，具有最高优先级的元素会排在第一位。优先级队列中的元素的优先级将决定元素从优先级队列中被移除的顺序。\n\n优先级队列只支持可比较的元素，这意味着元素是按升序或降序排列的。\n\n例如，假设我们有一些像 1、3、4、8、14、22 这样的数值被插入优先级队列中，对这些数值的排序是从最小到最大。因此，1 号将有最高的优先权，而 22 号将有最低的优先权。\n\n\n# 优先级队列的特点\n\n优先级队列是队列的扩展，包含以下特点：\n\n * 优先级队列中的每个元素都有一些与之相关的优先级。\n * 一个具有较高优先级的元素将在删除较低优先级的元素之前被删除。\n * 如果一个优先级队列中的两个元素具有相同的优先级，它们将使用先进先出的原则进行排列。\n\n让我们通过一个例子来理解优先级队列：我们有一个优先级队列，其中包含以下数值：1, 3, 4, 8, 14, 22，所有的值都按升序排列。现在，我们将观察一下执行以下操作后的优先级队列的情况。\n\n * poll ()。这个函数将从优先级队列中移除最高优先级的元素。在上面的优先级队列中，'1' 元素的优先级最高，所以它将被从优先级队列中删除。\n * add (2)。这个函数将在优先级队列中插入 '2' 元素。由于 2 是所有数字中最小的元素，所以它将获得最高的优先级。\n * poll ()。它将从优先级队列中删除 '2' 元素，因为它拥有最高的优先级队列。\n * add (5)。它将在 4 后面插入 5 元素，因为 5 比 4 大，比 8 小，所以它将获得优先级队列中的第三高优先级。\n\n\n# 操作\n\n优先队列至少需要支持下述操作：\n\n * 插入带优先级的元素（insert_with_priority）\n * 取出具有最高优先级的元素（pull_highest_priority_element）\n * 查看最高优先级的元素（peek）：O (1) 时间复杂度\n\n其它可选的操作：\n\n * 检查优先级高的一批元素\n * 清空优先队列\n * 批量插入一批元素\n * 合并多个优先队列\n * 调整一个元素的优先级\n\n\n# 实现\n\n初级实现：\n\n有许多简单低效的实现。如用一个有序的数组；或使用无序数组，在每次取出时搜索全集合，这种方法插入的效率为O(1)O(1)O(1)，但取出时效率为 O(n) O(n) O(n)。\n\n典型实现：\n\n出于性能考虑，优先队列用堆来实现，具有O(logn)O(log n)O(logn) 时间复杂度的插入元素性能，O(n)O(n)O(n) 的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(logn)O(log n)O(logn)，构造二叉树的时间复杂度为O(nlogn)O(n log n)O(nlogn)。\n\n从计算复杂度的角度，优先级队列等价于排序算法。\n\n有一些特殊的堆为优先队列的实现提供了额外的性能：二叉堆的插入与提取操作的时间复杂度为O(logn)O(log n)O(logn)，并可以常量时间复杂度的 peek 操作。二项堆提供了几种额外操作。斐波那契堆的插入、提取、修改元素优先级等操作具有分摊常量时间复杂度，但删除操作的时间复杂度为O(logn)O(log n)O(logn)。Brodal queue 具有最糟糕情况下的常量复杂度但算法相当复杂因而不具有实用性。\n\n对于整型、浮点型等具有有限值域的元素的数据类型，优先队列有更快的实现。\n\n\n# JavaScript\n\nconst { Heap } = require('@datastructures-js/heap');\n\nclass PriorityQueue {\n  /**\n   * Creates a priority queue\n   * @params {function} compare\n   */\n  constructor(compare, _values) {\n    if (typeof compare !== 'function') {\n      throw new Error('PriorityQueue constructor expects a compare function');\n    }\n    this._heap = new Heap(compare, _values);\n    if (_values) {\n      this._heap.fix();\n    }\n  }\n\n  /**\n   * Returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  front() {\n    return this._heap.root();\n  }\n\n  /**\n   * Returns an element with lowest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  back() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * Adds a value to the queue\n   * @public\n   * @param {number|string|object} value\n   * @returns {PriorityQueue}\n   */\n  enqueue(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * Removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  dequeue() {\n    return this._heap.extractRoot();\n  }\n\n  /**\n   * Returns the number of elements in the queue\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * Checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * Returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._heap.clone().sort().reverse();\n  }\n\n  /**\n   * Creates a priority queue from an existing array\n   * @public\n   * @static\n   * @returns {PriorityQueue}\n   */\n  static fromArray(values, compare) {\n    return new PriorityQueue(compare, values);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n参考：\n\n * Priority queue - Wikipedia\n * 优先队列 - 维基百科，自由的百科全书",normalizedContent:"# 什么是优先级队列？\n\n优先级队列是一种抽象的数据类型，其行为类似于普通队列，只是每个元素都有一定的优先级，也就是说，在优先级队列中，具有最高优先级的元素会排在第一位。优先级队列中的元素的优先级将决定元素从优先级队列中被移除的顺序。\n\n优先级队列只支持可比较的元素，这意味着元素是按升序或降序排列的。\n\n例如，假设我们有一些像 1、3、4、8、14、22 这样的数值被插入优先级队列中，对这些数值的排序是从最小到最大。因此，1 号将有最高的优先权，而 22 号将有最低的优先权。\n\n\n# 优先级队列的特点\n\n优先级队列是队列的扩展，包含以下特点：\n\n * 优先级队列中的每个元素都有一些与之相关的优先级。\n * 一个具有较高优先级的元素将在删除较低优先级的元素之前被删除。\n * 如果一个优先级队列中的两个元素具有相同的优先级，它们将使用先进先出的原则进行排列。\n\n让我们通过一个例子来理解优先级队列：我们有一个优先级队列，其中包含以下数值：1, 3, 4, 8, 14, 22，所有的值都按升序排列。现在，我们将观察一下执行以下操作后的优先级队列的情况。\n\n * poll ()。这个函数将从优先级队列中移除最高优先级的元素。在上面的优先级队列中，'1' 元素的优先级最高，所以它将被从优先级队列中删除。\n * add (2)。这个函数将在优先级队列中插入 '2' 元素。由于 2 是所有数字中最小的元素，所以它将获得最高的优先级。\n * poll ()。它将从优先级队列中删除 '2' 元素，因为它拥有最高的优先级队列。\n * add (5)。它将在 4 后面插入 5 元素，因为 5 比 4 大，比 8 小，所以它将获得优先级队列中的第三高优先级。\n\n\n# 操作\n\n优先队列至少需要支持下述操作：\n\n * 插入带优先级的元素（insert_with_priority）\n * 取出具有最高优先级的元素（pull_highest_priority_element）\n * 查看最高优先级的元素（peek）：o (1) 时间复杂度\n\n其它可选的操作：\n\n * 检查优先级高的一批元素\n * 清空优先队列\n * 批量插入一批元素\n * 合并多个优先队列\n * 调整一个元素的优先级\n\n\n# 实现\n\n初级实现：\n\n有许多简单低效的实现。如用一个有序的数组；或使用无序数组，在每次取出时搜索全集合，这种方法插入的效率为o(1)o(1)o(1)，但取出时效率为 o(n) o(n) o(n)。\n\n典型实现：\n\n出于性能考虑，优先队列用堆来实现，具有o(logn)o(log n)o(logn) 时间复杂度的插入元素性能，o(n)o(n)o(n) 的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为o(logn)o(log n)o(logn)，构造二叉树的时间复杂度为o(nlogn)o(n log n)o(nlogn)。\n\n从计算复杂度的角度，优先级队列等价于排序算法。\n\n有一些特殊的堆为优先队列的实现提供了额外的性能：二叉堆的插入与提取操作的时间复杂度为o(logn)o(log n)o(logn)，并可以常量时间复杂度的 peek 操作。二项堆提供了几种额外操作。斐波那契堆的插入、提取、修改元素优先级等操作具有分摊常量时间复杂度，但删除操作的时间复杂度为o(logn)o(log n)o(logn)。brodal queue 具有最糟糕情况下的常量复杂度但算法相当复杂因而不具有实用性。\n\n对于整型、浮点型等具有有限值域的元素的数据类型，优先队列有更快的实现。\n\n\n# javascript\n\nconst { heap } = require('@datastructures-js/heap');\n\nclass priorityqueue {\n  /**\n   * creates a priority queue\n   * @params {function} compare\n   */\n  constructor(compare, _values) {\n    if (typeof compare !== 'function') {\n      throw new error('priorityqueue constructor expects a compare function');\n    }\n    this._heap = new heap(compare, _values);\n    if (_values) {\n      this._heap.fix();\n    }\n  }\n\n  /**\n   * returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  front() {\n    return this._heap.root();\n  }\n\n  /**\n   * returns an element with lowest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  back() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * adds a value to the queue\n   * @public\n   * @param {number|string|object} value\n   * @returns {priorityqueue}\n   */\n  enqueue(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  dequeue() {\n    return this._heap.extractroot();\n  }\n\n  /**\n   * returns the number of elements in the queue\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._heap.isempty();\n  }\n\n  /**\n   * clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    return this._heap.clone().sort().reverse();\n  }\n\n  /**\n   * creates a priority queue from an existing array\n   * @public\n   * @static\n   * @returns {priorityqueue}\n   */\n  static fromarray(values, compare) {\n    return new priorityqueue(compare, values);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n参考：\n\n * priority queue - wikipedia\n * 优先队列 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"MinPriorityQueue [最小优先队列]",frontmatter:{title:"MinPriorityQueue [最小优先队列]",date:"2022-04-26T21:54:04.000Z",permalink:"/ds/queue/minPriorityQueue/",categories:["数据结构","queue队列"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.queue%20%E9%98%9F%E5%88%97/30.minPriorityQueue.html",relativePath:"10.数据结构/10.queue 队列/30.minPriorityQueue.md",key:"v-b8d450b8",path:"/ds/queue/minPriorityQueue/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:60},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:654}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n最小优先级队列是一种数据结构，它管理一个键（值）的列表。并且给具有最小值的元素以优先权。可以用 Heap 来实现它。\n\n最小优先队列实际就是一个小顶堆，即每次插入堆中的元素，都存储至堆末端，通过上浮操作比较，小于父节点则和父节点交换元素，直到根结点为止，这样就形成了一个小顶堆。在获取最小值时，由于堆是数组的结构，只需获取根结点的值，即数组下标为 1 的值即可。获取最小值并删除，则可以交换根结点和尾结点，之后删除尾结点，并对根结点进行下沉操作，保证每个父节点都小于两个左右子树即可。\n\n\n\n它支持以下操作：\n\n * getMin () - 给出最小优先级的元素，但不要删除它。\n * extractMin () - 给出最小优先级的元素，并删除它。\n * insert (element) - 在优先级队列中插入一个元素。\n * decrement (index, newValue) - 从优先级队列中减少一个元素。\n\n为什么不使用其他数据结构（除了 Heap）？\n\n * 链表：每次有新的元素出现将最小的元素放在顶部，或者一个元素的优先级改变时，运行时间复杂度为 O (n^2)。\n * 二叉搜索树（Binary Search Tree）的插入很容易，获得最小值是一个简单的操作。它消耗了额外的空间来保存每个节点的指针。在插入和改变优先级的情况下，树需要再次被重新平衡，这比维护堆数据结构中的最小堆更复杂。堆使用数组，所以访问一个元素，缓存一个元素，总是更快的操作。\n\n\n# 实现\n\n\n# JavaScript\n\nconst { Heap, MinHeap } = require('@datastructures-js/heap');\n\nconst getMinCompare = (getCompareValue) => (a, b) => {\n  const aVal = typeof getCompareValue === 'function' ? getCompareValue(a) : a;\n  const bVal = typeof getCompareValue === 'function' ? getCompareValue(b) : b;\n  return aVal < bVal ? -1 : 1;\n};\n\n/**\n * @class MinPriorityQueue\n */\nclass MinPriorityQueue {\n  constructor(getCompareValue, _heap) {\n    if (getCompareValue && typeof getCompareValue !== 'function') {\n      throw new Error('MinPriorityQueue constructor requires a callback for object values');\n    }\n    this._heap = _heap || new MinHeap(getCompareValue);\n  }\n\n  /**\n   * Returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  front() {\n    return this._heap.root();\n  }\n\n  /**\n   * Returns an element with lowest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  back() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * Adds a value to the queue\n   * @public\n   * @param {number|string|object} value\n   * @returns {MinPriorityQueue}\n   */\n  enqueue(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * Removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  dequeue() {\n    return this._heap.extractRoot();\n  }\n\n  /**\n   * Returns the number of elements in the queue\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * Checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * Returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._heap.clone().sort().reverse();\n  }\n\n  /**\n   * Creates a priority queue from an existing array\n   * @public\n   * @static\n   * @returns {MinPriorityQueue}\n   */\n  static fromArray(values, getCompareValue) {\n    const heap = new Heap(getMinCompare(getCompareValue), values);\n    return new MinPriorityQueue(\n      getCompareValue,\n      new MinHeap(getCompareValue, heap).fix()\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n\n或者：\n\n/* Minimum Priority Queue\n* It is a part of heap data structure\n* A heap is a specific tree based data structure\n* in which all the nodes of tree are in a specific order.\n* that is the children are arranged in some\n* respect of their parents, can either be greater\n* or less than the parent. This makes it a min priority queue\n* or max priority queue.\n*/\n\n// Functions: insert, delete, peek, isEmpty, print, heapSort, sink\n\nclass MinPriorityQueue {\n  // calls the constructor and initializes the capacity\n  constructor (c) {\n    this.heap = []\n    this.capacity = c\n    this.size = 0\n  }\n\n  // inserts the key at the end and rearranges it\n  // so that the binary heap is in appropriate order\n  insert (key) {\n    if (this.isFull()) return\n    this.heap[this.size + 1] = key\n    let k = this.size + 1\n    while (k > 1) {\n      if (this.heap[k] < this.heap[Math.floor(k / 2)]) {\n        const temp = this.heap[k]\n        this.heap[k] = this.heap[Math.floor(k / 2)]\n        this.heap[Math.floor(k / 2)] = temp\n      }\n      k = Math.floor(k / 2)\n    }\n    this.size++\n  }\n\n  // returns the highest priority value\n  peek () {\n    return this.heap[1]\n  }\n\n  // returns boolean value whether the heap is empty or not\n  isEmpty () {\n    return this.size === 0\n  }\n\n  // returns boolean value whether the heap is full or not\n  isFull () {\n    if (this.size === this.capacity) return true\n    return false\n  }\n\n  // prints the heap\n  print (output = value => console.log(value)) {\n    output(this.heap.slice(1))\n  }\n\n  // heap reverse can be done by performing swapping the first\n  // element with the last, removing the last element to\n  // new array and calling sink function.\n  heapReverse () {\n    const heapSort = []\n    while (this.size > 0) {\n      // swap first element with last element\n      [this.heap[1], this.heap[this.size]] = [this.heap[this.size], this.heap[1]]\n      heapSort.push(this.heap.pop())\n      this.size--\n      this.sink()\n    }\n    // first value from heap it's empty to respect\n    // structure with 1 as index of the first element\n    this.heap = [undefined, ...heapSort.reverse()]\n    this.size = heapSort.length\n  }\n\n  // this function reorders the heap after every delete function\n  sink () {\n    let k = 1\n    while (2 * k <= this.size || 2 * k + 1 <= this.size) {\n      let minIndex\n      if (this.heap[2 * k] >= this.heap[k]) {\n        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {\n          break\n        } else if (2 * k + 1 > this.size) {\n          break\n        }\n      }\n      if (2 * k + 1 > this.size) {\n        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k\n      } else {\n        if (\n          this.heap[k] > this.heap[2 * k] ||\n          this.heap[k] > this.heap[2 * k + 1]\n        ) {\n          minIndex =\n            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1\n        } else {\n          minIndex = k\n        }\n      }\n      const temp = this.heap[k]\n      this.heap[k] = this.heap[minIndex]\n      this.heap[minIndex] = temp\n      k = minIndex\n    }\n  }\n\n  // deletes the highest priority value from the heap. The last\n  // element goes to ahead to first position and reorder heap\n  delete () {\n    // checks empty and one element array conditions\n    if (this.isEmpty()) return\n    if (this.size === 1) {\n      this.size--\n      return this.heap.pop()\n    }\n    const min = this.heap[1]\n    this.heap[1] = this.heap.pop()\n    this.size--\n    this.sink()\n    return min\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n",normalizedContent:"# 介绍\n\n最小优先级队列是一种数据结构，它管理一个键（值）的列表。并且给具有最小值的元素以优先权。可以用 heap 来实现它。\n\n最小优先队列实际就是一个小顶堆，即每次插入堆中的元素，都存储至堆末端，通过上浮操作比较，小于父节点则和父节点交换元素，直到根结点为止，这样就形成了一个小顶堆。在获取最小值时，由于堆是数组的结构，只需获取根结点的值，即数组下标为 1 的值即可。获取最小值并删除，则可以交换根结点和尾结点，之后删除尾结点，并对根结点进行下沉操作，保证每个父节点都小于两个左右子树即可。\n\n\n\n它支持以下操作：\n\n * getmin () - 给出最小优先级的元素，但不要删除它。\n * extractmin () - 给出最小优先级的元素，并删除它。\n * insert (element) - 在优先级队列中插入一个元素。\n * decrement (index, newvalue) - 从优先级队列中减少一个元素。\n\n为什么不使用其他数据结构（除了 heap）？\n\n * 链表：每次有新的元素出现将最小的元素放在顶部，或者一个元素的优先级改变时，运行时间复杂度为 o (n^2)。\n * 二叉搜索树（binary search tree）的插入很容易，获得最小值是一个简单的操作。它消耗了额外的空间来保存每个节点的指针。在插入和改变优先级的情况下，树需要再次被重新平衡，这比维护堆数据结构中的最小堆更复杂。堆使用数组，所以访问一个元素，缓存一个元素，总是更快的操作。\n\n\n# 实现\n\n\n# javascript\n\nconst { heap, minheap } = require('@datastructures-js/heap');\n\nconst getmincompare = (getcomparevalue) => (a, b) => {\n  const aval = typeof getcomparevalue === 'function' ? getcomparevalue(a) : a;\n  const bval = typeof getcomparevalue === 'function' ? getcomparevalue(b) : b;\n  return aval < bval ? -1 : 1;\n};\n\n/**\n * @class minpriorityqueue\n */\nclass minpriorityqueue {\n  constructor(getcomparevalue, _heap) {\n    if (getcomparevalue && typeof getcomparevalue !== 'function') {\n      throw new error('minpriorityqueue constructor requires a callback for object values');\n    }\n    this._heap = _heap || new minheap(getcomparevalue);\n  }\n\n  /**\n   * returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  front() {\n    return this._heap.root();\n  }\n\n  /**\n   * returns an element with lowest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  back() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * adds a value to the queue\n   * @public\n   * @param {number|string|object} value\n   * @returns {minpriorityqueue}\n   */\n  enqueue(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  dequeue() {\n    return this._heap.extractroot();\n  }\n\n  /**\n   * returns the number of elements in the queue\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._heap.isempty();\n  }\n\n  /**\n   * clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    return this._heap.clone().sort().reverse();\n  }\n\n  /**\n   * creates a priority queue from an existing array\n   * @public\n   * @static\n   * @returns {minpriorityqueue}\n   */\n  static fromarray(values, getcomparevalue) {\n    const heap = new heap(getmincompare(getcomparevalue), values);\n    return new minpriorityqueue(\n      getcomparevalue,\n      new minheap(getcomparevalue, heap).fix()\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n\n或者：\n\n/* minimum priority queue\n* it is a part of heap data structure\n* a heap is a specific tree based data structure\n* in which all the nodes of tree are in a specific order.\n* that is the children are arranged in some\n* respect of their parents, can either be greater\n* or less than the parent. this makes it a min priority queue\n* or max priority queue.\n*/\n\n// functions: insert, delete, peek, isempty, print, heapsort, sink\n\nclass minpriorityqueue {\n  // calls the constructor and initializes the capacity\n  constructor (c) {\n    this.heap = []\n    this.capacity = c\n    this.size = 0\n  }\n\n  // inserts the key at the end and rearranges it\n  // so that the binary heap is in appropriate order\n  insert (key) {\n    if (this.isfull()) return\n    this.heap[this.size + 1] = key\n    let k = this.size + 1\n    while (k > 1) {\n      if (this.heap[k] < this.heap[math.floor(k / 2)]) {\n        const temp = this.heap[k]\n        this.heap[k] = this.heap[math.floor(k / 2)]\n        this.heap[math.floor(k / 2)] = temp\n      }\n      k = math.floor(k / 2)\n    }\n    this.size++\n  }\n\n  // returns the highest priority value\n  peek () {\n    return this.heap[1]\n  }\n\n  // returns boolean value whether the heap is empty or not\n  isempty () {\n    return this.size === 0\n  }\n\n  // returns boolean value whether the heap is full or not\n  isfull () {\n    if (this.size === this.capacity) return true\n    return false\n  }\n\n  // prints the heap\n  print (output = value => console.log(value)) {\n    output(this.heap.slice(1))\n  }\n\n  // heap reverse can be done by performing swapping the first\n  // element with the last, removing the last element to\n  // new array and calling sink function.\n  heapreverse () {\n    const heapsort = []\n    while (this.size > 0) {\n      // swap first element with last element\n      [this.heap[1], this.heap[this.size]] = [this.heap[this.size], this.heap[1]]\n      heapsort.push(this.heap.pop())\n      this.size--\n      this.sink()\n    }\n    // first value from heap it's empty to respect\n    // structure with 1 as index of the first element\n    this.heap = [undefined, ...heapsort.reverse()]\n    this.size = heapsort.length\n  }\n\n  // this function reorders the heap after every delete function\n  sink () {\n    let k = 1\n    while (2 * k <= this.size || 2 * k + 1 <= this.size) {\n      let minindex\n      if (this.heap[2 * k] >= this.heap[k]) {\n        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {\n          break\n        } else if (2 * k + 1 > this.size) {\n          break\n        }\n      }\n      if (2 * k + 1 > this.size) {\n        minindex = this.heap[2 * k] < this.heap[k] ? 2 * k : k\n      } else {\n        if (\n          this.heap[k] > this.heap[2 * k] ||\n          this.heap[k] > this.heap[2 * k + 1]\n        ) {\n          minindex =\n            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1\n        } else {\n          minindex = k\n        }\n      }\n      const temp = this.heap[k]\n      this.heap[k] = this.heap[minindex]\n      this.heap[minindex] = temp\n      k = minindex\n    }\n  }\n\n  // deletes the highest priority value from the heap. the last\n  // element goes to ahead to first position and reorder heap\n  delete () {\n    // checks empty and one element array conditions\n    if (this.isempty()) return\n    if (this.size === 1) {\n      this.size--\n      return this.heap.pop()\n    }\n    const min = this.heap[1]\n    this.heap[1] = this.heap.pop()\n    this.size--\n    this.sink()\n    return min\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"MaxPriorityQueue [最大优先队列]",frontmatter:{title:"MaxPriorityQueue [最大优先队列]",date:"2022-04-26T21:56:08.000Z",permalink:"/ds/queue/maxPriorityQueue/",categories:["数据结构","queue队列"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.queue%20%E9%98%9F%E5%88%97/40.maxPriorityQueue.html",relativePath:"10.数据结构/10.queue 队列/40.maxPriorityQueue.md",key:"v-aee07d78",path:"/ds/queue/maxPriorityQueue/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:195},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:202}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n最大优先队列实际就是一个大顶堆，即每次插入堆中的元素，都存储至堆末端，通过上浮操作比较，大于父节点则和父节点交换元素，直到根结点为止，这样就形成了一个大顶堆。在获取最大值时，由于堆是数组的结构，只需获取根结点的值，即数组下标为 1 的值即可。获取最大值并删除，则可以交换根结点和尾结点，之后删除尾结点，并对根结点进行下沉操作，保证每个父节点都大于两个左右子树即可。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\nconst { Heap, MaxHeap } = require('@datastructures-js/heap');\n\nconst getMaxCompare = (getCompareValue) => (a, b) => {\n  const aVal = typeof getCompareValue === 'function' ? getCompareValue(a) : a;\n  const bVal = typeof getCompareValue === 'function' ? getCompareValue(b) : b;\n  return aVal < bVal ? 1 : -1;\n};\n\n/**\n * @class MaxPriorityQueue\n * @extends MaxHeap\n */\nclass MaxPriorityQueue {\n  constructor(getCompareValue, _heap) {\n    if (getCompareValue && typeof getCompareValue !== 'function') {\n      throw new Error('MaxPriorityQueue constructor requires a callback for object values');\n    }\n    this._heap = _heap || new MaxHeap(getCompareValue);\n  }\n\n  /**\n   * Returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  front() {\n    return this._heap.root();\n  }\n\n  /**\n   * Returns an element with lowest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  back() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * Adds a value to the queue\n   * @public\n   * @param {number|string|object} value\n   * @returns {MaxPriorityQueue}\n   */\n  enqueue(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * Removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  dequeue() {\n    return this._heap.extractRoot();\n  }\n\n  /**\n   * Returns the number of elements in the queue\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * Checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * Returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._heap.clone().sort().reverse();\n  }\n\n  /**\n   * Creates a priority queue from an existing array\n   * @public\n   * @static\n   * @returns {MaxPriorityQueue}\n   */\n  static fromArray(values, getCompareValue) {\n    const heap = new Heap(getMaxCompare(getCompareValue), values);\n    return new MaxPriorityQueue(\n      getCompareValue,\n      new MaxHeap(getCompareValue, heap).fix()\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n",normalizedContent:"# 介绍\n\n最大优先队列实际就是一个大顶堆，即每次插入堆中的元素，都存储至堆末端，通过上浮操作比较，大于父节点则和父节点交换元素，直到根结点为止，这样就形成了一个大顶堆。在获取最大值时，由于堆是数组的结构，只需获取根结点的值，即数组下标为 1 的值即可。获取最大值并删除，则可以交换根结点和尾结点，之后删除尾结点，并对根结点进行下沉操作，保证每个父节点都大于两个左右子树即可。\n\n\n\n\n# 实现\n\n\n# javascript\n\nconst { heap, maxheap } = require('@datastructures-js/heap');\n\nconst getmaxcompare = (getcomparevalue) => (a, b) => {\n  const aval = typeof getcomparevalue === 'function' ? getcomparevalue(a) : a;\n  const bval = typeof getcomparevalue === 'function' ? getcomparevalue(b) : b;\n  return aval < bval ? 1 : -1;\n};\n\n/**\n * @class maxpriorityqueue\n * @extends maxheap\n */\nclass maxpriorityqueue {\n  constructor(getcomparevalue, _heap) {\n    if (getcomparevalue && typeof getcomparevalue !== 'function') {\n      throw new error('maxpriorityqueue constructor requires a callback for object values');\n    }\n    this._heap = _heap || new maxheap(getcomparevalue);\n  }\n\n  /**\n   * returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  front() {\n    return this._heap.root();\n  }\n\n  /**\n   * returns an element with lowest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  back() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * adds a value to the queue\n   * @public\n   * @param {number|string|object} value\n   * @returns {maxpriorityqueue}\n   */\n  enqueue(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {number|string|object}\n   */\n  dequeue() {\n    return this._heap.extractroot();\n  }\n\n  /**\n   * returns the number of elements in the queue\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._heap.isempty();\n  }\n\n  /**\n   * clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    return this._heap.clone().sort().reverse();\n  }\n\n  /**\n   * creates a priority queue from an existing array\n   * @public\n   * @static\n   * @returns {maxpriorityqueue}\n   */\n  static fromarray(values, getcomparevalue) {\n    const heap = new heap(getmaxcompare(getcomparevalue), values);\n    return new maxpriorityqueue(\n      getcomparevalue,\n      new maxheap(getcomparevalue, heap).fix()\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"Deque(double-ended queue) [双端队列]",frontmatter:{title:"Deque(double-ended queue) [双端队列]",date:"2022-04-26T22:29:24.000Z",permalink:"/ds/queue/deque/",categories:["数据结构","queue 队列"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.queue%20%E9%98%9F%E5%88%97/50.deque.html",relativePath:"10.数据结构/10.queue 队列/50.deque.md",key:"v-00ca2008",path:"/ds/queue/deque/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:79},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:174},{level:2,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:186},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4839}],headersStr:"介绍 操作 实现 JavaScript 参考",content:"# 介绍\n\n双端队列（deque，全名 double-ended queue）是一种具有队列和栈性质的抽象数据类型。双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。\n\n\n# 操作\n\n双端队列可以在队列任意一端入队和出队。此外，经常还会有一个查看（Peek）操作，返回该端的数据而不将其出队。\n\n操作的名称依语言的不同而不同；主流实现包括：\n\n\n\n注意：JavaScript 的数组就是一个双端队列。\n\n\n# 实现\n\n\n# JavaScript\n\nclass Deque {\n  /**\n   * Creates a deque\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._backElements = Array.isArray(elements) ? elements : [];\n    this._frontElements = [];\n    this._backOffset = 0;\n    this._frontOffset = 0;\n  }\n\n  /**\n   * Adds an element at the front of the queue\n   * @public\n   * @param {any} element\n   */\n  pushFront(element) {\n    this._frontElements.push(element);\n    return this;\n  }\n\n  /**\n   * Adds an element at the back of the queue\n   * @public\n   * @param {any} element\n   */\n  pushBack(element) {\n    this._backElements.push(element);\n    return this;\n  }\n\n  /**\n   * Dequeues the front element in the queue\n   * @public\n   * @returns {any}\n   */\n  popFront() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._frontElements.length > 0) {\n      const front = this._frontElements.pop();\n      if (this._frontOffset >= this._frontElements.length) {\n        this._frontElements = this._frontElements.slice(this._frontOffset);\n        this._frontOffset = 0;\n      }\n      return front;\n    }\n\n    const front = this.front();\n    this._backOffset += 1;\n\n    if (this._backOffset * 2 < this._backElements.length) {\n      return front;\n    }\n\n    this._backElements = this._backElements.slice(this._backOffset);\n    this._backOffset = 0;\n    return front;\n  }\n\n  /**\n   * Dequeues the back element of the queue\n   * @public\n   * @returns {any}\n   */\n  popBack() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._backElements.length > 0) {\n      const back = this._backElements.pop();\n      if (this._backOffset >= this._backElements.length) {\n        this._backElements = this._backElements.slice(this._backOffset);\n        this._backOffset = 0;\n      }\n      return back;\n    }\n\n    const back = this.back();\n    this._frontOffset += 1;\n    if (this._frontOffset * 2 < this._frontElements.length) {\n      return back;\n    }\n\n    this._frontElements = this._frontElements.slice(this._frontOffset);\n    this._frontOffset = 0;\n    return back;\n  }\n\n  /**\n   * Returns the front element of the queue\n   * @public\n   * @returns {any}\n   */\n  front() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._frontElements.length > 0) {\n      return this._frontElements[this._frontElements.length - 1];\n    }\n\n    return this._backElements[this._backOffset];\n  }\n\n  /**\n   * Returns the back element of the queue\n   * @public\n   * @returns {any}\n   */\n  back() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._backElements.length > 0) {\n      return this._backElements[this._backElements.length - 1];\n    }\n\n    return this._frontElements[this._frontOffset];\n  }\n\n  /**\n   * Returns the number of elements in the deque\n   * @public\n   * @returns {number}\n   */\n  size() {\n    const frontSize = this._frontElements.length - this._frontOffset;\n    const backSize = this._backElements.length - this._backOffset;\n    return frontSize + backSize;\n  }\n\n  /**\n   * Checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Returns the remaining elements in the queue as an array\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const backElements = this._backElements.slice(this._backOffset);\n    const frontElements = this._frontElements.slice(this._frontElements);\n    return frontElements.reverse().concat(backElements);\n  }\n\n  /**\n   * Clears the queue\n   * @public\n   */\n  clear() {\n    this._backElements = [];\n    this._frontElements = [];\n    this._backOffset = 0;\n    this._frontOffset = 0;\n  }\n\n  /**\n   * Creates a shallow copy of the queue\n   * @public\n   * @return {Deque}\n   */\n  clone() {\n    return new Deque(this.toArray());\n  }\n\n  /**\n   * Creates a deque from an existing array\n   * @public\n   * @static\n   * @param {array} elements\n   * @return {Deque}\n   */\n  static fromArray(elements) {\n    return new Deque(elements);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n\n\n\n# 参考\n\n * Double-ended queue - Wikipedia\n * 双端队列 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n双端队列（deque，全名 double-ended queue）是一种具有队列和栈性质的抽象数据类型。双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。\n\n\n# 操作\n\n双端队列可以在队列任意一端入队和出队。此外，经常还会有一个查看（peek）操作，返回该端的数据而不将其出队。\n\n操作的名称依语言的不同而不同；主流实现包括：\n\n\n\n注意：javascript 的数组就是一个双端队列。\n\n\n# 实现\n\n\n# javascript\n\nclass deque {\n  /**\n   * creates a deque\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._backelements = array.isarray(elements) ? elements : [];\n    this._frontelements = [];\n    this._backoffset = 0;\n    this._frontoffset = 0;\n  }\n\n  /**\n   * adds an element at the front of the queue\n   * @public\n   * @param {any} element\n   */\n  pushfront(element) {\n    this._frontelements.push(element);\n    return this;\n  }\n\n  /**\n   * adds an element at the back of the queue\n   * @public\n   * @param {any} element\n   */\n  pushback(element) {\n    this._backelements.push(element);\n    return this;\n  }\n\n  /**\n   * dequeues the front element in the queue\n   * @public\n   * @returns {any}\n   */\n  popfront() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._frontelements.length > 0) {\n      const front = this._frontelements.pop();\n      if (this._frontoffset >= this._frontelements.length) {\n        this._frontelements = this._frontelements.slice(this._frontoffset);\n        this._frontoffset = 0;\n      }\n      return front;\n    }\n\n    const front = this.front();\n    this._backoffset += 1;\n\n    if (this._backoffset * 2 < this._backelements.length) {\n      return front;\n    }\n\n    this._backelements = this._backelements.slice(this._backoffset);\n    this._backoffset = 0;\n    return front;\n  }\n\n  /**\n   * dequeues the back element of the queue\n   * @public\n   * @returns {any}\n   */\n  popback() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._backelements.length > 0) {\n      const back = this._backelements.pop();\n      if (this._backoffset >= this._backelements.length) {\n        this._backelements = this._backelements.slice(this._backoffset);\n        this._backoffset = 0;\n      }\n      return back;\n    }\n\n    const back = this.back();\n    this._frontoffset += 1;\n    if (this._frontoffset * 2 < this._frontelements.length) {\n      return back;\n    }\n\n    this._frontelements = this._frontelements.slice(this._frontoffset);\n    this._frontoffset = 0;\n    return back;\n  }\n\n  /**\n   * returns the front element of the queue\n   * @public\n   * @returns {any}\n   */\n  front() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._frontelements.length > 0) {\n      return this._frontelements[this._frontelements.length - 1];\n    }\n\n    return this._backelements[this._backoffset];\n  }\n\n  /**\n   * returns the back element of the queue\n   * @public\n   * @returns {any}\n   */\n  back() {\n    if (this.size() === 0) {\n      return null;\n    }\n\n    if (this._backelements.length > 0) {\n      return this._backelements[this._backelements.length - 1];\n    }\n\n    return this._frontelements[this._frontoffset];\n  }\n\n  /**\n   * returns the number of elements in the deque\n   * @public\n   * @returns {number}\n   */\n  size() {\n    const frontsize = this._frontelements.length - this._frontoffset;\n    const backsize = this._backelements.length - this._backoffset;\n    return frontsize + backsize;\n  }\n\n  /**\n   * checks if the queue is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * returns the remaining elements in the queue as an array\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    const backelements = this._backelements.slice(this._backoffset);\n    const frontelements = this._frontelements.slice(this._frontelements);\n    return frontelements.reverse().concat(backelements);\n  }\n\n  /**\n   * clears the queue\n   * @public\n   */\n  clear() {\n    this._backelements = [];\n    this._frontelements = [];\n    this._backoffset = 0;\n    this._frontoffset = 0;\n  }\n\n  /**\n   * creates a shallow copy of the queue\n   * @public\n   * @return {deque}\n   */\n  clone() {\n    return new deque(this.toarray());\n  }\n\n  /**\n   * creates a deque from an existing array\n   * @public\n   * @static\n   * @param {array} elements\n   * @return {deque}\n   */\n  static fromarray(elements) {\n    return new deque(elements);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n\n\n\n# 参考\n\n * double-ended queue - wikipedia\n * 双端队列 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"CircularQueue [循环队列]",frontmatter:{title:"CircularQueue [循环队列]",date:"2022-09-26T10:05:25.000Z",permalink:"/pages/694de4/",categories:["数据结构","queue 队列"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.queue%20%E9%98%9F%E5%88%97/60.CircularQueue.html",relativePath:"10.数据结构/10.queue 队列/60.CircularQueue.md",key:"v-139bd2e6",path:"/pages/694de4/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:134},{level:2,title:"工作机制",slug:"工作机制",normalizedTitle:"工作机制",charIndex:421},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:239},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:652},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:2964},{level:3,title:"卡牌序列问题",slug:"卡牌序列问题",normalizedTitle:"卡牌序列问题",charIndex:2971},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4864}],headersStr:"介绍 用法 工作机制 实现 JavaScript 应用 卡牌序列问题 参考",content:'# 介绍\n\n圆形缓冲区（circular buffer），也称作圆形队列（circular queue），循环缓冲区（cyclic buffer），环形缓冲区（ring buffer），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。\n\n\n# 用法\n\n圆形缓冲区的一个有用特性是：当一个数据元素被用掉后，其余数据元素不需要移动其存储位置。相反，一个非圆形缓冲区（例如一个普通的队列）在用掉一个数据元素后，其余数据元素需要向前搬移。换句话说，圆形缓冲区适合实现先进先出缓冲区，而非圆形缓冲区适合后进先出缓冲区。\n\n圆形缓冲区适合于事先明确了缓冲区的最大容量的情形。扩展一个圆形缓冲区的容量，需要搬移其中的数据。因此一个缓冲区如果需要经常调整其容量，用链表实现更为合适。\n\n写操作覆盖圆形缓冲区中未被处理的数据在某些情况下是允许的。特别是在多媒体处理时。例如，音频的生产者可以覆盖掉声卡尚未来得及处理的音频数据。\n\n\n# 工作机制\n\n由于计算机内存是线性地址空间，因此圆形缓冲区需要特别的设计才可以从逻辑上实现。\n\n读指针与写指针：\n\n一般的，圆形缓冲区需要 4 个指针：\n\n * 在内存中实际开始位置；\n * 在内存中实际结束位置，也可以用缓冲区长度代替；\n * 存储在缓冲区中的有效数据的开始位置（读指针）；\n * 存储在缓冲区中的有效数据的结尾位置（写指针）。\n\n读指针、写指针可以用整型值来表示。\n\n扩展：生产者消费者问题，参见：操作系统原理之进程同步\n\n\n# 实现\n\n\n# JavaScript\n\n// Circular Queues offer a quick to store FIFO data with a maximum size.\n// Conserves memory as we only store up to our capacity\n// It is opposed to a queue which could continue to grow if input outpaces output\n// Doesn’t use dynamic memory so No memory leaks\n\nclass CircularQueue {\n  constructor (maxLength) {\n    this.queue = []\n    this.front = 0\n    this.rear = 0\n    this.maxLength = maxLength\n  }\n\n  // ADD ELEMENTS TO QUEUE\n  enqueue (value) {\n    if (this.checkOverflow()) return\n    if (this.checkEmpty()) {\n      this.front += 1\n      this.rear += 1\n    } else {\n      if (this.rear === this.maxLength) {\n        this.rear = 1\n      } else this.rear += 1\n    }\n    this.queue[this.rear] = value\n  }\n\n  // REMOVES ELEMENTS\n  dequeue () {\n    if (this.checkEmpty()) {\n      // UNDERFLOW\n      return\n    }\n    const y = this.queue[this.front]\n    this.queue[this.front] = \'*\'\n    if (!this.checkSingleelement()) {\n      if (this.front === this.maxLength) this.front = 1\n      else {\n        this.front += 1\n      }\n    }\n\n    return y // Returns the removed element and replaces it with a star\n  }\n\n  // checks if the queue is empty or not\n  checkEmpty () {\n    if (this.front === 0 && this.rear === 0) {\n      return true\n    }\n  }\n\n  checkSingleelement () {\n    if (this.front === this.rear && this.rear !== 0) {\n      this.front = this.rear = 0\n      return true\n    }\n  }\n\n  // Checks if max capacity of queue has been reached or not\n  checkOverflow () {\n    if ((this.front === 1 && this.rear === this.maxLength) || (this.front === this.rear + 1)) {\n      // CIRCULAR QUEUE OVERFLOW\n      return true\n    }\n  }\n\n  // Prints the entire array (\'*\' represents blank space)\n  display (output = value => console.log(value)) {\n    for (let index = 1; index < this.queue.length; index++) {\n      output(this.queue[index])\n    }\n  }\n\n  // Displays the length of queue\n  length () {\n    return this.queue.length - 1\n  }\n\n  // Display the top most value of queue\n  peek () {\n    return this.queue[this.front]\n  }\n}\n\nexport { CircularQueue }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# 应用\n\n\n# 卡牌序列问题\n\n// see https://gist.github.com/tinylamb/9228640\n/*\n * =========================================================\n *       Filename:  throwcards.c\n *    Description:  google Throwing cards away I\n *    题目大意：给n张牌，放成一叠，从上到下编号从1到n，当至少还有两张牌时\n *    丢弃最上面的牌，然后把新的最上面的牌放到最下面，一直重复，直到只剩下一张牌\n *    输出丢弃牌的序列。\n * =========================================================\n */\n#include <stdio.h>\n#include <stdbool.h>\n#include <assert.h>\n#define MAX 51 //预先知道数组最大值,留一个空来区别空/满\n\n/*数据集定义*/\ntypedef struct Queue{\n    int array[MAX];\n    int head,tail;\n}Queue;\n\n/*queue上的基本操作*/\nvoid InitQueue(Queue *q);\nbool IsEmpty(Queue *q);\nbool IsFull(Queue *q);\nvoid InQueue(Queue *q,int e);\nint DeQueue(Queue *q);\n\nint main(){\n    int n;\n    int discards[MAX];\n    Queue q;\n    while(scanf("%d",&n)!=EOF && n){\n        InitQueue(&q);\n        int i;\n        for(i=1;i<=n;i++)\n            InQueue(&q,i);\n        int k=0;\n        while(!IsEmpty(&q)){\n            discards[k++]=DeQueue(&q);\n            int top=DeQueue(&q);\n            InQueue(&q , top);\n        }\n        printf("Discarded cards:");\n        for(i=0;i<n-1;i++)\n            printf("%d%s",discards[i],(i==n-2)?"\\n":",");\n        printf("Remaining card:%d\\n",discards[i]);\n    }\n    return 0;\n}\n\nvoid InitQueue(Queue *q){\n    q->head=q->tail=0;\n}\nbool IsEmpty(Queue *q){\n    return (q->head==q->tail)?true:false;\n}\n\nbool IsFull(Queue *q){\n    return ((q->tail + 1) % MAX == q->head)?true:false;\n}\n\nvoid InQueue(Queue *q,int e){\n    assert(!IsFull(q));\n    q->array[q->tail]=e;\n    q->tail = (q->tail+1) % MAX;\n}\nint DeQueue(Queue *q){\n    assert(!IsEmpty(q));\n    int e=q->array[q->head];\n    q->head = (q->head + 1) % MAX;\n    return e;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n\n# 参考\n\n * 环形缓冲区 - Wikiwand',normalizedContent:'# 介绍\n\n圆形缓冲区（circular buffer），也称作圆形队列（circular queue），循环缓冲区（cyclic buffer），环形缓冲区（ring buffer），是一种用于表示一个固定尺寸、头尾相连的缓冲区的数据结构，适合缓存数据流。\n\n\n# 用法\n\n圆形缓冲区的一个有用特性是：当一个数据元素被用掉后，其余数据元素不需要移动其存储位置。相反，一个非圆形缓冲区（例如一个普通的队列）在用掉一个数据元素后，其余数据元素需要向前搬移。换句话说，圆形缓冲区适合实现先进先出缓冲区，而非圆形缓冲区适合后进先出缓冲区。\n\n圆形缓冲区适合于事先明确了缓冲区的最大容量的情形。扩展一个圆形缓冲区的容量，需要搬移其中的数据。因此一个缓冲区如果需要经常调整其容量，用链表实现更为合适。\n\n写操作覆盖圆形缓冲区中未被处理的数据在某些情况下是允许的。特别是在多媒体处理时。例如，音频的生产者可以覆盖掉声卡尚未来得及处理的音频数据。\n\n\n# 工作机制\n\n由于计算机内存是线性地址空间，因此圆形缓冲区需要特别的设计才可以从逻辑上实现。\n\n读指针与写指针：\n\n一般的，圆形缓冲区需要 4 个指针：\n\n * 在内存中实际开始位置；\n * 在内存中实际结束位置，也可以用缓冲区长度代替；\n * 存储在缓冲区中的有效数据的开始位置（读指针）；\n * 存储在缓冲区中的有效数据的结尾位置（写指针）。\n\n读指针、写指针可以用整型值来表示。\n\n扩展：生产者消费者问题，参见：操作系统原理之进程同步\n\n\n# 实现\n\n\n# javascript\n\n// circular queues offer a quick to store fifo data with a maximum size.\n// conserves memory as we only store up to our capacity\n// it is opposed to a queue which could continue to grow if input outpaces output\n// doesn’t use dynamic memory so no memory leaks\n\nclass circularqueue {\n  constructor (maxlength) {\n    this.queue = []\n    this.front = 0\n    this.rear = 0\n    this.maxlength = maxlength\n  }\n\n  // add elements to queue\n  enqueue (value) {\n    if (this.checkoverflow()) return\n    if (this.checkempty()) {\n      this.front += 1\n      this.rear += 1\n    } else {\n      if (this.rear === this.maxlength) {\n        this.rear = 1\n      } else this.rear += 1\n    }\n    this.queue[this.rear] = value\n  }\n\n  // removes elements\n  dequeue () {\n    if (this.checkempty()) {\n      // underflow\n      return\n    }\n    const y = this.queue[this.front]\n    this.queue[this.front] = \'*\'\n    if (!this.checksingleelement()) {\n      if (this.front === this.maxlength) this.front = 1\n      else {\n        this.front += 1\n      }\n    }\n\n    return y // returns the removed element and replaces it with a star\n  }\n\n  // checks if the queue is empty or not\n  checkempty () {\n    if (this.front === 0 && this.rear === 0) {\n      return true\n    }\n  }\n\n  checksingleelement () {\n    if (this.front === this.rear && this.rear !== 0) {\n      this.front = this.rear = 0\n      return true\n    }\n  }\n\n  // checks if max capacity of queue has been reached or not\n  checkoverflow () {\n    if ((this.front === 1 && this.rear === this.maxlength) || (this.front === this.rear + 1)) {\n      // circular queue overflow\n      return true\n    }\n  }\n\n  // prints the entire array (\'*\' represents blank space)\n  display (output = value => console.log(value)) {\n    for (let index = 1; index < this.queue.length; index++) {\n      output(this.queue[index])\n    }\n  }\n\n  // displays the length of queue\n  length () {\n    return this.queue.length - 1\n  }\n\n  // display the top most value of queue\n  peek () {\n    return this.queue[this.front]\n  }\n}\n\nexport { circularqueue }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# 应用\n\n\n# 卡牌序列问题\n\n// see https://gist.github.com/tinylamb/9228640\n/*\n * =========================================================\n *       filename:  throwcards.c\n *    description:  google throwing cards away i\n *    题目大意：给n张牌，放成一叠，从上到下编号从1到n，当至少还有两张牌时\n *    丢弃最上面的牌，然后把新的最上面的牌放到最下面，一直重复，直到只剩下一张牌\n *    输出丢弃牌的序列。\n * =========================================================\n */\n#include <stdio.h>\n#include <stdbool.h>\n#include <assert.h>\n#define max 51 //预先知道数组最大值,留一个空来区别空/满\n\n/*数据集定义*/\ntypedef struct queue{\n    int array[max];\n    int head,tail;\n}queue;\n\n/*queue上的基本操作*/\nvoid initqueue(queue *q);\nbool isempty(queue *q);\nbool isfull(queue *q);\nvoid inqueue(queue *q,int e);\nint dequeue(queue *q);\n\nint main(){\n    int n;\n    int discards[max];\n    queue q;\n    while(scanf("%d",&n)!=eof && n){\n        initqueue(&q);\n        int i;\n        for(i=1;i<=n;i++)\n            inqueue(&q,i);\n        int k=0;\n        while(!isempty(&q)){\n            discards[k++]=dequeue(&q);\n            int top=dequeue(&q);\n            inqueue(&q , top);\n        }\n        printf("discarded cards:");\n        for(i=0;i<n-1;i++)\n            printf("%d%s",discards[i],(i==n-2)?"\\n":",");\n        printf("remaining card:%d\\n",discards[i]);\n    }\n    return 0;\n}\n\nvoid initqueue(queue *q){\n    q->head=q->tail=0;\n}\nbool isempty(queue *q){\n    return (q->head==q->tail)?true:false;\n}\n\nbool isfull(queue *q){\n    return ((q->tail + 1) % max == q->head)?true:false;\n}\n\nvoid inqueue(queue *q,int e){\n    assert(!isfull(q));\n    q->array[q->tail]=e;\n    q->tail = (q->tail+1) % max;\n}\nint dequeue(queue *q){\n    assert(!isempty(q));\n    int e=q->array[q->head];\n    q->head = (q->head + 1) % max;\n    return e;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n\n# 参考\n\n * 环形缓冲区 - wikiwand',charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"MinHeap [最小堆]",frontmatter:{title:"MinHeap [最小堆]",date:"2022-04-26T22:00:07.000Z",permalink:"/ds/heap/minHeap/",categories:["数据结构","heap堆"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.heap%20%E5%A0%86/20.minHeap.html",relativePath:"10.数据结构/20.heap 堆/20.minHeap.md",key:"v-482f803c",path:"/ds/heap/minHeap/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:57},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:64}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n最小堆是一种特殊的堆，若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）。\n\n\n# 实现\n\n\n# JavaScript\n\nconst { Heap } = require('./heap');\n\nconst getMinCompare = (getCompareValue) => (a, b) => {\n  const aVal = typeof getCompareValue === 'function' ? getCompareValue(a) : a;\n  const bVal = typeof getCompareValue === 'function' ? getCompareValue(b) : b;\n  return aVal < bVal ? -1 : 1;\n};\n\n/**\n * @class MinHeap\n * @extends Heap\n */\nclass MinHeap {\n  /**\n   * @param {function} [getCompareValue]\n   * @param {Heap} [_heap]\n   */\n  constructor(getCompareValue, _heap) {\n    this._getCompareValue = getCompareValue;\n    this._heap = _heap || new Heap(getMinCompare(getCompareValue));\n  }\n\n  /**\n   * Inserts a new value into the heap\n   * @public\n   * @param {number|string|object} value\n   * @returns {MinHeap}\n   */\n  insert(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * Removes and returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  extractRoot() {\n    return this._heap.extractRoot();\n  }\n\n  /**\n   * Applies heap sort and return the values sorted by priority\n   * @public\n   * @returns {array}\n   */\n  sort() {\n    return this._heap.sort();\n  }\n\n  /**\n   * Fixes node positions in the heap\n   * @public\n   * @returns {MinHeap}\n   */\n  fix() {\n    return this._heap.fix();\n  }\n\n  /**\n   * Verifies that all heap nodes are in the right position\n   * @public\n   * @returns {boolean}\n   */\n  isValid() {\n    return this._heap.isValid();\n  }\n\n  /**\n   * Returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  root() {\n    return this._heap.root();\n  }\n\n  /**\n   * Returns a leaf node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  leaf() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * Returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * Checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Clears the heap\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * Returns a shallow copy of the MinHeap\n   * @public\n   * @returns {MinHeap}\n   */\n  clone() {\n    return new MinHeap(this._getCompareValue, this._heap.clone());\n  }\n\n  /**\n   * Builds a MinHeap from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getCompareValue]\n   * @returns {MinHeap}\n   */\n  static heapify(values, getCompareValue) {\n    if (!Array.isArray(values)) {\n      throw new Error('MinHeap.heapify expects an array');\n    }\n    const heap = new Heap(getMinCompare(getCompareValue), values);\n    return new MinHeap(getCompareValue, heap).fix();\n  }\n\n  /**\n   * Checks if a list of values is a valid min heap\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getCompareValue]\n   * @returns {boolean}\n   */\n  static isHeapified(values, getCompareValue) {\n    const heap = new Heap(getMinCompare(getCompareValue), values);\n    return new MinHeap(getCompareValue, heap).isValid();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n\n\n或者：\n\n/**\n *   Min Heap is one of the two Binary Heap types (the other is Max Heap)\n *   which maintains the smallest value of its input array on top and remaining values in loosely (but not perfectly sorted) order.\n *\n *   Min Heaps can be expressed as a 'complete' binary tree structure\n *   (in which all levels of the binary tree are filled, with the exception of the last level which must be filled left-to-right).\n *\n *   However the Min Heap class below expresses this tree structure as an array\n *   which represent the binary tree node values in an array ordered from root-to-leaf, left-to-right.\n *\n *   In the array representation, the parent node-child node relationship is such that the\n *      * parent index relative to its two children are: (parentIdx * 2) and (parent * 2 + 1)\n *      * and either child's index position relative to its parent is: Math.floor((childIdx-1)/2)\n *\n *   The parent and respective child values define much of heap behavior as we continue to sort or not sort depending on their values.\n *      * The parent value must be less than or equal to either child's value.\n *\n *   This is a condensed overview but for more information and visuals here is a nice read: https://www.geeksforgeeks.org/binary-heap/\n */\n\nclass MinHeap {\n  constructor (array) {\n    this.heap = this.initializeHeap(array)\n  }\n\n  /**\n   *   startingParent represents the parent of the last index (=== array.length-1)\n   *   and iterates towards 0 with all index values below sorted to meet heap conditions\n  */\n  initializeHeap (array) {\n    const startingParent = Math.floor((array.length - 2) / 2)\n\n    for (let currIdx = startingParent; currIdx >= 0; currIdx--) {\n      this.sinkDown(currIdx, array.length - 1, array)\n    }\n    return array\n  }\n\n  /**\n   *   overall functionality: heap-sort value at a starting index (currIdx) towards end of heap\n   *\n   *   currIdx is considered to be a starting 'parent' index of two children indices (childOneIdx, childTwoIdx).\n   *   endIdx represents the last valid index in the heap.\n   *\n   *   first check that childOneIdx and childTwoIdx are both smaller than endIdx\n   *   and check for the smaller heap value between them.\n   *\n   *   the child index with the smaller heap value is set to a variable called swapIdx.\n   *\n   *   swapIdx's value will be compared to currIdx (the 'parent' index)\n   *   and if swapIdx's value is smaller than currIdx's value, swap the values in the heap,\n   *   update currIdx and recalculate the new childOneIdx to check heap conditions again.\n   *\n   *   if there is no swap, it means the children indices and the parent index satisfy heap conditions and can exit the function.\n  */\n  sinkDown (currIdx, endIdx, heap) {\n    let childOneIdx = currIdx * 2 + 1\n\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = childOneIdx + 1 <= endIdx ? childOneIdx + 1 : -1\n      const swapIdx = childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]\n        ? childTwoIdx\n        : childOneIdx\n\n      if (heap[swapIdx] < heap[currIdx]) {\n        this.swap(currIdx, swapIdx, heap)\n        currIdx = swapIdx\n        childOneIdx = currIdx * 2 + 1\n      } else {\n        return\n      }\n    }\n  }\n\n  /**\n   *   overall functionality: heap-sort value at a starting index (currIdx) towards front of heap.\n   *\n   *   while the currIdx's value is smaller than its parent's (parentIdx) value, swap the values in the heap\n   *   update currIdx and recalculate the new parentIdx to check heap condition again.\n   *\n   *   iteration does not end while a valid currIdx has a value smaller than its parentIdx's value\n  */\n  bubbleUp (currIdx) {\n    let parentIdx = Math.floor((currIdx - 1) / 2)\n\n    while (currIdx > 0 && this.heap[currIdx] < this.heap[parentIdx]) {\n      this.swap(currIdx, parentIdx, this.heap)\n      currIdx = parentIdx\n      parentIdx = Math.floor((currIdx - 1) / 2)\n    }\n  }\n\n  peek () {\n    return this.heap[0]\n  }\n\n  /**\n   *   the min heap value should be the first value in the heap (=== this.heap[0])\n   *\n   *   firstIdx value and lastIdx value are swapped\n   *   the resulting min heap value now resides at heap[heap.length-1] which is popped and later returned.\n   *\n   *   the remaining values in the heap are re-sorted\n  */\n  extractMin () {\n    this.swap(0, this.heap.length - 1, this.heap)\n    const min = this.heap.pop()\n    this.sinkDown(0, this.heap.length - 1, this.heap)\n    return min\n  }\n\n  // a new value is pushed to the end of the heap and sorted up\n  insert (value) {\n    this.heap.push(value)\n    this.bubbleUp(this.heap.length - 1)\n  }\n\n  // index-swapping helper method\n  swap (idx1, idx2, heap) {\n    const temp = heap[idx1]\n    heap[idx1] = heap[idx2]\n    heap[idx2] = temp\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n",normalizedContent:"# 介绍\n\n最小堆是一种特殊的堆，若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）。\n\n\n# 实现\n\n\n# javascript\n\nconst { heap } = require('./heap');\n\nconst getmincompare = (getcomparevalue) => (a, b) => {\n  const aval = typeof getcomparevalue === 'function' ? getcomparevalue(a) : a;\n  const bval = typeof getcomparevalue === 'function' ? getcomparevalue(b) : b;\n  return aval < bval ? -1 : 1;\n};\n\n/**\n * @class minheap\n * @extends heap\n */\nclass minheap {\n  /**\n   * @param {function} [getcomparevalue]\n   * @param {heap} [_heap]\n   */\n  constructor(getcomparevalue, _heap) {\n    this._getcomparevalue = getcomparevalue;\n    this._heap = _heap || new heap(getmincompare(getcomparevalue));\n  }\n\n  /**\n   * inserts a new value into the heap\n   * @public\n   * @param {number|string|object} value\n   * @returns {minheap}\n   */\n  insert(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * removes and returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  extractroot() {\n    return this._heap.extractroot();\n  }\n\n  /**\n   * applies heap sort and return the values sorted by priority\n   * @public\n   * @returns {array}\n   */\n  sort() {\n    return this._heap.sort();\n  }\n\n  /**\n   * fixes node positions in the heap\n   * @public\n   * @returns {minheap}\n   */\n  fix() {\n    return this._heap.fix();\n  }\n\n  /**\n   * verifies that all heap nodes are in the right position\n   * @public\n   * @returns {boolean}\n   */\n  isvalid() {\n    return this._heap.isvalid();\n  }\n\n  /**\n   * returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  root() {\n    return this._heap.root();\n  }\n\n  /**\n   * returns a leaf node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  leaf() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._heap.isempty();\n  }\n\n  /**\n   * clears the heap\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * returns a shallow copy of the minheap\n   * @public\n   * @returns {minheap}\n   */\n  clone() {\n    return new minheap(this._getcomparevalue, this._heap.clone());\n  }\n\n  /**\n   * builds a minheap from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getcomparevalue]\n   * @returns {minheap}\n   */\n  static heapify(values, getcomparevalue) {\n    if (!array.isarray(values)) {\n      throw new error('minheap.heapify expects an array');\n    }\n    const heap = new heap(getmincompare(getcomparevalue), values);\n    return new minheap(getcomparevalue, heap).fix();\n  }\n\n  /**\n   * checks if a list of values is a valid min heap\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getcomparevalue]\n   * @returns {boolean}\n   */\n  static isheapified(values, getcomparevalue) {\n    const heap = new heap(getmincompare(getcomparevalue), values);\n    return new minheap(getcomparevalue, heap).isvalid();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n\n\n或者：\n\n/**\n *   min heap is one of the two binary heap types (the other is max heap)\n *   which maintains the smallest value of its input array on top and remaining values in loosely (but not perfectly sorted) order.\n *\n *   min heaps can be expressed as a 'complete' binary tree structure\n *   (in which all levels of the binary tree are filled, with the exception of the last level which must be filled left-to-right).\n *\n *   however the min heap class below expresses this tree structure as an array\n *   which represent the binary tree node values in an array ordered from root-to-leaf, left-to-right.\n *\n *   in the array representation, the parent node-child node relationship is such that the\n *      * parent index relative to its two children are: (parentidx * 2) and (parent * 2 + 1)\n *      * and either child's index position relative to its parent is: math.floor((childidx-1)/2)\n *\n *   the parent and respective child values define much of heap behavior as we continue to sort or not sort depending on their values.\n *      * the parent value must be less than or equal to either child's value.\n *\n *   this is a condensed overview but for more information and visuals here is a nice read: https://www.geeksforgeeks.org/binary-heap/\n */\n\nclass minheap {\n  constructor (array) {\n    this.heap = this.initializeheap(array)\n  }\n\n  /**\n   *   startingparent represents the parent of the last index (=== array.length-1)\n   *   and iterates towards 0 with all index values below sorted to meet heap conditions\n  */\n  initializeheap (array) {\n    const startingparent = math.floor((array.length - 2) / 2)\n\n    for (let curridx = startingparent; curridx >= 0; curridx--) {\n      this.sinkdown(curridx, array.length - 1, array)\n    }\n    return array\n  }\n\n  /**\n   *   overall functionality: heap-sort value at a starting index (curridx) towards end of heap\n   *\n   *   curridx is considered to be a starting 'parent' index of two children indices (childoneidx, childtwoidx).\n   *   endidx represents the last valid index in the heap.\n   *\n   *   first check that childoneidx and childtwoidx are both smaller than endidx\n   *   and check for the smaller heap value between them.\n   *\n   *   the child index with the smaller heap value is set to a variable called swapidx.\n   *\n   *   swapidx's value will be compared to curridx (the 'parent' index)\n   *   and if swapidx's value is smaller than curridx's value, swap the values in the heap,\n   *   update curridx and recalculate the new childoneidx to check heap conditions again.\n   *\n   *   if there is no swap, it means the children indices and the parent index satisfy heap conditions and can exit the function.\n  */\n  sinkdown (curridx, endidx, heap) {\n    let childoneidx = curridx * 2 + 1\n\n    while (childoneidx <= endidx) {\n      const childtwoidx = childoneidx + 1 <= endidx ? childoneidx + 1 : -1\n      const swapidx = childtwoidx !== -1 && heap[childtwoidx] < heap[childoneidx]\n        ? childtwoidx\n        : childoneidx\n\n      if (heap[swapidx] < heap[curridx]) {\n        this.swap(curridx, swapidx, heap)\n        curridx = swapidx\n        childoneidx = curridx * 2 + 1\n      } else {\n        return\n      }\n    }\n  }\n\n  /**\n   *   overall functionality: heap-sort value at a starting index (curridx) towards front of heap.\n   *\n   *   while the curridx's value is smaller than its parent's (parentidx) value, swap the values in the heap\n   *   update curridx and recalculate the new parentidx to check heap condition again.\n   *\n   *   iteration does not end while a valid curridx has a value smaller than its parentidx's value\n  */\n  bubbleup (curridx) {\n    let parentidx = math.floor((curridx - 1) / 2)\n\n    while (curridx > 0 && this.heap[curridx] < this.heap[parentidx]) {\n      this.swap(curridx, parentidx, this.heap)\n      curridx = parentidx\n      parentidx = math.floor((curridx - 1) / 2)\n    }\n  }\n\n  peek () {\n    return this.heap[0]\n  }\n\n  /**\n   *   the min heap value should be the first value in the heap (=== this.heap[0])\n   *\n   *   firstidx value and lastidx value are swapped\n   *   the resulting min heap value now resides at heap[heap.length-1] which is popped and later returned.\n   *\n   *   the remaining values in the heap are re-sorted\n  */\n  extractmin () {\n    this.swap(0, this.heap.length - 1, this.heap)\n    const min = this.heap.pop()\n    this.sinkdown(0, this.heap.length - 1, this.heap)\n    return min\n  }\n\n  // a new value is pushed to the end of the heap and sorted up\n  insert (value) {\n    this.heap.push(value)\n    this.bubbleup(this.heap.length - 1)\n  }\n\n  // index-swapping helper method\n  swap (idx1, idx2, heap) {\n    const temp = heap[idx1]\n    heap[idx1] = heap[idx2]\n    heap[idx2] = temp\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"Heap [堆]",frontmatter:{title:"Heap [堆]",date:"2022-04-26T21:58:13.000Z",permalink:"/ds/heap/heap/",categories:["数据结构","heap堆"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.heap%20%E5%A0%86/10.heap.html",relativePath:"10.数据结构/20.heap 堆/10.heap.md",key:"v-3712a3c0",path:"/ds/heap/heap/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"堆树",slug:"堆树",normalizedTitle:"堆树",charIndex:236},{level:2,title:"性质",slug:"性质",normalizedTitle:"性质",charIndex:403},{level:2,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:676},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:409},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:735},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:9514}],headersStr:"介绍 堆树 性质 基本操作 实现 JavaScript 参考",content:"# 介绍\n\n堆（英语：Heap）是计算机科学中的一种特别的完全二叉树。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于）C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。\n\n\n# 堆树\n\n堆树的定义如下：\n\n * 堆树是一颗完全二叉树；\n * 堆树中某个节点的值总是不大于或不小于其孩子节点的值；\n * 堆树中每个节点的子树都是堆树。\n\n当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。如下图所示，左边为最大堆，右边为最小堆。\n\n\n\n\n# 性质\n\n堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。\n\n * 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。\n * 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n * 将根节点最大的堆叫做最大堆或大根堆（大顶堆），根节点最小的堆叫做最小堆或小根堆（小顶堆）。\n\n堆有许多种高级类型包含了适合制作双端队列的最大 — 最小堆及制作优先权队列的斐波那契堆等。\n\n\n# 基本操作\n\n\n\n某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。\n\n\n# 实现\n\n\n# JavaScript\n\nclass Heap {\n  /**\n   * @param {function} compare\n   * @param {array} [_values]\n   * @param {number|string|object} [_leaf]\n   */\n  constructor(compare, _values, _leaf) {\n    if (typeof compare !== 'function') {\n      throw new Error('Heap constructor expects a compare function');\n    }\n    this._compare = compare;\n    this._nodes = Array.isArray(_values) ? _values : [];\n    this._leaf = _leaf || null;\n  }\n\n  /**\n   * Checks if a parent has a left child\n   * @private\n   */\n  _hasLeftChild(parentIndex) {\n    const leftChildIndex = (parentIndex * 2) + 1;\n    return leftChildIndex < this.size();\n  }\n\n  /**\n   * Checks if a parent has a right child\n   * @private\n   */\n  _hasRightChild(parentIndex) {\n    const rightChildIndex = (parentIndex * 2) + 2;\n    return rightChildIndex < this.size();\n  }\n\n  /**\n   * Compares two nodes\n   * @private\n   */\n  _compareAt(i, j) {\n    return this._compare(this._nodes[i], this._nodes[j]);\n  }\n\n  /**\n   * Swaps two nodes in the heap\n   * @private\n   */\n  _swap(i, j) {\n    const temp = this._nodes[i];\n    this._nodes[i] = this._nodes[j];\n    this._nodes[j] = temp;\n  }\n\n  /**\n   * Checks if parent and child should be swapped\n   * @private\n   */\n  _shouldSwap(parentIndex, childIndex) {\n    if (parentIndex < 0 || parentIndex >= this.size()) {\n      return false;\n    }\n\n    if (childIndex < 0 || childIndex >= this.size()) {\n      return false;\n    }\n\n    return this._compareAt(parentIndex, childIndex) > 0;\n  }\n\n  /**\n   * Compares children of a parent\n   * @private\n   */\n  _compareChildrenOf(parentIndex) {\n    if (!this._hasLeftChild(parentIndex) && !this._hasRightChild(parentIndex)) {\n      return -1;\n    }\n\n    const leftChildIndex = (parentIndex * 2) + 1;\n    const rightChildIndex = (parentIndex * 2) + 2;\n\n    if (!this._hasLeftChild(parentIndex)) {\n      return rightChildIndex;\n    }\n\n    if (!this._hasRightChild(parentIndex)) {\n      return leftChildIndex;\n    }\n\n    const compare = this._compareAt(leftChildIndex, rightChildIndex);\n    return compare > 0 ? rightChildIndex : leftChildIndex;\n  }\n\n  /**\n   * Compares two children before a position\n   * @private\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const compare = this._compareAt(rightChildIndex, leftChildIndex);\n\n    if (compare <= 0 && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n\n    return leftChildIndex;\n  }\n\n  /**\n   * Recursively bubbles up a node if it's in a wrong position\n   * @private\n   */\n  _heapifyUp(startIndex) {\n    let childIndex = startIndex;\n    let parentIndex = Math.floor((childIndex - 1) / 2);\n\n    while (this._shouldSwap(parentIndex, childIndex)) {\n      this._swap(parentIndex, childIndex);\n      childIndex = parentIndex;\n      parentIndex = Math.floor((childIndex - 1) / 2);\n    }\n  }\n\n  /**\n   * Recursively bubbles down a node if it's in a wrong position\n   * @private\n   */\n  _heapifyDown(startIndex) {\n    let parentIndex = startIndex;\n    let childIndex = this._compareChildrenOf(parentIndex);\n\n    while (this._shouldSwap(parentIndex, childIndex)) {\n      this._swap(parentIndex, childIndex);\n      parentIndex = childIndex;\n      childIndex = this._compareChildrenOf(parentIndex);\n    }\n  }\n\n  /**\n   * Recursively bubbles down a node before a given index\n   * @private\n   */\n  _heapifyDownUntil(index) {\n    let parentIndex = 0;\n    let leftChildIndex = 1;\n    let rightChildIndex = 2;\n    let childIndex;\n\n    while (leftChildIndex < index) {\n      childIndex = this._compareChildrenBefore(\n        index,\n        leftChildIndex,\n        rightChildIndex\n      );\n\n      if (this._shouldSwap(parentIndex, childIndex)) {\n        this._swap(parentIndex, childIndex);\n      }\n\n      parentIndex = childIndex;\n      leftChildIndex = (parentIndex * 2) + 1;\n      rightChildIndex = (parentIndex * 2) + 2;\n    }\n  }\n\n  /**\n   * Inserts a new value into the heap\n   * @public\n   * @param {number|string|object} value\n   * @returns {Heap}\n   */\n  insert(value) {\n    this._nodes.push(value);\n    this._heapifyUp(this.size() - 1);\n    if (this._leaf === null || this._compare(value, this._leaf) > 0) {\n      this._leaf = value;\n    }\n    return this;\n  }\n\n  /**\n   * Removes and returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  extractRoot() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const root = this.root();\n    this._nodes[0] = this._nodes[this.size() - 1];\n    this._nodes.pop();\n    this._heapifyDown(0);\n\n    if (root === this._leaf) {\n      this._leaf = this.root();\n    }\n\n    return root;\n  }\n\n  /**\n   * Applies heap sort and return the values sorted by priority\n   * @public\n   * @returns {array}\n   */\n  sort() {\n    for (let i = this.size() - 1; i > 0; i -= 1) {\n      this._swap(0, i);\n      this._heapifyDownUntil(i);\n    }\n    return this._nodes;\n  }\n\n  /**\n   * Fixes node positions in the heap\n   * @public\n   * @returns {Heap}\n   */\n  fix() {\n    for (let i = 0; i < this.size(); i += 1) {\n      this._heapifyUp(i);\n    }\n    return this;\n  }\n\n  /**\n   * Verifies that all heap nodes are in the right position\n   * @public\n   * @returns {boolean}\n   */\n  isValid() {\n    const isValidRecursive = (parentIndex) => {\n      let isValidLeft = true;\n      let isValidRight = true;\n\n      if (this._hasLeftChild(parentIndex)) {\n        const leftChildIndex = (parentIndex * 2) + 1;\n        if (this._compareAt(parentIndex, leftChildIndex) > 0) {\n          return false;\n        }\n        isValidLeft = isValidRecursive(leftChildIndex);\n      }\n\n      if (this._hasRightChild(parentIndex)) {\n        const rightChildIndex = (parentIndex * 2) + 2;\n        if (this._compareAt(parentIndex, rightChildIndex) > 0) {\n          return false;\n        }\n        isValidRight = isValidRecursive(rightChildIndex);\n      }\n\n      return isValidLeft && isValidRight;\n    };\n\n    return isValidRecursive(0);\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {Heap}\n   */\n  clone() {\n    return new Heap(this._compare, this._nodes.slice(), this._leaf);\n  }\n\n  /**\n   * Returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  root() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    return this._nodes[0];\n  }\n\n  /**\n   * Returns a leaf node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  leaf() {\n    return this._leaf;\n  }\n\n  /**\n   * Returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._nodes.length;\n  }\n\n  /**\n   * Checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Clears the heap\n   * @public\n   */\n  clear() {\n    this._nodes = [];\n    this._leaf = null;\n  }\n\n  /**\n   * Builds a heap from a array of values\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} compare\n   * @returns {Heap}\n   */\n  static heapify(values, compare) {\n    if (!Array.isArray(values)) {\n      throw new Error('Heap.heapify expects an array of values');\n    }\n\n    if (typeof compare !== 'function') {\n      throw new Error('Heap.heapify expects a compare function');\n    }\n\n    return new Heap(compare, values).fix();\n  }\n\n  /**\n   * Checks if a list of values is a valid heap\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} compare\n   * @returns {boolean}\n   */\n  static isHeapified(values, compare) {\n    return new Heap(compare, values).isValid();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n\n\n\n# 参考\n\n * Heap (data structure) - Wikipedia\n * 堆 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n堆（英语：heap）是计算机科学中的一种特别的完全二叉树。若是满足以下特性，即可称为堆：“给定堆中任意节点 p 和 c，若 p 是 c 的母节点，那么 p 的值会小于等于（或大于等于）c 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。\n\n\n# 堆树\n\n堆树的定义如下：\n\n * 堆树是一颗完全二叉树；\n * 堆树中某个节点的值总是不大于或不小于其孩子节点的值；\n * 堆树中每个节点的子树都是堆树。\n\n当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。如下图所示，左边为最大堆，右边为最小堆。\n\n\n\n\n# 性质\n\n堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。\n\n * 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。\n * 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n * 将根节点最大的堆叫做最大堆或大根堆（大顶堆），根节点最小的堆叫做最小堆或小根堆（小顶堆）。\n\n堆有许多种高级类型包含了适合制作双端队列的最大 — 最小堆及制作优先权队列的斐波那契堆等。\n\n\n# 基本操作\n\n\n\n某些堆实现还支持其他的一些操作，如斐波那契堆支持检查一个堆中是否存在某个元素。\n\n\n# 实现\n\n\n# javascript\n\nclass heap {\n  /**\n   * @param {function} compare\n   * @param {array} [_values]\n   * @param {number|string|object} [_leaf]\n   */\n  constructor(compare, _values, _leaf) {\n    if (typeof compare !== 'function') {\n      throw new error('heap constructor expects a compare function');\n    }\n    this._compare = compare;\n    this._nodes = array.isarray(_values) ? _values : [];\n    this._leaf = _leaf || null;\n  }\n\n  /**\n   * checks if a parent has a left child\n   * @private\n   */\n  _hasleftchild(parentindex) {\n    const leftchildindex = (parentindex * 2) + 1;\n    return leftchildindex < this.size();\n  }\n\n  /**\n   * checks if a parent has a right child\n   * @private\n   */\n  _hasrightchild(parentindex) {\n    const rightchildindex = (parentindex * 2) + 2;\n    return rightchildindex < this.size();\n  }\n\n  /**\n   * compares two nodes\n   * @private\n   */\n  _compareat(i, j) {\n    return this._compare(this._nodes[i], this._nodes[j]);\n  }\n\n  /**\n   * swaps two nodes in the heap\n   * @private\n   */\n  _swap(i, j) {\n    const temp = this._nodes[i];\n    this._nodes[i] = this._nodes[j];\n    this._nodes[j] = temp;\n  }\n\n  /**\n   * checks if parent and child should be swapped\n   * @private\n   */\n  _shouldswap(parentindex, childindex) {\n    if (parentindex < 0 || parentindex >= this.size()) {\n      return false;\n    }\n\n    if (childindex < 0 || childindex >= this.size()) {\n      return false;\n    }\n\n    return this._compareat(parentindex, childindex) > 0;\n  }\n\n  /**\n   * compares children of a parent\n   * @private\n   */\n  _comparechildrenof(parentindex) {\n    if (!this._hasleftchild(parentindex) && !this._hasrightchild(parentindex)) {\n      return -1;\n    }\n\n    const leftchildindex = (parentindex * 2) + 1;\n    const rightchildindex = (parentindex * 2) + 2;\n\n    if (!this._hasleftchild(parentindex)) {\n      return rightchildindex;\n    }\n\n    if (!this._hasrightchild(parentindex)) {\n      return leftchildindex;\n    }\n\n    const compare = this._compareat(leftchildindex, rightchildindex);\n    return compare > 0 ? rightchildindex : leftchildindex;\n  }\n\n  /**\n   * compares two children before a position\n   * @private\n   */\n  _comparechildrenbefore(index, leftchildindex, rightchildindex) {\n    const compare = this._compareat(rightchildindex, leftchildindex);\n\n    if (compare <= 0 && rightchildindex < index) {\n      return rightchildindex;\n    }\n\n    return leftchildindex;\n  }\n\n  /**\n   * recursively bubbles up a node if it's in a wrong position\n   * @private\n   */\n  _heapifyup(startindex) {\n    let childindex = startindex;\n    let parentindex = math.floor((childindex - 1) / 2);\n\n    while (this._shouldswap(parentindex, childindex)) {\n      this._swap(parentindex, childindex);\n      childindex = parentindex;\n      parentindex = math.floor((childindex - 1) / 2);\n    }\n  }\n\n  /**\n   * recursively bubbles down a node if it's in a wrong position\n   * @private\n   */\n  _heapifydown(startindex) {\n    let parentindex = startindex;\n    let childindex = this._comparechildrenof(parentindex);\n\n    while (this._shouldswap(parentindex, childindex)) {\n      this._swap(parentindex, childindex);\n      parentindex = childindex;\n      childindex = this._comparechildrenof(parentindex);\n    }\n  }\n\n  /**\n   * recursively bubbles down a node before a given index\n   * @private\n   */\n  _heapifydownuntil(index) {\n    let parentindex = 0;\n    let leftchildindex = 1;\n    let rightchildindex = 2;\n    let childindex;\n\n    while (leftchildindex < index) {\n      childindex = this._comparechildrenbefore(\n        index,\n        leftchildindex,\n        rightchildindex\n      );\n\n      if (this._shouldswap(parentindex, childindex)) {\n        this._swap(parentindex, childindex);\n      }\n\n      parentindex = childindex;\n      leftchildindex = (parentindex * 2) + 1;\n      rightchildindex = (parentindex * 2) + 2;\n    }\n  }\n\n  /**\n   * inserts a new value into the heap\n   * @public\n   * @param {number|string|object} value\n   * @returns {heap}\n   */\n  insert(value) {\n    this._nodes.push(value);\n    this._heapifyup(this.size() - 1);\n    if (this._leaf === null || this._compare(value, this._leaf) > 0) {\n      this._leaf = value;\n    }\n    return this;\n  }\n\n  /**\n   * removes and returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  extractroot() {\n    if (this.isempty()) {\n      return null;\n    }\n\n    const root = this.root();\n    this._nodes[0] = this._nodes[this.size() - 1];\n    this._nodes.pop();\n    this._heapifydown(0);\n\n    if (root === this._leaf) {\n      this._leaf = this.root();\n    }\n\n    return root;\n  }\n\n  /**\n   * applies heap sort and return the values sorted by priority\n   * @public\n   * @returns {array}\n   */\n  sort() {\n    for (let i = this.size() - 1; i > 0; i -= 1) {\n      this._swap(0, i);\n      this._heapifydownuntil(i);\n    }\n    return this._nodes;\n  }\n\n  /**\n   * fixes node positions in the heap\n   * @public\n   * @returns {heap}\n   */\n  fix() {\n    for (let i = 0; i < this.size(); i += 1) {\n      this._heapifyup(i);\n    }\n    return this;\n  }\n\n  /**\n   * verifies that all heap nodes are in the right position\n   * @public\n   * @returns {boolean}\n   */\n  isvalid() {\n    const isvalidrecursive = (parentindex) => {\n      let isvalidleft = true;\n      let isvalidright = true;\n\n      if (this._hasleftchild(parentindex)) {\n        const leftchildindex = (parentindex * 2) + 1;\n        if (this._compareat(parentindex, leftchildindex) > 0) {\n          return false;\n        }\n        isvalidleft = isvalidrecursive(leftchildindex);\n      }\n\n      if (this._hasrightchild(parentindex)) {\n        const rightchildindex = (parentindex * 2) + 2;\n        if (this._compareat(parentindex, rightchildindex) > 0) {\n          return false;\n        }\n        isvalidright = isvalidrecursive(rightchildindex);\n      }\n\n      return isvalidleft && isvalidright;\n    };\n\n    return isvalidrecursive(0);\n  }\n\n  /**\n   * returns a shallow copy of the heap\n   * @public\n   * @returns {heap}\n   */\n  clone() {\n    return new heap(this._compare, this._nodes.slice(), this._leaf);\n  }\n\n  /**\n   * returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  root() {\n    if (this.isempty()) {\n      return null;\n    }\n\n    return this._nodes[0];\n  }\n\n  /**\n   * returns a leaf node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  leaf() {\n    return this._leaf;\n  }\n\n  /**\n   * returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._nodes.length;\n  }\n\n  /**\n   * checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * clears the heap\n   * @public\n   */\n  clear() {\n    this._nodes = [];\n    this._leaf = null;\n  }\n\n  /**\n   * builds a heap from a array of values\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} compare\n   * @returns {heap}\n   */\n  static heapify(values, compare) {\n    if (!array.isarray(values)) {\n      throw new error('heap.heapify expects an array of values');\n    }\n\n    if (typeof compare !== 'function') {\n      throw new error('heap.heapify expects a compare function');\n    }\n\n    return new heap(compare, values).fix();\n  }\n\n  /**\n   * checks if a list of values is a valid heap\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} compare\n   * @returns {boolean}\n   */\n  static isheapified(values, compare) {\n    return new heap(compare, values).isvalid();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n\n\n\n# 参考\n\n * heap (data structure) - wikipedia\n * 堆 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"MaxHeap [最大堆]",frontmatter:{title:"MaxHeap [最大堆]",date:"2022-04-26T22:01:19.000Z",permalink:"/ds/heap/maxHeap/",categories:["数据结构","heap堆"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.heap%20%E5%A0%86/30.maxHeap.html",relativePath:"10.数据结构/20.heap 堆/30.maxHeap.md",key:"v-131a8800",path:"/ds/heap/maxHeap/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:57},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:64}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n最大堆是一种特殊的堆，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。\n\n\n# 实现\n\n\n# JavaScript\n\nconst { Heap } = require('./heap');\n\nconst getMaxCompare = (getCompareValue) => (a, b) => {\n  const aVal = typeof getCompareValue === 'function' ? getCompareValue(a) : a;\n  const bVal = typeof getCompareValue === 'function' ? getCompareValue(b) : b;\n  return aVal < bVal ? 1 : -1;\n};\n\n/**\n * @class MaxHeap\n * @extends Heap\n */\nclass MaxHeap {\n  /**\n   * @param {function} [getCompareValue]\n   * @param {Heap} [_heap]\n   */\n  constructor(getCompareValue, _heap) {\n    this._getCompareValue = getCompareValue;\n    this._heap = _heap || new Heap(getMaxCompare(getCompareValue));\n  }\n\n  /**\n   * Inserts a new value into the heap\n   * @public\n   * @param {number|string|object} value\n   * @returns {MaxHeap}\n   */\n  insert(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * Removes and returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  extractRoot() {\n    return this._heap.extractRoot();\n  }\n\n  /**\n   * Applies heap sort and return the values sorted by priority\n   * @public\n   * @returns {array}\n   */\n  sort() {\n    return this._heap.sort();\n  }\n\n  /**\n   * Fixes node positions in the heap\n   * @public\n   * @returns {MaxHeap}\n   */\n  fix() {\n    return this._heap.fix();\n  }\n\n  /**\n   * Verifies that all heap nodes are in the right position\n   * @public\n   * @returns {boolean}\n   */\n  isValid() {\n    return this._heap.isValid();\n  }\n\n  /**\n   * Returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  root() {\n    return this._heap.root();\n  }\n\n  /**\n   * Returns a leaf node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  leaf() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * Returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * Checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Clears the heap\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * Returns a shallow copy of the MaxHeap\n   * @public\n   * @returns {MaxHeap}\n   */\n  clone() {\n    return new MaxHeap(this._getCompareValue, this._heap.clone());\n  }\n\n  /**\n   * Builds a MaxHeap from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getCompareValue]\n   * @returns {MaxHeap}\n   */\n  static heapify(values, getCompareValue) {\n    if (!Array.isArray(values)) {\n      throw new Error('MaxHeap.heapify expects an array');\n    }\n    const heap = new Heap(getMaxCompare(getCompareValue), values);\n    return new MaxHeap(getCompareValue, heap).fix();\n  }\n\n  /**\n   * Checks if a list of values is a valid max heap\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getCompareValue]\n   * @returns {boolean}\n   */\n  static isHeapified(values, getCompareValue) {\n    const heap = new Heap(getMaxCompare(getCompareValue), values);\n    return new MaxHeap(getCompareValue, heap).isValid();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n\n\n或者：\n\nclass BinaryHeap {\n  constructor () {\n    this.heap = []\n  }\n\n  insert (value) {\n    this.heap.push(value)\n    this.heapify()\n  }\n\n  size () {\n    return this.heap.length\n  }\n\n  empty () {\n    return this.size() === 0\n  }\n\n  // using iterative approach to reorder the heap after insertion\n  heapify () {\n    let index = this.size() - 1\n\n    while (index > 0) {\n      const element = this.heap[index]\n      const parentIndex = Math.floor((index - 1) / 2)\n      const parent = this.heap[parentIndex]\n\n      if (parent[0] >= element[0]) break\n      this.heap[index] = parent\n      this.heap[parentIndex] = element\n      index = parentIndex\n    }\n  }\n\n  // Extracting the maximum element from the Heap\n  extractMax () {\n    const max = this.heap[0]\n    const tmp = this.heap.pop()\n    if (!this.empty()) {\n      this.heap[0] = tmp\n      this.sinkDown(0)\n    }\n    return max\n  }\n\n  // To restore the balance of the heap after extraction.\n  sinkDown (index) {\n    const left = 2 * index + 1\n    const right = 2 * index + 2\n    let largest = index\n    const length = this.size()\n\n    if (left < length && this.heap[left][0] > this.heap[largest][0]) {\n      largest = left\n    }\n    if (right < length && this.heap[right][0] > this.heap[largest][0]) {\n      largest = right\n    }\n    // swap\n    if (largest !== index) {\n      const tmp = this.heap[largest]\n      this.heap[largest] = this.heap[index]\n      this.heap[index] = tmp\n      this.sinkDown(largest)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n",normalizedContent:"# 介绍\n\n最大堆是一种特殊的堆，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。\n\n\n# 实现\n\n\n# javascript\n\nconst { heap } = require('./heap');\n\nconst getmaxcompare = (getcomparevalue) => (a, b) => {\n  const aval = typeof getcomparevalue === 'function' ? getcomparevalue(a) : a;\n  const bval = typeof getcomparevalue === 'function' ? getcomparevalue(b) : b;\n  return aval < bval ? 1 : -1;\n};\n\n/**\n * @class maxheap\n * @extends heap\n */\nclass maxheap {\n  /**\n   * @param {function} [getcomparevalue]\n   * @param {heap} [_heap]\n   */\n  constructor(getcomparevalue, _heap) {\n    this._getcomparevalue = getcomparevalue;\n    this._heap = _heap || new heap(getmaxcompare(getcomparevalue));\n  }\n\n  /**\n   * inserts a new value into the heap\n   * @public\n   * @param {number|string|object} value\n   * @returns {maxheap}\n   */\n  insert(value) {\n    return this._heap.insert(value);\n  }\n\n  /**\n   * removes and returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  extractroot() {\n    return this._heap.extractroot();\n  }\n\n  /**\n   * applies heap sort and return the values sorted by priority\n   * @public\n   * @returns {array}\n   */\n  sort() {\n    return this._heap.sort();\n  }\n\n  /**\n   * fixes node positions in the heap\n   * @public\n   * @returns {maxheap}\n   */\n  fix() {\n    return this._heap.fix();\n  }\n\n  /**\n   * verifies that all heap nodes are in the right position\n   * @public\n   * @returns {boolean}\n   */\n  isvalid() {\n    return this._heap.isvalid();\n  }\n\n  /**\n   * returns the root node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  root() {\n    return this._heap.root();\n  }\n\n  /**\n   * returns a leaf node in the heap\n   * @public\n   * @returns {number|string|object}\n   */\n  leaf() {\n    return this._heap.leaf();\n  }\n\n  /**\n   * returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._heap.isempty();\n  }\n\n  /**\n   * clears the heap\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n\n  /**\n   * returns a shallow copy of the maxheap\n   * @public\n   * @returns {maxheap}\n   */\n  clone() {\n    return new maxheap(this._getcomparevalue, this._heap.clone());\n  }\n\n  /**\n   * builds a maxheap from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getcomparevalue]\n   * @returns {maxheap}\n   */\n  static heapify(values, getcomparevalue) {\n    if (!array.isarray(values)) {\n      throw new error('maxheap.heapify expects an array');\n    }\n    const heap = new heap(getmaxcompare(getcomparevalue), values);\n    return new maxheap(getcomparevalue, heap).fix();\n  }\n\n  /**\n   * checks if a list of values is a valid max heap\n   * @public\n   * @static\n   * @param {array} values\n   * @param {function} [getcomparevalue]\n   * @returns {boolean}\n   */\n  static isheapified(values, getcomparevalue) {\n    const heap = new heap(getmaxcompare(getcomparevalue), values);\n    return new maxheap(getcomparevalue, heap).isvalid();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n\n\n或者：\n\nclass binaryheap {\n  constructor () {\n    this.heap = []\n  }\n\n  insert (value) {\n    this.heap.push(value)\n    this.heapify()\n  }\n\n  size () {\n    return this.heap.length\n  }\n\n  empty () {\n    return this.size() === 0\n  }\n\n  // using iterative approach to reorder the heap after insertion\n  heapify () {\n    let index = this.size() - 1\n\n    while (index > 0) {\n      const element = this.heap[index]\n      const parentindex = math.floor((index - 1) / 2)\n      const parent = this.heap[parentindex]\n\n      if (parent[0] >= element[0]) break\n      this.heap[index] = parent\n      this.heap[parentindex] = element\n      index = parentindex\n    }\n  }\n\n  // extracting the maximum element from the heap\n  extractmax () {\n    const max = this.heap[0]\n    const tmp = this.heap.pop()\n    if (!this.empty()) {\n      this.heap[0] = tmp\n      this.sinkdown(0)\n    }\n    return max\n  }\n\n  // to restore the balance of the heap after extraction.\n  sinkdown (index) {\n    const left = 2 * index + 1\n    const right = 2 * index + 2\n    let largest = index\n    const length = this.size()\n\n    if (left < length && this.heap[left][0] > this.heap[largest][0]) {\n      largest = left\n    }\n    if (right < length && this.heap[right][0] > this.heap[largest][0]) {\n      largest = right\n    }\n    // swap\n    if (largest !== index) {\n      const tmp = this.heap[largest]\n      this.heap[largest] = this.heap[index]\n      this.heap[index] = tmp\n      this.sinkdown(largest)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"Roadmap 路线",frontmatter:{title:"Roadmap 路线",date:"2022-04-16T16:44:46.000Z",permalink:"/ds/roadmap/",categories:["数据结构"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.roadmap.html",relativePath:"10.数据结构/3.roadmap.md",key:"v-0ba4d67b",path:"/ds/roadmap/",headers:[{level:2,title:"Roadmap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:2},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:23}],headersStr:"Roadmap 参考",content:"# Roadmap\n\nRoadmap\n\n\n# 参考\n\n * 如何系统地学习数据结构与算法？ - 知乎",normalizedContent:"# roadmap\n\nroadmap\n\n\n# 参考\n\n * 如何系统地学习数据结构与算法？ - 知乎",charsets:{cjk:!0},lastUpdated:"2022/09/26, 19:49:08",lastUpdatedTimestamp:1664192948e3},{title:"LinkedList [链表]",frontmatter:{title:"LinkedList [链表]",date:"2022-04-26T22:03:50.000Z",permalink:"/ds/linked-list/linkedList/",categories:["数据结构","linked-list链表"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/30.linked-list%20%E9%93%BE%E8%A1%A8/10.linkedList.html",relativePath:"10.数据结构/30.linked-list 链表/10.linkedList.md",key:"v-1ae8a7a5",path:"/ds/linked-list/linkedList/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:288},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:730},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:18300},{level:3,title:"循环检测(CycleDetection)",slug:"循环检测-cycledetection",normalizedTitle:"循环检测 (cycledetection)",charIndex:18307},{level:3,title:"RotateListRight",slug:"rotatelistright",normalizedTitle:"rotatelistright",charIndex:19270},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:20460}],headersStr:"介绍 实现 JavaScript 应用 循环检测(CycleDetection) RotateListRight 参考",content:"# 介绍\n\n在计算机科学中，链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针 (Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)O(1)O(1) 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)O(n)O(n) 的时间，而顺序表相应的时间复杂度分别是O(logn)O(logn)O(logn) 和O(1)O(1)O(1)。\n\n\n\n使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。\n\n在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个 / 或下一个节点的位置的链接（\"links\"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。\n\n链表可以在多种编程语言中实现。像 Lisp 和 Scheme 这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如 C/C++ 和 Java 依靠易变工具来生成链表。\n\n\n# 实现\n\n\n# JavaScript\n\nclass LinkedListNode {\n  /**\n   * Creates a linked list node.\n   * @param {any} value\n   * @param {LinkedListNode} [next]\n   */\n  constructor(value, next) {\n    this._value = value;\n    this.setNext(next);\n  }\n\n  /**\n   * @public\n   * @param {any} value\n   * @returns {LinkedListNode}\n   */\n  setValue(value) {\n    this._value = value;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {any}\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {LinkedListNode} [next]\n   * @returns {LinkedListNode}\n   */\n  setNext(next) {\n    if (next && !(next instanceof LinkedListNode)) {\n      throw new Error('seNext expects a LinkedListNode or null');\n    }\n    this._next = next || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {LinkedListNode}\n   */\n  getNext() {\n    return this._next;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  hasNext() {\n    return this._next instanceof LinkedListNode;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this._head = null;\n    this._count = 0;\n  }\n\n  /**\n   * Adds a node at the beginning of the list.\n   * @public\n   * @param {any} value\n   * @returns {LinkedListNode}\n   */\n  insertFirst(value) {\n    this._head = new LinkedListNode(value, this._head);\n    this._count += 1;\n    return this._head;\n  }\n\n  /**\n   * Adds a node at the end of the list.\n   * @public\n   * @param {any} value\n   * @param {LinkedListNode} [startingNode]\n   * @returns {LinkedListNode}\n   */\n  insertLast(value, startingNode) {\n    if (this.isEmpty()) {\n      return this.insertFirst(value);\n    }\n\n    if (startingNode && !(startingNode instanceof LinkedListNode)) {\n      throw new Error('insertLast expects a LinkedListNode starting node');\n    }\n\n    let current = startingNode || this._head;\n    while (current.hasNext()) {\n      current = current.getNext();\n    }\n\n    current.setNext(new LinkedListNode(value, null));\n    this._count += 1;\n    return current.getNext();\n  }\n\n  /**\n   * Adds a node at a specific position.\n   * @public\n   * @param {number} position\n   * @param {any} value\n   * @returns {LinkedListNode}\n   */\n  insertAt(position, value) {\n    if (\n      Number.isNaN(+position)\n      || position < 0 || position > this._count\n    ) {\n      throw new Error('insertAt expects a position num <= linked list size.');\n    }\n\n    // head node is at position 0\n    if (position === 0) {\n      return this.insertFirst(value);\n    }\n\n    let currentPosition = 1;\n    let prev = this._head;\n    while (currentPosition < position) {\n      currentPosition += 1;\n      prev = prev.getNext();\n    }\n\n    // add it at a position after the head, between prev & prev.getNext()\n    prev.setNext(new LinkedListNode(value, prev.getNext()));\n    this._count += 1;\n    return prev.getNext();\n  }\n\n  /**\n   * Removes the head node.\n   * @public\n   * @returns {LinkedListNode}\n   */\n  removeFirst() {\n    if (this.isEmpty()) return null;\n\n    const removed = this._head;\n    this._head = this._head.getNext();\n    this._count -= 1;\n    return removed.setNext(null);\n  }\n\n  /**\n   * Removes the last node in the list.\n   * @public\n   * @returns {LinkedListNode}\n   */\n  removeLast() {\n    if (this.isEmpty()) return null;\n\n    let prev = null;\n    let current = this._head;\n    while (current.hasNext()) {\n      prev = current;\n      current = current.getNext();\n    }\n\n    // linked list has 1 node\n    if (prev === null) {\n      return this.removeFirst();\n    }\n\n    prev.setNext(null);\n    this._count -= 1;\n    return current;\n  }\n\n  /**\n   * Removes all nodes based on a callback.\n   * @public\n   * @param {function} cb\n   * @returns {number} number of removed nodes\n   */\n  removeEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.removeEach(cb) expects a callback');\n    }\n\n    let removedCount = 0;\n    let position = 0;\n    let prev = null;\n    let current = this._head;\n    while (current instanceof LinkedListNode) {\n      if (cb(current, position)) {\n        if (prev === null) {\n          this.removeFirst();\n        } else {\n          prev.setNext(prev.getNext().getNext());\n        }\n        this._count -= 1;\n        removedCount += 1;\n      } else {\n        prev = current;\n      }\n      position += 1;\n      current = current.getNext();\n    }\n    return removedCount;\n  }\n\n  /**\n   * Removes a node at a specific position.\n   * @public\n   * @param {number} position\n   * @returns {LinkedListNode}\n   */\n  removeAt(position) {\n    if (\n      Number.isNaN(+position)\n      || position < 0\n      || position >= this._count\n    ) {\n      return null;\n    }\n\n    if (position === 0) {\n      return this.removeFirst();\n    }\n\n    let counter = 1;\n    let prev = this._head;\n    while (counter < position) {\n      counter += 1;\n      prev = prev.getNext();\n    }\n    const removed = prev.getNext();\n    prev.setNext(prev.getNext().getNext());\n    this._count -= 1;\n    return removed.setNext(null);\n  }\n\n  /**\n   * Traverses the list from beginning to end.\n   * @public\n   * @param {function} cb\n   */\n  forEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.forEach(cb) expects a callback');\n    }\n\n    let current = this._head;\n    let position = 0;\n    while (current instanceof LinkedListNode) {\n      cb(current, position);\n      position += 1;\n      current = current.getNext();\n    }\n  }\n\n  /**\n   * Finds one node in the list based on a callback.\n   * @public\n   * @param {function} cb\n   * @param {DoublyLinkedListNode} [startingNode]\n   * @returns {LinkedListNode}\n   */\n  find(cb, startingNode = this._head) {\n    if (typeof cb !== 'function') {\n      throw new Error('.find(cb) expects a callback');\n    }\n\n    if (startingNode && !(startingNode instanceof LinkedListNode)) {\n      throw new Error('.find(cb) expects to start from a LinkedListNode');\n    }\n\n    let current = startingNode;\n    while (current instanceof LinkedListNode) {\n      if (cb(current)) {\n        return current;\n      }\n      current = current.getNext();\n    }\n    return null;\n  }\n\n  /**\n   * Filters the list based on a callback.\n   * @public\n   * @param {function} cb - callback should return true for required nodes.\n   * @returns {LinkedList}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.filter(cb) expects a callback');\n    }\n\n    let last = null;\n    const result = new LinkedList();\n    this.forEach((node, position) => {\n      if (!cb(node, position)) return;\n      last = result.insertLast(node.getValue(), last);\n    });\n    return result;\n  }\n\n  /**\n   * Returns the head node.\n   * @public\n   * @returns {LinkedListNode}\n   */\n  head() {\n    return this._head;\n  }\n\n  /**\n   * Returns the nodes count in the list.\n   * @public\n   * @returns {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * Converts the linked list into an array.\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((node) => result.push(node.getValue()));\n    return result;\n  }\n\n  /**\n   * Checks if the list is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._head === null;\n  }\n\n  /**\n   * Clears the list\n   * @public\n   */\n  clear() {\n    this._head = null;\n    this._count = 0;\n  }\n\n  /**\n   * Creates a linked list from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @return {LinkedList}\n   */\n  static fromArray(values) {\n    if (!Array.isArray(values)) {\n      throw new Error('cannot create LinkedList from none-array values');\n    }\n\n    const linkedList = new LinkedList();\n    let lastInserted = null;\n    values.forEach((value) => {\n      lastInserted = linkedList.insertLast(value, lastInserted);\n    });\n    return linkedList;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n\n\n或者：\n\n/* SinglyLinkedList!!\n* A linked list is similar to an array, it holds a list of values.\n* However, links in a linked list do not have indexes. With\n* a linked list you do not need to predetermine its size as\n* it grows and shrinks as it is edited. This is an example of\n* a singly linked list.\n*/\n\n// Methods - size, head, addLast, addFirst, addAt, removeFirst, removeLast, remove, removeAt, indexOf, isEmpty,  elementAt, get, clean\n\nclass Node {\n  constructor (data) {\n    this.data = data\n    this.next = null\n  }\n}\n\nclass LinkedList {\n  constructor () {\n    this.headNode = null\n    this.length = 0\n  }\n\n  // initiates the currentNode and currentIndex and return as an object\n  initiateNodeAndIndex () {\n    return { currentNode: this.headNode, currentIndex: 0 }\n  }\n\n  // Returns length\n  size () {\n    return this.length\n  }\n\n  // Returns the head\n  head () {\n    return this.headNode?.data || null\n  }\n\n  // Return if the list is empty\n  isEmpty () {\n    return this.length === 0\n  }\n\n  // add a node at last it to linklist\n  addLast (element) {\n    // Check if its the first element\n    if (this.headNode === null) {\n      return this.addFirst(element)\n    }\n    let { currentNode } = this.initiateNodeAndIndex()\n\n    // Loop till there is a node present in the list\n    while (currentNode.next) {\n      currentNode = currentNode.next\n    }\n\n    const node = new Node(element)\n    // Adding node at the end of the list and increase the length\n    currentNode.next = node\n    this.length++\n    return this.size()\n  }\n\n  // add a node at first it to linklist\n  addFirst (element) {\n    const node = new Node(element)\n    node.next = this.headNode\n    this.headNode = node\n    this.length++\n    return this.size()\n  }\n\n  // remove the first from the linklist\n  removeFirst () {\n    const removedNode = this.headNode\n    if (this.length > 0) {\n      this.headNode = this.headNode.next\n      this.length--\n    }\n    console.log(removedNode.data)\n    return removedNode?.data\n  }\n\n  // remove the last from the linklist\n  removeLast () {\n    if (this.isEmpty()) return null\n    if (this.length === 1) {\n      return this.removeFirst()\n    }\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n    while (currentIndex !== this.length - 2) {\n      currentIndex++\n      currentNode = currentNode.next\n    }\n    const removedNode = currentNode.next\n    currentNode.next = null\n    this.length--\n    return removedNode.data\n  }\n\n  // Removes the node with the value as param\n  remove (element) {\n    if (this.isEmpty()) return null\n    let { currentNode } = this.initiateNodeAndIndex()\n    let removedNode = null\n    // Check if the head node is the element to remove\n    if (currentNode.data === element) {\n      return this.removeFirst()\n    }\n    // Check which node is the node to remove\n    while (currentNode?.next) {\n      if (currentNode.next.data === element) {\n        removedNode = currentNode.next\n        currentNode.next = currentNode.next.next\n        this.length--\n        break\n      }\n      currentNode = currentNode.next\n    }\n    return removedNode?.data || null\n  }\n\n  // Returns the index of the element passed as param otherwise -1\n  indexOf (element) {\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n\n    while (currentNode) {\n      // Checking if the node is the element we are searching for\n      if (currentNode.data === element) {\n        return currentIndex\n      }\n      currentNode = currentNode.next\n      currentIndex++\n    }\n    return -1\n  }\n\n  // Returns the element at an index\n  elementAt (index) {\n    if (index >= this.length || index < 0) {\n      throw new RangeError('Out of Range index')\n    }\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n    while (currentIndex < index) {\n      currentIndex++\n      currentNode = currentNode.next\n    }\n    return currentNode.data\n  }\n\n  // Adds the element at specified index\n  addAt (index, element) {\n    // Check if index is out of bounds of list\n    if (index > this.length || index < 0) {\n      throw new RangeError('Out of Range index')\n    }\n    if (index === 0) return this.addFirst(element)\n    if (index === this.length) return this.addLast(element)\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n    const node = new Node(element)\n\n    while (currentIndex !== index - 1) {\n      currentIndex++\n      currentNode = currentNode.next\n    }\n\n    // Adding the node at specified index\n    const tempNode = currentNode.next\n    currentNode.next = node\n    node.next = tempNode\n    // Incrementing the length\n    this.length++\n    return this.size()\n  }\n\n  // Removes the node at specified index\n  removeAt (index) {\n    // Check if index is present in list\n    if (index < 0 || index >= this.length) {\n      throw new RangeError('Out of Range index')\n    }\n    if (index === 0) return this.removeFirst()\n    if (index === this.length) return this.removeLast()\n\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n    while (currentIndex !== index - 1) {\n      currentIndex++\n      currentNode = currentNode.next\n    }\n    const removedNode = currentNode.next\n    currentNode.next = currentNode.next.next\n    // Decrementing the length\n    this.length--\n    return removedNode.data\n  }\n\n  // make the linkedList Empty\n  clean () {\n    this.headNode = null\n    this.length = 0\n  }\n\n  // Method to get the LinkedList\n  get () {\n    const list = []\n    let { currentNode } = this.initiateNodeAndIndex()\n    while (currentNode) {\n      list.push(currentNode.data)\n      currentNode = currentNode.next\n    }\n\n    return list\n  }\n\n  // Method to iterate over the LinkedList\n  iterator () {\n    let { currentNode } = this.initiateNodeAndIndex()\n    if (currentNode === null) return -1\n\n    const iterate = function * () {\n      while (currentNode) {\n        yield currentNode.data\n        currentNode = currentNode.next\n      }\n    }\n    return iterate()\n  }\n\n  // Method to log the LinkedList\n  log () {\n    console.log(JSON.stringify(this.headNode, null, 2))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n\n\nAddTwoNumbers:\n\n/**\n * A LinkedList based solution for Add Two Numbers\n *\n */\nimport { Node } from './SinglyLinkedList.js'\n\n/*\nProblem Statement:\nGiven two non-empty linked lists representing two non-negative integers.\nThe digits are stored in reverse order and each of their nodes contain a single digit.\nAdd the two numbers and return it as a linked list.\n\nLink for the Problem: https://leetcode.com/problems/add-two-numbers/\n*/\n\nclass AddTwoNumbers {\n  constructor () {\n    this.dummyNode = new Node(0)\n  }\n\n  solution (firstList, secondList) {\n    let firstRunner = firstList\n    let secondRunner = secondList\n    let tail = this.dummyNode\n    let carry = 0\n    while (firstRunner != null || secondRunner != null) {\n      const firstNumber = firstRunner ? firstRunner.data : 0\n      const secondNumber = secondRunner ? secondRunner.data : 0\n      const sum = carry + firstNumber + secondNumber\n      carry = parseInt(sum / 10)\n      tail.next = new Node(sum % 10)\n      tail = tail.next\n      if (firstRunner) {\n        firstRunner = firstRunner.next\n      }\n      if (secondRunner) {\n        secondRunner = secondRunner.next\n      }\n    }\n    if (carry > 0) {\n      tail.next = new Node(carry % 10)\n    }\n\n    return this.dummyNode.next\n  }\n\n  solutionToArray () {\n    const list = []\n    let currentNode = this.dummyNode.next\n    while (currentNode) {\n      list.push(currentNode.data)\n      currentNode = currentNode.next\n    }\n\n    return list\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 应用\n\n\n# 循环检测 (CycleDetection)\n\n/**\n * A LinkedList based solution for Detect a Cycle in a list\n * https://en.wikipedia.org/wiki/Cycle_detection\n */\n\nfunction main () {\n  /*\n  Problem Statement:\n  Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\n  Note:\n  * While Solving the problem in given link below, don't use main() function.\n  * Just use only the code inside main() function.\n  * The purpose of using main() function here is to avoid global variables.\n\n  Link for the Problem: https://leetcode.com/problems/linked-list-cycle/\n  */\n  const head = '' // Reference to head is given in the problem. So please ignore this line\n  let fast = head\n  let slow = head\n\n  while (fast != null && fast.next != null && slow != null) {\n    fast = fast.next.next\n    slow = slow.next\n    if (fast === slow) {\n      return true\n    }\n  }\n  return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# RotateListRight\n\n/**\n * A LinkedList based solution for Rotating a List to the right by k places\n */\n\nfunction main () {\n  /*\n  Problem Statement:\n  Given a linked list, rotate the list to the right by k places, where k is non-negative.\n\n  Note:\n  * While Solving the problem in given link below, don't use main() function.\n  * Just use only the code inside main() function.\n  * The purpose of using main() function here is to avoid global variables.\n\n  Link for the Problem: https://leetcode.com/problems/rotate-list/\n  */\n  // Reference to both head and k is given in the problem. So please ignore below two lines\n  let head = ''\n  let k = ''\n  let i = 0\n  let current = head\n  while (current) {\n    i++\n    current = current.next\n  }\n  k %= i\n  current = head\n  let prev = null\n  while (k--) {\n    if (!current || !current.next) {\n      return current\n    } else {\n      while (current.next) {\n        prev = current\n        current = current.next\n      }\n      prev.next = current.next\n      current.next = head\n      head = current\n    }\n  }\n  return head\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * 链表 - 维基百科，自由的百科全书\n * 单向链表 - 维基百科，自由的百科全书\n * Linked list - Wikipedia",normalizedContent:"# 介绍\n\n在计算机科学中，链表（linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针 (pointer)。由于不必须按顺序存储，链表在插入的时候可以达到o(1)o(1)o(1) 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要o(n)o(n)o(n) 的时间，而顺序表相应的时间复杂度分别是o(logn)o(logn)o(logn) 和o(1)o(1)o(1)。\n\n\n\n使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。\n\n在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个 / 或下一个节点的位置的链接（\"links\"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。\n\n链表可以在多种编程语言中实现。像 lisp 和 scheme 这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如 c/c++ 和 java 依靠易变工具来生成链表。\n\n\n# 实现\n\n\n# javascript\n\nclass linkedlistnode {\n  /**\n   * creates a linked list node.\n   * @param {any} value\n   * @param {linkedlistnode} [next]\n   */\n  constructor(value, next) {\n    this._value = value;\n    this.setnext(next);\n  }\n\n  /**\n   * @public\n   * @param {any} value\n   * @returns {linkedlistnode}\n   */\n  setvalue(value) {\n    this._value = value;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {any}\n   */\n  getvalue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {linkedlistnode} [next]\n   * @returns {linkedlistnode}\n   */\n  setnext(next) {\n    if (next && !(next instanceof linkedlistnode)) {\n      throw new error('senext expects a linkedlistnode or null');\n    }\n    this._next = next || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {linkedlistnode}\n   */\n  getnext() {\n    return this._next;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  hasnext() {\n    return this._next instanceof linkedlistnode;\n  }\n}\n\nclass linkedlist {\n  constructor() {\n    this._head = null;\n    this._count = 0;\n  }\n\n  /**\n   * adds a node at the beginning of the list.\n   * @public\n   * @param {any} value\n   * @returns {linkedlistnode}\n   */\n  insertfirst(value) {\n    this._head = new linkedlistnode(value, this._head);\n    this._count += 1;\n    return this._head;\n  }\n\n  /**\n   * adds a node at the end of the list.\n   * @public\n   * @param {any} value\n   * @param {linkedlistnode} [startingnode]\n   * @returns {linkedlistnode}\n   */\n  insertlast(value, startingnode) {\n    if (this.isempty()) {\n      return this.insertfirst(value);\n    }\n\n    if (startingnode && !(startingnode instanceof linkedlistnode)) {\n      throw new error('insertlast expects a linkedlistnode starting node');\n    }\n\n    let current = startingnode || this._head;\n    while (current.hasnext()) {\n      current = current.getnext();\n    }\n\n    current.setnext(new linkedlistnode(value, null));\n    this._count += 1;\n    return current.getnext();\n  }\n\n  /**\n   * adds a node at a specific position.\n   * @public\n   * @param {number} position\n   * @param {any} value\n   * @returns {linkedlistnode}\n   */\n  insertat(position, value) {\n    if (\n      number.isnan(+position)\n      || position < 0 || position > this._count\n    ) {\n      throw new error('insertat expects a position num <= linked list size.');\n    }\n\n    // head node is at position 0\n    if (position === 0) {\n      return this.insertfirst(value);\n    }\n\n    let currentposition = 1;\n    let prev = this._head;\n    while (currentposition < position) {\n      currentposition += 1;\n      prev = prev.getnext();\n    }\n\n    // add it at a position after the head, between prev & prev.getnext()\n    prev.setnext(new linkedlistnode(value, prev.getnext()));\n    this._count += 1;\n    return prev.getnext();\n  }\n\n  /**\n   * removes the head node.\n   * @public\n   * @returns {linkedlistnode}\n   */\n  removefirst() {\n    if (this.isempty()) return null;\n\n    const removed = this._head;\n    this._head = this._head.getnext();\n    this._count -= 1;\n    return removed.setnext(null);\n  }\n\n  /**\n   * removes the last node in the list.\n   * @public\n   * @returns {linkedlistnode}\n   */\n  removelast() {\n    if (this.isempty()) return null;\n\n    let prev = null;\n    let current = this._head;\n    while (current.hasnext()) {\n      prev = current;\n      current = current.getnext();\n    }\n\n    // linked list has 1 node\n    if (prev === null) {\n      return this.removefirst();\n    }\n\n    prev.setnext(null);\n    this._count -= 1;\n    return current;\n  }\n\n  /**\n   * removes all nodes based on a callback.\n   * @public\n   * @param {function} cb\n   * @returns {number} number of removed nodes\n   */\n  removeeach(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.removeeach(cb) expects a callback');\n    }\n\n    let removedcount = 0;\n    let position = 0;\n    let prev = null;\n    let current = this._head;\n    while (current instanceof linkedlistnode) {\n      if (cb(current, position)) {\n        if (prev === null) {\n          this.removefirst();\n        } else {\n          prev.setnext(prev.getnext().getnext());\n        }\n        this._count -= 1;\n        removedcount += 1;\n      } else {\n        prev = current;\n      }\n      position += 1;\n      current = current.getnext();\n    }\n    return removedcount;\n  }\n\n  /**\n   * removes a node at a specific position.\n   * @public\n   * @param {number} position\n   * @returns {linkedlistnode}\n   */\n  removeat(position) {\n    if (\n      number.isnan(+position)\n      || position < 0\n      || position >= this._count\n    ) {\n      return null;\n    }\n\n    if (position === 0) {\n      return this.removefirst();\n    }\n\n    let counter = 1;\n    let prev = this._head;\n    while (counter < position) {\n      counter += 1;\n      prev = prev.getnext();\n    }\n    const removed = prev.getnext();\n    prev.setnext(prev.getnext().getnext());\n    this._count -= 1;\n    return removed.setnext(null);\n  }\n\n  /**\n   * traverses the list from beginning to end.\n   * @public\n   * @param {function} cb\n   */\n  foreach(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.foreach(cb) expects a callback');\n    }\n\n    let current = this._head;\n    let position = 0;\n    while (current instanceof linkedlistnode) {\n      cb(current, position);\n      position += 1;\n      current = current.getnext();\n    }\n  }\n\n  /**\n   * finds one node in the list based on a callback.\n   * @public\n   * @param {function} cb\n   * @param {doublylinkedlistnode} [startingnode]\n   * @returns {linkedlistnode}\n   */\n  find(cb, startingnode = this._head) {\n    if (typeof cb !== 'function') {\n      throw new error('.find(cb) expects a callback');\n    }\n\n    if (startingnode && !(startingnode instanceof linkedlistnode)) {\n      throw new error('.find(cb) expects to start from a linkedlistnode');\n    }\n\n    let current = startingnode;\n    while (current instanceof linkedlistnode) {\n      if (cb(current)) {\n        return current;\n      }\n      current = current.getnext();\n    }\n    return null;\n  }\n\n  /**\n   * filters the list based on a callback.\n   * @public\n   * @param {function} cb - callback should return true for required nodes.\n   * @returns {linkedlist}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.filter(cb) expects a callback');\n    }\n\n    let last = null;\n    const result = new linkedlist();\n    this.foreach((node, position) => {\n      if (!cb(node, position)) return;\n      last = result.insertlast(node.getvalue(), last);\n    });\n    return result;\n  }\n\n  /**\n   * returns the head node.\n   * @public\n   * @returns {linkedlistnode}\n   */\n  head() {\n    return this._head;\n  }\n\n  /**\n   * returns the nodes count in the list.\n   * @public\n   * @returns {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * converts the linked list into an array.\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    const result = [];\n    this.foreach((node) => result.push(node.getvalue()));\n    return result;\n  }\n\n  /**\n   * checks if the list is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._head === null;\n  }\n\n  /**\n   * clears the list\n   * @public\n   */\n  clear() {\n    this._head = null;\n    this._count = 0;\n  }\n\n  /**\n   * creates a linked list from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @return {linkedlist}\n   */\n  static fromarray(values) {\n    if (!array.isarray(values)) {\n      throw new error('cannot create linkedlist from none-array values');\n    }\n\n    const linkedlist = new linkedlist();\n    let lastinserted = null;\n    values.foreach((value) => {\n      lastinserted = linkedlist.insertlast(value, lastinserted);\n    });\n    return linkedlist;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n\n\n或者：\n\n/* singlylinkedlist!!\n* a linked list is similar to an array, it holds a list of values.\n* however, links in a linked list do not have indexes. with\n* a linked list you do not need to predetermine its size as\n* it grows and shrinks as it is edited. this is an example of\n* a singly linked list.\n*/\n\n// methods - size, head, addlast, addfirst, addat, removefirst, removelast, remove, removeat, indexof, isempty,  elementat, get, clean\n\nclass node {\n  constructor (data) {\n    this.data = data\n    this.next = null\n  }\n}\n\nclass linkedlist {\n  constructor () {\n    this.headnode = null\n    this.length = 0\n  }\n\n  // initiates the currentnode and currentindex and return as an object\n  initiatenodeandindex () {\n    return { currentnode: this.headnode, currentindex: 0 }\n  }\n\n  // returns length\n  size () {\n    return this.length\n  }\n\n  // returns the head\n  head () {\n    return this.headnode?.data || null\n  }\n\n  // return if the list is empty\n  isempty () {\n    return this.length === 0\n  }\n\n  // add a node at last it to linklist\n  addlast (element) {\n    // check if its the first element\n    if (this.headnode === null) {\n      return this.addfirst(element)\n    }\n    let { currentnode } = this.initiatenodeandindex()\n\n    // loop till there is a node present in the list\n    while (currentnode.next) {\n      currentnode = currentnode.next\n    }\n\n    const node = new node(element)\n    // adding node at the end of the list and increase the length\n    currentnode.next = node\n    this.length++\n    return this.size()\n  }\n\n  // add a node at first it to linklist\n  addfirst (element) {\n    const node = new node(element)\n    node.next = this.headnode\n    this.headnode = node\n    this.length++\n    return this.size()\n  }\n\n  // remove the first from the linklist\n  removefirst () {\n    const removednode = this.headnode\n    if (this.length > 0) {\n      this.headnode = this.headnode.next\n      this.length--\n    }\n    console.log(removednode.data)\n    return removednode?.data\n  }\n\n  // remove the last from the linklist\n  removelast () {\n    if (this.isempty()) return null\n    if (this.length === 1) {\n      return this.removefirst()\n    }\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n    while (currentindex !== this.length - 2) {\n      currentindex++\n      currentnode = currentnode.next\n    }\n    const removednode = currentnode.next\n    currentnode.next = null\n    this.length--\n    return removednode.data\n  }\n\n  // removes the node with the value as param\n  remove (element) {\n    if (this.isempty()) return null\n    let { currentnode } = this.initiatenodeandindex()\n    let removednode = null\n    // check if the head node is the element to remove\n    if (currentnode.data === element) {\n      return this.removefirst()\n    }\n    // check which node is the node to remove\n    while (currentnode?.next) {\n      if (currentnode.next.data === element) {\n        removednode = currentnode.next\n        currentnode.next = currentnode.next.next\n        this.length--\n        break\n      }\n      currentnode = currentnode.next\n    }\n    return removednode?.data || null\n  }\n\n  // returns the index of the element passed as param otherwise -1\n  indexof (element) {\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n\n    while (currentnode) {\n      // checking if the node is the element we are searching for\n      if (currentnode.data === element) {\n        return currentindex\n      }\n      currentnode = currentnode.next\n      currentindex++\n    }\n    return -1\n  }\n\n  // returns the element at an index\n  elementat (index) {\n    if (index >= this.length || index < 0) {\n      throw new rangeerror('out of range index')\n    }\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n    while (currentindex < index) {\n      currentindex++\n      currentnode = currentnode.next\n    }\n    return currentnode.data\n  }\n\n  // adds the element at specified index\n  addat (index, element) {\n    // check if index is out of bounds of list\n    if (index > this.length || index < 0) {\n      throw new rangeerror('out of range index')\n    }\n    if (index === 0) return this.addfirst(element)\n    if (index === this.length) return this.addlast(element)\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n    const node = new node(element)\n\n    while (currentindex !== index - 1) {\n      currentindex++\n      currentnode = currentnode.next\n    }\n\n    // adding the node at specified index\n    const tempnode = currentnode.next\n    currentnode.next = node\n    node.next = tempnode\n    // incrementing the length\n    this.length++\n    return this.size()\n  }\n\n  // removes the node at specified index\n  removeat (index) {\n    // check if index is present in list\n    if (index < 0 || index >= this.length) {\n      throw new rangeerror('out of range index')\n    }\n    if (index === 0) return this.removefirst()\n    if (index === this.length) return this.removelast()\n\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n    while (currentindex !== index - 1) {\n      currentindex++\n      currentnode = currentnode.next\n    }\n    const removednode = currentnode.next\n    currentnode.next = currentnode.next.next\n    // decrementing the length\n    this.length--\n    return removednode.data\n  }\n\n  // make the linkedlist empty\n  clean () {\n    this.headnode = null\n    this.length = 0\n  }\n\n  // method to get the linkedlist\n  get () {\n    const list = []\n    let { currentnode } = this.initiatenodeandindex()\n    while (currentnode) {\n      list.push(currentnode.data)\n      currentnode = currentnode.next\n    }\n\n    return list\n  }\n\n  // method to iterate over the linkedlist\n  iterator () {\n    let { currentnode } = this.initiatenodeandindex()\n    if (currentnode === null) return -1\n\n    const iterate = function * () {\n      while (currentnode) {\n        yield currentnode.data\n        currentnode = currentnode.next\n      }\n    }\n    return iterate()\n  }\n\n  // method to log the linkedlist\n  log () {\n    console.log(json.stringify(this.headnode, null, 2))\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n\n\naddtwonumbers:\n\n/**\n * a linkedlist based solution for add two numbers\n *\n */\nimport { node } from './singlylinkedlist.js'\n\n/*\nproblem statement:\ngiven two non-empty linked lists representing two non-negative integers.\nthe digits are stored in reverse order and each of their nodes contain a single digit.\nadd the two numbers and return it as a linked list.\n\nlink for the problem: https://leetcode.com/problems/add-two-numbers/\n*/\n\nclass addtwonumbers {\n  constructor () {\n    this.dummynode = new node(0)\n  }\n\n  solution (firstlist, secondlist) {\n    let firstrunner = firstlist\n    let secondrunner = secondlist\n    let tail = this.dummynode\n    let carry = 0\n    while (firstrunner != null || secondrunner != null) {\n      const firstnumber = firstrunner ? firstrunner.data : 0\n      const secondnumber = secondrunner ? secondrunner.data : 0\n      const sum = carry + firstnumber + secondnumber\n      carry = parseint(sum / 10)\n      tail.next = new node(sum % 10)\n      tail = tail.next\n      if (firstrunner) {\n        firstrunner = firstrunner.next\n      }\n      if (secondrunner) {\n        secondrunner = secondrunner.next\n      }\n    }\n    if (carry > 0) {\n      tail.next = new node(carry % 10)\n    }\n\n    return this.dummynode.next\n  }\n\n  solutiontoarray () {\n    const list = []\n    let currentnode = this.dummynode.next\n    while (currentnode) {\n      list.push(currentnode.data)\n      currentnode = currentnode.next\n    }\n\n    return list\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 应用\n\n\n# 循环检测 (cycledetection)\n\n/**\n * a linkedlist based solution for detect a cycle in a list\n * https://en.wikipedia.org/wiki/cycle_detection\n */\n\nfunction main () {\n  /*\n  problem statement:\n  given head, the head of a linked list, determine if the linked list has a cycle in it.\n\n  note:\n  * while solving the problem in given link below, don't use main() function.\n  * just use only the code inside main() function.\n  * the purpose of using main() function here is to avoid global variables.\n\n  link for the problem: https://leetcode.com/problems/linked-list-cycle/\n  */\n  const head = '' // reference to head is given in the problem. so please ignore this line\n  let fast = head\n  let slow = head\n\n  while (fast != null && fast.next != null && slow != null) {\n    fast = fast.next.next\n    slow = slow.next\n    if (fast === slow) {\n      return true\n    }\n  }\n  return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# rotatelistright\n\n/**\n * a linkedlist based solution for rotating a list to the right by k places\n */\n\nfunction main () {\n  /*\n  problem statement:\n  given a linked list, rotate the list to the right by k places, where k is non-negative.\n\n  note:\n  * while solving the problem in given link below, don't use main() function.\n  * just use only the code inside main() function.\n  * the purpose of using main() function here is to avoid global variables.\n\n  link for the problem: https://leetcode.com/problems/rotate-list/\n  */\n  // reference to both head and k is given in the problem. so please ignore below two lines\n  let head = ''\n  let k = ''\n  let i = 0\n  let current = head\n  while (current) {\n    i++\n    current = current.next\n  }\n  k %= i\n  current = head\n  let prev = null\n  while (k--) {\n    if (!current || !current.next) {\n      return current\n    } else {\n      while (current.next) {\n        prev = current\n        current = current.next\n      }\n      prev.next = current.next\n      current.next = head\n      head = current\n    }\n  }\n  return head\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * 链表 - 维基百科，自由的百科全书\n * 单向链表 - 维基百科，自由的百科全书\n * linked list - wikipedia",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"DoublyLinkedList [双向链表]",frontmatter:{title:"DoublyLinkedList [双向链表]",date:"2022-04-26T22:05:40.000Z",permalink:"/ds/linked-list/doublyLinkedList",categories:["数据结构","linked-list链表"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/30.linked-list%20%E9%93%BE%E8%A1%A8/20.doublyLinkedList.html",relativePath:"10.数据结构/30.linked-list 链表/20.doublyLinkedList.md",key:"v-c59b6bb6",path:"/ds/linked-list/doublyLinkedList/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:116},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:123},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:17645}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\nclass DoublyLinkedListNode {\n  /**\n   * Creates a doubly linked list node.\n   * @param {any} value\n   * @param {DoublyLinkedListNode} [prev]\n   * @param {DoublyLinkedListNode} [next]\n   */\n  constructor(value, prev, next) {\n    this._value = value;\n    this.setPrev(prev);\n    this.setNext(next);\n  }\n\n  /**\n   * @public\n   * @param {object} value\n   */\n  setValue(value) {\n    this._value = value;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {object}\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {DoublyLinkedListNode} [next]\n   * @returns {DoublyLinkedListNode}\n   */\n  setNext(next) {\n    if (next && !(next instanceof DoublyLinkedListNode)) {\n      throw new Error('setNext expects a DoublyLinkedListNode or null');\n    }\n    this._next = next || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  getNext() {\n    return this._next;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  hasNext() {\n    return this._next instanceof DoublyLinkedListNode;\n  }\n\n  /**\n   * @public\n   * @param {DoublyLinkedListNode} [prev]\n   * @returns {DoublyLinkedList}\n   */\n  setPrev(prev) {\n    if (prev && !(prev instanceof DoublyLinkedListNode)) {\n      throw new Error('setPrev expects a DoublyLinkedListNode or null');\n    }\n    this._prev = prev || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  getPrev() {\n    return this._prev;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  hasPrev() {\n    return this._prev instanceof DoublyLinkedListNode;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this._head = null;\n    this._tail = null;\n    this._count = 0;\n  }\n\n  /**\n   * Adds a node at the beginning of the list.\n   * @public\n   * @param {any} value\n   * @returns {DoublyLinkedListNode}\n   */\n  insertFirst(value) {\n    const newNode = new DoublyLinkedListNode(value);\n\n    if (this.isEmpty()) {\n      this._head = newNode;\n      this._tail = newNode;\n    } else {\n      this._head.setPrev(newNode);\n      newNode.setNext(this._head);\n      this._head = newNode;\n    }\n    this._count += 1;\n    return newNode;\n  }\n\n  /**\n   * Adds a node at the end of the list.\n   * @public\n   * @param {any} value\n   * @returns {DoublyLinkedListNode}\n   */\n  insertLast(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (this.isEmpty()) {\n      this._head = newNode;\n      this._tail = newNode;\n    } else {\n      newNode.setPrev(this._tail);\n      this._tail.setNext(newNode);\n      this._tail = newNode;\n    }\n    this._count += 1;\n    return newNode;\n  }\n\n  /**\n   * Adds a node at a specific position.\n   * @public\n   * @param {number} position\n   * @param {any} value\n   * @returns {DoublyLinkedListNode}\n   */\n  insertAt(position, value) {\n    if (\n      Number.isNaN(+position)\n      || position < 0 || position > this._count\n    ) {\n      throw new Error('.insertAt expects a position num <= linked list size');\n    }\n\n    if (position === 0) {\n      return this.insertFirst(value);\n    }\n\n    if (position === this._count) {\n      return this.insertLast(value);\n    }\n\n    let currentPosition = 1;\n    let prev = this._head;\n    while (currentPosition < position) {\n      currentPosition += 1;\n      prev = prev.getNext();\n    }\n\n    const newNode = new DoublyLinkedListNode(value);\n    newNode.setNext(prev.getNext());\n    newNode.setPrev(prev);\n    newNode.getNext().setPrev(newNode);\n    newNode.getPrev().setNext(newNode);\n    this._count += 1;\n    return newNode;\n  }\n\n  /**\n   * Removes the head node.\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  removeFirst() {\n    if (this.isEmpty()) return null;\n\n    const removedNode = this._head;\n    if (this._head.hasNext()) {\n      this._head = this._head.getNext();\n      this._head.setPrev(null);\n    } else {\n      this._head = null;\n      this._tail = null;\n    }\n    this._count -= 1;\n    return removedNode.setNext(null);\n  }\n\n  /**\n   * Removes the tail node.\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  removeLast() {\n    if (this.isEmpty()) return null;\n\n    const removedNode = this._tail;\n    if (this._tail.hasPrev()) {\n      this._tail = this._tail.getPrev();\n      this._tail.setNext(null);\n    } else {\n      this._head = null;\n      this._tail = null;\n    }\n    this._count -= 1;\n    return removedNode.setPrev(null);\n  }\n\n  /**\n   * Removes a node in a specific position.\n   * @public\n   * @param {number} position\n   * @returns {DoublyLinkedListNode}\n   */\n  removeAt(position) {\n    if (\n      Number.isNaN(+position)\n      || position < 0\n      || position >= this._count\n    ) {\n      return null;\n    }\n\n    if (position === 0) {\n      return this.removeFirst();\n    }\n\n    if (position === this._count - 1) {\n      return this.removeLast();\n    }\n\n    let currentPosition = 1;\n    let current = this._head.getNext();\n    while (currentPosition < position) {\n      currentPosition += 1;\n      current = current.getNext();\n    }\n    return this.remove(current);\n  }\n\n  /**\n   * Removes a node from the list by its reference.\n   * @public\n   * @param {DoublyLinkedListNode} node\n   * @returns {DoublyLinkedListNode}\n   */\n  remove(node) {\n    if (node && !(node instanceof DoublyLinkedListNode)) {\n      throw new Error('remove: expects a DoublyLinkedListNode node');\n    }\n\n    if (!node) {\n      return null;\n    }\n\n    if (!node.hasPrev()) {\n      return this.removeFirst();\n    }\n\n    if (!node.hasNext()) {\n      return this.removeLast();\n    }\n\n    node.getPrev().setNext(node.getNext());\n    node.getNext().setPrev(node.getPrev());\n    this._count -= 1;\n    return node.setPrev(null).setNext(null);\n  }\n\n  /**\n   * Removes all nodes based on a callback.\n   * @public\n   * @param {function} cb\n   * @returns {number} number of removed nodes\n   */\n  removeEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.removeEach(cb) expects a callback');\n    }\n\n    let removedCount = 0;\n    let position = 0;\n    let current = this._head;\n    while (current instanceof DoublyLinkedListNode) {\n      if (cb(current, position)) {\n        const next = current.getNext();\n        this.remove(current);\n        removedCount += 1;\n        current = next;\n      } else {\n        current = current.getNext();\n      }\n      position += 1;\n    }\n    return removedCount;\n  }\n\n  /**\n   * Traverses the list from beginning to end.\n   * @public\n   * @param {function} cb\n   */\n  forEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.forEach(cb) expects a callback');\n    }\n\n    let current = this._head;\n    let position = 0;\n    while (current instanceof DoublyLinkedListNode) {\n      cb(current, position);\n      position += 1;\n      current = current.getNext();\n    }\n  }\n\n  /**\n   * Traverses the list backward from end to beginning\n   * @public\n   * @param {function} cb\n   */\n  forEachReverse(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.forEachReverse(cb) expects a callback');\n    }\n\n    let current = this._tail;\n    let position = this._count - 1;\n    while (current instanceof DoublyLinkedListNode) {\n      cb(current, position);\n      position -= 1;\n      current = current.getPrev();\n    }\n  }\n\n  /**\n   * Finds a node in the list using a callback\n   * @public\n   * @param {function} cb\n   * @param {DoublyLinkedListNode} [startingNode]\n   * @returns {DoublyLinkedListNode}\n   */\n  find(cb, startingNode = this._head) {\n    if (typeof cb !== 'function') {\n      throw new Error('.find(cb) expects a callback');\n    }\n\n    if (startingNode && !(startingNode instanceof DoublyLinkedListNode)) {\n      throw new Error('.find(cb) expects to start from a DoublyLinkedListNode');\n    }\n\n    let current = startingNode;\n    while (current instanceof DoublyLinkedListNode) {\n      if (cb(current)) {\n        return current;\n      }\n      current = current.getNext();\n    }\n    return null;\n  }\n\n  /**\n   * Finds a node in the list using a callback in reverse order\n   * @public\n   * @param {function} cb\n   * @param {DoublyLinkedListNode} [startingNode]\n   * @returns {DoublyLinkedListNode}\n   */\n  findReverse(cb, startingNode = this._tail) {\n    if (typeof cb !== 'function') {\n      throw new Error('.findReverse(cb) expects a callback');\n    }\n\n    if (startingNode && !(startingNode instanceof DoublyLinkedListNode)) {\n      throw new Error('.findReverse(cb) expects to start from a DoublyLinkedListNode');\n    }\n\n    let current = startingNode;\n    while (current instanceof DoublyLinkedListNode) {\n      if (cb(current)) {\n        return current;\n      }\n      current = current.getPrev();\n    }\n    return null;\n  }\n\n  /**\n   * Filters the list based on a callback.\n   * @public\n   * @param {function} cb\n   * @returns {LinkedList}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.filter(cb) expects a callback');\n    }\n\n    const result = new DoublyLinkedList();\n    this.forEach((node, position) => {\n      if (!cb(node, position)) return;\n      result.insertLast(node.getValue());\n    });\n    return result;\n  }\n\n  /**\n   * Returns the head node.\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  head() {\n    return this._head;\n  }\n\n  /**\n   * Returns the tail node.\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  tail() {\n    return this._tail;\n  }\n\n  /**\n   * Returns the nodes count in the list.\n   * @public\n   * @returns {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * Converts the doubly linked list into an array.\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((node) => result.push(node.getValue()));\n    return result;\n  }\n\n  /**\n   * Checks if the list is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._head === null;\n  }\n\n  /**\n   * Clears the list\n   * @public\n   */\n  clear() {\n    this._head = null;\n    this._tail = null;\n    this._count = 0;\n  }\n\n  /**\n   * Creates a doubly linked list from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @return {DoublyLinkedList}\n   */\n  static fromArray(values) {\n    if (!Array.isArray(values)) {\n      throw new Error('cannot create DoublyLinkedList from none-array values');\n    }\n\n    const doublyLinkedList = new DoublyLinkedList();\n    values.forEach((value) => {\n      doublyLinkedList.insertLast(value);\n    });\n    return doublyLinkedList;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n\n\n或者：\n\nclass Node {\n  constructor (element) {\n    this.element = element\n    this.next = null\n    this.prev = null\n  }\n}\n\nclass DoubleLinkedList {\n  constructor () {\n    this.length = 0\n    this.head = null\n    this.tail = null\n  }\n\n  // Add new element\n  append (element) {\n    const node = new Node(element)\n\n    if (!this.head) {\n      this.head = node\n      this.tail = node\n    } else {\n      node.prev = this.tail\n      this.tail.next = node\n      this.tail = node\n    }\n\n    this.length++\n  }\n\n  // Add element\n  insert (position, element) {\n    // Check of out-of-bound values\n    if (position >= 0 && position <= this.length) {\n      const node = new Node(element)\n      let current = this.head\n      let previous = 0\n      let index = 0\n\n      if (position === 0) {\n        if (!this.head) {\n          this.head = node\n          this.tail = node\n        } else {\n          node.next = current\n          current.prev = node\n          this.head = node\n        }\n      } else if (position === this.length) {\n        current = this.tail\n        current.next = node\n        node.prev = current\n        this.tail = node\n      } else {\n        while (index++ < position) {\n          previous = current\n          current = current.next\n        }\n\n        node.next = current\n        previous.next = node\n\n        // New\n        current.prev = node\n        node.prev = previous\n      }\n\n      this.length++\n      return true\n    } else {\n      return false\n    }\n  }\n\n  // Remove element at any position\n  removeAt (position) {\n    // look for out-of-bounds value\n    if (position > -1 && position < this.length) {\n      let current = this.head\n      let previous = 0\n      let index = 0\n\n      // Removing first item\n      if (position === 0) {\n        this.head = current.next\n\n        // if there is only one item, update this.tail //NEW\n        if (this.length === 1) {\n          this.tail = null\n        } else {\n          this.head.prev = null\n        }\n      } else if (position === this.length - 1) {\n        current = this.tail\n        this.tail = current.prev\n        this.tail.next = null\n      } else {\n        while (index++ < position) {\n          previous = current\n          current = current.next\n        }\n\n        // link previous with current's next - skip it\n        previous.next = current.next\n        current.next.prev = previous\n      }\n\n      this.length--\n      return current.element\n    } else {\n      return null\n    }\n  }\n\n  // Get the indexOf item\n  indexOf (elm) {\n    let current = this.head\n    let index = -1\n\n    // If element found then return its position\n    while (current) {\n      if (elm === current.element) {\n        return ++index\n      }\n\n      index++\n      current = current.next\n    }\n\n    // Else return -1\n    return -1\n  }\n\n  // Find the item in the list\n  isPresent (elm) {\n    return this.indexOf(elm) !== -1\n  }\n\n  // Delete an item from the list\n  delete (elm) {\n    return this.removeAt(this.indexOf(elm))\n  }\n\n  // Delete first item from the list\n  deleteHead () {\n    this.removeAt(0)\n  }\n\n  // Delete last item from the list\n  deleteTail () {\n    this.removeAt(this.length - 1)\n  }\n\n  // Print item of the string\n  toString () {\n    let current = this.head\n    let string = ''\n\n    while (current) {\n      string += current.element + (current.next ? '\\n' : '')\n      current = current.next\n    }\n\n    return string\n  }\n\n  // Convert list to array\n  toArray () {\n    const arr = []\n    let current = this.head\n\n    while (current) {\n      arr.push(current.element)\n      current = current.next\n    }\n\n    return arr\n  }\n\n  // Check if list is empty\n  isEmpty () {\n    return this.length === 0\n  }\n\n  // Get the size of the list\n  size () {\n    return this.length\n  }\n\n  // Get the this.head\n  getHead () {\n    return this.head\n  }\n\n  // Get the this.tail\n  getTail () {\n    return this.tail\n  }\n\n  // Method to iterate over the LinkedList\n  iterator () {\n    let currentNode = this.getHead()\n    if (currentNode === null) return -1\n\n    const iterate = function * () {\n      while (currentNode) {\n        yield currentNode.element\n        currentNode = currentNode.next\n      }\n    }\n    return iterate()\n  }\n\n  // Method to log the LinkedList, for debugging\n  // it' a circular structure, so can't use stringify to debug the whole structure\n  log () {\n    let currentNode = this.getHead()\n    while (currentNode) {\n      console.log(currentNode.element)\n      currentNode = currentNode.next\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n\n\n\n# 参考\n\n * 双向链表 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。\n\n\n\n\n# 实现\n\n\n# javascript\n\nclass doublylinkedlistnode {\n  /**\n   * creates a doubly linked list node.\n   * @param {any} value\n   * @param {doublylinkedlistnode} [prev]\n   * @param {doublylinkedlistnode} [next]\n   */\n  constructor(value, prev, next) {\n    this._value = value;\n    this.setprev(prev);\n    this.setnext(next);\n  }\n\n  /**\n   * @public\n   * @param {object} value\n   */\n  setvalue(value) {\n    this._value = value;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {object}\n   */\n  getvalue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {doublylinkedlistnode} [next]\n   * @returns {doublylinkedlistnode}\n   */\n  setnext(next) {\n    if (next && !(next instanceof doublylinkedlistnode)) {\n      throw new error('setnext expects a doublylinkedlistnode or null');\n    }\n    this._next = next || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {doublylinkedlistnode}\n   */\n  getnext() {\n    return this._next;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  hasnext() {\n    return this._next instanceof doublylinkedlistnode;\n  }\n\n  /**\n   * @public\n   * @param {doublylinkedlistnode} [prev]\n   * @returns {doublylinkedlist}\n   */\n  setprev(prev) {\n    if (prev && !(prev instanceof doublylinkedlistnode)) {\n      throw new error('setprev expects a doublylinkedlistnode or null');\n    }\n    this._prev = prev || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @returns {doublylinkedlistnode}\n   */\n  getprev() {\n    return this._prev;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  hasprev() {\n    return this._prev instanceof doublylinkedlistnode;\n  }\n}\n\nclass doublylinkedlist {\n  constructor() {\n    this._head = null;\n    this._tail = null;\n    this._count = 0;\n  }\n\n  /**\n   * adds a node at the beginning of the list.\n   * @public\n   * @param {any} value\n   * @returns {doublylinkedlistnode}\n   */\n  insertfirst(value) {\n    const newnode = new doublylinkedlistnode(value);\n\n    if (this.isempty()) {\n      this._head = newnode;\n      this._tail = newnode;\n    } else {\n      this._head.setprev(newnode);\n      newnode.setnext(this._head);\n      this._head = newnode;\n    }\n    this._count += 1;\n    return newnode;\n  }\n\n  /**\n   * adds a node at the end of the list.\n   * @public\n   * @param {any} value\n   * @returns {doublylinkedlistnode}\n   */\n  insertlast(value) {\n    const newnode = new doublylinkedlistnode(value);\n    if (this.isempty()) {\n      this._head = newnode;\n      this._tail = newnode;\n    } else {\n      newnode.setprev(this._tail);\n      this._tail.setnext(newnode);\n      this._tail = newnode;\n    }\n    this._count += 1;\n    return newnode;\n  }\n\n  /**\n   * adds a node at a specific position.\n   * @public\n   * @param {number} position\n   * @param {any} value\n   * @returns {doublylinkedlistnode}\n   */\n  insertat(position, value) {\n    if (\n      number.isnan(+position)\n      || position < 0 || position > this._count\n    ) {\n      throw new error('.insertat expects a position num <= linked list size');\n    }\n\n    if (position === 0) {\n      return this.insertfirst(value);\n    }\n\n    if (position === this._count) {\n      return this.insertlast(value);\n    }\n\n    let currentposition = 1;\n    let prev = this._head;\n    while (currentposition < position) {\n      currentposition += 1;\n      prev = prev.getnext();\n    }\n\n    const newnode = new doublylinkedlistnode(value);\n    newnode.setnext(prev.getnext());\n    newnode.setprev(prev);\n    newnode.getnext().setprev(newnode);\n    newnode.getprev().setnext(newnode);\n    this._count += 1;\n    return newnode;\n  }\n\n  /**\n   * removes the head node.\n   * @public\n   * @returns {doublylinkedlistnode}\n   */\n  removefirst() {\n    if (this.isempty()) return null;\n\n    const removednode = this._head;\n    if (this._head.hasnext()) {\n      this._head = this._head.getnext();\n      this._head.setprev(null);\n    } else {\n      this._head = null;\n      this._tail = null;\n    }\n    this._count -= 1;\n    return removednode.setnext(null);\n  }\n\n  /**\n   * removes the tail node.\n   * @public\n   * @returns {doublylinkedlistnode}\n   */\n  removelast() {\n    if (this.isempty()) return null;\n\n    const removednode = this._tail;\n    if (this._tail.hasprev()) {\n      this._tail = this._tail.getprev();\n      this._tail.setnext(null);\n    } else {\n      this._head = null;\n      this._tail = null;\n    }\n    this._count -= 1;\n    return removednode.setprev(null);\n  }\n\n  /**\n   * removes a node in a specific position.\n   * @public\n   * @param {number} position\n   * @returns {doublylinkedlistnode}\n   */\n  removeat(position) {\n    if (\n      number.isnan(+position)\n      || position < 0\n      || position >= this._count\n    ) {\n      return null;\n    }\n\n    if (position === 0) {\n      return this.removefirst();\n    }\n\n    if (position === this._count - 1) {\n      return this.removelast();\n    }\n\n    let currentposition = 1;\n    let current = this._head.getnext();\n    while (currentposition < position) {\n      currentposition += 1;\n      current = current.getnext();\n    }\n    return this.remove(current);\n  }\n\n  /**\n   * removes a node from the list by its reference.\n   * @public\n   * @param {doublylinkedlistnode} node\n   * @returns {doublylinkedlistnode}\n   */\n  remove(node) {\n    if (node && !(node instanceof doublylinkedlistnode)) {\n      throw new error('remove: expects a doublylinkedlistnode node');\n    }\n\n    if (!node) {\n      return null;\n    }\n\n    if (!node.hasprev()) {\n      return this.removefirst();\n    }\n\n    if (!node.hasnext()) {\n      return this.removelast();\n    }\n\n    node.getprev().setnext(node.getnext());\n    node.getnext().setprev(node.getprev());\n    this._count -= 1;\n    return node.setprev(null).setnext(null);\n  }\n\n  /**\n   * removes all nodes based on a callback.\n   * @public\n   * @param {function} cb\n   * @returns {number} number of removed nodes\n   */\n  removeeach(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.removeeach(cb) expects a callback');\n    }\n\n    let removedcount = 0;\n    let position = 0;\n    let current = this._head;\n    while (current instanceof doublylinkedlistnode) {\n      if (cb(current, position)) {\n        const next = current.getnext();\n        this.remove(current);\n        removedcount += 1;\n        current = next;\n      } else {\n        current = current.getnext();\n      }\n      position += 1;\n    }\n    return removedcount;\n  }\n\n  /**\n   * traverses the list from beginning to end.\n   * @public\n   * @param {function} cb\n   */\n  foreach(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.foreach(cb) expects a callback');\n    }\n\n    let current = this._head;\n    let position = 0;\n    while (current instanceof doublylinkedlistnode) {\n      cb(current, position);\n      position += 1;\n      current = current.getnext();\n    }\n  }\n\n  /**\n   * traverses the list backward from end to beginning\n   * @public\n   * @param {function} cb\n   */\n  foreachreverse(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.foreachreverse(cb) expects a callback');\n    }\n\n    let current = this._tail;\n    let position = this._count - 1;\n    while (current instanceof doublylinkedlistnode) {\n      cb(current, position);\n      position -= 1;\n      current = current.getprev();\n    }\n  }\n\n  /**\n   * finds a node in the list using a callback\n   * @public\n   * @param {function} cb\n   * @param {doublylinkedlistnode} [startingnode]\n   * @returns {doublylinkedlistnode}\n   */\n  find(cb, startingnode = this._head) {\n    if (typeof cb !== 'function') {\n      throw new error('.find(cb) expects a callback');\n    }\n\n    if (startingnode && !(startingnode instanceof doublylinkedlistnode)) {\n      throw new error('.find(cb) expects to start from a doublylinkedlistnode');\n    }\n\n    let current = startingnode;\n    while (current instanceof doublylinkedlistnode) {\n      if (cb(current)) {\n        return current;\n      }\n      current = current.getnext();\n    }\n    return null;\n  }\n\n  /**\n   * finds a node in the list using a callback in reverse order\n   * @public\n   * @param {function} cb\n   * @param {doublylinkedlistnode} [startingnode]\n   * @returns {doublylinkedlistnode}\n   */\n  findreverse(cb, startingnode = this._tail) {\n    if (typeof cb !== 'function') {\n      throw new error('.findreverse(cb) expects a callback');\n    }\n\n    if (startingnode && !(startingnode instanceof doublylinkedlistnode)) {\n      throw new error('.findreverse(cb) expects to start from a doublylinkedlistnode');\n    }\n\n    let current = startingnode;\n    while (current instanceof doublylinkedlistnode) {\n      if (cb(current)) {\n        return current;\n      }\n      current = current.getprev();\n    }\n    return null;\n  }\n\n  /**\n   * filters the list based on a callback.\n   * @public\n   * @param {function} cb\n   * @returns {linkedlist}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.filter(cb) expects a callback');\n    }\n\n    const result = new doublylinkedlist();\n    this.foreach((node, position) => {\n      if (!cb(node, position)) return;\n      result.insertlast(node.getvalue());\n    });\n    return result;\n  }\n\n  /**\n   * returns the head node.\n   * @public\n   * @returns {doublylinkedlistnode}\n   */\n  head() {\n    return this._head;\n  }\n\n  /**\n   * returns the tail node.\n   * @public\n   * @returns {doublylinkedlistnode}\n   */\n  tail() {\n    return this._tail;\n  }\n\n  /**\n   * returns the nodes count in the list.\n   * @public\n   * @returns {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * converts the doubly linked list into an array.\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    const result = [];\n    this.foreach((node) => result.push(node.getvalue()));\n    return result;\n  }\n\n  /**\n   * checks if the list is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._head === null;\n  }\n\n  /**\n   * clears the list\n   * @public\n   */\n  clear() {\n    this._head = null;\n    this._tail = null;\n    this._count = 0;\n  }\n\n  /**\n   * creates a doubly linked list from an array\n   * @public\n   * @static\n   * @param {array} values\n   * @return {doublylinkedlist}\n   */\n  static fromarray(values) {\n    if (!array.isarray(values)) {\n      throw new error('cannot create doublylinkedlist from none-array values');\n    }\n\n    const doublylinkedlist = new doublylinkedlist();\n    values.foreach((value) => {\n      doublylinkedlist.insertlast(value);\n    });\n    return doublylinkedlist;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n\n\n或者：\n\nclass node {\n  constructor (element) {\n    this.element = element\n    this.next = null\n    this.prev = null\n  }\n}\n\nclass doublelinkedlist {\n  constructor () {\n    this.length = 0\n    this.head = null\n    this.tail = null\n  }\n\n  // add new element\n  append (element) {\n    const node = new node(element)\n\n    if (!this.head) {\n      this.head = node\n      this.tail = node\n    } else {\n      node.prev = this.tail\n      this.tail.next = node\n      this.tail = node\n    }\n\n    this.length++\n  }\n\n  // add element\n  insert (position, element) {\n    // check of out-of-bound values\n    if (position >= 0 && position <= this.length) {\n      const node = new node(element)\n      let current = this.head\n      let previous = 0\n      let index = 0\n\n      if (position === 0) {\n        if (!this.head) {\n          this.head = node\n          this.tail = node\n        } else {\n          node.next = current\n          current.prev = node\n          this.head = node\n        }\n      } else if (position === this.length) {\n        current = this.tail\n        current.next = node\n        node.prev = current\n        this.tail = node\n      } else {\n        while (index++ < position) {\n          previous = current\n          current = current.next\n        }\n\n        node.next = current\n        previous.next = node\n\n        // new\n        current.prev = node\n        node.prev = previous\n      }\n\n      this.length++\n      return true\n    } else {\n      return false\n    }\n  }\n\n  // remove element at any position\n  removeat (position) {\n    // look for out-of-bounds value\n    if (position > -1 && position < this.length) {\n      let current = this.head\n      let previous = 0\n      let index = 0\n\n      // removing first item\n      if (position === 0) {\n        this.head = current.next\n\n        // if there is only one item, update this.tail //new\n        if (this.length === 1) {\n          this.tail = null\n        } else {\n          this.head.prev = null\n        }\n      } else if (position === this.length - 1) {\n        current = this.tail\n        this.tail = current.prev\n        this.tail.next = null\n      } else {\n        while (index++ < position) {\n          previous = current\n          current = current.next\n        }\n\n        // link previous with current's next - skip it\n        previous.next = current.next\n        current.next.prev = previous\n      }\n\n      this.length--\n      return current.element\n    } else {\n      return null\n    }\n  }\n\n  // get the indexof item\n  indexof (elm) {\n    let current = this.head\n    let index = -1\n\n    // if element found then return its position\n    while (current) {\n      if (elm === current.element) {\n        return ++index\n      }\n\n      index++\n      current = current.next\n    }\n\n    // else return -1\n    return -1\n  }\n\n  // find the item in the list\n  ispresent (elm) {\n    return this.indexof(elm) !== -1\n  }\n\n  // delete an item from the list\n  delete (elm) {\n    return this.removeat(this.indexof(elm))\n  }\n\n  // delete first item from the list\n  deletehead () {\n    this.removeat(0)\n  }\n\n  // delete last item from the list\n  deletetail () {\n    this.removeat(this.length - 1)\n  }\n\n  // print item of the string\n  tostring () {\n    let current = this.head\n    let string = ''\n\n    while (current) {\n      string += current.element + (current.next ? '\\n' : '')\n      current = current.next\n    }\n\n    return string\n  }\n\n  // convert list to array\n  toarray () {\n    const arr = []\n    let current = this.head\n\n    while (current) {\n      arr.push(current.element)\n      current = current.next\n    }\n\n    return arr\n  }\n\n  // check if list is empty\n  isempty () {\n    return this.length === 0\n  }\n\n  // get the size of the list\n  size () {\n    return this.length\n  }\n\n  // get the this.head\n  gethead () {\n    return this.head\n  }\n\n  // get the this.tail\n  gettail () {\n    return this.tail\n  }\n\n  // method to iterate over the linkedlist\n  iterator () {\n    let currentnode = this.gethead()\n    if (currentnode === null) return -1\n\n    const iterate = function * () {\n      while (currentnode) {\n        yield currentnode.element\n        currentnode = currentnode.next\n      }\n    }\n    return iterate()\n  }\n\n  // method to log the linkedlist, for debugging\n  // it' a circular structure, so can't use stringify to debug the whole structure\n  log () {\n    let currentnode = this.gethead()\n    while (currentnode) {\n      console.log(currentnode.element)\n      currentnode = currentnode.next\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n\n\n\n# 参考\n\n * 双向链表 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/11, 17:42:20",lastUpdatedTimestamp:166548134e4},{title:"SinglyCircularLinkedList [单项循环链表]",frontmatter:{title:"SinglyCircularLinkedList [单项循环链表]",date:"2022-09-26T10:05:25.000Z",permalink:"/pages/c35641/",categories:["数据结构","linked-list 链表","Linked-List"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/30.linked-list%20%E9%93%BE%E8%A1%A8/30.SinglyCircularLinkedList.html",relativePath:"10.数据结构/30.linked-list 链表/30.SinglyCircularLinkedList.md",key:"v-34625985",path:"/pages/c35641/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n// Methods - size, head, isEmpty, getElementAt, addAtFirst, add, clean, insertAt, remove, removeData, printData, get, clear\nimport { Node } from './SinglyLinkedList.js'\n\nclass SinglyCircularLinkedList {\n  constructor () {\n    this.headNode = null\n    this.length = 0\n  }\n\n  // Get size of the linkedList\n  size = () => this.length\n  // Get the headNode data\n  head = () => this.headNode?.data || null\n  // Check if the linkedList is empty\n  isEmpty = () => this.length === 0\n\n  // initiate the node and index\n  initiateNodeAndIndex () {\n    return { currentNode: this.headNode, currentIndex: 0 }\n  }\n\n  // get the data specific to an index\n  getElementAt (index) {\n    if (this.length !== 0 && index >= 0 && index <= this.length) {\n      let { currentNode } = this.initiateNodeAndIndex()\n      for (let i = 0; i < index && currentNode !== null; i++) {\n        currentNode = currentNode.next\n      }\n      return currentNode\n    }\n    return undefined\n  }\n\n  // Add the element in the first position\n  addAtFirst (data) {\n    const node = new Node(data)\n    node.next = this.headNode\n    this.headNode = node\n    this.length++\n    return this.length\n  }\n\n  // Add any data to the end of the linkedList\n  add (data) {\n    if (!this.headNode) { return this.addAtFirst(data) }\n    const node = new Node(data)\n    // Getting the last node\n    const currentNode = this.getElementAt(this.length - 1)\n    currentNode.next = node\n    node.next = this.headNode\n    this.length++\n    return this.length\n  }\n\n  // insert data at a specific position\n  insertAt (index, data) {\n    if (index === 0) return this.addAtFirst(data)\n    if (index === this.length) return this.add(data)\n    if (index < 0 || index > this.length) throw new RangeError(`Index is out of range max ${this.length}`)\n    const node = new Node(data)\n    const previousNode = this.getElementAt(index - 1)\n    node.next = previousNode.next\n    previousNode.next = node\n    this.length++\n    return this.length\n  }\n\n  // find the first index of the data\n  indexOf (data) {\n    let { currentNode } = this.initiateNodeAndIndex()\n    // initializing currentIndex as -1\n    let currentIndex = -1\n    while (currentNode) {\n      if (currentNode.data === data) {\n        return currentIndex + 1\n      }\n      currentIndex++\n      currentNode = currentNode.next\n    }\n    return -1\n  }\n\n  // remove the data from the end of the list\n  remove () {\n    if (this.isEmpty()) return null\n    const secondLastNode = this.getElementAt(this.length - 2)\n    const removedNode = secondLastNode.next\n    secondLastNode.next = this.headNode\n    this.length--\n    return removedNode.data || null\n  }\n\n  // remove the data from the first of the list\n  removeFirst () {\n    if (this.isEmpty()) return null\n    const removedNode = this.headNode\n    if (this.length === 1) {\n      this.clear()\n      return removedNode.data\n    }\n    const lastNode = this.getElementAt(this.length - 1)\n    this.headNode = this.headNode.next\n    lastNode.next = this.headNode\n    this.length--\n    return removedNode.data || null\n  }\n\n  // remove the data from the index\n  removeAt (index) {\n    if (this.isEmpty()) return null\n    if (index === 0) return this.removeFirst()\n    if (index === this.length) return this.remove()\n    if (index < 0 && index > this.length) return null\n    const previousNode = this.getElementAt(index - 1)\n    const currentNode = previousNode.next\n    previousNode.next = currentNode.next\n    this.length--\n    return currentNode.data || null\n  }\n\n  // remove if the data is present\n  removeData (data) {\n    if (this.isEmpty()) return null\n    const index = this.indexOf(data)\n    return this.removeAt(index)\n  }\n\n  // logs the data\n  printData (output = value => console.log(value)) {\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n\n    while (currentNode !== null && currentIndex < this.length) {\n      output(currentNode.data)\n      currentNode = currentNode.next\n      currentIndex++\n    }\n  }\n\n  // get the data from the linkedList\n  get () {\n    let { currentIndex, currentNode } = this.initiateNodeAndIndex()\n    const list = []\n    while (currentNode !== null && currentIndex < this.length) {\n      list.push(currentNode.data)\n      currentNode = currentNode.next\n      currentIndex++\n    }\n    return list\n  }\n\n  clear () {\n    this.headNode = null\n    this.length = 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n",normalizedContent:"# 实现\n\n\n# javascript\n\n// methods - size, head, isempty, getelementat, addatfirst, add, clean, insertat, remove, removedata, printdata, get, clear\nimport { node } from './singlylinkedlist.js'\n\nclass singlycircularlinkedlist {\n  constructor () {\n    this.headnode = null\n    this.length = 0\n  }\n\n  // get size of the linkedlist\n  size = () => this.length\n  // get the headnode data\n  head = () => this.headnode?.data || null\n  // check if the linkedlist is empty\n  isempty = () => this.length === 0\n\n  // initiate the node and index\n  initiatenodeandindex () {\n    return { currentnode: this.headnode, currentindex: 0 }\n  }\n\n  // get the data specific to an index\n  getelementat (index) {\n    if (this.length !== 0 && index >= 0 && index <= this.length) {\n      let { currentnode } = this.initiatenodeandindex()\n      for (let i = 0; i < index && currentnode !== null; i++) {\n        currentnode = currentnode.next\n      }\n      return currentnode\n    }\n    return undefined\n  }\n\n  // add the element in the first position\n  addatfirst (data) {\n    const node = new node(data)\n    node.next = this.headnode\n    this.headnode = node\n    this.length++\n    return this.length\n  }\n\n  // add any data to the end of the linkedlist\n  add (data) {\n    if (!this.headnode) { return this.addatfirst(data) }\n    const node = new node(data)\n    // getting the last node\n    const currentnode = this.getelementat(this.length - 1)\n    currentnode.next = node\n    node.next = this.headnode\n    this.length++\n    return this.length\n  }\n\n  // insert data at a specific position\n  insertat (index, data) {\n    if (index === 0) return this.addatfirst(data)\n    if (index === this.length) return this.add(data)\n    if (index < 0 || index > this.length) throw new rangeerror(`index is out of range max ${this.length}`)\n    const node = new node(data)\n    const previousnode = this.getelementat(index - 1)\n    node.next = previousnode.next\n    previousnode.next = node\n    this.length++\n    return this.length\n  }\n\n  // find the first index of the data\n  indexof (data) {\n    let { currentnode } = this.initiatenodeandindex()\n    // initializing currentindex as -1\n    let currentindex = -1\n    while (currentnode) {\n      if (currentnode.data === data) {\n        return currentindex + 1\n      }\n      currentindex++\n      currentnode = currentnode.next\n    }\n    return -1\n  }\n\n  // remove the data from the end of the list\n  remove () {\n    if (this.isempty()) return null\n    const secondlastnode = this.getelementat(this.length - 2)\n    const removednode = secondlastnode.next\n    secondlastnode.next = this.headnode\n    this.length--\n    return removednode.data || null\n  }\n\n  // remove the data from the first of the list\n  removefirst () {\n    if (this.isempty()) return null\n    const removednode = this.headnode\n    if (this.length === 1) {\n      this.clear()\n      return removednode.data\n    }\n    const lastnode = this.getelementat(this.length - 1)\n    this.headnode = this.headnode.next\n    lastnode.next = this.headnode\n    this.length--\n    return removednode.data || null\n  }\n\n  // remove the data from the index\n  removeat (index) {\n    if (this.isempty()) return null\n    if (index === 0) return this.removefirst()\n    if (index === this.length) return this.remove()\n    if (index < 0 && index > this.length) return null\n    const previousnode = this.getelementat(index - 1)\n    const currentnode = previousnode.next\n    previousnode.next = currentnode.next\n    this.length--\n    return currentnode.data || null\n  }\n\n  // remove if the data is present\n  removedata (data) {\n    if (this.isempty()) return null\n    const index = this.indexof(data)\n    return this.removeat(index)\n  }\n\n  // logs the data\n  printdata (output = value => console.log(value)) {\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n\n    while (currentnode !== null && currentindex < this.length) {\n      output(currentnode.data)\n      currentnode = currentnode.next\n      currentindex++\n    }\n  }\n\n  // get the data from the linkedlist\n  get () {\n    let { currentindex, currentnode } = this.initiatenodeandindex()\n    const list = []\n    while (currentnode !== null && currentindex < this.length) {\n      list.push(currentnode.data)\n      currentnode = currentnode.next\n      currentindex++\n    }\n    return list\n  }\n\n  clear () {\n    this.headnode = null\n    this.length = 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"术语表",frontmatter:{title:"术语表",date:"2022-09-26T11:44:34.000Z",permalink:"/ds/term/",categories:["数据结构"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%9C%AF%E8%AF%AD%E8%A1%A8.html",relativePath:"10.数据结构/4.术语表.md",key:"v-4a6a90eb",path:"/ds/term/",headers:[{level:2,title:"常见数据结构术语中英对照表",slug:"常见数据结构术语中英对照表",normalizedTitle:"常见数据结构术语中英对照表",charIndex:2}],headersStr:"常见数据结构术语中英对照表",content:"# 常见数据结构术语中英对照表\n\n * 数据： Data\n * 数据元素： Data element\n * 数据项： Data item\n * 数据结构： Data structure\n * 逻辑结构： Logical structure\n * 数据类型： Data type\n * 指针： Pointer\n * 顺序存储结构： Sequential storage structure\n * 链状存储结构： Linked storage structure\n * 稠密索引： Dense index\n * 稀疏索引： Sparse index\n * 抽象数据类型： Abstract DataType\n * 算法： Algorithm\n * 正确性： Correctness\n * 可读性： Readability\n * 健壮性： Robustness\n * 频度： Frequency count\n * 时间复杂度： Time complexity\n * 空间复杂度： Space complexity\n * 直接前驱： Immediate predecessor\n * 线性表： Linear list\n * 顺序表： Sequenatial list\n * 单链表： Singly linked list\n * 循环链表： Circylar linked lists\n * 双向链表： Double linked lists\n * 双向循环链表： Double circular linked list\n * 栈： Stack\n * 栈顶： Top\n * 栈底： Botton\n * 后进先出： Last In First Out\n * 上溢： Overflow\n * 下溢： Underflow\n * 共享： Shared\n * 队列： Queue\n * 队尾： Rear\n * 队头： Front\n * 先进后出： First In Last Out\n * 串： String\n * 子串： Substring\n * 模式匹配： Pattern matching\n * 数组： Arrays\n * 行为主序： Row major order\n * 列为主序： Column major order\n * 稀疏矩阵： Sparse matrices\n * 特殊矩阵： Special matrices\n * 三元组表： List of 3_tuples\n * 十字链表： Orthogonal list\n * 广义表： Generalized lists\n * 树： Tree\n * 二叉树： Binary tree\n * 满二叉树： Full binary tree\n * 完全二叉树： Complete binary tree\n * 二叉排序树： Binary sort tree\n * 二叉搜索树： Binary search tree\n * 前序遍历： Preorder traversal\n * 中序遍历： Inorder traversal\n * 后序遍历： Postorder traversal\n * 哈夫曼树： Huffman tree\n * 回溯： Backtrackins\n * 图： Graph\n * 有向图： Directed graph (digraph)\n * 无向图： Undirected graph (undigraph)\n * 有向完全图： Undirected Complete Graph\n * 无向完全图： directed complete graph\n * 稀疏图： Sparse graph\n * 稠密图： Dense graph\n * 网点： Network\n * 邻结点： Adjacent\n * 度： Degree\n * 出度： Outdegree\n * 入度： Indegree\n * 连通图： Connected graph\n * 连通分支： Connected component\n * 强连通图： Strong graph\n * 生成树： Spanning tree\n * 邻接矩阵： Adjacency lists\n * 邻接表： Adjacency lists\n * 邻接多重表： Adjacency multilists\n * 深度优先索引： Depth-First Search\n * 广度优先索引： Breath-First Search\n * 最小生成树： Minimum spanning tree\n * 最短路径： Shortest path\n * 有向无环图： Directed acycline graph\n * 拓扑排序： Topological sort\n * 检索： Searching\n * 关键字： Key\n * 主关键字： Primary key\n * 顺序检索： Sequential search\n * 折半检索： Binary search\n * 分块检索： Blocking search\n * 平衡二叉树： Best wishes alanced binary tree\n * 平衡因子： Balanced factor\n * 直接定址： Immediately allocate\n * 除留余数法： Division method\n * 数字分析法： Digit analysis method\n * 折叠法： Folding method\n * 线性探查： Linear probing\n * 平方取中法： Mid-square method\n * 开放定址法： Open addressing\n * 链地址法： Chaining\n * 排序： Sorting\n * 直接插入排序： Straight insertion sort\n * 希尔排序： Shells method\n * 缩小增量排序： Diminishing increment sort\n * 折半插入排序： Binary insertion sort\n * 二路插入排序： 2_way insertion sort\n * 共享插入排序： Shared insertion sort\n * 冒泡排序： Bubble sort\n * 快速排序： Quick sort\n * 选择排序： Selection sort\n * 直接选择排序： Straight selection sort\n * 树形选择排序： Tree selection sort\n * 锦标赛排序： Tournament sort\n * 堆排序： Heap sort\n * 归并排序： Merging sort\n * 二路归并： 2_way merge\n * 多路归并： Multi_way merge\n * 基数排序： Radix sorting\n * 最低位优先： (LSD) Least Significant Digit First\n * 最高位优先： (MSD) Most Significant Digit First\n * 文件： Files\n * 顺序文件： Sequential file\n * 索引文件： Indexed file\n * 索引顺序存取方法： Indexed Sequential Access Method\n * 虚拟存储存取方法： Virtual Storage Access Method\n * 散列文件： Hashed file\n * 多关键字文件： With more than one key\n * 多重表文件： Multilist file\n * 倒排文件： Inverted file\n * 数据抽象： data abstraction\n * 数据元素： data element\n * 数据对象： data object\n * 数据项： data item\n * 数据类型： data type\n * 抽象数据类型： abstract data type\n * 基本数据类型： atomic data type\n * 固定聚合数据类型： fixed-aggregate data type\n * 可变聚合数据类型： variable-aggregate data type\n * 线性表： linear list\n * 栈： stack\n * 队列： queue\n * 串： string\n * 数组： array\n * 树： tree\n * 图： grabh\n * 前趋： predecessor\n * 后继： successor\n * 直接前趋： immediate predecessor\n * 直接后继： immediate successor\n * 双端列表： deque (double-ended queue)\n * 循环队列： cirular queue\n * 指针： pointer\n * 先进先出表（队列）： first-in first-out list\n * 后进先出表（队列）： last-in first-out list\n * 栈底： bottom\n * 栈顶： top\n * 压入： push\n * 弹出： pop\n * 队头： front\n * 队尾： rear\n * 上溢： overflow\n * 下溢： underflow\n * 数组： array\n * 矩阵： matrix\n * 多维数组： multi-dimentional array\n * 以行为主的顺序分配： row major order\n * 以列为主的顺序分配： column major order\n * 三角矩阵： truangular matrix\n * 对称矩阵： symmetric matrix\n * 稀疏矩阵： sparse matrix\n * 转置矩阵： transposed matrix\n * 链表： linked list\n * 线性链表： linear linked list\n * 单链表： single linked list\n * 多重链表： multilinked list\n * 循环链表： circular linked list\n * 双向链表： doubly linked list\n * 十字链表： orthogonal list\n * 广义表： generalized list\n * 链： link\n * 指针域： pointer field\n * 链域： link field\n * 头结点： head node\n * 头指针： head pointer\n * 尾指针： tail pointer\n * 串： string\n * 空白（空格）串： blank string\n * 空串（零串）： null string\n * 子串： substring\n * 树： tree\n * 子树： subtree\n * 森林： forest\n * 根： root\n * 叶子： leaf\n * 结点： node\n * 深度： depth\n * 层次： level\n * 二叉树： binary tree\n * 平衡二叉树： banlanced binary tree\n * 满二叉树： full binary tree\n * 完全二叉树： complete binary tree\n * 遍历二叉树： traversing binary tree\n * 二叉排序树： binary sort tree\n * 二叉查找树： binary search tree\n * 线索二叉树： threaded binary tree\n * 哈夫曼树： Huffman tree\n * 有序数： ordered tree\n * 无序数： unordered tree\n * 判定树： decision tree\n * 双链树： doubly linked tree\n * 数字查找树： digital search tree\n * 树的遍历： traversal of tree\n * 先序遍历： preorder traversal\n * 中序遍历： inorder traversal\n\n后序遍历 postorder traversal",normalizedContent:"# 常见数据结构术语中英对照表\n\n * 数据： data\n * 数据元素： data element\n * 数据项： data item\n * 数据结构： data structure\n * 逻辑结构： logical structure\n * 数据类型： data type\n * 指针： pointer\n * 顺序存储结构： sequential storage structure\n * 链状存储结构： linked storage structure\n * 稠密索引： dense index\n * 稀疏索引： sparse index\n * 抽象数据类型： abstract datatype\n * 算法： algorithm\n * 正确性： correctness\n * 可读性： readability\n * 健壮性： robustness\n * 频度： frequency count\n * 时间复杂度： time complexity\n * 空间复杂度： space complexity\n * 直接前驱： immediate predecessor\n * 线性表： linear list\n * 顺序表： sequenatial list\n * 单链表： singly linked list\n * 循环链表： circylar linked lists\n * 双向链表： double linked lists\n * 双向循环链表： double circular linked list\n * 栈： stack\n * 栈顶： top\n * 栈底： botton\n * 后进先出： last in first out\n * 上溢： overflow\n * 下溢： underflow\n * 共享： shared\n * 队列： queue\n * 队尾： rear\n * 队头： front\n * 先进后出： first in last out\n * 串： string\n * 子串： substring\n * 模式匹配： pattern matching\n * 数组： arrays\n * 行为主序： row major order\n * 列为主序： column major order\n * 稀疏矩阵： sparse matrices\n * 特殊矩阵： special matrices\n * 三元组表： list of 3_tuples\n * 十字链表： orthogonal list\n * 广义表： generalized lists\n * 树： tree\n * 二叉树： binary tree\n * 满二叉树： full binary tree\n * 完全二叉树： complete binary tree\n * 二叉排序树： binary sort tree\n * 二叉搜索树： binary search tree\n * 前序遍历： preorder traversal\n * 中序遍历： inorder traversal\n * 后序遍历： postorder traversal\n * 哈夫曼树： huffman tree\n * 回溯： backtrackins\n * 图： graph\n * 有向图： directed graph (digraph)\n * 无向图： undirected graph (undigraph)\n * 有向完全图： undirected complete graph\n * 无向完全图： directed complete graph\n * 稀疏图： sparse graph\n * 稠密图： dense graph\n * 网点： network\n * 邻结点： adjacent\n * 度： degree\n * 出度： outdegree\n * 入度： indegree\n * 连通图： connected graph\n * 连通分支： connected component\n * 强连通图： strong graph\n * 生成树： spanning tree\n * 邻接矩阵： adjacency lists\n * 邻接表： adjacency lists\n * 邻接多重表： adjacency multilists\n * 深度优先索引： depth-first search\n * 广度优先索引： breath-first search\n * 最小生成树： minimum spanning tree\n * 最短路径： shortest path\n * 有向无环图： directed acycline graph\n * 拓扑排序： topological sort\n * 检索： searching\n * 关键字： key\n * 主关键字： primary key\n * 顺序检索： sequential search\n * 折半检索： binary search\n * 分块检索： blocking search\n * 平衡二叉树： best wishes alanced binary tree\n * 平衡因子： balanced factor\n * 直接定址： immediately allocate\n * 除留余数法： division method\n * 数字分析法： digit analysis method\n * 折叠法： folding method\n * 线性探查： linear probing\n * 平方取中法： mid-square method\n * 开放定址法： open addressing\n * 链地址法： chaining\n * 排序： sorting\n * 直接插入排序： straight insertion sort\n * 希尔排序： shells method\n * 缩小增量排序： diminishing increment sort\n * 折半插入排序： binary insertion sort\n * 二路插入排序： 2_way insertion sort\n * 共享插入排序： shared insertion sort\n * 冒泡排序： bubble sort\n * 快速排序： quick sort\n * 选择排序： selection sort\n * 直接选择排序： straight selection sort\n * 树形选择排序： tree selection sort\n * 锦标赛排序： tournament sort\n * 堆排序： heap sort\n * 归并排序： merging sort\n * 二路归并： 2_way merge\n * 多路归并： multi_way merge\n * 基数排序： radix sorting\n * 最低位优先： (lsd) least significant digit first\n * 最高位优先： (msd) most significant digit first\n * 文件： files\n * 顺序文件： sequential file\n * 索引文件： indexed file\n * 索引顺序存取方法： indexed sequential access method\n * 虚拟存储存取方法： virtual storage access method\n * 散列文件： hashed file\n * 多关键字文件： with more than one key\n * 多重表文件： multilist file\n * 倒排文件： inverted file\n * 数据抽象： data abstraction\n * 数据元素： data element\n * 数据对象： data object\n * 数据项： data item\n * 数据类型： data type\n * 抽象数据类型： abstract data type\n * 基本数据类型： atomic data type\n * 固定聚合数据类型： fixed-aggregate data type\n * 可变聚合数据类型： variable-aggregate data type\n * 线性表： linear list\n * 栈： stack\n * 队列： queue\n * 串： string\n * 数组： array\n * 树： tree\n * 图： grabh\n * 前趋： predecessor\n * 后继： successor\n * 直接前趋： immediate predecessor\n * 直接后继： immediate successor\n * 双端列表： deque (double-ended queue)\n * 循环队列： cirular queue\n * 指针： pointer\n * 先进先出表（队列）： first-in first-out list\n * 后进先出表（队列）： last-in first-out list\n * 栈底： bottom\n * 栈顶： top\n * 压入： push\n * 弹出： pop\n * 队头： front\n * 队尾： rear\n * 上溢： overflow\n * 下溢： underflow\n * 数组： array\n * 矩阵： matrix\n * 多维数组： multi-dimentional array\n * 以行为主的顺序分配： row major order\n * 以列为主的顺序分配： column major order\n * 三角矩阵： truangular matrix\n * 对称矩阵： symmetric matrix\n * 稀疏矩阵： sparse matrix\n * 转置矩阵： transposed matrix\n * 链表： linked list\n * 线性链表： linear linked list\n * 单链表： single linked list\n * 多重链表： multilinked list\n * 循环链表： circular linked list\n * 双向链表： doubly linked list\n * 十字链表： orthogonal list\n * 广义表： generalized list\n * 链： link\n * 指针域： pointer field\n * 链域： link field\n * 头结点： head node\n * 头指针： head pointer\n * 尾指针： tail pointer\n * 串： string\n * 空白（空格）串： blank string\n * 空串（零串）： null string\n * 子串： substring\n * 树： tree\n * 子树： subtree\n * 森林： forest\n * 根： root\n * 叶子： leaf\n * 结点： node\n * 深度： depth\n * 层次： level\n * 二叉树： binary tree\n * 平衡二叉树： banlanced binary tree\n * 满二叉树： full binary tree\n * 完全二叉树： complete binary tree\n * 遍历二叉树： traversing binary tree\n * 二叉排序树： binary sort tree\n * 二叉查找树： binary search tree\n * 线索二叉树： threaded binary tree\n * 哈夫曼树： huffman tree\n * 有序数： ordered tree\n * 无序数： unordered tree\n * 判定树： decision tree\n * 双链树： doubly linked tree\n * 数字查找树： digital search tree\n * 树的遍历： traversal of tree\n * 先序遍历： preorder traversal\n * 中序遍历： inorder traversal\n\n后序遍历 postorder traversal",charsets:{cjk:!0},lastUpdated:"2022/09/26, 19:49:08",lastUpdatedTimestamp:1664192948e3},{title:"Stack [栈]",frontmatter:{title:"Stack [栈]",date:"2022-04-26T22:31:29.000Z",permalink:"/ds/stack/stack/",categories:["数据结构","stack栈"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/40.stack%20%E6%A0%88/10.stack.html",relativePath:"10.数据结构/40.stack 栈/10.stack.md",key:"v-2955bc57",path:"/ds/stack/stack/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:186},{level:2,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:293},{level:2,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:352},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:157},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:638},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:5766},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6937}],headersStr:"介绍 操作 特点 分类 实现 JavaScript 扩展 参考",content:"# 介绍\n\n堆栈（英语：stack）又称为栈或堆叠，是计算机科学中的一种抽象资料类型，只允许在有序的线性资料集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作，堆栈常用一维数组或链表来实现。常与另一种有序的线性资料集合队列相提并论。\n\n\n# 操作\n\n堆栈使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：\n\n * 推入：将资料放入堆栈顶端，堆栈顶端移到新放入的资料。\n * 弹出：将堆栈顶端资料移除，堆栈顶端移到移除后的下一笔资料。\n\n\n# 特点\n\n堆栈的基本特点：\n\n * 先入后出，后入先出。\n * 除头尾节点之外，每个元素有一个前驱，一个后继。\n\n\n# 分类\n\n * 顺序栈：采用顺序存储的栈称为顺序栈，它是利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶的位置。\n * 共享栈：一种特殊的顺序栈，利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。\n\n\n\n * 链栈：采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，top 指向栈顶元素，\n\n\n# 实现\n\n\n# JavaScript\n\nclass Stack {\n  /**\n   * Creates a stack.\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._elements = Array.isArray(elements) ? elements : [];\n  }\n\n  /**\n   * Checks if the stack is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._elements.length === 0;\n  }\n\n  /**\n   * Returns the number of elements in the stack.\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._elements.length;\n  }\n\n  /**\n   * Returns the top element in the stack.\n   * @public\n   * @returns {object}\n   */\n  peek() {\n    if (this.isEmpty()) return null;\n\n    return this._elements[this._elements.length - 1];\n  }\n\n  /**\n   * Adds an element to the top of the stack.\n   * @public\n   * @param {object} element\n   */\n  push(element) {\n    this._elements.push(element);\n    return this;\n  }\n\n  /**\n   * Removes and returns the top element in the stack.\n   * @public\n   * @returns {object}\n   */\n  pop() {\n    if (this.isEmpty()) return null;\n\n    return this._elements.pop();\n  }\n\n  /**\n   * Returns the remaining elements as an array.\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._elements.slice();\n  }\n\n  /**\n   * Clears all elements from the stack.\n   * @public\n   */\n  clear() {\n    this._elements = [];\n  }\n\n  /**\n   * Creates a shallow copy from the stack.\n   * @public\n   * @return {Stack}\n   */\n  clone() {\n    return new Stack(this._elements.slice());\n  }\n\n  /**\n   * Creates a stack from an existing array\n   * @public\n   * @static\n   * @param {array} [elements]\n   * @return {Stack}\n   */\n  static fromArray(elements) {\n    return new Stack(elements);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n或者：\n\n/* Stack data-structure. It's work is based on the LIFO method (last-IN-first-OUT).\n * It means that elements added to the stack are placed on the top and only the\n * last element (from the top) can be reached. After we get access to the last\n * element, he pops from the stack.\n * This is a class-based implementation of a Stack. It provides functions\n * 'push' - to add an element, 'pop' - to remove an element from the top.\n * Also it implements 'length', 'last' and 'isEmpty' properties and\n * static isStack method to check is an object the instance of Stack class.\n */\n\n// Class declaration\nclass Stack {\n  constructor () {\n    this.stack = []\n    this.top = 0\n  }\n\n  // Adds a value to the end of the Stack\n  push (newValue) {\n    this.stack.push(newValue)\n    this.top += 1\n  }\n\n  // Returns and removes the last element of the Stack\n  pop () {\n    if (this.top !== 0) {\n      this.top -= 1\n      return this.stack.pop()\n    }\n    throw new Error('Stack Underflow')\n  }\n\n  // Returns the number of elements in the Stack\n  get length () {\n    return this.top\n  }\n\n  // Returns true if stack is empty, false otherwise\n  get isEmpty () {\n    return this.top === 0\n  }\n\n  // Returns the last element without removing it\n  get last () {\n    if (this.top !== 0) {\n      return this.stack[this.stack.length - 1]\n    }\n    return null\n  }\n\n  // Checks if an object is the instance os the Stack class\n  static isStack (el) {\n    return el instanceof Stack\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n或者使用 ES5:\n\n/* Stack!!\n* A stack is exactly what it sounds like. An element gets added to the top of\n* the stack and only the element on the top may be removed. This is an example\n* of an array implementation of a Stack. So an element can only be added/removed\n* from the end of the array.\n*/\n\n// Functions: push, pop, peek, view, length\n\n// Creates a stack constructor\nconst Stack = (function () {\n  function Stack () {\n    // The top of the Stack\n    this.top = 0\n    // The array representation of the stack\n    this.stack = []\n  }\n\n  // Adds a value onto the end of the stack\n  Stack.prototype.push = function (value) {\n    this.stack[this.top] = value\n    this.top++\n  }\n\n  // Removes and returns the value at the end of the stack\n  Stack.prototype.pop = function () {\n    if (this.top === 0) {\n      return 'Stack is Empty'\n    }\n\n    this.top--\n    const result = this.stack[this.top]\n    this.stack = this.stack.splice(0, this.top)\n    return result\n  }\n\n  // Returns the size of the stack\n  Stack.prototype.size = function () {\n    return this.top\n  }\n\n  // Returns the value at the end of the stack\n  Stack.prototype.peek = function () {\n    return this.stack[this.top - 1]\n  }\n\n  // To see all the elements in the stack\n  Stack.prototype.view = function (output = value => console.log(value)) {\n    for (let i = 0; i < this.top; i++) {\n      output(this.stack[i])\n    }\n  }\n\n  return Stack\n}())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 扩展\n\n使用 Stack 检查表达式中的括号是否平衡（格式正确性）。\n\n// Javascript program for checking balanced brackets\nfunction areBracketsBalanced(expr) {\n  // Using ArrayDeque is faster than using Stack class\n  let stack = [];\n\n  // Traversing the Expression\n  for(let i = 0; i < expr.length; i++) {\n    let x = expr[i];\n\n    if (x == '(' || x == '[' || x == '{') {         \n      // Push the element in the stack\n      stack.push(x);\n      continue;\n    }\n\n    // If current character is not opening bracket, then it must be closing.\n    // So stack cannot be empty at this point.\n    if (stack.length == 0) return false;\n         \n    let check;\n    switch (x) {\n      case ')':\n        check = stack.pop();\n        if (check == '{' || check == '[') return false;\n        break;\n\n      case '}':\n        check = stack.pop();\n        if (check == '(' || check == '[') return false;\n        break;\n\n      case ']':\n        check = stack.pop();\n        if (check == '(' || check == '{') return false;\n        break;\n    }\n  }\n\n  // Check Empty Stack\n  return (stack.length == 0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n参考：Check for Balanced Brackets in an expression (well-formedness) using Stack - GeeksforGeeks\n\n\n# 参考\n\n * 堆栈 - 维基百科，自由的百科全书\n * 数据结构 - 栈（Stack） - 知乎",normalizedContent:"# 介绍\n\n堆栈（英语：stack）又称为栈或堆叠，是计算机科学中的一种抽象资料类型，只允许在有序的线性资料集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（lifo, last in first out）的原理运作，堆栈常用一维数组或链表来实现。常与另一种有序的线性资料集合队列相提并论。\n\n\n# 操作\n\n堆栈使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：\n\n * 推入：将资料放入堆栈顶端，堆栈顶端移到新放入的资料。\n * 弹出：将堆栈顶端资料移除，堆栈顶端移到移除后的下一笔资料。\n\n\n# 特点\n\n堆栈的基本特点：\n\n * 先入后出，后入先出。\n * 除头尾节点之外，每个元素有一个前驱，一个后继。\n\n\n# 分类\n\n * 顺序栈：采用顺序存储的栈称为顺序栈，它是利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶的位置。\n * 共享栈：一种特殊的顺序栈，利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。\n\n\n\n * 链栈：采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，top 指向栈顶元素，\n\n\n# 实现\n\n\n# javascript\n\nclass stack {\n  /**\n   * creates a stack.\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._elements = array.isarray(elements) ? elements : [];\n  }\n\n  /**\n   * checks if the stack is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isempty() {\n    return this._elements.length === 0;\n  }\n\n  /**\n   * returns the number of elements in the stack.\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._elements.length;\n  }\n\n  /**\n   * returns the top element in the stack.\n   * @public\n   * @returns {object}\n   */\n  peek() {\n    if (this.isempty()) return null;\n\n    return this._elements[this._elements.length - 1];\n  }\n\n  /**\n   * adds an element to the top of the stack.\n   * @public\n   * @param {object} element\n   */\n  push(element) {\n    this._elements.push(element);\n    return this;\n  }\n\n  /**\n   * removes and returns the top element in the stack.\n   * @public\n   * @returns {object}\n   */\n  pop() {\n    if (this.isempty()) return null;\n\n    return this._elements.pop();\n  }\n\n  /**\n   * returns the remaining elements as an array.\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    return this._elements.slice();\n  }\n\n  /**\n   * clears all elements from the stack.\n   * @public\n   */\n  clear() {\n    this._elements = [];\n  }\n\n  /**\n   * creates a shallow copy from the stack.\n   * @public\n   * @return {stack}\n   */\n  clone() {\n    return new stack(this._elements.slice());\n  }\n\n  /**\n   * creates a stack from an existing array\n   * @public\n   * @static\n   * @param {array} [elements]\n   * @return {stack}\n   */\n  static fromarray(elements) {\n    return new stack(elements);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n或者：\n\n/* stack data-structure. it's work is based on the lifo method (last-in-first-out).\n * it means that elements added to the stack are placed on the top and only the\n * last element (from the top) can be reached. after we get access to the last\n * element, he pops from the stack.\n * this is a class-based implementation of a stack. it provides functions\n * 'push' - to add an element, 'pop' - to remove an element from the top.\n * also it implements 'length', 'last' and 'isempty' properties and\n * static isstack method to check is an object the instance of stack class.\n */\n\n// class declaration\nclass stack {\n  constructor () {\n    this.stack = []\n    this.top = 0\n  }\n\n  // adds a value to the end of the stack\n  push (newvalue) {\n    this.stack.push(newvalue)\n    this.top += 1\n  }\n\n  // returns and removes the last element of the stack\n  pop () {\n    if (this.top !== 0) {\n      this.top -= 1\n      return this.stack.pop()\n    }\n    throw new error('stack underflow')\n  }\n\n  // returns the number of elements in the stack\n  get length () {\n    return this.top\n  }\n\n  // returns true if stack is empty, false otherwise\n  get isempty () {\n    return this.top === 0\n  }\n\n  // returns the last element without removing it\n  get last () {\n    if (this.top !== 0) {\n      return this.stack[this.stack.length - 1]\n    }\n    return null\n  }\n\n  // checks if an object is the instance os the stack class\n  static isstack (el) {\n    return el instanceof stack\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n或者使用 es5:\n\n/* stack!!\n* a stack is exactly what it sounds like. an element gets added to the top of\n* the stack and only the element on the top may be removed. this is an example\n* of an array implementation of a stack. so an element can only be added/removed\n* from the end of the array.\n*/\n\n// functions: push, pop, peek, view, length\n\n// creates a stack constructor\nconst stack = (function () {\n  function stack () {\n    // the top of the stack\n    this.top = 0\n    // the array representation of the stack\n    this.stack = []\n  }\n\n  // adds a value onto the end of the stack\n  stack.prototype.push = function (value) {\n    this.stack[this.top] = value\n    this.top++\n  }\n\n  // removes and returns the value at the end of the stack\n  stack.prototype.pop = function () {\n    if (this.top === 0) {\n      return 'stack is empty'\n    }\n\n    this.top--\n    const result = this.stack[this.top]\n    this.stack = this.stack.splice(0, this.top)\n    return result\n  }\n\n  // returns the size of the stack\n  stack.prototype.size = function () {\n    return this.top\n  }\n\n  // returns the value at the end of the stack\n  stack.prototype.peek = function () {\n    return this.stack[this.top - 1]\n  }\n\n  // to see all the elements in the stack\n  stack.prototype.view = function (output = value => console.log(value)) {\n    for (let i = 0; i < this.top; i++) {\n      output(this.stack[i])\n    }\n  }\n\n  return stack\n}())\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 扩展\n\n使用 stack 检查表达式中的括号是否平衡（格式正确性）。\n\n// javascript program for checking balanced brackets\nfunction arebracketsbalanced(expr) {\n  // using arraydeque is faster than using stack class\n  let stack = [];\n\n  // traversing the expression\n  for(let i = 0; i < expr.length; i++) {\n    let x = expr[i];\n\n    if (x == '(' || x == '[' || x == '{') {         \n      // push the element in the stack\n      stack.push(x);\n      continue;\n    }\n\n    // if current character is not opening bracket, then it must be closing.\n    // so stack cannot be empty at this point.\n    if (stack.length == 0) return false;\n         \n    let check;\n    switch (x) {\n      case ')':\n        check = stack.pop();\n        if (check == '{' || check == '[') return false;\n        break;\n\n      case '}':\n        check = stack.pop();\n        if (check == '(' || check == '[') return false;\n        break;\n\n      case ']':\n        check = stack.pop();\n        if (check == '(' || check == '{') return false;\n        break;\n    }\n  }\n\n  // check empty stack\n  return (stack.length == 0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n参考：check for balanced brackets in an expression (well-formedness) using stack - geeksforgeeks\n\n\n# 参考\n\n * 堆栈 - 维基百科，自由的百科全书\n * 数据结构 - 栈（stack） - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:41:26",lastUpdatedTimestamp:1666701686e3},{title:"数据结构简介",frontmatter:{title:"数据结构简介",date:"2022-09-26T19:15:40.000Z",permalink:"/ds/introduction/",categories:["数据结构"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.introduction.html",relativePath:"10.数据结构/5.introduction.md",key:"v-266e70f7",path:"/ds/introduction/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"基本术语",slug:"基本术语",normalizedTitle:"基本术语",charIndex:225},{level:2,title:"数据结构的需求",slug:"数据结构的需求",normalizedTitle:"数据结构的需求",charIndex:666},{level:2,title:"数据结构的优势",slug:"数据结构的优势",normalizedTitle:"数据结构的优势",charIndex:983},{level:2,title:"数据结构的分类",slug:"数据结构的分类",normalizedTitle:"数据结构的分类",charIndex:1297},{level:2,title:"对数据结构的操作",slug:"对数据结构的操作",normalizedTitle:"对数据结构的操作",charIndex:2177}],headersStr:"简介 基本术语 数据结构的需求 数据结构的优势 数据结构的分类 对数据结构的操作",content:"# 简介\n\n数据结构可以被定义为一组数据元素，它提供了一种在计算机中存储和组织数据的有效方法，从而可以有效地使用它。数据结构的一些例子是数组、链表、堆栈、队列等。数据结构被广泛用于计算机科学的几乎每一个方面，如操作系统、编译器设计、人工智能、图形等。\n\n数据结构是许多计算机科学算法的主要部分，因为它们使程序员能够以一种有效的方式处理数据。它在提高软件或程序的性能方面起着至关重要的作用，因为软件的主要功能是尽可能快地存储和检索用户的数据。\n\n\n# 基本术语\n\n数据结构是任何程序或软件的构建块。为一个程序选择合适的数据结构是程序员最困难的任务。就数据结构而言，我们使用了以下术语。\n\n * 数据。数据可以被定义为一个基本的值或值的集合，例如，学生的名字和它的 ID 是关于学生的数据。\n * 组项目（Group Items）。有下级数据项的数据项被称为组项，例如，学生的名字可以有名字和姓氏。\n * 记录（Record）。记录可以被定义为各种数据项的集合，例如，如果我们谈论学生实体，那么它的名字、地址、课程和分数可以被组合在一起，形成学生的记录。\n * 文件（File）：文件是一种类型的实体的各种记录的集合，例如，如果班上有 60 名员工，那么在相关的文件中会有 20 条记录，每条记录包含每个员工的数据。\n * 属性和实体（Attribute and Entity）。一个实体代表了某一类的对象。它包含各种属性。每个属性代表该实体的特定属性。\n * 字段（Field）。字段是代表一个实体的属性的单一基本信息单位。\n\n\n# 数据结构的需求\n\n由于应用程序越来越复杂，数据量也与日俱增，可能会出现以下问题。\n\n * 处理器速度：为了处理非常大的数据量，需要高速处理，但由于数据每天都在增长，每个实体有数十亿个文件，处理器可能无法处理这么多的数据量。\n * 数据搜索。考虑一个商店的库存规模为 106 件物品，我们的应用程序需要搜索一个特定的项目，它每次都需要遍历 106 个项目，从而导致搜索过程变慢。\n * 多个请求。如果成千上万的用户同时在网络服务器上搜索数据，那么有可能在这个过程中，一个非常大的服务器会出现故障。\n\n为了解决上述问题，我们使用了数据结构。数据被组织起来形成一个数据结构，使所有的项目都不需要被搜索，所需的数据可以被立即搜索到。\n\n\n# 数据结构的优势\n\n * 效率。一个程序的效率取决于对数据结构的选择。例如：假设我们有一些数据，我们需要对某个特定的记录进行搜索。在这种情况下，如果我们把数据组织在一个数组中，我们将不得不按顺序逐个元素进行搜索，因此，在这里使用数组可能不是很有效率。有一些更好的数据结构可以使搜索过程变得高效，如有序数组、二叉搜索树或哈希表。\n\n * 可重用性。数据结构是可重复使用的，也就是说，一旦我们实现了一个特定的数据结构，我们就可以在任何其他地方使用它。数据结构的实现可以被编译成库，可以被不同的客户使用。\n\n * 抽象。数据结构是由 ADT 指定的，它提供了一个抽象的层次。客户端程序只通过接口使用数据结构，而不涉及实现细节。\n\n\n# 数据结构的分类\n\n\n\n * 线性数据结构。如果一个数据结构的所有元素都以线性顺序排列，那么它就被称为线性数据结构。在线性数据结构中，元素是以非层次的方式存储的，除了第一个和最后一个元素，每个元素都有继承者和前任。下面给出了线性数据结构的类型。\n   * 数组。数组是一个类似类型的数据项的集合，每个数据项被称为数组的一个元素。元素的数据类型可以是任何有效的数据类型，如 char, int, float 或 double。数组中的元素共享相同的变量名，但每个元素都有一个不同的索引号，称为下标。数组可以是一维的，二维的或多维的。\n   * 链表。链表是一种线性数据结构，用于维护内存中的列表。它可以被看作是存储在非相邻内存位置的节点的集合。列表中的每个节点都包含一个指向其相邻节点的指针。\n   * 堆栈。堆栈是一个线性列表，其中只允许在一端插入和删除，称为顶部。堆栈是一种抽象的数据类型（ADT），可以在大多数编程语言中实现。它被命名为堆栈，因为它的行为就像现实世界中的堆栈，例如：一堆盘子或一副牌等等。\n   * 队列。队列是一个线性列表，其中的元素只能在称为后端的一端插入，只能在称为前端的另一端删除。它是一个抽象的数据结构，类似于堆栈。队列是在两端打开的，因此它遵循先进先出（FIFO）的方法来存储数据项。\n * 非线性数据结构。这种数据结构不形成序列，即每个项目或元素以非线性排列方式与两个或多个其他项目相连。数据元素不按顺序结构排列。下面给出了非线性数据结构的类型。\n   * 树。树是一种多层次的数据结构，其元素之间具有层次关系，称为节点。层次结构中最底层的节点被称为叶子节点，而最顶层的节点被称为根节点。每个节点都包含指向相邻节点的指针。树形数据结构基于节点之间的父子关系。除了叶子节点外，树中的每个节点都可以有一个以上的孩子，而除了根节点外，每个节点最多可以有一个父节点。树可以被分为许多类别。\n   * 图。图可以被定义为由称为边的链接所连接的元素集合（用顶点表示）的图形表示。图与树的不同之处在于，图可以有循环，而树不能有循环。\n\n\n# 对数据结构的操作\n\n * 遍历。每个数据结构都包含数据元素的集合。遍历数据结构意味着访问数据结构中的每个元素，以执行一些特定的操作，如搜索或排序。例子：如果我们需要计算一个学生在 6 个不同科目中获得的平均分数，我们需要遍历整个分数数组并计算总和，然后我们将这个总和除以科目数，即 6，以便找到平均分数。\n * 插入。插入可以被定义为在数据结构的任何位置添加元素的过程。如果数据结构的大小为 n，那么我们只能在其中插入 n-1 个数据元素。\n * 删除：从数据结构中删除一个元素的过程被称为删除。我们可以在数据结构中的任何位置删除一个元素。如果我们试图从一个空的数据结构中删除一个元素，就会发生下溢。\n * 搜索：在数据结构中寻找一个元素的位置的过程被称为搜索。有两种算法来执行搜索，线性搜索和二分搜索。\n * 排序。将数据结构按特定顺序排列的过程被称为排序。有许多算法可以用来进行排序，例如，插入排序、选择排序、冒泡排序等。\n * 合并。当两个大小分别为 M 和 N 的列表 A 和列表 B，具有类似的元素类型，通过聚合或连接产生第三个列表，即大小为（M+N）的列表 C，那么这个过程被称为合并。",normalizedContent:"# 简介\n\n数据结构可以被定义为一组数据元素，它提供了一种在计算机中存储和组织数据的有效方法，从而可以有效地使用它。数据结构的一些例子是数组、链表、堆栈、队列等。数据结构被广泛用于计算机科学的几乎每一个方面，如操作系统、编译器设计、人工智能、图形等。\n\n数据结构是许多计算机科学算法的主要部分，因为它们使程序员能够以一种有效的方式处理数据。它在提高软件或程序的性能方面起着至关重要的作用，因为软件的主要功能是尽可能快地存储和检索用户的数据。\n\n\n# 基本术语\n\n数据结构是任何程序或软件的构建块。为一个程序选择合适的数据结构是程序员最困难的任务。就数据结构而言，我们使用了以下术语。\n\n * 数据。数据可以被定义为一个基本的值或值的集合，例如，学生的名字和它的 id 是关于学生的数据。\n * 组项目（group items）。有下级数据项的数据项被称为组项，例如，学生的名字可以有名字和姓氏。\n * 记录（record）。记录可以被定义为各种数据项的集合，例如，如果我们谈论学生实体，那么它的名字、地址、课程和分数可以被组合在一起，形成学生的记录。\n * 文件（file）：文件是一种类型的实体的各种记录的集合，例如，如果班上有 60 名员工，那么在相关的文件中会有 20 条记录，每条记录包含每个员工的数据。\n * 属性和实体（attribute and entity）。一个实体代表了某一类的对象。它包含各种属性。每个属性代表该实体的特定属性。\n * 字段（field）。字段是代表一个实体的属性的单一基本信息单位。\n\n\n# 数据结构的需求\n\n由于应用程序越来越复杂，数据量也与日俱增，可能会出现以下问题。\n\n * 处理器速度：为了处理非常大的数据量，需要高速处理，但由于数据每天都在增长，每个实体有数十亿个文件，处理器可能无法处理这么多的数据量。\n * 数据搜索。考虑一个商店的库存规模为 106 件物品，我们的应用程序需要搜索一个特定的项目，它每次都需要遍历 106 个项目，从而导致搜索过程变慢。\n * 多个请求。如果成千上万的用户同时在网络服务器上搜索数据，那么有可能在这个过程中，一个非常大的服务器会出现故障。\n\n为了解决上述问题，我们使用了数据结构。数据被组织起来形成一个数据结构，使所有的项目都不需要被搜索，所需的数据可以被立即搜索到。\n\n\n# 数据结构的优势\n\n * 效率。一个程序的效率取决于对数据结构的选择。例如：假设我们有一些数据，我们需要对某个特定的记录进行搜索。在这种情况下，如果我们把数据组织在一个数组中，我们将不得不按顺序逐个元素进行搜索，因此，在这里使用数组可能不是很有效率。有一些更好的数据结构可以使搜索过程变得高效，如有序数组、二叉搜索树或哈希表。\n\n * 可重用性。数据结构是可重复使用的，也就是说，一旦我们实现了一个特定的数据结构，我们就可以在任何其他地方使用它。数据结构的实现可以被编译成库，可以被不同的客户使用。\n\n * 抽象。数据结构是由 adt 指定的，它提供了一个抽象的层次。客户端程序只通过接口使用数据结构，而不涉及实现细节。\n\n\n# 数据结构的分类\n\n\n\n * 线性数据结构。如果一个数据结构的所有元素都以线性顺序排列，那么它就被称为线性数据结构。在线性数据结构中，元素是以非层次的方式存储的，除了第一个和最后一个元素，每个元素都有继承者和前任。下面给出了线性数据结构的类型。\n   * 数组。数组是一个类似类型的数据项的集合，每个数据项被称为数组的一个元素。元素的数据类型可以是任何有效的数据类型，如 char, int, float 或 double。数组中的元素共享相同的变量名，但每个元素都有一个不同的索引号，称为下标。数组可以是一维的，二维的或多维的。\n   * 链表。链表是一种线性数据结构，用于维护内存中的列表。它可以被看作是存储在非相邻内存位置的节点的集合。列表中的每个节点都包含一个指向其相邻节点的指针。\n   * 堆栈。堆栈是一个线性列表，其中只允许在一端插入和删除，称为顶部。堆栈是一种抽象的数据类型（adt），可以在大多数编程语言中实现。它被命名为堆栈，因为它的行为就像现实世界中的堆栈，例如：一堆盘子或一副牌等等。\n   * 队列。队列是一个线性列表，其中的元素只能在称为后端的一端插入，只能在称为前端的另一端删除。它是一个抽象的数据结构，类似于堆栈。队列是在两端打开的，因此它遵循先进先出（fifo）的方法来存储数据项。\n * 非线性数据结构。这种数据结构不形成序列，即每个项目或元素以非线性排列方式与两个或多个其他项目相连。数据元素不按顺序结构排列。下面给出了非线性数据结构的类型。\n   * 树。树是一种多层次的数据结构，其元素之间具有层次关系，称为节点。层次结构中最底层的节点被称为叶子节点，而最顶层的节点被称为根节点。每个节点都包含指向相邻节点的指针。树形数据结构基于节点之间的父子关系。除了叶子节点外，树中的每个节点都可以有一个以上的孩子，而除了根节点外，每个节点最多可以有一个父节点。树可以被分为许多类别。\n   * 图。图可以被定义为由称为边的链接所连接的元素集合（用顶点表示）的图形表示。图与树的不同之处在于，图可以有循环，而树不能有循环。\n\n\n# 对数据结构的操作\n\n * 遍历。每个数据结构都包含数据元素的集合。遍历数据结构意味着访问数据结构中的每个元素，以执行一些特定的操作，如搜索或排序。例子：如果我们需要计算一个学生在 6 个不同科目中获得的平均分数，我们需要遍历整个分数数组并计算总和，然后我们将这个总和除以科目数，即 6，以便找到平均分数。\n * 插入。插入可以被定义为在数据结构的任何位置添加元素的过程。如果数据结构的大小为 n，那么我们只能在其中插入 n-1 个数据元素。\n * 删除：从数据结构中删除一个元素的过程被称为删除。我们可以在数据结构中的任何位置删除一个元素。如果我们试图从一个空的数据结构中删除一个元素，就会发生下溢。\n * 搜索：在数据结构中寻找一个元素的位置的过程被称为搜索。有两种算法来执行搜索，线性搜索和二分搜索。\n * 排序。将数据结构按特定顺序排列的过程被称为排序。有许多算法可以用来进行排序，例如，插入排序、选择排序、冒泡排序等。\n * 合并。当两个大小分别为 m 和 n 的列表 a 和列表 b，具有类似的元素类型，通过聚合或连接产生第三个列表，即大小为（m+n）的列表 c，那么这个过程被称为合并。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 19:49:08",lastUpdatedTimestamp:1664192948e3},{title:"EnhancedSet [集合]",frontmatter:{title:"EnhancedSet [集合]",date:"2022-04-26T22:27:40.000Z",permalink:"/ds/set/enhancedSet/",categories:["数据结构","set集合"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/50.set%20%E9%9B%86%E5%90%88/10.enhancedSet.html",relativePath:"10.数据结构/50.set 集合/10.enhancedSet.md",key:"v-5f2c0b7c",path:"/ds/set/enhancedSet/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:106},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:113},{level:3,title:"Go",slug:"go",normalizedTitle:"go",charIndex:1889},{level:2,title:"EnhancedSet",slug:"enhancedset",normalizedTitle:"enhancedset",charIndex:1917},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7544}],headersStr:"介绍 实现 JavaScript Go EnhancedSet 参考",content:"# 介绍\n\n集合（英语：Set），简称集，是一个基本的数学模型，指具有某种特定性质的事物的总体。集合里的事物称作元素，它们可以是任何类型的数学对象：数字、符号、变量、空间中的点、线、面，甚至是其他集合。\n\n\n# 实现\n\n\n# JavaScript\n\n// see https://gist.github.com/vinitkumar/7839388\nfunction Set() {\n  this.values = {};\n  this.n = 0;\n  this.add.apply(this.arguments);\n}\n\n\nSet.prototype.add = function () {\n  var i, \n      val, \n      str;\n  for (i = 0; i < arguments.length; i++) {\n    val = arguments[i];\n    str = Set._v2s(eval);\n    if (!this.values.hasOwnProperty(str)) {\n      this.values[str] = val;\n      this.n++;\n    }\n  }\n  return this;\n};\n\nSet.prototype.remove = function () {\n  var i,\n      l, \n      str;\n  for (i = 0, l = arguments.length; i < l; i ++) {\n    str = Set._v2s(arguments[i]);\n    if (this.values.hasOwnProperty(str)) {\n      delete this.values[str];\n      this.n--;      \n    }\n  }\n  return this;\n};\n\nSet.prototype.contains = function (value) {\n  return this.values.hasOwnProperty(Set._v2s(value));\n};\n\nSet.prototype.size = function () { return this.n; };\n\nSet.prototype.forEach = function(f, context) {\n  var s;\n  for(s in this.values) {\n    if (this.values.hasOwnProperty(s)) { f.call(context, this.values[s]); }\n  }\n};\n\n\nSet._v2s = function (val) {\n  \n  function ObjectId(o) {\n    var prop = \"|**objectid**|\";\n    if (!o.hasOwnProperty(prop)) {\n      o[prop] = Set._v2s.next++;\n    }\n    return o[prop];\n  }\n\n  switch(val) {\n    case undefined: return 'u';\n    case null: return 'n';\n    case true: return 't';\n    case false: return 'f';\n    default: switch(typeof val) {\n      case 'number': return '#' + val;\n      case 'string': return '#' + val;\n      default: return '@' + ObjectId(val);\n    }\n  }\n  \n \n};\n\n\nSet._v2s.next = 100;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# Go\n\n参见：Go 语言 Set 集合简单实现\n\n\n# EnhancedSet\n\nclass EnhancedSet extends Set {\n  /**\n   * Returns a set of all elements of the set and another set\n   * @public\n   * @param {Set} set\n   * @returns {EnhancedSet}\n   */\n  union(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.union expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => result.add(element));\n    set.forEach((element) => result.add(element));\n    return result;\n  }\n\n  /**\n   * Returns the common elements between the set and another set\n   * @public\n   * @param {Set} set\n   * @returns {EnhancedSet}\n   */\n  intersect(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.intersect expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => {\n      if (set.has(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Returns the elements in the set that are not in another set\n   * @public\n   * @param {Set} set\n   * @returns {EnhancedSet}\n   */\n  complement(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.complement expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => {\n      if (!set.has(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Checks if the set is a subset of another set\n   * @public\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  isSubsetOf(set) {\n    if (!(set instanceof Set)) return false;\n\n    let count = 0;\n    this.forEach((element) => {\n      if (set.has(element)) {\n        count += 1;\n      }\n    });\n\n    return count === this.size;\n  }\n\n  /**\n   * Checks if the set is a superset of another set\n   * @public\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  isSupersetOf(set) {\n    if (!(set instanceof Set)) return false;\n\n    let count = 0;\n    set.forEach((element) => {\n      if (this.has(element)) {\n        count += 1;\n      }\n    });\n\n    return count === set.size;\n  }\n\n  /**\n   * Applies a cartesian product（笛卡尔乘积） with another set\n   * @public\n   * @param {Set} set\n   * @param {string} [separator]\n   * @returns {EnhancedSet}\n   */\n  product(set, seprator = '') {\n    if (!(set instanceof Set)) {\n      throw new Error('.product expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((e1) => {\n      set.forEach((e2) => {\n        result.add(`${e1}${seprator}${e2}`);\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Applies cartesian product with the set itself\n   * @public\n   * @param {number} m\n   * @param {string} [separator]\n   * @returns {EnhancedSet}\n   */\n  power(m, seprator = '') {\n    if (Number.isNaN(+m) || +m < 0) {\n      throw new Error('.power expects a positive number');\n    }\n\n    if (+m === 0) return new EnhancedSet();\n\n    let result = this.clone();\n    for (let i = 0; i < +m - 1; i += 1) {\n      result = result.product(this, seprator);\n    }\n\n    return result;\n  }\n\n  /**\n   * Finds m permutations（排列组合） of the set\n   * @public\n   * @param {number} m\n   * @param {string} [separator]\n   * @returns {EnhancedSet}\n   */\n  permutations(m, separator = '') {\n    if (Number.isNaN(+m) || +m < 0) {\n      throw new Error('.permutations expects a positive number');\n    }\n\n    if (m > this.size) {\n      throw new Error('.permutations expects a number less or euqal set size');\n    }\n\n    const result = new EnhancedSet();\n\n    const generatePermutation = (currentSet, i = 0, prefix = '') => {\n      if (i === m && prefix.length > 0) {\n        result.add(prefix);\n        return;\n      }\n\n      currentSet.forEach((el) => {\n        const nextSet = currentSet.clone();\n        nextSet.delete(el);\n        const acc = prefix.length ? `${prefix}${separator}${el}` : `${el}`;\n        generatePermutation(nextSet, i + 1, acc);\n      });\n    };\n\n    generatePermutation(this.clone());\n    return result;\n  }\n\n  /**\n   * Checks if two sets are equal\n   * @public\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  equals(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.equals expects a Set');\n    }\n\n    return this.isSubsetOf(set) && this.size === set.size;\n  }\n\n  /**\n   * Filters the set elements using a callback\n   * @public\n   * @param {function} cb\n   * @returns {EnhancedSet}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.filter expects a callback');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => {\n      if (cb(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Converst the set into an array\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return Array.from(this);\n  }\n\n  /**\n   * Clones the set\n   * @public\n   * @returns {EnhancedSet}\n   */\n  clone() {\n    return new EnhancedSet(this.toArray());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n\n\n\n# 参考\n\n * 集合 (数学) - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n集合（英语：set），简称集，是一个基本的数学模型，指具有某种特定性质的事物的总体。集合里的事物称作元素，它们可以是任何类型的数学对象：数字、符号、变量、空间中的点、线、面，甚至是其他集合。\n\n\n# 实现\n\n\n# javascript\n\n// see https://gist.github.com/vinitkumar/7839388\nfunction set() {\n  this.values = {};\n  this.n = 0;\n  this.add.apply(this.arguments);\n}\n\n\nset.prototype.add = function () {\n  var i, \n      val, \n      str;\n  for (i = 0; i < arguments.length; i++) {\n    val = arguments[i];\n    str = set._v2s(eval);\n    if (!this.values.hasownproperty(str)) {\n      this.values[str] = val;\n      this.n++;\n    }\n  }\n  return this;\n};\n\nset.prototype.remove = function () {\n  var i,\n      l, \n      str;\n  for (i = 0, l = arguments.length; i < l; i ++) {\n    str = set._v2s(arguments[i]);\n    if (this.values.hasownproperty(str)) {\n      delete this.values[str];\n      this.n--;      \n    }\n  }\n  return this;\n};\n\nset.prototype.contains = function (value) {\n  return this.values.hasownproperty(set._v2s(value));\n};\n\nset.prototype.size = function () { return this.n; };\n\nset.prototype.foreach = function(f, context) {\n  var s;\n  for(s in this.values) {\n    if (this.values.hasownproperty(s)) { f.call(context, this.values[s]); }\n  }\n};\n\n\nset._v2s = function (val) {\n  \n  function objectid(o) {\n    var prop = \"|**objectid**|\";\n    if (!o.hasownproperty(prop)) {\n      o[prop] = set._v2s.next++;\n    }\n    return o[prop];\n  }\n\n  switch(val) {\n    case undefined: return 'u';\n    case null: return 'n';\n    case true: return 't';\n    case false: return 'f';\n    default: switch(typeof val) {\n      case 'number': return '#' + val;\n      case 'string': return '#' + val;\n      default: return '@' + objectid(val);\n    }\n  }\n  \n \n};\n\n\nset._v2s.next = 100;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# go\n\n参见：go 语言 set 集合简单实现\n\n\n# enhancedset\n\nclass enhancedset extends set {\n  /**\n   * returns a set of all elements of the set and another set\n   * @public\n   * @param {set} set\n   * @returns {enhancedset}\n   */\n  union(set) {\n    if (!(set instanceof set)) {\n      throw new error('.union expects a set');\n    }\n\n    const result = new enhancedset();\n    this.foreach((element) => result.add(element));\n    set.foreach((element) => result.add(element));\n    return result;\n  }\n\n  /**\n   * returns the common elements between the set and another set\n   * @public\n   * @param {set} set\n   * @returns {enhancedset}\n   */\n  intersect(set) {\n    if (!(set instanceof set)) {\n      throw new error('.intersect expects a set');\n    }\n\n    const result = new enhancedset();\n    this.foreach((element) => {\n      if (set.has(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * returns the elements in the set that are not in another set\n   * @public\n   * @param {set} set\n   * @returns {enhancedset}\n   */\n  complement(set) {\n    if (!(set instanceof set)) {\n      throw new error('.complement expects a set');\n    }\n\n    const result = new enhancedset();\n    this.foreach((element) => {\n      if (!set.has(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * checks if the set is a subset of another set\n   * @public\n   * @param {set} set\n   * @returns {boolean}\n   */\n  issubsetof(set) {\n    if (!(set instanceof set)) return false;\n\n    let count = 0;\n    this.foreach((element) => {\n      if (set.has(element)) {\n        count += 1;\n      }\n    });\n\n    return count === this.size;\n  }\n\n  /**\n   * checks if the set is a superset of another set\n   * @public\n   * @param {set} set\n   * @returns {boolean}\n   */\n  issupersetof(set) {\n    if (!(set instanceof set)) return false;\n\n    let count = 0;\n    set.foreach((element) => {\n      if (this.has(element)) {\n        count += 1;\n      }\n    });\n\n    return count === set.size;\n  }\n\n  /**\n   * applies a cartesian product（笛卡尔乘积） with another set\n   * @public\n   * @param {set} set\n   * @param {string} [separator]\n   * @returns {enhancedset}\n   */\n  product(set, seprator = '') {\n    if (!(set instanceof set)) {\n      throw new error('.product expects a set');\n    }\n\n    const result = new enhancedset();\n    this.foreach((e1) => {\n      set.foreach((e2) => {\n        result.add(`${e1}${seprator}${e2}`);\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * applies cartesian product with the set itself\n   * @public\n   * @param {number} m\n   * @param {string} [separator]\n   * @returns {enhancedset}\n   */\n  power(m, seprator = '') {\n    if (number.isnan(+m) || +m < 0) {\n      throw new error('.power expects a positive number');\n    }\n\n    if (+m === 0) return new enhancedset();\n\n    let result = this.clone();\n    for (let i = 0; i < +m - 1; i += 1) {\n      result = result.product(this, seprator);\n    }\n\n    return result;\n  }\n\n  /**\n   * finds m permutations（排列组合） of the set\n   * @public\n   * @param {number} m\n   * @param {string} [separator]\n   * @returns {enhancedset}\n   */\n  permutations(m, separator = '') {\n    if (number.isnan(+m) || +m < 0) {\n      throw new error('.permutations expects a positive number');\n    }\n\n    if (m > this.size) {\n      throw new error('.permutations expects a number less or euqal set size');\n    }\n\n    const result = new enhancedset();\n\n    const generatepermutation = (currentset, i = 0, prefix = '') => {\n      if (i === m && prefix.length > 0) {\n        result.add(prefix);\n        return;\n      }\n\n      currentset.foreach((el) => {\n        const nextset = currentset.clone();\n        nextset.delete(el);\n        const acc = prefix.length ? `${prefix}${separator}${el}` : `${el}`;\n        generatepermutation(nextset, i + 1, acc);\n      });\n    };\n\n    generatepermutation(this.clone());\n    return result;\n  }\n\n  /**\n   * checks if two sets are equal\n   * @public\n   * @param {set} set\n   * @returns {boolean}\n   */\n  equals(set) {\n    if (!(set instanceof set)) {\n      throw new error('.equals expects a set');\n    }\n\n    return this.issubsetof(set) && this.size === set.size;\n  }\n\n  /**\n   * filters the set elements using a callback\n   * @public\n   * @param {function} cb\n   * @returns {enhancedset}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.filter expects a callback');\n    }\n\n    const result = new enhancedset();\n    this.foreach((element) => {\n      if (cb(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * converst the set into an array\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    return array.from(this);\n  }\n\n  /**\n   * clones the set\n   * @public\n   * @returns {enhancedset}\n   */\n  clone() {\n    return new enhancedset(this.toarray());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n\n\n\n# 参考\n\n * 集合 (数学) - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"Graph [图]",frontmatter:{title:"Graph [图]",date:"2022-04-26T22:16:21.000Z",permalink:"/ds/graph/graph/",categories:["数据结构","graph 图"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/60.graph%20%E5%9B%BE/10.graph.html",relativePath:"10.数据结构/60.graph 图/10.graph.md",key:"v-50ca6409",path:"/ds/graph/graph/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:299},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:306},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6701}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在离散数学中，图（Graph）是用于表示物体与物体之间存在某种关系的结构。数学抽象后的 “物体” 称作节点或顶点（英語：Vertex，node 或 point），节点间的相关关系则称作边。在描绘一张图的时候，通常用一组点或小圆圈表示节点，其间的边则使用直线或曲线。\n\n图中的边可以是有方向或没有方向的。例如在一张图中，如果节点表示聚会上的人，而边表示两人曾经握手，则该图就是没有方向的，因为甲和乙握过手也意味着乙一定和甲握过手。相反，如果一条从甲到乙的边表示甲欠乙的钱，则该图就是有方向的，因为 “曾经欠钱” 这个关系不一定是双向的。前一种图称为无向图，后一种称为有向图。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\nconst { DirectedGraph } = require('./directedGraph');\n\n/**\n * @class Graph\n * @extends DirectedGraph\n */\nclass Graph extends DirectedGraph {\n  /**\n   * Removes all edges connected to a vertex\n   * @public\n   * @override\n   * @param {number|string} key\n   * @return {number} number of removedEdgesCount edges\n   */\n  removeEdges(key) {\n    if (!this.hasVertex(key)) {\n      return 0;\n    }\n\n    let removedEdgesCount = 0;\n    this._edges.get(key).forEach((weight, destKey) => {\n      this.removeEdge(destKey, key);\n      removedEdgesCount += 1;\n    });\n\n    this._edgesCount -= this._edges.get(key).size;\n    this._edges.set(key, new Map());\n    return removedEdgesCount;\n  }\n\n  /**\n   * Adds an edge between two existing vertices\n   * @public\n   * @override\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @param {number} [weight] - default 1\n   */\n  addEdge(sourceKey, destKey, weight) {\n    super.addEdge(sourceKey, destKey, weight);\n    return super.addEdge(destKey, sourceKey, weight);\n  }\n\n  /**\n   * Removes the connecting edge between two vertices\n   * @public\n   * @override\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @returns {boolean}\n   */\n  removeEdge(sourceKey, destKey) {\n    super.removeEdge(sourceKey, destKey);\n    return super.removeEdge(destKey, sourceKey);\n  }\n\n  /**\n   * Gets the number of edges in the graph\n   * @public\n   * @override\n   * @returns {number}\n   */\n  getEdgesCount() {\n    return super.getEdgesCount() / 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n或者\n\nclass Graph {\n  constructor () {\n    this.adjacencyMap = {}\n  }\n\n  addVertex (vertex) {\n    this.adjacencyMap[vertex] = []\n  }\n\n  containsVertex (vertex) {\n    return typeof (this.adjacencyMap[vertex]) !== 'undefined'\n  }\n\n  addEdge (vertex1, vertex2) {\n    if (this.containsVertex(vertex1) && this.containsVertex(vertex2)) {\n      this.adjacencyMap[vertex1].push(vertex2)\n      this.adjacencyMap[vertex2].push(vertex1)\n    }\n  }\n\n  printGraph (output = value => console.log(value)) {\n    const keys = Object.keys(this.adjacencyMap)\n    for (const i of keys) {\n      const values = this.adjacencyMap[i]\n      let vertex = ''\n      for (const j of values) {\n        vertex += j + ' '\n      }\n      output(i + ' -> ' + vertex)\n    }\n  }\n\n  /**\n   * Prints the Breadth first traversal of the graph from source.\n   * @param {number} source The source vertex to start BFS.\n   */\n  bfs (source, output = value => console.log(value)) {\n    const queue = [[source, 0]] // level of source is 0\n    const visited = new Set()\n\n    while (queue.length) {\n      const [node, level] = queue.shift() // remove the front of the queue\n      if (visited.has(node)) { // visited\n        continue\n      }\n\n      visited.add(node)\n      output(`Visited node ${node} at level ${level}.`)\n      for (const next of this.adjacencyMap[node]) {\n        queue.push([next, level + 1]) // level 1 more than current\n      }\n    }\n  }\n\n  /**\n   * Prints the Depth first traversal of the graph from source.\n   * @param {number} source The source vertex to start DFS.\n   */\n  dfs (source, visited = new Set(), output = value => console.log(value)) {\n    if (visited.has(source)) { // visited\n      return\n    }\n\n    output(`Visited node ${source}`)\n    visited.add(source)\n    for (const neighbour of this.adjacencyMap[source]) {\n      this.dfs(neighbour, visited, output)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n或者：\n\nclass Graph {\n  constructor () {\n    this.adjacencyObject = {}\n  }\n\n  addVertex (vertex) {\n    if (!this.adjacencyObject[vertex]) this.adjacencyObject[vertex] = []\n  }\n\n  addEdge (vertex1, vertex2) {\n    this.adjacencyObject[vertex1].push(vertex2)\n    this.adjacencyObject[vertex2].push(vertex1)\n  }\n\n  removeEdge (vertex1, vertex2) {\n    this.adjacencyObject[vertex1] = this.adjacencyObject[vertex1].filter(\n      (v) => v !== vertex2\n    )\n    this.adjacencyObject[vertex2] = this.adjacencyObject[vertex2].filter(\n      (v) => v !== vertex1\n    )\n  }\n\n  removeVertex (vertex) {\n    while (this.adjacencyObject[vertex].length) {\n      const adjacentVertex = this.adjacencyObject[vertex].pop()\n      this.removeEdge(vertex, adjacentVertex)\n    }\n  }\n\n  /**\n   * Return DFS (Depth First Search) List Using Recursive Method\n   */\n  DFS (start) {\n    if (!start) return null\n\n    const result = []\n    const visited = {}\n    const adjacencyObject = this.adjacencyObject\n\n    function dfs (vertex) {\n      if (!vertex) return null\n      visited[vertex] = true\n      result.push(vertex)\n      adjacencyObject[vertex].forEach((neighbor) => {\n        if (!visited[neighbor]) {\n          dfs(neighbor)\n        }\n      })\n    }\n\n    dfs(start)\n    return result\n  }\n\n  /**\n   * Return DFS(Depth First Search) List Using Iteration\n   */\n  DFSIterative (start) {\n    if (!start) return null\n\n    const stack = [start]\n    const visited = {}\n    visited[start] = true\n\n    const result = []\n    let currentVertex\n\n    while (stack.length) {\n      currentVertex = stack.pop()\n      result.push(currentVertex)\n\n      this.adjacencyObject[currentVertex].forEach((neighbor) => {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true\n          stack.push(neighbor)\n        }\n      })\n    }\n    return result\n  }\n\n  BFS (start) {\n    if (!start) return null\n\n    const queue = [start]\n    const visited = {}\n    visited[start] = true\n\n    let currentVertex\n    const result = []\n\n    while (queue.length) {\n      currentVertex = queue.shift()\n      result.push(currentVertex)\n\n      this.adjacencyObject[currentVertex].forEach((neighbor) => {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true\n          queue.push(neighbor)\n        }\n      })\n    }\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\n\n# 参考\n\n * 图 (数学) - Wikiwand",normalizedContent:"# 介绍\n\n在离散数学中，图（graph）是用于表示物体与物体之间存在某种关系的结构。数学抽象后的 “物体” 称作节点或顶点（英語：vertex，node 或 point），节点间的相关关系则称作边。在描绘一张图的时候，通常用一组点或小圆圈表示节点，其间的边则使用直线或曲线。\n\n图中的边可以是有方向或没有方向的。例如在一张图中，如果节点表示聚会上的人，而边表示两人曾经握手，则该图就是没有方向的，因为甲和乙握过手也意味着乙一定和甲握过手。相反，如果一条从甲到乙的边表示甲欠乙的钱，则该图就是有方向的，因为 “曾经欠钱” 这个关系不一定是双向的。前一种图称为无向图，后一种称为有向图。\n\n\n\n\n# 实现\n\n\n# javascript\n\nconst { directedgraph } = require('./directedgraph');\n\n/**\n * @class graph\n * @extends directedgraph\n */\nclass graph extends directedgraph {\n  /**\n   * removes all edges connected to a vertex\n   * @public\n   * @override\n   * @param {number|string} key\n   * @return {number} number of removededgescount edges\n   */\n  removeedges(key) {\n    if (!this.hasvertex(key)) {\n      return 0;\n    }\n\n    let removededgescount = 0;\n    this._edges.get(key).foreach((weight, destkey) => {\n      this.removeedge(destkey, key);\n      removededgescount += 1;\n    });\n\n    this._edgescount -= this._edges.get(key).size;\n    this._edges.set(key, new map());\n    return removededgescount;\n  }\n\n  /**\n   * adds an edge between two existing vertices\n   * @public\n   * @override\n   * @param {number|string} srckey\n   * @param {number|string} destkey\n   * @param {number} [weight] - default 1\n   */\n  addedge(sourcekey, destkey, weight) {\n    super.addedge(sourcekey, destkey, weight);\n    return super.addedge(destkey, sourcekey, weight);\n  }\n\n  /**\n   * removes the connecting edge between two vertices\n   * @public\n   * @override\n   * @param {number|string} srckey\n   * @param {number|string} destkey\n   * @returns {boolean}\n   */\n  removeedge(sourcekey, destkey) {\n    super.removeedge(sourcekey, destkey);\n    return super.removeedge(destkey, sourcekey);\n  }\n\n  /**\n   * gets the number of edges in the graph\n   * @public\n   * @override\n   * @returns {number}\n   */\n  getedgescount() {\n    return super.getedgescount() / 2;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n或者\n\nclass graph {\n  constructor () {\n    this.adjacencymap = {}\n  }\n\n  addvertex (vertex) {\n    this.adjacencymap[vertex] = []\n  }\n\n  containsvertex (vertex) {\n    return typeof (this.adjacencymap[vertex]) !== 'undefined'\n  }\n\n  addedge (vertex1, vertex2) {\n    if (this.containsvertex(vertex1) && this.containsvertex(vertex2)) {\n      this.adjacencymap[vertex1].push(vertex2)\n      this.adjacencymap[vertex2].push(vertex1)\n    }\n  }\n\n  printgraph (output = value => console.log(value)) {\n    const keys = object.keys(this.adjacencymap)\n    for (const i of keys) {\n      const values = this.adjacencymap[i]\n      let vertex = ''\n      for (const j of values) {\n        vertex += j + ' '\n      }\n      output(i + ' -> ' + vertex)\n    }\n  }\n\n  /**\n   * prints the breadth first traversal of the graph from source.\n   * @param {number} source the source vertex to start bfs.\n   */\n  bfs (source, output = value => console.log(value)) {\n    const queue = [[source, 0]] // level of source is 0\n    const visited = new set()\n\n    while (queue.length) {\n      const [node, level] = queue.shift() // remove the front of the queue\n      if (visited.has(node)) { // visited\n        continue\n      }\n\n      visited.add(node)\n      output(`visited node ${node} at level ${level}.`)\n      for (const next of this.adjacencymap[node]) {\n        queue.push([next, level + 1]) // level 1 more than current\n      }\n    }\n  }\n\n  /**\n   * prints the depth first traversal of the graph from source.\n   * @param {number} source the source vertex to start dfs.\n   */\n  dfs (source, visited = new set(), output = value => console.log(value)) {\n    if (visited.has(source)) { // visited\n      return\n    }\n\n    output(`visited node ${source}`)\n    visited.add(source)\n    for (const neighbour of this.adjacencymap[source]) {\n      this.dfs(neighbour, visited, output)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n或者：\n\nclass graph {\n  constructor () {\n    this.adjacencyobject = {}\n  }\n\n  addvertex (vertex) {\n    if (!this.adjacencyobject[vertex]) this.adjacencyobject[vertex] = []\n  }\n\n  addedge (vertex1, vertex2) {\n    this.adjacencyobject[vertex1].push(vertex2)\n    this.adjacencyobject[vertex2].push(vertex1)\n  }\n\n  removeedge (vertex1, vertex2) {\n    this.adjacencyobject[vertex1] = this.adjacencyobject[vertex1].filter(\n      (v) => v !== vertex2\n    )\n    this.adjacencyobject[vertex2] = this.adjacencyobject[vertex2].filter(\n      (v) => v !== vertex1\n    )\n  }\n\n  removevertex (vertex) {\n    while (this.adjacencyobject[vertex].length) {\n      const adjacentvertex = this.adjacencyobject[vertex].pop()\n      this.removeedge(vertex, adjacentvertex)\n    }\n  }\n\n  /**\n   * return dfs (depth first search) list using recursive method\n   */\n  dfs (start) {\n    if (!start) return null\n\n    const result = []\n    const visited = {}\n    const adjacencyobject = this.adjacencyobject\n\n    function dfs (vertex) {\n      if (!vertex) return null\n      visited[vertex] = true\n      result.push(vertex)\n      adjacencyobject[vertex].foreach((neighbor) => {\n        if (!visited[neighbor]) {\n          dfs(neighbor)\n        }\n      })\n    }\n\n    dfs(start)\n    return result\n  }\n\n  /**\n   * return dfs(depth first search) list using iteration\n   */\n  dfsiterative (start) {\n    if (!start) return null\n\n    const stack = [start]\n    const visited = {}\n    visited[start] = true\n\n    const result = []\n    let currentvertex\n\n    while (stack.length) {\n      currentvertex = stack.pop()\n      result.push(currentvertex)\n\n      this.adjacencyobject[currentvertex].foreach((neighbor) => {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true\n          stack.push(neighbor)\n        }\n      })\n    }\n    return result\n  }\n\n  bfs (start) {\n    if (!start) return null\n\n    const queue = [start]\n    const visited = {}\n    visited[start] = true\n\n    let currentvertex\n    const result = []\n\n    while (queue.length) {\n      currentvertex = queue.shift()\n      result.push(currentvertex)\n\n      this.adjacencyobject[currentvertex].foreach((neighbor) => {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true\n          queue.push(neighbor)\n        }\n      })\n    }\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\n\n# 参考\n\n * 图 (数学) - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"DirectedGraph [有向图]",frontmatter:{title:"DirectedGraph [有向图]",date:"2022-04-26T22:15:14.000Z",permalink:"/ds/graph/directedGraph/",categories:["数据结构","graph 图"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/60.graph%20%E5%9B%BE/20.directedGraph.html",relativePath:"10.数据结构/60.graph 图/20.directedGraph.md",key:"v-7e089229",path:"/ds/graph/directedGraph/",headers:[{level:2,title:"有向图",slug:"有向图",normalizedTitle:"有向图",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:54},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:61},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5880}],headersStr:"有向图 实现 JavaScript 参考",content:"# 有向图\n\n边为有方向的图称作有向图（英語：directed graph 或 digraph）。\n\n\n# 实现\n\n\n# JavaScript\n\nconst Queue = require('@datastructures-js/queue');\n\n/**\n * @class\n */\nclass DirectedGraph {\n  constructor() {\n    this._vertices = new Map();\n    this._edges = new Map();\n    this._edgesCount = 0;\n  }\n\n  /**\n   * Adds a vertex to the graph\n   * @public\n   * @param {number|string} key\n   * @param {object} value\n   * @return {DirectedGraph}\n   */\n  addVertex(key, value) {\n    this._vertices.set(key, value);\n    if (!this._edges.has(key)) {\n      this._edges.set(key, new Map());\n    }\n    return this;\n  }\n\n  /**\n   * Checks if the graph has a vertex\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  hasVertex(key) {\n    return this._vertices.has(key);\n  }\n\n  /**\n   * Removes a vertex and all its edges from the graph\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  removeVertex(key) {\n    if (!this.hasVertex(key)) return false;\n\n    this.removeEdges(key);\n    this._edges.delete(key);\n    this._vertices.delete(key);\n    return true;\n  }\n\n  /**\n   * Returns the number of vertices in the graph\n   * @public\n   * @return {number}\n   */\n  getVerticesCount() {\n    return this._vertices.size;\n  }\n\n  /**\n   * Adds a directed edge from a source vertex to a destination\n   * @public\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @param {number} [weight] - default 1\n   */\n  addEdge(srcKey, destKey, weight) {\n    if (!this._vertices.has(srcKey)) {\n      throw new Error(`addEdge: vertex \"${srcKey}\" not found`);\n    }\n\n    if (!this._vertices.has(destKey)) {\n      throw new Error(`addEdge: vertex \"${destKey}\" not found`);\n    }\n\n    if (weight && Number.isNaN(+weight)) {\n      throw new Error('addEdge: expects a numberic weight');\n    }\n\n    const w = Number.isNaN(+weight) ? 1 : +weight;\n    this._edges.get(srcKey).set(destKey, w);\n    this._edgesCount += 1;\n    return this;\n  }\n\n  /**\n   * Checks if there is a direction between two nodes\n   * @public\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @returns {boolean}\n   */\n  hasEdge(srcKey, destKey) {\n    return this.hasVertex(srcKey)\n      && this.hasVertex(destKey)\n      && this._edges.get(srcKey).has(destKey);\n  }\n\n  /**\n   * Gets the weight of an edge if exists\n   * @public\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @returns {number}\n   */\n  getWeight(srcKey, destKey) {\n    if (this.hasVertex(srcKey) && srcKey === destKey) {\n      return 0;\n    }\n\n    if (!this.hasEdge(srcKey, destKey)) {\n      return Infinity;\n    }\n\n    return this._edges.get(srcKey).get(destKey);\n  }\n\n  /**\n   * Removes the direction from source to destination\n   * @public\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   */\n  removeEdge(srcKey, destKey) {\n    if (!this.hasEdge(srcKey, destKey)) {\n      return false;\n    }\n\n    this._edges.get(srcKey).delete(destKey);\n    this._edgesCount -= 1;\n    return true;\n  }\n\n  /**\n   * Removes in and out directions of a vertex\n   * @public\n   * @param {number|string} key\n   * @return {number} number of removed edges\n   */\n  removeEdges(key) {\n    if (!this.hasVertex(key)) {\n      return 0;\n    }\n\n    let removedEdgesCount = 0;\n    this._edges.forEach((destEdges, srcKey) => {\n      if (destEdges.has(key)) {\n        this.removeEdge(srcKey, key);\n        removedEdgesCount += 1;\n      }\n    });\n\n    removedEdgesCount += this._edges.get(key).size;\n    this._edgesCount -= this._edges.get(key).size;\n    this._edges.set(key, new Map());\n    return removedEdgesCount;\n  }\n\n  /**\n   * Returns the number of edges in the graph\n   * @public\n   * @returns {number}\n   */\n  getEdgesCount() {\n    return this._edgesCount;\n  }\n\n  /**\n   * Traverse all vertices in the graph using depth-first search\n   * @public\n   * @param {number|string} srcKey - starting node\n   * @param {function} cb\n   */\n  traverseDfs(srcKey, cb) {\n    const traverseDfsRecursive = (key, visited = new Set()) => {\n      if (!this.hasVertex(key) || visited.has(key)) return;\n\n      cb(key, this._vertices.get(key));\n      visited.add(key);\n\n      this._edges.get(key).forEach((weight, destKey) => {\n        traverseDfsRecursive(destKey, visited);\n      });\n    };\n    traverseDfsRecursive(srcKey);\n  }\n\n  /**\n   * Traverse all vertices in the graph using breadth-first search\n   * @public\n   * @param {number|string} srcKey - starting node\n   * @param {function} cb\n   */\n  traverseBfs(srcKey, cb) {\n    if (!this.hasVertex(srcKey)) return;\n\n    const queue = new Queue([srcKey]);\n    const visited = new Set([srcKey]);\n\n    while (!queue.isEmpty()) {\n      const nextKey = queue.dequeue();\n      cb(nextKey, this._vertices.get(nextKey));\n      this._edges.get(nextKey).forEach((weight, destKey) => {\n        if (!visited.has(destKey)) {\n          queue.enqueue(destKey);\n          visited.add(destKey);\n        }\n      });\n    }\n  }\n\n  /**\n   * Clears the graph\n   * @public\n   */\n  clear() {\n    this._vertices = new Map();\n    this._edges = new Map();\n    this._edgesCount = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n\n\n\n# 参考\n\n * Algorithm-and-Leetcode/DirectedGraph.md at master · Seanforfun/Algorithm-and-Leetcode",normalizedContent:"# 有向图\n\n边为有方向的图称作有向图（英語：directed graph 或 digraph）。\n\n\n# 实现\n\n\n# javascript\n\nconst queue = require('@datastructures-js/queue');\n\n/**\n * @class\n */\nclass directedgraph {\n  constructor() {\n    this._vertices = new map();\n    this._edges = new map();\n    this._edgescount = 0;\n  }\n\n  /**\n   * adds a vertex to the graph\n   * @public\n   * @param {number|string} key\n   * @param {object} value\n   * @return {directedgraph}\n   */\n  addvertex(key, value) {\n    this._vertices.set(key, value);\n    if (!this._edges.has(key)) {\n      this._edges.set(key, new map());\n    }\n    return this;\n  }\n\n  /**\n   * checks if the graph has a vertex\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  hasvertex(key) {\n    return this._vertices.has(key);\n  }\n\n  /**\n   * removes a vertex and all its edges from the graph\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  removevertex(key) {\n    if (!this.hasvertex(key)) return false;\n\n    this.removeedges(key);\n    this._edges.delete(key);\n    this._vertices.delete(key);\n    return true;\n  }\n\n  /**\n   * returns the number of vertices in the graph\n   * @public\n   * @return {number}\n   */\n  getverticescount() {\n    return this._vertices.size;\n  }\n\n  /**\n   * adds a directed edge from a source vertex to a destination\n   * @public\n   * @param {number|string} srckey\n   * @param {number|string} destkey\n   * @param {number} [weight] - default 1\n   */\n  addedge(srckey, destkey, weight) {\n    if (!this._vertices.has(srckey)) {\n      throw new error(`addedge: vertex \"${srckey}\" not found`);\n    }\n\n    if (!this._vertices.has(destkey)) {\n      throw new error(`addedge: vertex \"${destkey}\" not found`);\n    }\n\n    if (weight && number.isnan(+weight)) {\n      throw new error('addedge: expects a numberic weight');\n    }\n\n    const w = number.isnan(+weight) ? 1 : +weight;\n    this._edges.get(srckey).set(destkey, w);\n    this._edgescount += 1;\n    return this;\n  }\n\n  /**\n   * checks if there is a direction between two nodes\n   * @public\n   * @param {number|string} srckey\n   * @param {number|string} destkey\n   * @returns {boolean}\n   */\n  hasedge(srckey, destkey) {\n    return this.hasvertex(srckey)\n      && this.hasvertex(destkey)\n      && this._edges.get(srckey).has(destkey);\n  }\n\n  /**\n   * gets the weight of an edge if exists\n   * @public\n   * @param {number|string} srckey\n   * @param {number|string} destkey\n   * @returns {number}\n   */\n  getweight(srckey, destkey) {\n    if (this.hasvertex(srckey) && srckey === destkey) {\n      return 0;\n    }\n\n    if (!this.hasedge(srckey, destkey)) {\n      return infinity;\n    }\n\n    return this._edges.get(srckey).get(destkey);\n  }\n\n  /**\n   * removes the direction from source to destination\n   * @public\n   * @param {number|string} srckey\n   * @param {number|string} destkey\n   */\n  removeedge(srckey, destkey) {\n    if (!this.hasedge(srckey, destkey)) {\n      return false;\n    }\n\n    this._edges.get(srckey).delete(destkey);\n    this._edgescount -= 1;\n    return true;\n  }\n\n  /**\n   * removes in and out directions of a vertex\n   * @public\n   * @param {number|string} key\n   * @return {number} number of removed edges\n   */\n  removeedges(key) {\n    if (!this.hasvertex(key)) {\n      return 0;\n    }\n\n    let removededgescount = 0;\n    this._edges.foreach((destedges, srckey) => {\n      if (destedges.has(key)) {\n        this.removeedge(srckey, key);\n        removededgescount += 1;\n      }\n    });\n\n    removededgescount += this._edges.get(key).size;\n    this._edgescount -= this._edges.get(key).size;\n    this._edges.set(key, new map());\n    return removededgescount;\n  }\n\n  /**\n   * returns the number of edges in the graph\n   * @public\n   * @returns {number}\n   */\n  getedgescount() {\n    return this._edgescount;\n  }\n\n  /**\n   * traverse all vertices in the graph using depth-first search\n   * @public\n   * @param {number|string} srckey - starting node\n   * @param {function} cb\n   */\n  traversedfs(srckey, cb) {\n    const traversedfsrecursive = (key, visited = new set()) => {\n      if (!this.hasvertex(key) || visited.has(key)) return;\n\n      cb(key, this._vertices.get(key));\n      visited.add(key);\n\n      this._edges.get(key).foreach((weight, destkey) => {\n        traversedfsrecursive(destkey, visited);\n      });\n    };\n    traversedfsrecursive(srckey);\n  }\n\n  /**\n   * traverse all vertices in the graph using breadth-first search\n   * @public\n   * @param {number|string} srckey - starting node\n   * @param {function} cb\n   */\n  traversebfs(srckey, cb) {\n    if (!this.hasvertex(srckey)) return;\n\n    const queue = new queue([srckey]);\n    const visited = new set([srckey]);\n\n    while (!queue.isempty()) {\n      const nextkey = queue.dequeue();\n      cb(nextkey, this._vertices.get(nextkey));\n      this._edges.get(nextkey).foreach((weight, destkey) => {\n        if (!visited.has(destkey)) {\n          queue.enqueue(destkey);\n          visited.add(destkey);\n        }\n      });\n    }\n  }\n\n  /**\n   * clears the graph\n   * @public\n   */\n  clear() {\n    this._vertices = new map();\n    this._edges = new map();\n    this._edgescount = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n\n\n\n# 参考\n\n * algorithm-and-leetcode/directedgraph.md at master · seanforfun/algorithm-and-leetcode",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"BinarySearchTree [二叉搜索树]",frontmatter:{title:"BinarySearchTree [二叉搜索树]",date:"2022-04-26T22:21:37.000Z",permalink:"/ds/tree/binarySearchTree/",categories:["数据结构","tree 树"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/80.tree%20%E6%A0%91/10.binarySearchTree.html",relativePath:"10.数据结构/80.tree 树/10.binarySearchTree.md",key:"v-4da18530",path:"/ds/tree/binarySearchTree/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:653},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:660},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:13891}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n\n * 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n * 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n * 任意节点的左、右子树也分别为二叉查找树；\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log⁡n)O(\\log n)O(logn)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n\n二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以透过建构一棵二叉查找树变成一个有序序列，建构树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望O(log⁡n)O(\\log n)O(logn)，最坏退化为偏斜二元树O(n)O(n)O(n)。对于可能形成偏斜二元树的问题可以经由树高改良后的平衡树将搜寻、插入、删除的时间复杂度都维持在O(log⁡n)O(\\log n)O(logn)，如 AVL 树、红黑树等。\n\n\n# 实现\n\n\n# JavaScript\n\nclass BinarySearchTreeNode {\n  constructor(key, value) {\n    this._key = key;\n    this._value = value;\n    this._left = null;\n    this._right = null;\n    this._parent = null;\n  }\n\n  /**\n   * @public\n   * @param {number|string}\n   * @returns {BinarySearchTreeNode}\n   */\n  setKey(key) {\n    this._key = key;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {number|string}\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * @public\n   * @param {any} value\n   * @returns {BinarySearchTreeNode}\n   */\n  setValue(value) {\n    this._value = value;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {any}\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {BinarySearchTreeNode|null} left\n   * @returns {BinarySearchTreeNode}\n   */\n  setLeft(left) {\n    if (left && !(left instanceof BinarySearchTreeNode)) {\n      throw new Error('setLeft expects a BinarySearchTreeNode or null');\n    }\n\n    this._left = left || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  getLeft() {\n    return this._left;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  hasLeft() {\n    return this._left instanceof BinarySearchTreeNode;\n  }\n\n  /**\n   * @public\n   * @param {BinarySearchTreeNode|null} right\n   * @returns {BinarySearchTreeNode}\n   */\n  setRight(right) {\n    if (right && !(right instanceof BinarySearchTreeNode)) {\n      throw new Error('setRight expects a BinarySearchTreeNode or null');\n    }\n\n    this._right = right || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  getRight() {\n    return this._right;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  hasRight() {\n    return this._right instanceof BinarySearchTreeNode;\n  }\n\n  /**\n   * @public\n   * @param {BinarySearchTreeNode} parent\n   * @returns {BinarySearchTreeNode}\n   */\n  setParent(parent) {\n    if (parent && !(parent instanceof BinarySearchTreeNode)) {\n      throw new Error('setParent expects a BinarySearchTreeNode or null');\n    }\n\n    this._parent = parent || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  getParent() {\n    return this._parent;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  hasParent() {\n    return this._parent instanceof BinarySearchTreeNode;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isRoot() {\n    return this._parent === null;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isLeaf() {\n    return !this.hasLeft() && !this.hasRight();\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this._root = null;\n    this._count = 0;\n  }\n\n  /**\n   * Inserts a node with a key/value into the tree\n   * @public\n   * @param {number|string} key\n   * @param {any} value\n   * @return {BinarySearchTree}\n   */\n  insert(key, value) {\n    const newNode = new BinarySearchTreeNode(key, value);\n    const insertRecursive = (current) => {\n      if (key < current.getKey()) {\n        if (current.hasLeft()) {\n          insertRecursive(current.getLeft());\n        } else {\n          current.setLeft(newNode.setParent(current));\n          this._count += 1;\n        }\n      } else if (key > current.getKey()) {\n        if (current.hasRight()) {\n          insertRecursive(current.getRight());\n        } else {\n          current.setRight(newNode.setParent(current));\n          this._count += 1;\n        }\n      } else {\n        current.setValue(value);\n      }\n    };\n\n    if (this._root === null) {\n      this._root = newNode;\n      this._count += 1;\n    } else {\n      insertRecursive(this._root);\n    }\n\n    return newNode;\n  }\n\n  /**\n   * Checks if a value exists in the tree by its key\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  has(key) {\n    const hasRecursive = (current) => {\n      if (current === null) {\n        return false;\n      }\n\n      if (key === current.getKey()) {\n        return true;\n      }\n\n      if (key < current.getKey()) {\n        return hasRecursive(current.getLeft());\n      }\n\n      return hasRecursive(current.getRight());\n    };\n\n    return hasRecursive(this._root);\n  }\n\n  /**\n   * Finds a node by its key\n   * @public\n   * @param {number|string} key\n   * @return {BinarySearchTreeNode}\n   */\n  find(key) {\n    const findRecursive = (current) => {\n      if (current === null) {\n        return null;\n      }\n\n      if (key === current.getKey()) {\n        return current;\n      }\n\n      if (key < current.getKey()) {\n        return findRecursive(current.getLeft());\n      }\n\n      return findRecursive(current.getRight());\n    };\n\n    return findRecursive(this._root);\n  }\n\n  /**\n   * Finds the node with max key (most right) in the tree\n   * @public\n   * @param {BinarySearchTreeNode} [current]\n   * @return {BinarySearchTreeNode}\n   */\n  max(current = this._root) {\n    if (current === null) {\n      return null;\n    }\n\n    if (current.hasRight()) {\n      return this.max(current.getRight());\n    }\n\n    return current;\n  }\n\n  /**\n   * Finds the node with min key (most left) in the tree\n   * @public\n   * @param {BinarySearchTreeNode} [current]\n   * @return {BinarySearchTreeNode}\n   */\n  min(current = this._root) {\n    if (current === null) {\n      return null;\n    }\n\n    if (current.hasLeft()) {\n      return this.min(current.getLeft());\n    }\n\n    return current;\n  }\n\n  /**\n   * Returns the node with the biggest key less or equal to k\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeEqual\n   * @return {BinarySearchTreeNode|null}\n   */\n  lowerBound(k, includeEqual = true) {\n    let lowerBound = null;\n\n    const lowerBoundRecursive = (current) => {\n      if (current === null) {\n        return lowerBound;\n      }\n\n      const currentKey = current.getKey();\n      if (currentKey < k || (includeEqual && currentKey === k)) {\n        if (lowerBound === null || lowerBound.getKey() <= currentKey) {\n          lowerBound = current;\n        }\n        return lowerBoundRecursive(current.getRight());\n      }\n\n      return lowerBoundRecursive(current.getLeft());\n    };\n\n    return lowerBoundRecursive(this._root);\n  }\n\n  /**\n   * delegate to lowerBound\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeEqual\n   * @return {BinarySearchTreeNode|null}\n   */\n  floor(k, includeEqual = true) {\n    return this.lowerBound(k, includeEqual);\n  }\n\n  /**\n   * Returns the node with the smallest key bigger or equal k\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeEqual\n   * @return {BinarySearchTreeNode|null}\n   */\n  upperBound(k, includeEqual = true) {\n    let upperBound = null;\n\n    const upperBoundRecursive = (current) => {\n      if (current === null) {\n        return upperBound;\n      }\n\n      const currentKey = current.getKey();\n      if (currentKey > k || (includeEqual && currentKey === k)) {\n        if (upperBound === null || upperBound.getKey() >= currentKey) {\n          upperBound = current;\n        }\n        return upperBoundRecursive(current.getLeft());\n      }\n\n      return upperBoundRecursive(current.getRight());\n    };\n\n    return upperBoundRecursive(this._root);\n  }\n\n  /**\n   * delegate to upperBound\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeEqual\n   * @return {BinarySearchTreeNode|null}\n   */\n  ceil(k, includeEqual = true) {\n    return this.upperBound(k, includeEqual);\n  }\n\n  /**\n   * Returns the root node\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  root() {\n    return this._root;\n  }\n\n  /**\n   * Returns the nodes count\n   * @public\n   * @return {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * Removes a node by its key\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  remove(key) {\n    const removeRecursively = (k, current) => {\n      if (current === null) {\n        return false;\n      }\n\n      if (k < current.getKey()) {\n        return removeRecursively(k, current.getLeft());\n      }\n\n      if (k > current.getKey()) {\n        return removeRecursively(k, current.getRight());\n      }\n\n      // current node is the node to remove\n\n      // case 1: node has no children\n      if (current.isLeaf()) {\n        if (current.isRoot()) {\n          this._root = null;\n        } else if (k < current.getParent().getKey()) {\n          current.getParent().setLeft(null);\n        } else {\n          current.getParent().setRight(null);\n        }\n        this._count -= 1;\n        return true;\n      }\n\n      // case 2: node has a left child and no right child\n      if (!current.hasRight()) {\n        if (current.isRoot()) {\n          this._root = current.getLeft();\n        } else if (k < current.getParent().getKey()) {\n          current.getParent().setLeft(current.getLeft());\n        } else {\n          current.getParent().setRight(current.getLeft());\n        }\n        current.getLeft().setParent(current.getParent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 3: node has a right child and no left child\n      if (!current.hasLeft()) {\n        if (current.isRoot()) {\n          this._root = current.getRight();\n        } else if (k < current.getParent().getKey()) {\n          current.getParent().setLeft(current.getRight());\n        } else {\n          current.getParent().setRight(current.getRight());\n        }\n        current.getRight().setParent(current.getParent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 4: node has left and right children\n      const minRight = this.min(current.getRight());\n      current.setKey(minRight.getKey()).setValue(minRight.getValue());\n      return removeRecursively(minRight.getKey(), minRight);\n    };\n\n    return removeRecursively(key, this._root);\n  }\n\n  /**\n   * Traverses the tree in-order (left-node-right)\n   * @public\n   * @param {function} cb\n   */\n  traverseInOrder(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.traverseInOrder expects a callback function');\n    }\n\n    const traverseRecursive = (current) => {\n      if (current === null) return;\n      traverseRecursive(current.getLeft());\n      cb(current);\n      traverseRecursive(current.getRight());\n    };\n\n    traverseRecursive(this._root);\n  }\n\n  /**\n   * Traverses the tree pre-order (node-left-right)\n   * @public\n   * @param {function} cb\n   */\n  traversePreOrder(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.traversePreOrder expects a callback function');\n    }\n\n    const traverseRecursive = (current) => {\n      if (current === null) return;\n      cb(current);\n      traverseRecursive(current.getLeft());\n      traverseRecursive(current.getRight());\n    };\n\n    traverseRecursive(this._root);\n  }\n\n  /**\n   * Traverses the tree post-order (left-right-node)\n   * @public\n   * @param {function} cb\n   */\n  traversePostOrder(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.traversePostOrder expects a callback function');\n    }\n\n    const traverseRecursive = (current) => {\n      if (current === null) return;\n      traverseRecursive(current.getLeft());\n      traverseRecursive(current.getRight());\n      cb(current);\n    };\n\n    traverseRecursive(this._root);\n  }\n\n  /**\n   * Clears the tree\n   * @public\n   */\n  clear() {\n    this._root = null;\n    this._count = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n\n\n\n# 参考\n\n * 二元搜寻树 - Wikiwand",normalizedContent:"# 介绍\n\n二叉查找树（英语：binary search tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n\n * 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n * 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n * 任意节点的左、右子树也分别为二叉查找树；\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为o(log⁡n)o(\\log n)o(logn)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n\n二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以透过建构一棵二叉查找树变成一个有序序列，建构树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望o(log⁡n)o(\\log n)o(logn)，最坏退化为偏斜二元树o(n)o(n)o(n)。对于可能形成偏斜二元树的问题可以经由树高改良后的平衡树将搜寻、插入、删除的时间复杂度都维持在o(log⁡n)o(\\log n)o(logn)，如 avl 树、红黑树等。\n\n\n# 实现\n\n\n# javascript\n\nclass binarysearchtreenode {\n  constructor(key, value) {\n    this._key = key;\n    this._value = value;\n    this._left = null;\n    this._right = null;\n    this._parent = null;\n  }\n\n  /**\n   * @public\n   * @param {number|string}\n   * @returns {binarysearchtreenode}\n   */\n  setkey(key) {\n    this._key = key;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {number|string}\n   */\n  getkey() {\n    return this._key;\n  }\n\n  /**\n   * @public\n   * @param {any} value\n   * @returns {binarysearchtreenode}\n   */\n  setvalue(value) {\n    this._value = value;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {any}\n   */\n  getvalue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {binarysearchtreenode|null} left\n   * @returns {binarysearchtreenode}\n   */\n  setleft(left) {\n    if (left && !(left instanceof binarysearchtreenode)) {\n      throw new error('setleft expects a binarysearchtreenode or null');\n    }\n\n    this._left = left || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {binarysearchtreenode}\n   */\n  getleft() {\n    return this._left;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  hasleft() {\n    return this._left instanceof binarysearchtreenode;\n  }\n\n  /**\n   * @public\n   * @param {binarysearchtreenode|null} right\n   * @returns {binarysearchtreenode}\n   */\n  setright(right) {\n    if (right && !(right instanceof binarysearchtreenode)) {\n      throw new error('setright expects a binarysearchtreenode or null');\n    }\n\n    this._right = right || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {binarysearchtreenode}\n   */\n  getright() {\n    return this._right;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  hasright() {\n    return this._right instanceof binarysearchtreenode;\n  }\n\n  /**\n   * @public\n   * @param {binarysearchtreenode} parent\n   * @returns {binarysearchtreenode}\n   */\n  setparent(parent) {\n    if (parent && !(parent instanceof binarysearchtreenode)) {\n      throw new error('setparent expects a binarysearchtreenode or null');\n    }\n\n    this._parent = parent || null;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {binarysearchtreenode}\n   */\n  getparent() {\n    return this._parent;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  hasparent() {\n    return this._parent instanceof binarysearchtreenode;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isroot() {\n    return this._parent === null;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isleaf() {\n    return !this.hasleft() && !this.hasright();\n  }\n}\n\nclass binarysearchtree {\n  constructor() {\n    this._root = null;\n    this._count = 0;\n  }\n\n  /**\n   * inserts a node with a key/value into the tree\n   * @public\n   * @param {number|string} key\n   * @param {any} value\n   * @return {binarysearchtree}\n   */\n  insert(key, value) {\n    const newnode = new binarysearchtreenode(key, value);\n    const insertrecursive = (current) => {\n      if (key < current.getkey()) {\n        if (current.hasleft()) {\n          insertrecursive(current.getleft());\n        } else {\n          current.setleft(newnode.setparent(current));\n          this._count += 1;\n        }\n      } else if (key > current.getkey()) {\n        if (current.hasright()) {\n          insertrecursive(current.getright());\n        } else {\n          current.setright(newnode.setparent(current));\n          this._count += 1;\n        }\n      } else {\n        current.setvalue(value);\n      }\n    };\n\n    if (this._root === null) {\n      this._root = newnode;\n      this._count += 1;\n    } else {\n      insertrecursive(this._root);\n    }\n\n    return newnode;\n  }\n\n  /**\n   * checks if a value exists in the tree by its key\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  has(key) {\n    const hasrecursive = (current) => {\n      if (current === null) {\n        return false;\n      }\n\n      if (key === current.getkey()) {\n        return true;\n      }\n\n      if (key < current.getkey()) {\n        return hasrecursive(current.getleft());\n      }\n\n      return hasrecursive(current.getright());\n    };\n\n    return hasrecursive(this._root);\n  }\n\n  /**\n   * finds a node by its key\n   * @public\n   * @param {number|string} key\n   * @return {binarysearchtreenode}\n   */\n  find(key) {\n    const findrecursive = (current) => {\n      if (current === null) {\n        return null;\n      }\n\n      if (key === current.getkey()) {\n        return current;\n      }\n\n      if (key < current.getkey()) {\n        return findrecursive(current.getleft());\n      }\n\n      return findrecursive(current.getright());\n    };\n\n    return findrecursive(this._root);\n  }\n\n  /**\n   * finds the node with max key (most right) in the tree\n   * @public\n   * @param {binarysearchtreenode} [current]\n   * @return {binarysearchtreenode}\n   */\n  max(current = this._root) {\n    if (current === null) {\n      return null;\n    }\n\n    if (current.hasright()) {\n      return this.max(current.getright());\n    }\n\n    return current;\n  }\n\n  /**\n   * finds the node with min key (most left) in the tree\n   * @public\n   * @param {binarysearchtreenode} [current]\n   * @return {binarysearchtreenode}\n   */\n  min(current = this._root) {\n    if (current === null) {\n      return null;\n    }\n\n    if (current.hasleft()) {\n      return this.min(current.getleft());\n    }\n\n    return current;\n  }\n\n  /**\n   * returns the node with the biggest key less or equal to k\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeequal\n   * @return {binarysearchtreenode|null}\n   */\n  lowerbound(k, includeequal = true) {\n    let lowerbound = null;\n\n    const lowerboundrecursive = (current) => {\n      if (current === null) {\n        return lowerbound;\n      }\n\n      const currentkey = current.getkey();\n      if (currentkey < k || (includeequal && currentkey === k)) {\n        if (lowerbound === null || lowerbound.getkey() <= currentkey) {\n          lowerbound = current;\n        }\n        return lowerboundrecursive(current.getright());\n      }\n\n      return lowerboundrecursive(current.getleft());\n    };\n\n    return lowerboundrecursive(this._root);\n  }\n\n  /**\n   * delegate to lowerbound\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeequal\n   * @return {binarysearchtreenode|null}\n   */\n  floor(k, includeequal = true) {\n    return this.lowerbound(k, includeequal);\n  }\n\n  /**\n   * returns the node with the smallest key bigger or equal k\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeequal\n   * @return {binarysearchtreenode|null}\n   */\n  upperbound(k, includeequal = true) {\n    let upperbound = null;\n\n    const upperboundrecursive = (current) => {\n      if (current === null) {\n        return upperbound;\n      }\n\n      const currentkey = current.getkey();\n      if (currentkey > k || (includeequal && currentkey === k)) {\n        if (upperbound === null || upperbound.getkey() >= currentkey) {\n          upperbound = current;\n        }\n        return upperboundrecursive(current.getleft());\n      }\n\n      return upperboundrecursive(current.getright());\n    };\n\n    return upperboundrecursive(this._root);\n  }\n\n  /**\n   * delegate to upperbound\n   * @public\n   * @param {number|string} k\n   * @param {boolean} includeequal\n   * @return {binarysearchtreenode|null}\n   */\n  ceil(k, includeequal = true) {\n    return this.upperbound(k, includeequal);\n  }\n\n  /**\n   * returns the root node\n   * @public\n   * @return {binarysearchtreenode}\n   */\n  root() {\n    return this._root;\n  }\n\n  /**\n   * returns the nodes count\n   * @public\n   * @return {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * removes a node by its key\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  remove(key) {\n    const removerecursively = (k, current) => {\n      if (current === null) {\n        return false;\n      }\n\n      if (k < current.getkey()) {\n        return removerecursively(k, current.getleft());\n      }\n\n      if (k > current.getkey()) {\n        return removerecursively(k, current.getright());\n      }\n\n      // current node is the node to remove\n\n      // case 1: node has no children\n      if (current.isleaf()) {\n        if (current.isroot()) {\n          this._root = null;\n        } else if (k < current.getparent().getkey()) {\n          current.getparent().setleft(null);\n        } else {\n          current.getparent().setright(null);\n        }\n        this._count -= 1;\n        return true;\n      }\n\n      // case 2: node has a left child and no right child\n      if (!current.hasright()) {\n        if (current.isroot()) {\n          this._root = current.getleft();\n        } else if (k < current.getparent().getkey()) {\n          current.getparent().setleft(current.getleft());\n        } else {\n          current.getparent().setright(current.getleft());\n        }\n        current.getleft().setparent(current.getparent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 3: node has a right child and no left child\n      if (!current.hasleft()) {\n        if (current.isroot()) {\n          this._root = current.getright();\n        } else if (k < current.getparent().getkey()) {\n          current.getparent().setleft(current.getright());\n        } else {\n          current.getparent().setright(current.getright());\n        }\n        current.getright().setparent(current.getparent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 4: node has left and right children\n      const minright = this.min(current.getright());\n      current.setkey(minright.getkey()).setvalue(minright.getvalue());\n      return removerecursively(minright.getkey(), minright);\n    };\n\n    return removerecursively(key, this._root);\n  }\n\n  /**\n   * traverses the tree in-order (left-node-right)\n   * @public\n   * @param {function} cb\n   */\n  traverseinorder(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.traverseinorder expects a callback function');\n    }\n\n    const traverserecursive = (current) => {\n      if (current === null) return;\n      traverserecursive(current.getleft());\n      cb(current);\n      traverserecursive(current.getright());\n    };\n\n    traverserecursive(this._root);\n  }\n\n  /**\n   * traverses the tree pre-order (node-left-right)\n   * @public\n   * @param {function} cb\n   */\n  traversepreorder(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.traversepreorder expects a callback function');\n    }\n\n    const traverserecursive = (current) => {\n      if (current === null) return;\n      cb(current);\n      traverserecursive(current.getleft());\n      traverserecursive(current.getright());\n    };\n\n    traverserecursive(this._root);\n  }\n\n  /**\n   * traverses the tree post-order (left-right-node)\n   * @public\n   * @param {function} cb\n   */\n  traversepostorder(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('.traversepostorder expects a callback function');\n    }\n\n    const traverserecursive = (current) => {\n      if (current === null) return;\n      traverserecursive(current.getleft());\n      traverserecursive(current.getright());\n      cb(current);\n    };\n\n    traverserecursive(this._root);\n  }\n\n  /**\n   * clears the tree\n   * @public\n   */\n  clear() {\n    this._root = null;\n    this._count = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n\n\n\n# 参考\n\n * 二元搜寻树 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"AvlTree [AVL树]",frontmatter:{title:"AvlTree [AVL树]",date:"2022-04-26T22:25:14.000Z",permalink:"/ds/tree/avlTree/",categories:["数据结构","tree 树"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/80.tree%20%E6%A0%91/20.avlTree.html",relativePath:"10.数据结构/80.tree 树/20.avlTree.md",key:"v-3fb26e0a",path:"/ds/tree/avlTree/",headers:[{level:2,title:"平衡树",slug:"平衡树",normalizedTitle:"平衡树",charIndex:2},{level:3,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:185},{level:3,title:"树旋转",slug:"树旋转",normalizedTitle:"树旋转",charIndex:215},{level:3,title:"各种平衡树",slug:"各种平衡树",normalizedTitle:"各种平衡树",charIndex:975},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:2199},{level:2,title:"AVL 树",slug:"avl-树",normalizedTitle:"avl 树",charIndex:985},{level:3,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:187},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:96},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3368},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:12709}],headersStr:"平衡树 基本操作 树旋转 各种平衡树 应用 AVL 树 操作 实现 JavaScript 参考",content:"# 平衡树\n\n平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。\n\n在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。\n\n不平衡的树结构：\n\n\n\n平衡的树结构：\n\n\n\n\n# 基本操作\n\n旋转（rotate）：几乎所有平衡树的操作都基于树旋转操作（也有部分基于重构，如替罪羊树），通过旋转操作可以使得树趋于平衡。对一棵查找树（search tree）进行查询、新增、删除等动作，所花的时间与树的高度 h 成比例，并不与树的容量 n 成比例。如果可以让树维持平衡，也就是让 h 维持在O(log⁡n)O(\\log{n})O(logn) 的左右，就可以在O(log⁡n)O(\\log{n})O(logn) 的复杂度内完成各种基本操作。\n\n插入（insert）：在树中插入一个新值。\n\n删除（delete）：在树中删除一个值。\n\n查询前驱（predecessor）：前驱定义为小于 x，且最大的数。\n\n查询后继（successor）：后继定义为大于 x，且最小的数。\n\n在维护节点大小（size）后，可以支持以下操作：\n\n查询排名（rank）：排名定义为比 x 小的数的个数加一。\n\n查询第 k 大：即排名为 k 的数。\n\n\n# 树旋转\n\n在数据结构中，树旋转（英语：Tree rotation）是对二叉树的一种操作，不影响元素的顺序，但会改变树的结构，将一个节点上移、一个节点下移。树旋转会改变树的形状，因此常被用来将较小的子树下移、较大的子树上移，从而降低树的高度、提升许多树操作的效率。\n\n\n\n理解树旋转过程的关键，在于理解其中不变的约束。旋转操作不会导致叶节点顺序的改变（可以理解为旋转操作前后，树的中序遍历结果是一致的），旋转过程中也始终受二叉搜索树的主要性质约束：右子节点比父节点大、左子节点比父节点小。尤其需要注意的是，进行右旋转时，旋转前根的左节点的右节点会变成根的左节点，根本身则在旋转后会变成新的根的右节点，而在这一过程中，整棵树一直遵守着前面提到的几个约束。相反的左旋转操作亦然。\n\n中序不变：二叉树旋转前后，中序遍历的结果不变。\n\n\n# 各种平衡树\n\n * AVL 树：是最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log⁡n)O(\\log{n})O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。\n * 树堆（Treap）：是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为 O (\\log {n})。相对于其他的平衡二叉搜索树，Treap 的特点是实现简单，且能基本实现随机平衡的结构。\n * 伸展树（Splay tree）：能在均摊O(log⁡n)O(\\log{n})O(logn) 的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。 它的优势在于不需要记录用于平衡树的冗余信息。\n * 红黑树 （Red–black tree）：被称为 \" 对称二叉 B 树 \"。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在O(log⁡n)O(\\log{n})O(logn) 时间内完成查找，插入和删除，这里的 n 是树中元素的数目。\n * 加权平衡树（Weight balanced tree）：加权平衡树的每个结点储存这个结点下子树的大小，可以用来实现顺序统计树操作。优势在于占用空间相对较小。\n * 2-3 树：其内部节点（存在子节点的节点）要么有 2 个孩子和 1 个数据元素，要么有 3 个孩子和 2 个数据元素，叶子节点没有孩子，并且有 1 个或 2 个数据元素。2–3 树和 AA 树是等距同构的，换句话说，对于每个 2–3 树，都至少有 1 个 AA 树和它的元素排列是相同的。\n * AA 树：AA 树是红黑树的一种变种，设计的目的是减少红黑树考虑的不同情况，区别于红黑树的是，AA 树的红节点只能作为右叶子，从而大大简化了维护 2-3 树的模拟。\n * 替罪羊树：其平衡基于部分重建，在非平衡的二叉搜索树中，每次操作以后检查操作路径，找到最高的满足左右子树大小大于平衡因子（alpha）乘以自身大小的结点，重建整个子树。这样就得到了替罪羊树，而被重建的子树的原来的根就被称为替罪羊节点。\n\n\n# 应用\n\n用于表示有序的线性数据结构，如优先队列、关联数组、键 (key)- 值 (value) 的映射等。自平衡的二叉查找树与哈希表的相比，各有优缺。平衡树在按序遍历所有键值时是量级最优的，哈希表不能。自平衡二叉查找树在查找一个键值时，最坏情况下时间复杂度优于哈希表， O(log⁡n)O(\\log n)O(logn) 对比O(n)O(n)O(n)；但平均时间复杂度逊于 hash 表，O(log⁡n)O(\\log n)O(logn) 对比O(1)O(1)O(1)。\n\n平衡树的排序方法，虽然在平均时间复杂度上也是O(nlog⁡n){\\displaystyle O(n\\log n)}O(nlogn)，但由于 cache 性能、树的调整操作等，性能上不如快速排序、堆排序、归并排序等同为O(nlog⁡n){\\displaystyle O(n\\log n)}O(nlogn) 复杂度的排序。\n\n\n# AVL 树\n\nAVL 树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log⁡n)O(\\log{n})O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。\n\n节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n\n# 操作\n\nAVL 树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的 \"AVL 旋转 \"。\n\n以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。\n\n\n\n * 删除：从 AVL 树中删除，可以通过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。因为在旋转成叶子节点期间最多有lognlog nlogn 个节点被旋转，而每次 AVL 旋转耗费固定的时间，所以删除处理在整体上耗费O(logn)O(log n)O(logn) 时间。\n * 搜寻：可以像普通二叉查找树一样的进行，所以耗费O(logn)O(log n)O(logn) 时间，因为 AVL 树总是保持平衡的。不需要特殊的准备，树的结构不会由于查找而改变。（这是与伸展树搜寻相对立的，它会因为搜寻而变更树结构。）\n\n\n# 实现\n\n\n# JavaScript\n\nconst { BinarySearchTree } = require('./binarySearchTree');\nconst { BinarySearchTreeNode } = require('./binarySearchTreeNode');\n\n/**\n * @class AvlTreeNode\n * @extends BinarySearchTreeNode\n */\nclass AvlTreeNode extends BinarySearchTreeNode {\n  constructor(key, value) {\n    super(key, value);\n    this._height = 1;\n  }\n\n  /**\n   * Rotate-self left (counter-clockwise)\n   * @public\n   * @returns {AvlTreeNode}\n   */\n  rotateLeft() {\n    const right = this._right; // this._right will be re-assigned\n\n    // set the node as a left child of its right child\n    if (right !== null) {\n      if (right.hasLeft()) {\n        right.getLeft().setParent(this);\n      }\n\n      // rebase right child to node's right left child.\n      this._right = right.getLeft();\n\n      right.setLeft(this);\n      right.setParent(this._parent);\n    }\n\n    // rebase parent's child to node's right child\n    if (this.hasParent() && right !== null) {\n      if (this._parent.getKey() < right.getKey()) {\n        this._parent.setRight(right);\n      } else {\n        this._parent.setLeft(right);\n      }\n    }\n\n    // rebase parent to node's right child\n    this._parent = right;\n\n    this.updateHeight();\n    if (this.hasParent()) {\n      this._parent.updateHeight();\n    }\n\n    return this;\n  }\n\n  /**\n   * Rotate-self right (clockwise)\n   * @public\n   * @returns {AvlTreeNode}\n   */\n  rotateRight() {\n    const left = this._left; // this._left will be re-assigned\n\n    // set the node as a right child of its left child\n    if (left !== null) {\n      if (left.hasRight()) {\n        left.getRight().setParent(this);\n      }\n\n      // rebase left child to node's left right child.\n      this._left = left.getRight();\n\n      left.setRight(this);\n      left.setParent(this._parent);\n    }\n\n    // rebase parent's child to node's left child\n    if (this.hasParent() && left !== null) {\n      if (this._parent.getKey() > left.getKey()) {\n        this._parent.setLeft(left);\n      } else {\n        this._parent.setRight(left);\n      }\n    }\n\n    // rebase parent to node's left child\n    this._parent = left;\n\n    this.updateHeight();\n    if (this.hasParent()) {\n      this._parent.updateHeight();\n    }\n\n    return this;\n  }\n\n  /**\n   * Rotate-self to right after rotating left child to left\n   * @public\n   * @returns {AvlTreeNode}\n   */\n  rotateLeftRight() {\n    if (this.hasLeft()) {\n      this._left.rotateLeft();\n    }\n    this.rotateRight();\n    return this;\n  }\n\n  /**\n   * Rotate-self to left after rotating right child to right\n   * @public\n   * @returns {AvlTreeNode}\n   */\n  rotateRightLeft() {\n    if (this.hasRight()) {\n      this._right.rotateRight();\n    }\n    this.rotateLeft();\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getLeftHeight() {\n    return this.hasLeft() ? this.getLeft().getHeight() : 0;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getRightHeight() {\n    return this.hasRight() ? this.getRight().getHeight() : 0;\n  }\n\n  /**\n   * Updates self height based on the max height of children\n   * @public\n   * @returns {AvlTreeNode}\n  */\n  updateHeight() {\n    this._height = Math.max(this.getLeftHeight(), this.getRightHeight()) + 1;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getHeight() {\n    return this._height;\n  }\n\n  /**\n   * Gets the balance of a node as the diff between left & right heights\n   * @public\n   * @return {number}\n   */\n  getBalance() {\n    return this.getLeftHeight() - this.getRightHeight();\n  }\n\n  /**\n   * Checks if the node is balanced\n   * @public\n   * @return {boolean}\n   */\n  isBalanced() {\n    const balance = this.getBalance();\n    return balance >= -1 && balance <= 1;\n  }\n}\n\nclass AvlTree extends BinarySearchTree {\n  /**\n   * Applies the proper rotation on a node\n   * @private\n   * @param {AvlTreeNode} node\n   */\n  _balanceNode(node) {\n    if (!node) return;\n\n    node.updateHeight();\n    const balance = node.getBalance();\n    if (balance > 1) {\n      if (node.getLeft().hasLeft()) {\n        node.rotateRight();\n      } else if (node.getLeft().hasRight()) {\n        node.rotateLeftRight();\n      }\n    } else if (balance < -1) {\n      if (node.getRight().hasRight()) {\n        node.rotateLeft();\n      } else if (node.getRight().hasLeft()) {\n        node.rotateRightLeft();\n      }\n    }\n\n    // check if root was rotated\n    if ((balance < -1 || balance > 1) && node === this._root) {\n      // replace root when rotated with the child (now parent of root)\n      this._root = node.getParent();\n    }\n  }\n\n  /**\n   * Inserts a node with a key/value into tree\n   * and maintains the tree balanced by applying the necessary rotations\n   *\n   * @public\n   * @param {number|string} key\n   * @param {any} value\n   * @return {AvlTree}\n   */\n  insert(key, value) {\n    const newNode = new AvlTreeNode(key, value);\n    const insertRecursive = (current) => {\n      if (key < current.getKey()) {\n        if (current.hasLeft()) {\n          insertRecursive(current.getLeft());\n          this._balanceNode(current); // backward-tracking\n        } else {\n          newNode.setParent(current);\n          current.setLeft(newNode).updateHeight();\n          this._count += 1;\n        }\n      } else if (key > current.getKey()) {\n        if (current.hasRight()) {\n          insertRecursive(current.getRight());\n          this._balanceNode(current); // backward-tracking\n        } else {\n          newNode.setParent(current);\n          current.setRight(newNode).updateHeight();\n          this._count += 1;\n        }\n      } else {\n        current.setValue(value);\n      }\n    };\n\n    if (this._root === null) {\n      this._root = newNode;\n      this._count += 1;\n    } else {\n      insertRecursive(this._root);\n    }\n\n    return newNode;\n  }\n\n  /**\n   * Removes a node by its key\n   * and maintains the tree balanced by applying the necessary rotations\n   *\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  remove(key) {\n    const removeRecursively = (k, current) => {\n      if (current === null) {\n        return false;\n      }\n\n      if (k < current.getKey()) {\n        const removed = removeRecursively(k, current.getLeft());\n        this._balanceNode(current);\n        return removed;\n      }\n\n      if (k > current.getKey()) {\n        const removed = removeRecursively(k, current.getRight());\n        this._balanceNode(current);\n        return removed;\n      }\n\n      // current node is the node to remove\n\n      // case 1: node has no children\n      if (current.isLeaf()) {\n        if (current.isRoot()) {\n          this._root = null;\n        } else if (k < current.getParent().getKey()) {\n          current.getParent().setLeft(null).updateHeight();\n        } else {\n          current.getParent().setRight(null).updateHeight();\n        }\n        this._count -= 1;\n        return true;\n      }\n\n      // case 2: node has a left child and no right child\n      if (!current.hasRight()) {\n        if (current.isRoot()) {\n          this._root = current.getLeft();\n        } else if (k < current.getParent().getKey()) {\n          current.getParent().setLeft(current.getLeft()).updateHeight();\n        } else {\n          current.getParent().setRight(current.getLeft()).updateHeight();\n        }\n        current.getLeft().setParent(current.getParent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 3: node has a right child and no left child\n      if (!current.hasLeft()) {\n        if (current.isRoot()) {\n          this._root = current.getRight();\n        } else if (k < current.getParent().getKey()) {\n          current.getParent().setLeft(current.getRight()).updateHeight();\n        } else {\n          current.getParent().setRight(current.getRight()).updateHeight();\n        }\n        current.getRight().setParent(current.getParent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 4: node has left and right children\n      const minRight = this.min(current.getRight());\n      current.setKey(minRight.getKey()).setValue(minRight.getValue());\n      return removeRecursively(minRight.getKey(), minRight);\n    };\n\n    return removeRecursively(key, this._root);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n\n\n\n# 参考\n\n * 平衡树 - Wikiwand\n * 树旋转 - Wikiwand\n * AVL 树 - Wikiwand",normalizedContent:"# 平衡树\n\n平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。\n\n在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。\n\n不平衡的树结构：\n\n\n\n平衡的树结构：\n\n\n\n\n# 基本操作\n\n旋转（rotate）：几乎所有平衡树的操作都基于树旋转操作（也有部分基于重构，如替罪羊树），通过旋转操作可以使得树趋于平衡。对一棵查找树（search tree）进行查询、新增、删除等动作，所花的时间与树的高度 h 成比例，并不与树的容量 n 成比例。如果可以让树维持平衡，也就是让 h 维持在o(log⁡n)o(\\log{n})o(logn) 的左右，就可以在o(log⁡n)o(\\log{n})o(logn) 的复杂度内完成各种基本操作。\n\n插入（insert）：在树中插入一个新值。\n\n删除（delete）：在树中删除一个值。\n\n查询前驱（predecessor）：前驱定义为小于 x，且最大的数。\n\n查询后继（successor）：后继定义为大于 x，且最小的数。\n\n在维护节点大小（size）后，可以支持以下操作：\n\n查询排名（rank）：排名定义为比 x 小的数的个数加一。\n\n查询第 k 大：即排名为 k 的数。\n\n\n# 树旋转\n\n在数据结构中，树旋转（英语：tree rotation）是对二叉树的一种操作，不影响元素的顺序，但会改变树的结构，将一个节点上移、一个节点下移。树旋转会改变树的形状，因此常被用来将较小的子树下移、较大的子树上移，从而降低树的高度、提升许多树操作的效率。\n\n\n\n理解树旋转过程的关键，在于理解其中不变的约束。旋转操作不会导致叶节点顺序的改变（可以理解为旋转操作前后，树的中序遍历结果是一致的），旋转过程中也始终受二叉搜索树的主要性质约束：右子节点比父节点大、左子节点比父节点小。尤其需要注意的是，进行右旋转时，旋转前根的左节点的右节点会变成根的左节点，根本身则在旋转后会变成新的根的右节点，而在这一过程中，整棵树一直遵守着前面提到的几个约束。相反的左旋转操作亦然。\n\n中序不变：二叉树旋转前后，中序遍历的结果不变。\n\n\n# 各种平衡树\n\n * avl 树：是最早被发明的自平衡二叉查找树。在 avl 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是o(log⁡n)o(\\log{n})o(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。\n * 树堆（treap）：是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为 o (\\log {n})。相对于其他的平衡二叉搜索树，treap 的特点是实现简单，且能基本实现随机平衡的结构。\n * 伸展树（splay tree）：能在均摊o(log⁡n)o(\\log{n})o(logn) 的时间内完成基于伸展（splay）操作的插入、查找、修改和删除操作。在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。 它的优势在于不需要记录用于平衡树的冗余信息。\n * 红黑树 （red–black tree）：被称为 \" 对称二叉 b 树 \"。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在o(log⁡n)o(\\log{n})o(logn) 时间内完成查找，插入和删除，这里的 n 是树中元素的数目。\n * 加权平衡树（weight balanced tree）：加权平衡树的每个结点储存这个结点下子树的大小，可以用来实现顺序统计树操作。优势在于占用空间相对较小。\n * 2-3 树：其内部节点（存在子节点的节点）要么有 2 个孩子和 1 个数据元素，要么有 3 个孩子和 2 个数据元素，叶子节点没有孩子，并且有 1 个或 2 个数据元素。2–3 树和 aa 树是等距同构的，换句话说，对于每个 2–3 树，都至少有 1 个 aa 树和它的元素排列是相同的。\n * aa 树：aa 树是红黑树的一种变种，设计的目的是减少红黑树考虑的不同情况，区别于红黑树的是，aa 树的红节点只能作为右叶子，从而大大简化了维护 2-3 树的模拟。\n * 替罪羊树：其平衡基于部分重建，在非平衡的二叉搜索树中，每次操作以后检查操作路径，找到最高的满足左右子树大小大于平衡因子（alpha）乘以自身大小的结点，重建整个子树。这样就得到了替罪羊树，而被重建的子树的原来的根就被称为替罪羊节点。\n\n\n# 应用\n\n用于表示有序的线性数据结构，如优先队列、关联数组、键 (key)- 值 (value) 的映射等。自平衡的二叉查找树与哈希表的相比，各有优缺。平衡树在按序遍历所有键值时是量级最优的，哈希表不能。自平衡二叉查找树在查找一个键值时，最坏情况下时间复杂度优于哈希表， o(log⁡n)o(\\log n)o(logn) 对比o(n)o(n)o(n)；但平均时间复杂度逊于 hash 表，o(log⁡n)o(\\log n)o(logn) 对比o(1)o(1)o(1)。\n\n平衡树的排序方法，虽然在平均时间复杂度上也是o(nlog⁡n){\\displaystyle o(n\\log n)}o(nlogn)，但由于 cache 性能、树的调整操作等，性能上不如快速排序、堆排序、归并排序等同为o(nlog⁡n){\\displaystyle o(n\\log n)}o(nlogn) 复杂度的排序。\n\n\n# avl 树\n\navl 树（adelson-velsky and landis tree）是计算机科学中最早被发明的自平衡二叉查找树。在 avl 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是o(log⁡n)o(\\log{n})o(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。\n\n节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n\n# 操作\n\navl 树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的 \"avl 旋转 \"。\n\n以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。\n\n\n\n * 删除：从 avl 树中删除，可以通过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。因为在旋转成叶子节点期间最多有lognlog nlogn 个节点被旋转，而每次 avl 旋转耗费固定的时间，所以删除处理在整体上耗费o(logn)o(log n)o(logn) 时间。\n * 搜寻：可以像普通二叉查找树一样的进行，所以耗费o(logn)o(log n)o(logn) 时间，因为 avl 树总是保持平衡的。不需要特殊的准备，树的结构不会由于查找而改变。（这是与伸展树搜寻相对立的，它会因为搜寻而变更树结构。）\n\n\n# 实现\n\n\n# javascript\n\nconst { binarysearchtree } = require('./binarysearchtree');\nconst { binarysearchtreenode } = require('./binarysearchtreenode');\n\n/**\n * @class avltreenode\n * @extends binarysearchtreenode\n */\nclass avltreenode extends binarysearchtreenode {\n  constructor(key, value) {\n    super(key, value);\n    this._height = 1;\n  }\n\n  /**\n   * rotate-self left (counter-clockwise)\n   * @public\n   * @returns {avltreenode}\n   */\n  rotateleft() {\n    const right = this._right; // this._right will be re-assigned\n\n    // set the node as a left child of its right child\n    if (right !== null) {\n      if (right.hasleft()) {\n        right.getleft().setparent(this);\n      }\n\n      // rebase right child to node's right left child.\n      this._right = right.getleft();\n\n      right.setleft(this);\n      right.setparent(this._parent);\n    }\n\n    // rebase parent's child to node's right child\n    if (this.hasparent() && right !== null) {\n      if (this._parent.getkey() < right.getkey()) {\n        this._parent.setright(right);\n      } else {\n        this._parent.setleft(right);\n      }\n    }\n\n    // rebase parent to node's right child\n    this._parent = right;\n\n    this.updateheight();\n    if (this.hasparent()) {\n      this._parent.updateheight();\n    }\n\n    return this;\n  }\n\n  /**\n   * rotate-self right (clockwise)\n   * @public\n   * @returns {avltreenode}\n   */\n  rotateright() {\n    const left = this._left; // this._left will be re-assigned\n\n    // set the node as a right child of its left child\n    if (left !== null) {\n      if (left.hasright()) {\n        left.getright().setparent(this);\n      }\n\n      // rebase left child to node's left right child.\n      this._left = left.getright();\n\n      left.setright(this);\n      left.setparent(this._parent);\n    }\n\n    // rebase parent's child to node's left child\n    if (this.hasparent() && left !== null) {\n      if (this._parent.getkey() > left.getkey()) {\n        this._parent.setleft(left);\n      } else {\n        this._parent.setright(left);\n      }\n    }\n\n    // rebase parent to node's left child\n    this._parent = left;\n\n    this.updateheight();\n    if (this.hasparent()) {\n      this._parent.updateheight();\n    }\n\n    return this;\n  }\n\n  /**\n   * rotate-self to right after rotating left child to left\n   * @public\n   * @returns {avltreenode}\n   */\n  rotateleftright() {\n    if (this.hasleft()) {\n      this._left.rotateleft();\n    }\n    this.rotateright();\n    return this;\n  }\n\n  /**\n   * rotate-self to left after rotating right child to right\n   * @public\n   * @returns {avltreenode}\n   */\n  rotaterightleft() {\n    if (this.hasright()) {\n      this._right.rotateright();\n    }\n    this.rotateleft();\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getleftheight() {\n    return this.hasleft() ? this.getleft().getheight() : 0;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getrightheight() {\n    return this.hasright() ? this.getright().getheight() : 0;\n  }\n\n  /**\n   * updates self height based on the max height of children\n   * @public\n   * @returns {avltreenode}\n  */\n  updateheight() {\n    this._height = math.max(this.getleftheight(), this.getrightheight()) + 1;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getheight() {\n    return this._height;\n  }\n\n  /**\n   * gets the balance of a node as the diff between left & right heights\n   * @public\n   * @return {number}\n   */\n  getbalance() {\n    return this.getleftheight() - this.getrightheight();\n  }\n\n  /**\n   * checks if the node is balanced\n   * @public\n   * @return {boolean}\n   */\n  isbalanced() {\n    const balance = this.getbalance();\n    return balance >= -1 && balance <= 1;\n  }\n}\n\nclass avltree extends binarysearchtree {\n  /**\n   * applies the proper rotation on a node\n   * @private\n   * @param {avltreenode} node\n   */\n  _balancenode(node) {\n    if (!node) return;\n\n    node.updateheight();\n    const balance = node.getbalance();\n    if (balance > 1) {\n      if (node.getleft().hasleft()) {\n        node.rotateright();\n      } else if (node.getleft().hasright()) {\n        node.rotateleftright();\n      }\n    } else if (balance < -1) {\n      if (node.getright().hasright()) {\n        node.rotateleft();\n      } else if (node.getright().hasleft()) {\n        node.rotaterightleft();\n      }\n    }\n\n    // check if root was rotated\n    if ((balance < -1 || balance > 1) && node === this._root) {\n      // replace root when rotated with the child (now parent of root)\n      this._root = node.getparent();\n    }\n  }\n\n  /**\n   * inserts a node with a key/value into tree\n   * and maintains the tree balanced by applying the necessary rotations\n   *\n   * @public\n   * @param {number|string} key\n   * @param {any} value\n   * @return {avltree}\n   */\n  insert(key, value) {\n    const newnode = new avltreenode(key, value);\n    const insertrecursive = (current) => {\n      if (key < current.getkey()) {\n        if (current.hasleft()) {\n          insertrecursive(current.getleft());\n          this._balancenode(current); // backward-tracking\n        } else {\n          newnode.setparent(current);\n          current.setleft(newnode).updateheight();\n          this._count += 1;\n        }\n      } else if (key > current.getkey()) {\n        if (current.hasright()) {\n          insertrecursive(current.getright());\n          this._balancenode(current); // backward-tracking\n        } else {\n          newnode.setparent(current);\n          current.setright(newnode).updateheight();\n          this._count += 1;\n        }\n      } else {\n        current.setvalue(value);\n      }\n    };\n\n    if (this._root === null) {\n      this._root = newnode;\n      this._count += 1;\n    } else {\n      insertrecursive(this._root);\n    }\n\n    return newnode;\n  }\n\n  /**\n   * removes a node by its key\n   * and maintains the tree balanced by applying the necessary rotations\n   *\n   * @public\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  remove(key) {\n    const removerecursively = (k, current) => {\n      if (current === null) {\n        return false;\n      }\n\n      if (k < current.getkey()) {\n        const removed = removerecursively(k, current.getleft());\n        this._balancenode(current);\n        return removed;\n      }\n\n      if (k > current.getkey()) {\n        const removed = removerecursively(k, current.getright());\n        this._balancenode(current);\n        return removed;\n      }\n\n      // current node is the node to remove\n\n      // case 1: node has no children\n      if (current.isleaf()) {\n        if (current.isroot()) {\n          this._root = null;\n        } else if (k < current.getparent().getkey()) {\n          current.getparent().setleft(null).updateheight();\n        } else {\n          current.getparent().setright(null).updateheight();\n        }\n        this._count -= 1;\n        return true;\n      }\n\n      // case 2: node has a left child and no right child\n      if (!current.hasright()) {\n        if (current.isroot()) {\n          this._root = current.getleft();\n        } else if (k < current.getparent().getkey()) {\n          current.getparent().setleft(current.getleft()).updateheight();\n        } else {\n          current.getparent().setright(current.getleft()).updateheight();\n        }\n        current.getleft().setparent(current.getparent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 3: node has a right child and no left child\n      if (!current.hasleft()) {\n        if (current.isroot()) {\n          this._root = current.getright();\n        } else if (k < current.getparent().getkey()) {\n          current.getparent().setleft(current.getright()).updateheight();\n        } else {\n          current.getparent().setright(current.getright()).updateheight();\n        }\n        current.getright().setparent(current.getparent());\n        this._count -= 1;\n        return true;\n      }\n\n      // case 4: node has left and right children\n      const minright = this.min(current.getright());\n      current.setkey(minright.getkey()).setvalue(minright.getvalue());\n      return removerecursively(minright.getkey(), minright);\n    };\n\n    return removerecursively(key, this._root);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n\n\n\n# 参考\n\n * 平衡树 - wikiwand\n * 树旋转 - wikiwand\n * avl 树 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"Trie [前缀树]",frontmatter:{title:"Trie [前缀树]",date:"2022-04-26T22:19:29.000Z",permalink:"/ds/tree/trie/",categories:["数据结构","tree 树"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/80.tree%20%E6%A0%91/30.trie.html",relativePath:"10.数据结构/80.tree 树/30.trie.md",key:"v-3a0c73d0",path:"/ds/tree/trie/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:277},{level:2,title:"实现方式",slug:"实现方式",normalizedTitle:"实现方式",charIndex:348},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:348},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:700},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7838}],headersStr:"介绍 应用 实现方式 实现 JavaScript 参考",content:"# 介绍\n\n在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\n\n\n在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie 可以看作是一个确定有限状态自动机（DFA），尽管边上的符号一般是隐含在分支的顺序中的。\n\n\n# 应用\n\ntrie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。\n\n\n# 实现方式\n\ntrie 树实际上是一个确定有限状态自动机 (DFA)，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式即链表来表示状态转移，但由于要线性查询，会造成效率低下。\n\n于是人们提出了下面两种结构。\n\n * 三数组 Trie：三数组 Trie（Triple-Array Trie）结构包括三个数组：base,next 和 check.\n * 二数组 Trie：二数组 Trie（Double-Array Trie）包含 base 和 check 两个数组。base 数组的每个元素表示一个 Trie 节点，即一个状态；check 数组表示某个状态的前驱状态。\n\n\n# 实现\n\n\n# JavaScript\n\nclass TrieNode {\n  constructor(char) {\n    this._char = char;\n    this._isEndOfWord = false;\n    this._parent = null;\n    this._children = new Map();\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isRoot() {\n    return this._char === '';\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isLeaf() {\n    return this._children.size === 0;\n  }\n\n  /**\n   * @public\n   * @returns {string}\n   */\n  getChar() {\n    return this._char;\n  }\n\n  /**\n   * @internal\n   * @param {TrieNode} parentNode\n   */\n  setParent(parentNode) {\n    this._parent = parentNode;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {TrieNode}\n   */\n  getParent() {\n    return this._parent;\n  }\n\n  /**\n   * @internal\n   * @param {boolean} isEndOfWord\n   */\n  setEndOfWord(isEndOfWord) {\n    this._isEndOfWord = isEndOfWord;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isEndOfWord() {\n    return this._isEndOfWord;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   */\n  addChild(char) {\n    const childNode = new TrieNode(char);\n    childNode.setParent(this);\n    this._children.set(char, childNode);\n    return this;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   * @return {boolean}\n   */\n  removeChild(char) {\n    return this._children.delete(char);\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {TrieNode}\n   */\n  getChild(char) {\n    return this._children.get(char) || null;\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {boolean}\n   */\n  hasChild(char) {\n    return this._children.has(char);\n  }\n\n  /**\n   * @internal\n   * @return {Map}\n   */\n  children() {\n    return this._children;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  childrenCount() {\n    return this._children.size;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this._root = new TrieNode('');\n    this._wordsCount = 0;\n    this._nodesCount = 1; // root node\n  }\n\n  /**\n   * Inserts a word into the trie\n   * @public\n   * @param {any} value\n   * @returns {Trie}\n   */\n  insert(value) {\n    if (value === undefined || value === null) {\n      return this;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        currentNode.addChild(word[i]);\n        this._nodesCount += 1;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      currentNode.setEndOfWord(true);\n      this._wordsCount += 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Checks if a word exists in the trie\n   * @public\n   * @param {any} value\n   * @returns {boolean}\n   */\n  has(value) {\n    if (value === undefined || value === null) {\n      return false;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        return false;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Finds a word in the trie and returns its last char node\n   * @public\n   * @param {any} value\n   * @returns {TrieNode}\n   */\n  find(value) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        return null;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      return null;\n    }\n\n    return currentNode;\n  }\n\n  /**\n   * Removes a word from the trie\n   * @public\n   * @param {string} word\n   * @returns {string | null}\n   */\n  remove(value) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    const word = value.toString();\n    let currentNode = this._root;\n\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentNode.hasChild(word[i])) {\n        return null;\n      }\n      currentNode = currentNode.getChild(word[i]);\n    }\n\n    if (!currentNode.isEndOfWord()) {\n      return null;\n    }\n\n    if (currentNode.childrenCount() > 0 || word === '') {\n      currentNode.setEndOfWord(false);\n      this._wordsCount -= 1;\n      return word;\n    }\n\n    do {\n      currentNode.getParent().removeChild(currentNode.getChar());\n      this._nodesCount -= 1;\n      currentNode = currentNode.getParent();\n    } while (\n      currentNode.isLeaf()\n      && !currentNode.isEndOfWord()\n      && !currentNode.isRoot()\n    );\n\n    this._wordsCount -= 1;\n    return word;\n  }\n\n  /**\n   * Traverse the trie and pass words to a callback\n   * @public\n   * @param {function} cb\n   */\n  forEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('Trie.forEach expects a callback function');\n    }\n\n    const forEachRecursive = (node = this._root, word = '') => {\n      if (node.isEndOfWord()) {\n        cb(word);\n      }\n\n      node.children().forEach((child) => {\n        forEachRecursive(child, word + child.getChar());\n      });\n    };\n\n    return forEachRecursive();\n  }\n\n  /**\n   * Converts the trie into an array of words\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((word) => result.push(word));\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  nodesCount() {\n    return this._nodesCount;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  wordsCount() {\n    return this._wordsCount;\n  }\n\n  /**\n   * Clears the trie\n   * @public\n   */\n  clear() {\n    this._root = new TrieNode('');\n    this._nodesCount = 1;\n    this._wordsCount = 0;\n  }\n\n  /**\n   * Converts an existing list into a trie\n   * @public\n   * @static\n   * @returns {Trie}\n   */\n  static fromArray(values) {\n    const trie = new Trie();\n    values.forEach((value) => trie.insert(value));\n    return trie;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n\n\n\n# 参考\n\n * Trie - Wikiwand",normalizedContent:"# 介绍\n\n在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\n\n\n在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。trie 可以看作是一个确定有限状态自动机（dfa），尽管边上的符号一般是隐含在分支的顺序中的。\n\n\n# 应用\n\ntrie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。\n\n\n# 实现方式\n\ntrie 树实际上是一个确定有限状态自动机 (dfa)，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式即链表来表示状态转移，但由于要线性查询，会造成效率低下。\n\n于是人们提出了下面两种结构。\n\n * 三数组 trie：三数组 trie（triple-array trie）结构包括三个数组：base,next 和 check.\n * 二数组 trie：二数组 trie（double-array trie）包含 base 和 check 两个数组。base 数组的每个元素表示一个 trie 节点，即一个状态；check 数组表示某个状态的前驱状态。\n\n\n# 实现\n\n\n# javascript\n\nclass trienode {\n  constructor(char) {\n    this._char = char;\n    this._isendofword = false;\n    this._parent = null;\n    this._children = new map();\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isroot() {\n    return this._char === '';\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isleaf() {\n    return this._children.size === 0;\n  }\n\n  /**\n   * @public\n   * @returns {string}\n   */\n  getchar() {\n    return this._char;\n  }\n\n  /**\n   * @internal\n   * @param {trienode} parentnode\n   */\n  setparent(parentnode) {\n    this._parent = parentnode;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {trienode}\n   */\n  getparent() {\n    return this._parent;\n  }\n\n  /**\n   * @internal\n   * @param {boolean} isendofword\n   */\n  setendofword(isendofword) {\n    this._isendofword = isendofword;\n    return this;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isendofword() {\n    return this._isendofword;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   */\n  addchild(char) {\n    const childnode = new trienode(char);\n    childnode.setparent(this);\n    this._children.set(char, childnode);\n    return this;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   * @return {boolean}\n   */\n  removechild(char) {\n    return this._children.delete(char);\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {trienode}\n   */\n  getchild(char) {\n    return this._children.get(char) || null;\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {boolean}\n   */\n  haschild(char) {\n    return this._children.has(char);\n  }\n\n  /**\n   * @internal\n   * @return {map}\n   */\n  children() {\n    return this._children;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  childrencount() {\n    return this._children.size;\n  }\n}\n\nclass trie {\n  constructor() {\n    this._root = new trienode('');\n    this._wordscount = 0;\n    this._nodescount = 1; // root node\n  }\n\n  /**\n   * inserts a word into the trie\n   * @public\n   * @param {any} value\n   * @returns {trie}\n   */\n  insert(value) {\n    if (value === undefined || value === null) {\n      return this;\n    }\n\n    const word = value.tostring();\n    let currentnode = this._root;\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentnode.haschild(word[i])) {\n        currentnode.addchild(word[i]);\n        this._nodescount += 1;\n      }\n      currentnode = currentnode.getchild(word[i]);\n    }\n\n    if (!currentnode.isendofword()) {\n      currentnode.setendofword(true);\n      this._wordscount += 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * checks if a word exists in the trie\n   * @public\n   * @param {any} value\n   * @returns {boolean}\n   */\n  has(value) {\n    if (value === undefined || value === null) {\n      return false;\n    }\n\n    const word = value.tostring();\n    let currentnode = this._root;\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentnode.haschild(word[i])) {\n        return false;\n      }\n      currentnode = currentnode.getchild(word[i]);\n    }\n\n    if (!currentnode.isendofword()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * finds a word in the trie and returns its last char node\n   * @public\n   * @param {any} value\n   * @returns {trienode}\n   */\n  find(value) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    const word = value.tostring();\n    let currentnode = this._root;\n\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentnode.haschild(word[i])) {\n        return null;\n      }\n      currentnode = currentnode.getchild(word[i]);\n    }\n\n    if (!currentnode.isendofword()) {\n      return null;\n    }\n\n    return currentnode;\n  }\n\n  /**\n   * removes a word from the trie\n   * @public\n   * @param {string} word\n   * @returns {string | null}\n   */\n  remove(value) {\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    const word = value.tostring();\n    let currentnode = this._root;\n\n    for (let i = 0; i < word.length; i += 1) {\n      if (!currentnode.haschild(word[i])) {\n        return null;\n      }\n      currentnode = currentnode.getchild(word[i]);\n    }\n\n    if (!currentnode.isendofword()) {\n      return null;\n    }\n\n    if (currentnode.childrencount() > 0 || word === '') {\n      currentnode.setendofword(false);\n      this._wordscount -= 1;\n      return word;\n    }\n\n    do {\n      currentnode.getparent().removechild(currentnode.getchar());\n      this._nodescount -= 1;\n      currentnode = currentnode.getparent();\n    } while (\n      currentnode.isleaf()\n      && !currentnode.isendofword()\n      && !currentnode.isroot()\n    );\n\n    this._wordscount -= 1;\n    return word;\n  }\n\n  /**\n   * traverse the trie and pass words to a callback\n   * @public\n   * @param {function} cb\n   */\n  foreach(cb) {\n    if (typeof cb !== 'function') {\n      throw new error('trie.foreach expects a callback function');\n    }\n\n    const foreachrecursive = (node = this._root, word = '') => {\n      if (node.isendofword()) {\n        cb(word);\n      }\n\n      node.children().foreach((child) => {\n        foreachrecursive(child, word + child.getchar());\n      });\n    };\n\n    return foreachrecursive();\n  }\n\n  /**\n   * converts the trie into an array of words\n   * @public\n   * @returns {array}\n   */\n  toarray() {\n    const result = [];\n    this.foreach((word) => result.push(word));\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  nodescount() {\n    return this._nodescount;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  wordscount() {\n    return this._wordscount;\n  }\n\n  /**\n   * clears the trie\n   * @public\n   */\n  clear() {\n    this._root = new trienode('');\n    this._nodescount = 1;\n    this._wordscount = 0;\n  }\n\n  /**\n   * converts an existing list into a trie\n   * @public\n   * @static\n   * @returns {trie}\n   */\n  static fromarray(values) {\n    const trie = new trie();\n    values.foreach((value) => trie.insert(value));\n    return trie;\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n\n\n\n# 参考\n\n * trie - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"vector [矢量]",frontmatter:{title:"vector [矢量]",date:"2022-09-26T10:05:25.000Z",permalink:"/pages/44805c/",categories:["数据结构","vectors 矢量"],tags:[null]},regularPath:"/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/90.vectors%20%E7%9F%A2%E9%87%8F/10.vector.html",relativePath:"10.数据结构/90.vectors 矢量/10.vector.md",key:"v-7d2299f8",path:"/pages/44805c/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:428},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:435},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4229}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在数学和物理学中，矢量（vector，向量）是一个术语，通俗地指一些不能用单个数字（标量）表示的量，或指一些矢量空间的元素。\n\n历史上，矢量被引入几何学和物理学（通常是在力学中），用于表示那些既有大小又有方向的量，如位移、力和速度。这些量用几何向量表示，与距离、质量和时间用实数表示的方式相同。\n\n术语向量（vector）在某些情况下也用于元组（tuples），表示具有固定长度的有限序列的数字。\n\n几何向量和元组都可以被添加和缩放，这些向量操作引出了向量空间的概念，它是一个配备有向量加法和标量乘法的集合，满足一些概括上述各种向量操作的主要属性的公理。由几何向量构成的向量空间被称为欧几里得向量空间，由元组构成的向量空间被称为坐标向量空间。\n\n数学中考虑的向量空间有很多，如扩展场、多项式环、代数和函数空间。术语向量一般不用于这些向量空间的元素，一般保留给几何向量、元组和未指定的向量空间的元素（例如，在讨论向量空间的一般属性时）。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * In mathematics and physics, a vector is an element of a vector space.\n *\n * The Vector2-class implements 2-dimensional vectors together with various vector-operations.\n * @see https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics).\n */\n\nclass Vector2 {\n  constructor (x, y) {\n    this.x = x\n    this.y = y\n  }\n\n  /**\n   * Check for exact vector equality.\n   *\n   * @param vector The vector to compare to.\n   * @returns Whether they are exactly equal or not.\n   */\n  equalsExactly (vector) {\n    return this.x === vector.x && this.y === vector.y\n  }\n\n  /**\n   * Check for approximate vector equality.\n   *\n   * @param vector The vector to compare to.\n   * @param epsilon The allowed discrepancy for the x-values and the y-values.\n   * @returns Whether they are approximately equal or not.\n   */\n  equalsApproximately (vector, epsilon) {\n    return (Math.abs(this.x - vector.x) < epsilon && Math.abs(this.y - vector.y) < epsilon)\n  }\n\n  /**\n   * Vector length.\n   *\n   * @returns The length of the vector.\n   */\n  length () {\n    return Math.sqrt(this.x * this.x + this.y * this.y)\n  }\n\n  /**\n   * Normalization sets the vector to length 1 while maintaining its direction.\n   *\n   * @returns The normalized vector.\n   */\n  normalize () {\n    const length = this.length()\n    if (length === 0) {\n      throw new Error('Cannot normalize vectors of length 0')\n    }\n    return new Vector2(this.x / length, this.y / length)\n  }\n\n  /**\n   * Vector addition\n   *\n   * @param vector The vector to be added.\n   * @returns The sum-vector.\n   */\n  add (vector) {\n    const x = this.x + vector.x\n    const y = this.y + vector.y\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Vector subtraction\n   *\n   * @param vector The vector to be subtracted.\n   * @returns The difference-vector.\n   */\n  subtract (vector) {\n    const x = this.x - vector.x\n    const y = this.y - vector.y\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Vector scalar multiplication\n   *\n   * @param scalar The factor by which to multiply the vector.\n   * @returns The scaled vector.\n   */\n  multiply (scalar) {\n    const x = this.x * scalar\n    const y = this.y * scalar\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Distance between this vector and another vector.\n   *\n   * @param vector The vector to which to calculate the distance.\n   * @returns The distance.\n   */\n  distance (vector) {\n    const difference = vector.subtract(this)\n    return difference.length()\n  }\n\n  /**\n   * Vector dot product\n   *\n   * @param vector The vector used for the multiplication.\n   * @returns The resulting dot product.\n   */\n  dotProduct (vector) {\n    return this.x * vector.x + this.y * vector.y\n  }\n\n  /**\n   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)\n   *\n   * @param angleInRadians The angle in radians by which to rotate the vector.\n   * @returns The rotated vector.\n   */\n  rotate (angleInRadians) {\n    const ca = Math.cos(angleInRadians)\n    const sa = Math.sin(angleInRadians)\n    const x = ca * this.x - sa * this.y\n    const y = sa * this.x + ca * this.y\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Measure angle between two vectors\n   *\n   * @param vector The 2nd vector for the measurement.\n   * @returns The angle in radians.\n   */\n  angleBetween (vector) {\n    return Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n\n\n\n# 参考\n\n * Vector (mathematics and physics) - Wikiwand",normalizedContent:"# 介绍\n\n在数学和物理学中，矢量（vector，向量）是一个术语，通俗地指一些不能用单个数字（标量）表示的量，或指一些矢量空间的元素。\n\n历史上，矢量被引入几何学和物理学（通常是在力学中），用于表示那些既有大小又有方向的量，如位移、力和速度。这些量用几何向量表示，与距离、质量和时间用实数表示的方式相同。\n\n术语向量（vector）在某些情况下也用于元组（tuples），表示具有固定长度的有限序列的数字。\n\n几何向量和元组都可以被添加和缩放，这些向量操作引出了向量空间的概念，它是一个配备有向量加法和标量乘法的集合，满足一些概括上述各种向量操作的主要属性的公理。由几何向量构成的向量空间被称为欧几里得向量空间，由元组构成的向量空间被称为坐标向量空间。\n\n数学中考虑的向量空间有很多，如扩展场、多项式环、代数和函数空间。术语向量一般不用于这些向量空间的元素，一般保留给几何向量、元组和未指定的向量空间的元素（例如，在讨论向量空间的一般属性时）。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * in mathematics and physics, a vector is an element of a vector space.\n *\n * the vector2-class implements 2-dimensional vectors together with various vector-operations.\n * @see https://en.wikipedia.org/wiki/vector_(mathematics_and_physics).\n */\n\nclass vector2 {\n  constructor (x, y) {\n    this.x = x\n    this.y = y\n  }\n\n  /**\n   * check for exact vector equality.\n   *\n   * @param vector the vector to compare to.\n   * @returns whether they are exactly equal or not.\n   */\n  equalsexactly (vector) {\n    return this.x === vector.x && this.y === vector.y\n  }\n\n  /**\n   * check for approximate vector equality.\n   *\n   * @param vector the vector to compare to.\n   * @param epsilon the allowed discrepancy for the x-values and the y-values.\n   * @returns whether they are approximately equal or not.\n   */\n  equalsapproximately (vector, epsilon) {\n    return (math.abs(this.x - vector.x) < epsilon && math.abs(this.y - vector.y) < epsilon)\n  }\n\n  /**\n   * vector length.\n   *\n   * @returns the length of the vector.\n   */\n  length () {\n    return math.sqrt(this.x * this.x + this.y * this.y)\n  }\n\n  /**\n   * normalization sets the vector to length 1 while maintaining its direction.\n   *\n   * @returns the normalized vector.\n   */\n  normalize () {\n    const length = this.length()\n    if (length === 0) {\n      throw new error('cannot normalize vectors of length 0')\n    }\n    return new vector2(this.x / length, this.y / length)\n  }\n\n  /**\n   * vector addition\n   *\n   * @param vector the vector to be added.\n   * @returns the sum-vector.\n   */\n  add (vector) {\n    const x = this.x + vector.x\n    const y = this.y + vector.y\n    return new vector2(x, y)\n  }\n\n  /**\n   * vector subtraction\n   *\n   * @param vector the vector to be subtracted.\n   * @returns the difference-vector.\n   */\n  subtract (vector) {\n    const x = this.x - vector.x\n    const y = this.y - vector.y\n    return new vector2(x, y)\n  }\n\n  /**\n   * vector scalar multiplication\n   *\n   * @param scalar the factor by which to multiply the vector.\n   * @returns the scaled vector.\n   */\n  multiply (scalar) {\n    const x = this.x * scalar\n    const y = this.y * scalar\n    return new vector2(x, y)\n  }\n\n  /**\n   * distance between this vector and another vector.\n   *\n   * @param vector the vector to which to calculate the distance.\n   * @returns the distance.\n   */\n  distance (vector) {\n    const difference = vector.subtract(this)\n    return difference.length()\n  }\n\n  /**\n   * vector dot product\n   *\n   * @param vector the vector used for the multiplication.\n   * @returns the resulting dot product.\n   */\n  dotproduct (vector) {\n    return this.x * vector.x + this.y * vector.y\n  }\n\n  /**\n   * vector rotation (see https://en.wikipedia.org/wiki/rotation_matrix)\n   *\n   * @param angleinradians the angle in radians by which to rotate the vector.\n   * @returns the rotated vector.\n   */\n  rotate (angleinradians) {\n    const ca = math.cos(angleinradians)\n    const sa = math.sin(angleinradians)\n    const x = ca * this.x - sa * this.y\n    const y = sa * this.x + ca * this.y\n    return new vector2(x, y)\n  }\n\n  /**\n   * measure angle between two vectors\n   *\n   * @param vector the 2nd vector for the measurement.\n   * @returns the angle in radians.\n   */\n  anglebetween (vector) {\n    return math.atan2(vector.y, vector.x) - math.atan2(this.y, this.x)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n\n\n\n# 参考\n\n * vector (mathematics and physics) - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-16T16:43:23.000Z",permalink:"/algorithm/index/",categories:["算法"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/0.index.html",relativePath:"20.算法/0.index.md",key:"v-08c0f6d6",path:"/algorithm/index/",headers:[{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:2},{level:2,title:"视频资源",slug:"视频资源",normalizedTitle:"视频资源",charIndex:16},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:81}],headersStr:"练习 视频资源 参考",content:"# 练习\n\n练习：算法\n\n\n# 视频资源\n\n * MIT 6.006 算法导论 Introduction to Algorithms【双语 cc 字幕】\n\n\n# 参考\n\n * The Algorithms\n * The Algorithms 官网\n * trekhleb/javascript-algorithms: 📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings\n * Sorting Algorithms Animations\n * 复杂度速查表\n * Algorithms - GeeksforGeeks\n * Data Structure Visualization\n * Mirror: Data Structure Visualization\n * OI-wiki/OI-wiki: 🌟 Wiki of OI / ICPC for everyone. （某大型游戏线上攻略，内含炫酷算术魔法）\n * OI Wiki\n * Rust Algorithm Club - Rust Algorithm Club\n * raywenderlich/swift-algorithm-club: Algorithms and data structures in Swift, with explanations!\n * Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne\n * labuladong/fucking-algorithm: 刷算法全靠套路，认准 labuladong 就够了！English version supported! Crack LeetCode, not only how, but also why.",normalizedContent:"# 练习\n\n练习：算法\n\n\n# 视频资源\n\n * mit 6.006 算法导论 introduction to algorithms【双语 cc 字幕】\n\n\n# 参考\n\n * the algorithms\n * the algorithms 官网\n * trekhleb/javascript-algorithms: 📝 algorithms and data structures implemented in javascript with explanations and links to further readings\n * sorting algorithms animations\n * 复杂度速查表\n * algorithms - geeksforgeeks\n * data structure visualization\n * mirror: data structure visualization\n * oi-wiki/oi-wiki: 🌟 wiki of oi / icpc for everyone. （某大型游戏线上攻略，内含炫酷算术魔法）\n * oi wiki\n * rust algorithm club - rust algorithm club\n * raywenderlich/swift-algorithm-club: algorithms and data structures in swift, with explanations!\n * algorithms, 4th edition by robert sedgewick and kevin wayne\n * labuladong/fucking-algorithm: 刷算法全靠套路，认准 labuladong 就够了！english version supported! crack leetcode, not only how, but also why.",charsets:{cjk:!0},lastUpdated:"2022/11/01, 18:11:55",lastUpdatedTimestamp:1667297515e3},{title:"Plan 计划",frontmatter:{title:"Plan 计划",date:"2022-04-16T16:44:07.000Z",permalink:"/algorithm/plan/",categories:["算法"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/1.plan.html",relativePath:"20.算法/1.plan.md",key:"v-7c919012",path:"/algorithm/plan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 16:50:00",lastUpdatedTimestamp:1650099e6},{title:"章节概要",frontmatter:{title:"章节概要",date:"2022-05-09T13:19:28.000Z",permalink:"/algorithm/sort/index/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/0.index.html",relativePath:"20.算法/10.Sort 排序/0.index.md",key:"v-58cd83de",path:"/algorithm/sort/index/",headers:[{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:2},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:9}],headersStr:"动画 参考",content:"# 动画\n\n\n# 参考\n\n * 排序算法 - 维基百科，自由的百科全书",normalizedContent:"# 动画\n\n\n# 参考\n\n * 排序算法 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"AlphaNumericalSort [字母顺序排序]",frontmatter:{title:"AlphaNumericalSort [字母顺序排序]",date:"2022-04-26T22:46:08.000Z",permalink:"/algorithm/sort/alphaNumericalSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/10.alphaNumericalSort.html",relativePath:"20.算法/10.Sort 排序/10.alphaNumericalSort.md",key:"v-ec80aaaa",path:"/algorithm/sort/alphaNumericalSort/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1783}],headersStr:"实现 JavaScript 参考",content:'# 实现\n\n\n# JavaScript\n\n/*\n  https://en.wikipedia.org/wiki/Natural_sort_order\n  In computing, natural sort order (or natural sorting) is the ordering of strings in alphabetical order,\n  except that multi-digit numbers are treated atomically, i.e., as if they were a single character. Natural sort order\n  has been promoted as being more human-friendly ("natural") than machine-oriented, pure alphabetical sort order.[1]\n  For example, in alphabetical sorting, "z11" would be sorted before "z2" because the "1" in the first string is sorted as smaller\n  than "2", while in natural sorting "z2" is sorted before "z11" because "2" is treated as smaller than "11".\n  Alphabetical sorting:\n  1.z11\n  2.z2\n  Natural sorting:\n  1. z2\n  2. z11\n  P.S. use this function, as there are a lot of implementations on the stackoverflow and other forums, but many of them don\'t work correctly (can\'t pass all my tests)\n*/\n\nconst alphaNumericalSort = (a, b) => {\n  /*\n    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n    The localeCompare() method returns a number indicating whether a reference string comes before, or after, or is the same as the given string in sort order.\n    The new locales and options arguments let applications specify the language whose sort order should be used and customize the behavior of the function.\n    In older implementations, which ignore the locales and options arguments, the locale and sort order used are entirely implementation-dependent.\n    Syntax:\n    localeCompare(compareString, locales, options)\n  */\n  return a.localeCompare(b, undefined, { numeric: true })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nString.prototype.localeCompare()\n\nlocaleCompare () 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。参考：String.prototype.localeCompare() - JavaScript | MDN\n\n\n# 参考\n\n * How to sort strings in JavaScript - Stack Overflow',normalizedContent:'# 实现\n\n\n# javascript\n\n/*\n  https://en.wikipedia.org/wiki/natural_sort_order\n  in computing, natural sort order (or natural sorting) is the ordering of strings in alphabetical order,\n  except that multi-digit numbers are treated atomically, i.e., as if they were a single character. natural sort order\n  has been promoted as being more human-friendly ("natural") than machine-oriented, pure alphabetical sort order.[1]\n  for example, in alphabetical sorting, "z11" would be sorted before "z2" because the "1" in the first string is sorted as smaller\n  than "2", while in natural sorting "z2" is sorted before "z11" because "2" is treated as smaller than "11".\n  alphabetical sorting:\n  1.z11\n  2.z2\n  natural sorting:\n  1. z2\n  2. z11\n  p.s. use this function, as there are a lot of implementations on the stackoverflow and other forums, but many of them don\'t work correctly (can\'t pass all my tests)\n*/\n\nconst alphanumericalsort = (a, b) => {\n  /*\n    https://developer.mozilla.org/ru/docs/web/javascript/reference/global_objects/string/localecompare\n    the localecompare() method returns a number indicating whether a reference string comes before, or after, or is the same as the given string in sort order.\n    the new locales and options arguments let applications specify the language whose sort order should be used and customize the behavior of the function.\n    in older implementations, which ignore the locales and options arguments, the locale and sort order used are entirely implementation-dependent.\n    syntax:\n    localecompare(comparestring, locales, options)\n  */\n  return a.localecompare(b, undefined, { numeric: true })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nstring.prototype.localecompare()\n\nlocalecompare () 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。参考：string.prototype.localecompare() - javascript | mdn\n\n\n# 参考\n\n * how to sort strings in javascript - stack overflow',charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"FisherYatesShuffle [洗牌算法]",frontmatter:{title:"FisherYatesShuffle [洗牌算法]",date:"2022-04-26T23:01:20.000Z",permalink:"/algorithm/sort/fisherYatesShuffle/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/100.fisherYatesShuffle.html",relativePath:"20.算法/10.Sort 排序/100.fisherYatesShuffle.md",key:"v-3ee6121d",path:"/algorithm/sort/fisherYatesShuffle/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:94},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:211},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:218},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:852}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p>\n',headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\nFisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。\n\n\n# 原理\n\n\n\n根据每次迭代次数可以用下面的表格，描述这个算法的执行过程：\n\n\n\n动画：\n\nSee the Pen Fisher–Yates shuffle by Chuan shi (@haoyang) on CodePen.\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite sequence—in plain terms, the algorithm shuffles the sequence.\n **/\nconst fisherYatesShuffle = (array) => {\n  let maxLength = array.length\n  let temp\n  let idx\n\n  // While there remain elements to shuffle...\n  while (maxLength) {\n    // Pick a remaining element...\n    idx = Math.floor(Math.random() * maxLength--)\n\n    // And swap it with the current element\n    temp = array[maxLength]\n    array[maxLength] = array[idx]\n    array[idx] = temp\n  }\n\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 参考\n\n * Fisher–Yates shuffle - Wikipedia",normalizedContent:"# 介绍\n\nfisher–yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。\n\n\n# 原理\n\n\n\n根据每次迭代次数可以用下面的表格，描述这个算法的执行过程：\n\n\n\n动画：\n\nsee the pen fisher–yates shuffle by chuan shi (@haoyang) on codepen.\n\n\n# 实现\n\n\n# javascript\n\n/**\n * the fisher–yates shuffle is an algorithm for generating a random permutation of a finite sequence—in plain terms, the algorithm shuffles the sequence.\n **/\nconst fisheryatesshuffle = (array) => {\n  let maxlength = array.length\n  let temp\n  let idx\n\n  // while there remain elements to shuffle...\n  while (maxlength) {\n    // pick a remaining element...\n    idx = math.floor(math.random() * maxlength--)\n\n    // and swap it with the current element\n    temp = array[maxlength]\n    array[maxlength] = array[idx]\n    array[idx] = temp\n  }\n\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 参考\n\n * fisher–yates shuffle - wikipedia",charsets:{cjk:!0},lastUpdated:"2022/05/09, 13:34:14",lastUpdatedTimestamp:1652074454e3},{title:"FlashSort [闪电排序]",frontmatter:{title:"FlashSort [闪电排序]",date:"2022-04-26T23:02:12.000Z",permalink:"/algorithm/sort/flashSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/110.flashSort.html",relativePath:"20.算法/10.Sort 排序/110.flashSort.md",key:"v-27f6e919",path:"/algorithm/sort/flashSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:70},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:210},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:217},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1898}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>FlashSort 是一个分布排序算法显示线性计算复杂度 O (n) 用于均匀分布的数据集，并且几乎不需要额外的内存。</p>\n',headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\nFlashSort 是一个分布排序算法显示线性计算复杂度 O (n) 用于均匀分布的数据集，并且几乎不需要额外的内存。\n\n\n# 原理\n\n * 类似桶排序，但减少了无用的空桶，从而节约了空间。\n * 初始化桶的数量为待排序元素的个数。\n * 通过下面函数计算每个元素期望放入的桶。\n\n\n\n注意：这个下标是从 1 开始的。\n\n * 对同一个桶存在多个元素利用任意排序算法进行内排序，然后按顺序取出即可。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * FlashSort is a distribution sorting algorithm showing linear\n * computational complexity O(n) for uniformly distributed\n * data sets and relatively little additional memory requirement.\n *\n * Wikipedia: https://en.wikipedia.org/wiki/Flashsort\n */\n\nfunction flashSort (arr) {\n  let max = 0; let min = arr[0]\n  const n = arr.length\n  const m = ~~(0.45 * n)\n  const l = new Array(m)\n\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] < min) {\n      min = arr[i]\n    }\n    if (arr[i] > arr[max]) {\n      max = i\n    }\n  }\n\n  if (min === arr[max]) {\n    return arr\n  }\n\n  const c1 = (m - 1) / (arr[max] - min)\n\n  for (let k = 0; k < m; k++) {\n    l[k] = 0\n  }\n\n  for (let j = 0; j < n; ++j) {\n    const k = ~~(c1 * (arr[j] - min))\n    ++l[k]\n  }\n\n  for (let p = 1; p < m; ++p) {\n    l[p] = l[p] + l[p - 1]\n  }\n\n  let hold = arr[max]\n  arr[max] = arr[0]\n  arr[0] = hold\n\n  // permutation\n  let move = 0; let t; let flash\n  let j = 0\n  let k = m - 1\n\n  while (move < (n - 1)) {\n    while (j > (l[k] - 1)) {\n      ++j\n      k = ~~(c1 * (arr[j] - min))\n    }\n    if (k < 0) break\n    flash = arr[j]\n    while (j !== l[k]) {\n      k = ~~(c1 * (flash - min))\n      hold = arr[t = --l[k]]\n      arr[t] = flash\n      flash = hold\n      ++move\n    }\n  }\n\n  // insertion\n  for (j = 1; j < n; j++) {\n    hold = arr[j]\n    let i = j - 1\n    while (i >= 0 && arr[i] > hold) {\n      arr[i + 1] = arr[i--]\n    }\n    arr[i + 1] = hold\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 参考\n\n * Flashsort - Wikipedia\n * Flashsort - 维基百科",normalizedContent:"# 介绍\n\nflashsort 是一个分布排序算法显示线性计算复杂度 o (n) 用于均匀分布的数据集，并且几乎不需要额外的内存。\n\n\n# 原理\n\n * 类似桶排序，但减少了无用的空桶，从而节约了空间。\n * 初始化桶的数量为待排序元素的个数。\n * 通过下面函数计算每个元素期望放入的桶。\n\n\n\n注意：这个下标是从 1 开始的。\n\n * 对同一个桶存在多个元素利用任意排序算法进行内排序，然后按顺序取出即可。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * flashsort is a distribution sorting algorithm showing linear\n * computational complexity o(n) for uniformly distributed\n * data sets and relatively little additional memory requirement.\n *\n * wikipedia: https://en.wikipedia.org/wiki/flashsort\n */\n\nfunction flashsort (arr) {\n  let max = 0; let min = arr[0]\n  const n = arr.length\n  const m = ~~(0.45 * n)\n  const l = new array(m)\n\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] < min) {\n      min = arr[i]\n    }\n    if (arr[i] > arr[max]) {\n      max = i\n    }\n  }\n\n  if (min === arr[max]) {\n    return arr\n  }\n\n  const c1 = (m - 1) / (arr[max] - min)\n\n  for (let k = 0; k < m; k++) {\n    l[k] = 0\n  }\n\n  for (let j = 0; j < n; ++j) {\n    const k = ~~(c1 * (arr[j] - min))\n    ++l[k]\n  }\n\n  for (let p = 1; p < m; ++p) {\n    l[p] = l[p] + l[p - 1]\n  }\n\n  let hold = arr[max]\n  arr[max] = arr[0]\n  arr[0] = hold\n\n  // permutation\n  let move = 0; let t; let flash\n  let j = 0\n  let k = m - 1\n\n  while (move < (n - 1)) {\n    while (j > (l[k] - 1)) {\n      ++j\n      k = ~~(c1 * (arr[j] - min))\n    }\n    if (k < 0) break\n    flash = arr[j]\n    while (j !== l[k]) {\n      k = ~~(c1 * (flash - min))\n      hold = arr[t = --l[k]]\n      arr[t] = flash\n      flash = hold\n      ++move\n    }\n  }\n\n  // insertion\n  for (j = 1; j < n; j++) {\n    hold = arr[j]\n    let i = j - 1\n    while (i >= 0 && arr[i] > hold) {\n      arr[i + 1] = arr[i--]\n    }\n    arr[i + 1] = hold\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 参考\n\n * flashsort - wikipedia\n * flashsort - 维基百科",charsets:{cjk:!0},lastUpdated:"2022/05/09, 13:34:14",lastUpdatedTimestamp:1652074454e3},{title:"GnomeSort [侏儒排序]",frontmatter:{title:"GnomeSort [侏儒排序]",date:"2022-04-26T23:03:11.000Z",permalink:"/algorithm/sort/gnomeSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/120.gnomeSort.html",relativePath:"20.算法/10.Sort 排序/120.gnomeSort.md",key:"v-c42c0f0a",path:"/algorithm/sort/gnomeSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:125},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:134},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:378},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:50},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:527},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1079}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>Gnome 算法类似于插入排序，但是移动元素到它该去的位置是通过一系列类似冒泡排序的移动实现的。从概念上讲侏儒排序非常简单，甚至不需要嵌套循环。它的平均运行时间是 O (n2)，如果列表已经排序好则只需 O (n) 的运行时间。</p>\n',headersStr:"介绍 原理 伪代码 复杂度 实现 JavaScript 参考",content:"# 介绍\n\nGnome 算法类似于插入排序，但是移动元素到它该去的位置是通过一系列类似冒泡排序的移动实现的。从概念上讲侏儒排序非常简单，甚至不需要嵌套循环。它的平均运行时间是 O (n2)，如果列表已经排序好则只需 O (n) 的运行时间。\n\n\n# 原理\n\n\n\n\n# 伪代码\n\nprocedure gnomeSort(a[]):\n    pos := 0\n    while pos < length(a):\n        if (pos == 0 or a[pos] >= a[pos-1]):\n            pos := pos + 1\n        else:\n            swap a[pos] and a[pos-1]\n            pos := pos - 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 复杂度\n\n * 平均时间复杂度 O(n2)O(n^{2})O(n2)\n * 最坏时间复杂度 O(n2)O(n^{2})O(n2)\n * 最优时间复杂度 Ω(n){\\displaystyle \\Omega (n)}Ω(n)\n * 空间复杂度 O(1)O(1)O(1) 辅助空间\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Gnome sort is a sort algorithm that moving an element to its proper place is accomplished by a series of swap\n * more information: https://en.wikipedia.org/wiki/Gnome_sort\n *\n */\nfunction gnomeSort (items) {\n  if (items.length <= 1) {\n    return\n  }\n\n  let i = 1\n\n  while (i < items.length) {\n    if (items[i - 1] <= items[i]) {\n      i++\n    } else {\n      [items[i], items[i - 1]] = [items[i - 1], items[i]]\n\n      i = Math.max(1, i - 1)\n    }\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考\n\n * 侏儒排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\ngnome 算法类似于插入排序，但是移动元素到它该去的位置是通过一系列类似冒泡排序的移动实现的。从概念上讲侏儒排序非常简单，甚至不需要嵌套循环。它的平均运行时间是 o (n2)，如果列表已经排序好则只需 o (n) 的运行时间。\n\n\n# 原理\n\n\n\n\n# 伪代码\n\nprocedure gnomesort(a[]):\n    pos := 0\n    while pos < length(a):\n        if (pos == 0 or a[pos] >= a[pos-1]):\n            pos := pos + 1\n        else:\n            swap a[pos] and a[pos-1]\n            pos := pos - 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 复杂度\n\n * 平均时间复杂度 o(n2)o(n^{2})o(n2)\n * 最坏时间复杂度 o(n2)o(n^{2})o(n2)\n * 最优时间复杂度 ω(n){\\displaystyle \\omega (n)}ω(n)\n * 空间复杂度 o(1)o(1)o(1) 辅助空间\n\n\n# 实现\n\n\n# javascript\n\n/*\n * gnome sort is a sort algorithm that moving an element to its proper place is accomplished by a series of swap\n * more information: https://en.wikipedia.org/wiki/gnome_sort\n *\n */\nfunction gnomesort (items) {\n  if (items.length <= 1) {\n    return\n  }\n\n  let i = 1\n\n  while (i < items.length) {\n    if (items[i - 1] <= items[i]) {\n      i++\n    } else {\n      [items[i], items[i - 1]] = [items[i - 1], items[i]]\n\n      i = math.max(1, i - 1)\n    }\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考\n\n * 侏儒排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/05/09, 13:34:14",lastUpdatedTimestamp:1652074454e3},{title:"HeapSort [堆排序]",frontmatter:{title:"HeapSort [堆排序]",date:"2022-04-26T23:04:29.000Z",permalink:"/algorithm/sort/heapSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/130.heapSort.html",relativePath:"20.算法/10.Sort 排序/130.heapSort.md",key:"v-3d00a37d",path:"/algorithm/sort/heapSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:100},{level:3,title:"堆节点访问",slug:"堆节点访问",normalizedTitle:"堆节点访问",charIndex:455},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:683},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:867},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:473},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:881},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2427}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>堆排序（英语：HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</p>\n',headersStr:"介绍 原理 堆节点访问 复杂度 动画 实现 JavaScript 参考",content:'# 介绍\n\n堆排序（英语：HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。\n\n\n# 原理\n\n若以升序排序说明，把数组转换成最大堆 (Max-Heap Heap)，这是一种满足最大堆性质 (Max-Heap Property) 的二叉树：对于除了根之外的每个节点 i, A[parent(i)]≥A[i]A[parent(i)] ≥ A[i]A[parent(i)]≥A[i]。\n\n重复从最大堆取出数值最大的结点 (把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。\n\n\n\n堆排序的基本思路：\n\n * 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；\n * 将堆顶元素与末尾元素交换，将最大元素 "沉" 到数组末端；\n * 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。\n\n\n# 堆节点访问\n\n通常堆是通过一维数组来实现的。在数组起始位置为 0 的情形中：\n\n * 父节点 i 的左子节点在位置 (2i+1){\\displaystyle (2i+1)}(2i+1);\n * 父节点 i 的右子节点在位置 (2i+2){\\displaystyle (2i+2)}(2i+2);\n * 子节点 i 的父节点在位置 ⌊(i−1)/2⌋{\\displaystyle \\lfloor (i-1)/2\\rfloor }⌊(i−1)/2⌋;\n\n\n# 复杂度\n\n * 平均时间复杂度 Θ(nlog⁡n)\\Theta (n\\log n)Θ(nlogn)\n * 最坏时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)\n * 最优时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)\n * 空间复杂度 O(n)O(n)O(n) total, O(1)O(1)O(1) auxiliary\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Build a max heap out of the array. A heap is a specialized tree like\n * data structure that satisfies the heap property. The heap property\n * for max heap is the following: "if P is a parent node of C, then the\n * key (the value) of node P is greater than the key of node C"\n * Source: https://en.wikipedia.org/wiki/Heap_(data_structure)\n */\n/* eslint no-extend-native: ["off", { "exceptions": ["Object"] }] */\nArray.prototype.heapify = function (index, heapSize) {\n  let largest = index\n  const leftIndex = 2 * index + 1\n  const rightIndex = 2 * index + 2\n\n  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {\n    largest = leftIndex\n  }\n\n  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {\n    largest = rightIndex\n  }\n\n  if (largest !== index) {\n    const temp = this[largest]\n    this[largest] = this[index]\n    this[index] = temp\n\n    this.heapify(largest, heapSize)\n  }\n}\n\n/*\n * Heap sort sorts an array by building a heap from the array and\n * utilizing the heap property.\n * For more information see: https://en.wikipedia.org/wiki/Heapsort\n */\nfunction heapSort (items) {\n  const length = items.length\n\n  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {\n    items.heapify(i, length)\n  }\n  for (let j = length - 1; j > 0; j--) {\n    const tmp = items[0]\n    items[0] = items[j]\n    items[j] = tmp\n    items.heapify(0, j)\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 参考\n\n * 堆 - 维基百科，自由的百科全书\n * 堆排序 - 维基百科，自由的百科全书\n * 图解排序算法 (三) 之堆排序',normalizedContent:'# 介绍\n\n堆排序（英语：heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。\n\n\n# 原理\n\n若以升序排序说明，把数组转换成最大堆 (max-heap heap)，这是一种满足最大堆性质 (max-heap property) 的二叉树：对于除了根之外的每个节点 i, a[parent(i)]≥a[i]a[parent(i)] ≥ a[i]a[parent(i)]≥a[i]。\n\n重复从最大堆取出数值最大的结点 (把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。\n\n\n\n堆排序的基本思路：\n\n * 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；\n * 将堆顶元素与末尾元素交换，将最大元素 "沉" 到数组末端；\n * 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。\n\n\n# 堆节点访问\n\n通常堆是通过一维数组来实现的。在数组起始位置为 0 的情形中：\n\n * 父节点 i 的左子节点在位置 (2i+1){\\displaystyle (2i+1)}(2i+1);\n * 父节点 i 的右子节点在位置 (2i+2){\\displaystyle (2i+2)}(2i+2);\n * 子节点 i 的父节点在位置 ⌊(i−1)/2⌋{\\displaystyle \\lfloor (i-1)/2\\rfloor }⌊(i−1)/2⌋;\n\n\n# 复杂度\n\n * 平均时间复杂度 θ(nlog⁡n)\\theta (n\\log n)θ(nlogn)\n * 最坏时间复杂度 o(nlog⁡n)o(n\\log n)o(nlogn)\n * 最优时间复杂度 o(nlog⁡n)o(n\\log n)o(nlogn)\n * 空间复杂度 o(n)o(n)o(n) total, o(1)o(1)o(1) auxiliary\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/*\n * build a max heap out of the array. a heap is a specialized tree like\n * data structure that satisfies the heap property. the heap property\n * for max heap is the following: "if p is a parent node of c, then the\n * key (the value) of node p is greater than the key of node c"\n * source: https://en.wikipedia.org/wiki/heap_(data_structure)\n */\n/* eslint no-extend-native: ["off", { "exceptions": ["object"] }] */\narray.prototype.heapify = function (index, heapsize) {\n  let largest = index\n  const leftindex = 2 * index + 1\n  const rightindex = 2 * index + 2\n\n  if (leftindex < heapsize && this[leftindex] > this[largest]) {\n    largest = leftindex\n  }\n\n  if (rightindex < heapsize && this[rightindex] > this[largest]) {\n    largest = rightindex\n  }\n\n  if (largest !== index) {\n    const temp = this[largest]\n    this[largest] = this[index]\n    this[index] = temp\n\n    this.heapify(largest, heapsize)\n  }\n}\n\n/*\n * heap sort sorts an array by building a heap from the array and\n * utilizing the heap property.\n * for more information see: https://en.wikipedia.org/wiki/heapsort\n */\nfunction heapsort (items) {\n  const length = items.length\n\n  for (let i = math.floor(length / 2) - 1; i > -1; i--) {\n    items.heapify(i, length)\n  }\n  for (let j = length - 1; j > 0; j--) {\n    const tmp = items[0]\n    items[0] = items[j]\n    items[j] = tmp\n    items.heapify(0, j)\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 参考\n\n * 堆 - 维基百科，自由的百科全书\n * 堆排序 - 维基百科，自由的百科全书\n * 图解排序算法 (三) 之堆排序',charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"InsertionSort [插入排序]",frontmatter:{title:"InsertionSort [插入排序]",date:"2022-04-26T23:06:26.000Z",permalink:"/algorithm/sort/insertionSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/150.insertionSort.html",relativePath:"20.算法/10.Sort 排序/150.insertionSort.md",key:"v-01cb1163",path:"/algorithm/sort/insertionSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:93},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:451},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:587},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:142},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:601},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2898}],headersStr:"介绍 原理 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n插入排序（英语：Insertion Sort）是一种简单直观的排序算法。Insertion Sort 和打扑克牌时，从牌桌上逐一拿起扑克牌，在手上排序的过程相同。\n\n它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1){\\displaystyle O(1)}O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n\n# 原理\n\n一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：\n\n\n\n * 从第一个元素开始，该元素可以认为已经被排序\n * 取出下一个元素，在已经排序的元素序列中从后向前扫描\n * 如果该元素（已排序）大于新元素，将该元素移到下一位置\n * 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置\n * 将新元素插入到该位置后\n * 重复步骤 2~5\n\n\n\n\n# 复杂度\n\n * 平均时间复杂度O(n2)O(n^{2})O(n2)\n * 最坏时间复杂度O(n2)O(n^{2})O(n2)\n * 最优时间复杂度O(n)O(n)O(n)\n * 空间复杂度：总共 O(n)O(n)O(n) ，需要辅助空间 O(1)O(1)O(1)\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/* In insertion sort, we divide the initial unsorted array into two parts;\n * sorted part and unsorted part. Initially the sorted part just has one\n * element (Array of only 1 element is a sorted array). We then pick up\n * element one by one from unsorted part; insert into the sorted part at\n * the correct position and expand sorted part one element at a time.\n */\n\nfunction insertionSort (unsortedList) {\n  const len = unsortedList.length\n  for (let i = 1; i < len; i++) {\n    let j\n    const tmp = unsortedList[i] // Copy of the current element.\n    /* Check through the sorted part and compare with the number in tmp. If large, shift the number */\n    for (j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {\n      // Shift the number\n      unsortedList[j + 1] = unsortedList[j]\n    }\n    // Insert the copied number at the correct position\n    // in sorted part.\n    unsortedList[j + 1] = tmp\n  }\n}\n\n/**\n * @function insertionSortAlternativeImplementation\n * @description InsertionSort is a stable sorting algorithm\n * @param {Integer[]} array - Array of integers\n * @return {Integer[]} - Sorted array\n * @see [InsertionSort](https://en.wikipedia.org/wiki/Insertion_sort)\n */\n\n/*\n  * Big-O Analysis\n      * Time Complexity\n        - O(N^2) on average and worst case scenario\n        - O(N) on best case scenario (when input array is already almost sorted)\n      * Space Complexity\n        - O(1)\n*/\n\nfunction insertionSortAlternativeImplementation (array) {\n  const length = array.length\n  if (length < 2) return array\n\n  for (let i = 1; i < length; i++) {\n    // Take current element in array\n    const currentItem = array[i]\n    // Take index of previous element in array\n    let j = i - 1\n\n    // While j >= 0 and previous element is greater than current element\n    while (j >= 0 && array[j] > currentItem) {\n      // Move previous, greater element towards the unsorted part\n      array[j + 1] = array[j]\n      j--\n    }\n    // Insert currentItem number at the correct position in sorted part.\n    array[j + 1] = currentItem\n  }\n  // Return array sorted in ascending order\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 参考\n\n * 插入排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n插入排序（英语：insertion sort）是一种简单直观的排序算法。insertion sort 和打扑克牌时，从牌桌上逐一拿起扑克牌，在手上排序的过程相同。\n\n它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 o(1){\\displaystyle o(1)}o(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n\n# 原理\n\n一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：\n\n\n\n * 从第一个元素开始，该元素可以认为已经被排序\n * 取出下一个元素，在已经排序的元素序列中从后向前扫描\n * 如果该元素（已排序）大于新元素，将该元素移到下一位置\n * 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置\n * 将新元素插入到该位置后\n * 重复步骤 2~5\n\n\n\n\n# 复杂度\n\n * 平均时间复杂度o(n2)o(n^{2})o(n2)\n * 最坏时间复杂度o(n2)o(n^{2})o(n2)\n * 最优时间复杂度o(n)o(n)o(n)\n * 空间复杂度：总共 o(n)o(n)o(n) ，需要辅助空间 o(1)o(1)o(1)\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/* in insertion sort, we divide the initial unsorted array into two parts;\n * sorted part and unsorted part. initially the sorted part just has one\n * element (array of only 1 element is a sorted array). we then pick up\n * element one by one from unsorted part; insert into the sorted part at\n * the correct position and expand sorted part one element at a time.\n */\n\nfunction insertionsort (unsortedlist) {\n  const len = unsortedlist.length\n  for (let i = 1; i < len; i++) {\n    let j\n    const tmp = unsortedlist[i] // copy of the current element.\n    /* check through the sorted part and compare with the number in tmp. if large, shift the number */\n    for (j = i - 1; j >= 0 && (unsortedlist[j] > tmp); j--) {\n      // shift the number\n      unsortedlist[j + 1] = unsortedlist[j]\n    }\n    // insert the copied number at the correct position\n    // in sorted part.\n    unsortedlist[j + 1] = tmp\n  }\n}\n\n/**\n * @function insertionsortalternativeimplementation\n * @description insertionsort is a stable sorting algorithm\n * @param {integer[]} array - array of integers\n * @return {integer[]} - sorted array\n * @see [insertionsort](https://en.wikipedia.org/wiki/insertion_sort)\n */\n\n/*\n  * big-o analysis\n      * time complexity\n        - o(n^2) on average and worst case scenario\n        - o(n) on best case scenario (when input array is already almost sorted)\n      * space complexity\n        - o(1)\n*/\n\nfunction insertionsortalternativeimplementation (array) {\n  const length = array.length\n  if (length < 2) return array\n\n  for (let i = 1; i < length; i++) {\n    // take current element in array\n    const currentitem = array[i]\n    // take index of previous element in array\n    let j = i - 1\n\n    // while j >= 0 and previous element is greater than current element\n    while (j >= 0 && array[j] > currentitem) {\n      // move previous, greater element towards the unsorted part\n      array[j + 1] = array[j]\n      j--\n    }\n    // insert currentitem number at the correct position in sorted part.\n    array[j + 1] = currentitem\n  }\n  // return array sorted in ascending order\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 参考\n\n * 插入排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/13, 15:33:21",lastUpdatedTimestamp:1665646401e3},{title:"IntroSort [内省排序]",frontmatter:{title:"IntroSort [内省排序]",date:"2022-04-26T23:07:17.000Z",permalink:"/algorithm/sort/introSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/160.introSort.html",relativePath:"20.算法/10.Sort 排序/160.introSort.md",key:"v-226b6aaa",path:"/algorithm/sort/introSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:176},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:133},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:79},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:584},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:8062}],headersStr:"介绍 原理 复杂度 实现 JavaScript 参考",content:"# 介绍\n\nIntroSort 首先从快速排序开始，当递归深度超过一定深度（深度为排序元素数量的对数值）后转为堆排序。采用这个方法，内省排序既能在常规数据集上实现快速排序的高性能，又能在最坏情况下仍保持 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度。由于这两种算法都属于比较排序算法，所以内省排序也是一个比较排序算法。\n\n\n# 原理\n\n回顾 quickSort、heapSort 和 insertionSort：\n\n * 快速排序在大多数情况下效率最高，应当是首选的排序算法。但是它在某些情况下，会掉入陷阱，复杂度恶化到 O(n2)O(n^{2})O(n2)。\n * 堆排序虽然在大多数情况下不如快速排序效率高，但在所有的情况下复杂度都是 O(nlog⁡n)O(n\\log n)O(nlogn)。因此若能检测到快速排序掉入陷阱，则堆排序会是一个很好的补充。\n * 插入排序虽然复杂度虽然只能达到 O(n2)O(n^{2})O(n2)，但若能已知「几乎已经排好序」，切换到插入排序的效率又要比快速排序和堆排序高出不少，能做到 O(n)O(n)O(n)。\n\n\n# 复杂度\n\n * 平均时间复杂度O(nlog⁡n)O(n\\log n)O(nlogn)\n * 最坏时间复杂度O(nlog⁡n)O(n\\log n)O(nlogn)\n\n\n# 实现\n\n\n# JavaScript\n\nfunction introSort (array, compare) {\n  /**\n   * @function Default Comparison Function\n   * This function is same as implemented by\n   * Array.sort method\n   * @see [StackOverflow](https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function)\n   * @param {*} a variable 1\n   * @param {*} b variable 2\n   * @returns {Number}\n   * -1 if a is less than b\n   *  0 if a is equal to b\n   *  1 if a greater than b\n   */\n  const defaultComparator = function (x, y) {\n    if (x === undefined && y === undefined) return 0\n    if (x === undefined) return 1\n    if (y === undefined) return -1\n    const xString = toString(x)\n    const yString = toString(y)\n    if (xString < yString) return -1\n    if (xString > yString) return 1\n    return 0\n  }\n  /**\n   * @function helper function for defaultComparator\n   * Converts a given object to String\n   * @throws TypeError()\n   * @param {Object} obj\n   * @returns {String} String representation of given object\n   */\n  const toString = function (obj) {\n    if (obj === null) return 'null'\n    if (typeof obj === 'boolean' || typeof obj === 'number') {\n      return obj.toString()\n    }\n    if (typeof obj === 'string') return obj\n    if (typeof obj === 'symbol') throw new TypeError()\n    return obj.toString()\n  }\n  /**\n   * Checks if the value passed is an array\n   * or not\n   */\n  if (Array.isArray(array) === false) {\n    return \n  }\n  /**\n   * If the compare parameter is not a function\n   * or not passed at all use default comparator\n   * function\n   */\n  if (typeof compare !== 'function') {\n    compare = defaultComparator // If compare is not a comparator function\n  }\n  /**\n   * Use a closure to define the whole sort\n   * implementation this is done through\n   * [IIFE](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)\n   */\n  return (function (array, comparator) {\n    const swap = function (index1, index2) {\n      const temp = array[index1]\n      array[index1] = array[index2]\n      array[index2] = temp\n    }\n    /**\n     * @constant THRESHOLD\n     * If the length of array is less than\n     * this then we simply perform insertion sort\n     */\n    const THRESHOLD = 16\n    /**\n     * @constant TUNEMAXDEPTH\n     * Constant usec to increase or decrease value\n     * of maxDepth\n     */\n    const TUNEMAXDEPTH = 1\n    const len = array.length\n    /**\n     * Return if array is only of length 1\n     * Array of size 1 is always sorted\n     */\n    if (len === 1) {\n      return\n    }\n    /**\n     * Calculate maxDepth = log2(len)\n     * Taken from implementation in stdc++\n     */\n    const maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH\n    /**\n     * The very first call to quicksort\n     * this initiates sort routine\n     */\n    quickSort(0, len, maxDepth)\n    /**\n     * A final check call to insertion sort\n     * on sorted array\n     */\n    insertionSort(0, len)\n    /** *********************  Implementation of various routines  **************************/\n    /**\n     * @function\n     * This is recursive quicksort implementation in array\n     * of segment [start,last-1]\n     * [QuickSort](https://en.wikipedia.org/wiki/Quicksort)\n     * @param {Number} start the start index of array segment to be sorted\n     * @param {Number} last  one more than the last index of array segment\n     * @param {Number} depth this measures how many recursive calls are done\n     */\n    function quickSort (start, last, depth) {\n      if (last - start <= THRESHOLD) {\n        insertionSort(start, last)\n        return\n      } else if (depth <= 0) {\n        heapSort(start, last)\n        return\n      }\n      let pivot = (last + start) >> 1\n      pivot = partition(start, last, pivot)\n      quickSort(start, pivot, depth - 1)\n      quickSort(pivot + 1, last, depth - 1)\n    }\n    /**\n     * @function Helper function to quicksort\n     * @param {Number} start the start of array segment to partition\n     * @param {Number} last  one more than last index of the array segment\n     * @param {Number} pivot the index of pivot to be used\n     * @returns {Number} the index of pivot after partition\n     */\n    function partition (start, last, pivot) {\n      swap(start, pivot)\n      pivot = start\n      let lo = start\n      let hi = last\n      while (true) {\n        lo++\n        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {\n          lo++\n        }\n        hi--\n        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {\n          hi--\n        }\n        if (lo >= hi) {\n          break\n        }\n        swap(lo, hi)\n      }\n      swap(start, hi)\n      return hi\n    }\n    /**\n     * @function\n     * Performs insertion sort on array of range\n     * [start, last-1]\n     * @param {Number} start the first index of array segment to be sorted\n     * @param {Number} last  one more than last index of array to be sorted\n     */\n    function insertionSort (start, last) {\n      let i, j\n      for (i = start + 1; i < last; i++) {\n        j = i - 1\n        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {\n          swap(j, j + 1)\n          j--\n        }\n      }\n    }\n    /**\n     * @function\n     * Performs heapsort in array segment of range [start, last-1]\n     * [HeapSort](https://en.wikipedia.org/wiki/Heapsort)\n     * @param {Number} start the first index of array segment to be sorted\n     * @param {Number} last  one more than last index of array to be sorted\n     */\n    function heapSort (start, last) {\n      let x = (last + start) >> 1\n      while (x - start >= 0) {\n        heapify(x, start, last)\n        x--\n      }\n      x = last - 1\n      while (x - start > 0) {\n        swap(start, x)\n        heapify(start, start, x)\n        x--\n      }\n    }\n    /**\n     * @function Helper function to heapsort routine\n     * @param {Number} cur the index we need to heapify\n     * @param {Number} start the start index of array segment that cur belongs to\n     * @param {Number} last  one more than last index of segment that cur belongs to\n     */\n    function heapify (cur, start, last) {\n      const size = last - start\n      let max, lt, rt\n      cur = cur - start\n      while (true) {\n        max = cur\n        lt = 2 * max + 1\n        rt = 2 * max + 2\n        if (\n          lt < size &&\n          comparator(array[start + max], array[start + lt]) < 0\n        ) {\n          max = lt\n        }\n        if (\n          rt < size &&\n          comparator(array[start + max], array[start + rt]) < 0\n        ) {\n          max = rt\n        }\n        if (max !== cur) {\n          swap(start + cur, start + max)\n          cur = max\n        } else {\n          break\n        }\n      }\n    }\n  })(array, compare)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n\n\n\n# 参考\n\n * 内省排序 - 维基百科，自由的百科全书\n * 谈谈内省式排序算法 | 始终",normalizedContent:"# 介绍\n\nintrosort 首先从快速排序开始，当递归深度超过一定深度（深度为排序元素数量的对数值）后转为堆排序。采用这个方法，内省排序既能在常规数据集上实现快速排序的高性能，又能在最坏情况下仍保持 o(nlog⁡n)o(n\\log n)o(nlogn) 的时间复杂度。由于这两种算法都属于比较排序算法，所以内省排序也是一个比较排序算法。\n\n\n# 原理\n\n回顾 quicksort、heapsort 和 insertionsort：\n\n * 快速排序在大多数情况下效率最高，应当是首选的排序算法。但是它在某些情况下，会掉入陷阱，复杂度恶化到 o(n2)o(n^{2})o(n2)。\n * 堆排序虽然在大多数情况下不如快速排序效率高，但在所有的情况下复杂度都是 o(nlog⁡n)o(n\\log n)o(nlogn)。因此若能检测到快速排序掉入陷阱，则堆排序会是一个很好的补充。\n * 插入排序虽然复杂度虽然只能达到 o(n2)o(n^{2})o(n2)，但若能已知「几乎已经排好序」，切换到插入排序的效率又要比快速排序和堆排序高出不少，能做到 o(n)o(n)o(n)。\n\n\n# 复杂度\n\n * 平均时间复杂度o(nlog⁡n)o(n\\log n)o(nlogn)\n * 最坏时间复杂度o(nlog⁡n)o(n\\log n)o(nlogn)\n\n\n# 实现\n\n\n# javascript\n\nfunction introsort (array, compare) {\n  /**\n   * @function default comparison function\n   * this function is same as implemented by\n   * array.sort method\n   * @see [stackoverflow](https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function)\n   * @param {*} a variable 1\n   * @param {*} b variable 2\n   * @returns {number}\n   * -1 if a is less than b\n   *  0 if a is equal to b\n   *  1 if a greater than b\n   */\n  const defaultcomparator = function (x, y) {\n    if (x === undefined && y === undefined) return 0\n    if (x === undefined) return 1\n    if (y === undefined) return -1\n    const xstring = tostring(x)\n    const ystring = tostring(y)\n    if (xstring < ystring) return -1\n    if (xstring > ystring) return 1\n    return 0\n  }\n  /**\n   * @function helper function for defaultcomparator\n   * converts a given object to string\n   * @throws typeerror()\n   * @param {object} obj\n   * @returns {string} string representation of given object\n   */\n  const tostring = function (obj) {\n    if (obj === null) return 'null'\n    if (typeof obj === 'boolean' || typeof obj === 'number') {\n      return obj.tostring()\n    }\n    if (typeof obj === 'string') return obj\n    if (typeof obj === 'symbol') throw new typeerror()\n    return obj.tostring()\n  }\n  /**\n   * checks if the value passed is an array\n   * or not\n   */\n  if (array.isarray(array) === false) {\n    return \n  }\n  /**\n   * if the compare parameter is not a function\n   * or not passed at all use default comparator\n   * function\n   */\n  if (typeof compare !== 'function') {\n    compare = defaultcomparator // if compare is not a comparator function\n  }\n  /**\n   * use a closure to define the whole sort\n   * implementation this is done through\n   * [iife](https://en.wikipedia.org/wiki/immediately_invoked_function_expression)\n   */\n  return (function (array, comparator) {\n    const swap = function (index1, index2) {\n      const temp = array[index1]\n      array[index1] = array[index2]\n      array[index2] = temp\n    }\n    /**\n     * @constant threshold\n     * if the length of array is less than\n     * this then we simply perform insertion sort\n     */\n    const threshold = 16\n    /**\n     * @constant tunemaxdepth\n     * constant usec to increase or decrease value\n     * of maxdepth\n     */\n    const tunemaxdepth = 1\n    const len = array.length\n    /**\n     * return if array is only of length 1\n     * array of size 1 is always sorted\n     */\n    if (len === 1) {\n      return\n    }\n    /**\n     * calculate maxdepth = log2(len)\n     * taken from implementation in stdc++\n     */\n    const maxdepth = math.floor(math.log2(len)) * tunemaxdepth\n    /**\n     * the very first call to quicksort\n     * this initiates sort routine\n     */\n    quicksort(0, len, maxdepth)\n    /**\n     * a final check call to insertion sort\n     * on sorted array\n     */\n    insertionsort(0, len)\n    /** *********************  implementation of various routines  **************************/\n    /**\n     * @function\n     * this is recursive quicksort implementation in array\n     * of segment [start,last-1]\n     * [quicksort](https://en.wikipedia.org/wiki/quicksort)\n     * @param {number} start the start index of array segment to be sorted\n     * @param {number} last  one more than the last index of array segment\n     * @param {number} depth this measures how many recursive calls are done\n     */\n    function quicksort (start, last, depth) {\n      if (last - start <= threshold) {\n        insertionsort(start, last)\n        return\n      } else if (depth <= 0) {\n        heapsort(start, last)\n        return\n      }\n      let pivot = (last + start) >> 1\n      pivot = partition(start, last, pivot)\n      quicksort(start, pivot, depth - 1)\n      quicksort(pivot + 1, last, depth - 1)\n    }\n    /**\n     * @function helper function to quicksort\n     * @param {number} start the start of array segment to partition\n     * @param {number} last  one more than last index of the array segment\n     * @param {number} pivot the index of pivot to be used\n     * @returns {number} the index of pivot after partition\n     */\n    function partition (start, last, pivot) {\n      swap(start, pivot)\n      pivot = start\n      let lo = start\n      let hi = last\n      while (true) {\n        lo++\n        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {\n          lo++\n        }\n        hi--\n        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {\n          hi--\n        }\n        if (lo >= hi) {\n          break\n        }\n        swap(lo, hi)\n      }\n      swap(start, hi)\n      return hi\n    }\n    /**\n     * @function\n     * performs insertion sort on array of range\n     * [start, last-1]\n     * @param {number} start the first index of array segment to be sorted\n     * @param {number} last  one more than last index of array to be sorted\n     */\n    function insertionsort (start, last) {\n      let i, j\n      for (i = start + 1; i < last; i++) {\n        j = i - 1\n        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {\n          swap(j, j + 1)\n          j--\n        }\n      }\n    }\n    /**\n     * @function\n     * performs heapsort in array segment of range [start, last-1]\n     * [heapsort](https://en.wikipedia.org/wiki/heapsort)\n     * @param {number} start the first index of array segment to be sorted\n     * @param {number} last  one more than last index of array to be sorted\n     */\n    function heapsort (start, last) {\n      let x = (last + start) >> 1\n      while (x - start >= 0) {\n        heapify(x, start, last)\n        x--\n      }\n      x = last - 1\n      while (x - start > 0) {\n        swap(start, x)\n        heapify(start, start, x)\n        x--\n      }\n    }\n    /**\n     * @function helper function to heapsort routine\n     * @param {number} cur the index we need to heapify\n     * @param {number} start the start index of array segment that cur belongs to\n     * @param {number} last  one more than last index of segment that cur belongs to\n     */\n    function heapify (cur, start, last) {\n      const size = last - start\n      let max, lt, rt\n      cur = cur - start\n      while (true) {\n        max = cur\n        lt = 2 * max + 1\n        rt = 2 * max + 2\n        if (\n          lt < size &&\n          comparator(array[start + max], array[start + lt]) < 0\n        ) {\n          max = lt\n        }\n        if (\n          rt < size &&\n          comparator(array[start + max], array[start + rt]) < 0\n        ) {\n          max = rt\n        }\n        if (max !== cur) {\n          swap(start + cur, start + max)\n          cur = max\n        } else {\n          break\n        }\n      }\n    }\n  })(array, compare)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n\n\n\n# 参考\n\n * 内省排序 - 维基百科，自由的百科全书\n * 谈谈内省式排序算法 | 始终",charsets:{cjk:!0},lastUpdated:"2022/05/06, 13:20:49",lastUpdatedTimestamp:1651814449e3},{title:"MergeSort [归并排序]",frontmatter:{title:"MergeSort [归并排序]",date:"2022-04-26T23:12:01.000Z",permalink:"/algorithm/sort/mergeSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/170.mergeSort.html",relativePath:"20.算法/10.Sort 排序/170.mergeSort.md",key:"v-2419e8d6",path:"/algorithm/sort/mergeSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:137},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:215},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:382},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:389},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:396},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1839}],headersStr:"介绍 原理 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n归并排序是创建在归并操作上的一种有效的排序算法，效率为 O(nlog⁡n){\\displaystyle O(n\\log n)}O(nlogn)。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n\n\n# 原理\n\n采用分治法:\n\n\n\n * 分割：递归地把当前序列平均分割成两半。\n * 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。\n\n\n# 复杂度\n\n * 平均时间复杂度Θ(nlog⁡n)\\Theta (n\\log n)Θ(nlogn)\n * 最坏时间复杂度Θ(nlog⁡n)\\Theta (n\\log n)Θ(nlogn)\n * 最优时间复杂度Θ(nlog⁡n)\\Theta (n\\log n)Θ(nlogn)\n * 空间复杂度Θ(n)\\Theta(n)Θ(n)\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * MergeSort implementation.\n *\n * Merge Sort is an algorithm where the main list is divided down into two half sized lists, which then have merge sort\n * called on these two smaller lists recursively until there is only a sorted list of one.\n *\n * On the way up the recursive calls, the lists will be merged together inserting\n * the smaller value first, creating a larger sorted list.\n */\n\n/**\n * Sort and merge two given arrays.\n *\n * @param {Array} list1 Sublist to break down.\n * @param {Array} list2 Sublist to break down.\n * @return {Array} The merged list.\n */\nfunction merge (list1, list2) {\n  const results = []\n  let i = 0\n  let j = 0\n\n  while (i < list1.length && j < list2.length) {\n    if (list1[i] < list2[j]) {\n      results.push(list1[i++])\n    } else {\n      results.push(list2[j++])\n    }\n  }\n\n  return results.concat(list1.slice(i), list2.slice(j))\n}\n\n/**\n * Break down the lists into smaller pieces to be merged.\n *\n * @param {Array} list List to be sorted.\n * @return {Array} The sorted list.\n */\nfunction mergeSort (list) {\n  if (list.length < 2) return list\n\n  const listHalf = Math.floor(list.length / 2)\n  const subList1 = list.slice(0, listHalf)\n  const subList2 = list.slice(listHalf, list.length)\n\n  return merge(mergeSort(subList1), mergeSort(subList2))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 参考\n\n * 归并排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n归并排序是创建在归并操作上的一种有效的排序算法，效率为 o(nlog⁡n){\\displaystyle o(n\\log n)}o(nlogn)。该算法是采用分治法（divide and conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n\n\n# 原理\n\n采用分治法:\n\n\n\n * 分割：递归地把当前序列平均分割成两半。\n * 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。\n\n\n# 复杂度\n\n * 平均时间复杂度θ(nlog⁡n)\\theta (n\\log n)θ(nlogn)\n * 最坏时间复杂度θ(nlog⁡n)\\theta (n\\log n)θ(nlogn)\n * 最优时间复杂度θ(nlog⁡n)\\theta (n\\log n)θ(nlogn)\n * 空间复杂度θ(n)\\theta(n)θ(n)\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/*\n * mergesort implementation.\n *\n * merge sort is an algorithm where the main list is divided down into two half sized lists, which then have merge sort\n * called on these two smaller lists recursively until there is only a sorted list of one.\n *\n * on the way up the recursive calls, the lists will be merged together inserting\n * the smaller value first, creating a larger sorted list.\n */\n\n/**\n * sort and merge two given arrays.\n *\n * @param {array} list1 sublist to break down.\n * @param {array} list2 sublist to break down.\n * @return {array} the merged list.\n */\nfunction merge (list1, list2) {\n  const results = []\n  let i = 0\n  let j = 0\n\n  while (i < list1.length && j < list2.length) {\n    if (list1[i] < list2[j]) {\n      results.push(list1[i++])\n    } else {\n      results.push(list2[j++])\n    }\n  }\n\n  return results.concat(list1.slice(i), list2.slice(j))\n}\n\n/**\n * break down the lists into smaller pieces to be merged.\n *\n * @param {array} list list to be sorted.\n * @return {array} the sorted list.\n */\nfunction mergesort (list) {\n  if (list.length < 2) return list\n\n  const listhalf = math.floor(list.length / 2)\n  const sublist1 = list.slice(0, listhalf)\n  const sublist2 = list.slice(listhalf, list.length)\n\n  return merge(mergesort(sublist1), mergesort(sublist2))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 参考\n\n * 归并排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"OddEvenSort [奇偶排序]",frontmatter:{title:"OddEvenSort [奇偶排序]",date:"2022-04-26T23:12:52.000Z",permalink:"/algorithm/sort/oddEvenSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/180.oddEvenSort.html",relativePath:"20.算法/10.Sort 排序/180.oddEvenSort.md",key:"v-0250e5f5",path:"/algorithm/sort/oddEvenSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:174},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:241},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:248},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1225}],headersStr:"介绍 复杂度 实现 JavaScript 参考",content:"# 介绍\n\n奇偶排序，或奇偶换位排序，或砖排序，是一种相对简单的排序算法，最初发明用于有本地互连的并行计算。这是与冒泡排序特点类似的一种比较排序。\n\n该算法中，通过比较数组中相邻的（奇 - 偶）位置数字对，如果该奇偶对是错误的顺序（第一个大于第二个），则交换。下一步重复该操作，但针对所有的（偶 - 奇）位置数字对。如此交替进行下去。\n\n\n\n\n# 复杂度\n\n * 最坏时间复杂度Θ(n2)\\Theta (n^{2})Θ(n2)\n * 最优时间复杂度O(n)O(n)O(n)\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  odd–even sort or odd–even transposition sort\n  is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections.\n  It is a comparison sort related to bubble sort, with which it shares many characteristics.\n   for more information : https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\n*/\n\n// Helper function to swap array items\nswap (arr, i, j) {\n  const tmp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = tmp\n}\n\nfunction oddEvenSort (arr) {\n  let sorted = false\n  while (!sorted) {\n    sorted = true\n    for (let i = 1; i < arr.length - 1; i += 2) {\n      if (arr[i] > arr[i + 1]) {\n        swap(arr, i, i + 1)\n        sorted = false\n      }\n    }\n    for (let i = 0; i < arr.length - 1; i += 2) {\n      if (arr[i] > arr[i + 1]) {\n        swap(arr, i, i + 1)\n        sorted = false\n      }\n    }\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 参考\n\n * 奇偶排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n奇偶排序，或奇偶换位排序，或砖排序，是一种相对简单的排序算法，最初发明用于有本地互连的并行计算。这是与冒泡排序特点类似的一种比较排序。\n\n该算法中，通过比较数组中相邻的（奇 - 偶）位置数字对，如果该奇偶对是错误的顺序（第一个大于第二个），则交换。下一步重复该操作，但针对所有的（偶 - 奇）位置数字对。如此交替进行下去。\n\n\n\n\n# 复杂度\n\n * 最坏时间复杂度θ(n2)\\theta (n^{2})θ(n2)\n * 最优时间复杂度o(n)o(n)o(n)\n\n\n# 实现\n\n\n# javascript\n\n/*\n  odd–even sort or odd–even transposition sort\n  is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections.\n  it is a comparison sort related to bubble sort, with which it shares many characteristics.\n   for more information : https://en.wikipedia.org/wiki/odd%e2%80%93even_sort\n*/\n\n// helper function to swap array items\nswap (arr, i, j) {\n  const tmp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = tmp\n}\n\nfunction oddevensort (arr) {\n  let sorted = false\n  while (!sorted) {\n    sorted = true\n    for (let i = 1; i < arr.length - 1; i += 2) {\n      if (arr[i] > arr[i + 1]) {\n        swap(arr, i, i + 1)\n        sorted = false\n      }\n    }\n    for (let i = 0; i < arr.length - 1; i += 2) {\n      if (arr[i] > arr[i + 1]) {\n        swap(arr, i, i + 1)\n        sorted = false\n      }\n    }\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 参考\n\n * 奇偶排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/05/09, 13:34:14",lastUpdatedTimestamp:1652074454e3},{title:"PancakeSort [煎饼排序]",frontmatter:{title:"PancakeSort [煎饼排序]",date:"2022-04-26T23:13:54.000Z",permalink:"/algorithm/sort/pancakeSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/190.pancakeSort.html",relativePath:"20.算法/10.Sort 排序/190.pancakeSort.md",key:"v-715e4442",path:"/algorithm/sort/pancakeSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:136},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:143},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2946}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n煎饼排序（英语：Pancake sorting）指的是将大小不同的一摞煎饼按大小排序的数学问题，其中煎饼铲子每次只能从任意位置铲起上方全部煎饼并翻面。“煎饼数”（英语：pancake number）是指给定煎饼的张数时，最坏情况下需要的最少翻面次数。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Unlike a traditional sorting algorithm, which attempts to sort with the fewest\n * comparisons possible, the goal of pancake sort is to sort the sequence in as few reversals as\n * possible. The idea is to do something similar to Selection Sort. We one by one place\n * maximum element at the end and reduce the size of current array by one.\n *\n * Source: https://www.geeksforgeeks.org/pancake-sorting/\n *\n * This sorting algorithm is inspired by the pancake problem (hence the name),\n * where a spatula can be placed anywhere between two pancakes and flip all pancakes\n * above.\n *\n * The interesting about this algorithm (besides its name) is that instead of comparisons,\n * the algorithm relies on flipping an array.\n *\n * Source: https://en.wikipedia.org/wiki/Pancake_sorting#The_original_pancake_problem\n *\n */\n\n/**\n * Unlike Array.prototype.reverse, flipArray reverses only a subarray of the given\n * array, determined by the parameters startIndex and endIndex\n *\n * @param {number[]} array The array to flip\n * @param {number} startIndex The start of the subarray\n * @param {number} endIndex The end of the subarray\n * @returns The flipped array\n */\nfunction flipArray (array, startIndex, endIndex) {\n  while (startIndex < endIndex) {\n    // swap front and back of the subarray\n    const temp = array[startIndex]\n    array[startIndex] = array[endIndex]\n    array[endIndex] = temp\n\n    // essentially reducing the problem to a smaller subarray\n    startIndex++\n    endIndex--\n  }\n\n  return array\n}\n\n/**\n * Returns the index of the maximum number of a subarray in a given array\n *\n * @param {number[]} array The array to found the maximum number's index\n * @param {*} startIndex The start of the subarray\n * @param {*} endIndex The end of the subarray\n * @returns The index of the maximum number\n */\nfunction findMax (array, startIndex, endIndex) {\n  let maxIndex = 0\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (array[i] > array[maxIndex]) maxIndex = i\n  }\n\n  return maxIndex\n}\n\n/**\n * The Pancake Sort algorithm.\n *\n * Note that even though it's a completely different concept of sorting an\n * array, it's rather simple!\n *\n * @param {number[]} array The array to sort\n * @returns The sorted array\n */\nfunction pancakeSort (array) {\n  for (let subarraySize = array.length; subarraySize > 1; subarraySize--) {\n    const maximumIndex = findMax(array, 0, subarraySize - 1)\n\n    if (maximumIndex !== subarraySize - 1) {\n      flipArray(array, 0, maximumIndex)\n      flipArray(array, 0, subarraySize - 1)\n    }\n  }\n\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n\n# 参考\n\n * 煎饼排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n煎饼排序（英语：pancake sorting）指的是将大小不同的一摞煎饼按大小排序的数学问题，其中煎饼铲子每次只能从任意位置铲起上方全部煎饼并翻面。“煎饼数”（英语：pancake number）是指给定煎饼的张数时，最坏情况下需要的最少翻面次数。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * unlike a traditional sorting algorithm, which attempts to sort with the fewest\n * comparisons possible, the goal of pancake sort is to sort the sequence in as few reversals as\n * possible. the idea is to do something similar to selection sort. we one by one place\n * maximum element at the end and reduce the size of current array by one.\n *\n * source: https://www.geeksforgeeks.org/pancake-sorting/\n *\n * this sorting algorithm is inspired by the pancake problem (hence the name),\n * where a spatula can be placed anywhere between two pancakes and flip all pancakes\n * above.\n *\n * the interesting about this algorithm (besides its name) is that instead of comparisons,\n * the algorithm relies on flipping an array.\n *\n * source: https://en.wikipedia.org/wiki/pancake_sorting#the_original_pancake_problem\n *\n */\n\n/**\n * unlike array.prototype.reverse, fliparray reverses only a subarray of the given\n * array, determined by the parameters startindex and endindex\n *\n * @param {number[]} array the array to flip\n * @param {number} startindex the start of the subarray\n * @param {number} endindex the end of the subarray\n * @returns the flipped array\n */\nfunction fliparray (array, startindex, endindex) {\n  while (startindex < endindex) {\n    // swap front and back of the subarray\n    const temp = array[startindex]\n    array[startindex] = array[endindex]\n    array[endindex] = temp\n\n    // essentially reducing the problem to a smaller subarray\n    startindex++\n    endindex--\n  }\n\n  return array\n}\n\n/**\n * returns the index of the maximum number of a subarray in a given array\n *\n * @param {number[]} array the array to found the maximum number's index\n * @param {*} startindex the start of the subarray\n * @param {*} endindex the end of the subarray\n * @returns the index of the maximum number\n */\nfunction findmax (array, startindex, endindex) {\n  let maxindex = 0\n  for (let i = startindex; i <= endindex; i++) {\n    if (array[i] > array[maxindex]) maxindex = i\n  }\n\n  return maxindex\n}\n\n/**\n * the pancake sort algorithm.\n *\n * note that even though it's a completely different concept of sorting an\n * array, it's rather simple!\n *\n * @param {number[]} array the array to sort\n * @returns the sorted array\n */\nfunction pancakesort (array) {\n  for (let subarraysize = array.length; subarraysize > 1; subarraysize--) {\n    const maximumindex = findmax(array, 0, subarraysize - 1)\n\n    if (maximumindex !== subarraysize - 1) {\n      fliparray(array, 0, maximumindex)\n      fliparray(array, 0, subarraysize - 1)\n    }\n  }\n\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n\n# 参考\n\n * 煎饼排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/05/09, 13:34:14",lastUpdatedTimestamp:1652074454e3},{title:"BeadSort [珠排序]",frontmatter:{title:"BeadSort [珠排序]",date:"2022-04-26T22:47:31.000Z",permalink:"/algorithm/sort/beadSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/20.beadSort.html",relativePath:"20.算法/10.Sort 排序/20.beadSort.md",key:"v-7fb2d211",path:"/algorithm/sort/beadSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:130},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:436},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:30},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:673},{level:3,title:"Python",slug:"python",normalizedTitle:"python",charIndex:2280},{level:3,title:"CPP",slug:"cpp",normalizedTitle:"cpp",charIndex:3080},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4269}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>珠排序是一种自然排序算法。无论是电子还是实物上的实现，珠排序都能在 O (n) 时间内完成；然而，该算法 <code>在电子上的实现明显比实物要慢很多，并且只能用于对正整数序列进行排序</code> 。并且，即使在最好的情况，该算法也需要 O (n^2) 的空间。</p>\n',headersStr:"介绍 原理 复杂度 实现 JavaScript Python CPP 参考",content:"# 介绍\n\n珠排序是一种自然排序算法。无论是电子还是实物上的实现，珠排序都能在 O (n) 时间内完成；然而，该算法 在电子上的实现明显比实物要慢很多，并且只能用于对正整数序列进行排序 。并且，即使在最好的情况，该算法也需要 O (n^2) 的空间。\n\n\n# 原理\n\n\n\n当给定一个数组，数组里有多少个数字，就要有多少行；数组里最大的数字是几，就要准备多少根杆子。\n\n\n\n准备就绪后，释放珠子，珠子按重力下落，就完成了排序。如果我们要允许珠子掉落，那么每行表示已排序的整数。第 1 行表示在集合中最大的数，而第 n 行表示最小的数。\n\n允许珠子掉落的行为在物理意义上就是允许珠子从高的行掉落至低的行。如果被行 a 表示的值小于被行 a+1 表示的值，那么一些珠子就会从 a+1 掉落至 a；因为行 a 不包含足够的珠子防止珠从 a+1 行掉落，所以这一定会发生。\n\n用机械设备实现的珠排序类似于计数排序；每一杆上的数字与那些在所有数中等于或大于该数字的数量相当。\n\n\n# 复杂度\n\n珠排序可以是以下复杂度级别：\n\n * O(1)O(1)O(1)：即所有珠子都同时移动，但这种算法只是概念上的，无法在计算机中实现。\n * O(n)O(\\sqrt{n})O(n )：在真实的物理世界中用引力实现，所需时间正比于珠子最大高度的平方根，而最大高度正比于 n。\n * O(n)O(n)O(n)：一次移动一行珠子，可以用模拟和数字的硬件实现。\n * O(S)O(S)O(S)，S 是所有输入数据的和：一次移动一个珠子，能在软件中实现。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Bead Sort, also known as Gravity sort.\n *\n * This algorithm was inspired from natural phenomena and was designed keeping in mind objects (or beads) falling under\n * the influence of gravity.\n *\n * NOTE: It only works for arrays of positive integers.\n *\n * Wikipedia: https://en.wikipedia.org/wiki/Bead_sort\n */\nexport function beadSort (sequence) {\n  /* Let's ensure our sequence has only Positive Integers */\n  if (sequence.some((integer) => integer < 0)) {\n    throw RangeError('Sequence must be a list of Positive integers Only!')\n  }\n\n  const sequenceLength = sequence.length\n  const max = Math.max(...sequence)\n\n  // Set initial Grid\n  const grid = sequence.map(number => {\n    const maxArr = new Array(max)\n\n    for (let i = 0; i < number; i++) {\n      maxArr[i] = '*'\n    }\n\n    return maxArr\n  })\n\n  // Drop the Beads!\n  for (let col = 0; col < max; col++) {\n    let beadsCount = 0\n\n    for (let row = 0; row < sequenceLength; row++) {\n      if (grid[row][col] === '*') {\n        beadsCount++\n      }\n    }\n\n    for (let row = sequenceLength - 1; row > -1; row--) {\n      if (beadsCount) {\n        grid[row][col] = '*'\n        beadsCount--\n      } else {\n        grid[row][col] = undefined\n      }\n    }\n  }\n\n  /* Finally, let's turn our Bead rows into their Respective Numbers */\n  return grid.map((beadArray) => {\n    const beadsArray = beadArray.filter(bead => bead === '*')\n    return beadsArray.length\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# Python\n\ndef bead_sort(l):\n    b = []\n    l_len = len(l) - 1 \n    index = 0 \n    count = 0 \n \n    while(any(l)):\n        if l[index] != 0:\n            count += 1\n            l[index] -= 1\n \n        if index == l_len:\n            b.append(count)\n            index = 0 \n            count = 0 \n        else:\n            index += 1\n \n    if count != 0:\n        b.append(count)\n\n    result = []\n    for i, v in enumerate(b[:-1]):\n        if v == b[i+1]:\n            continue\n        else:\n            result.extend([i + 1 for _ in range(v - b[i + 1])])\n \n    result.extend([len(b) for _ in range(max(b) - len(result))])\n \n    return result\n\nif __name__ == \"__main__\":\n    print(bead_sort([2, 4, 1, 3, 3]))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# CPP\n\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n \nusing namespace std;\n \n#define BEAD(i, j) beads[i*max + j]\n \nvoid beadsort(int *a, int len)\n{\n    int max = a[0];\n    for(int i = 1; i < len; i++)\n    {\n        if(a[i] > max)\n        {\n            max = a[i];\n        }\n    }\n \n    unsigned int beads[max * len]; //positive int only\n    memset(beads, 0, sizeof(beads));\n \n    for (int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < a[i]; j++)\n        {\n            BEAD(i, j) = 1;\n        }\n    }\n \n    for(int j = 0; j < max; j++)\n    {\n        int sum = 0;\n        for (int i = 0; i < len; i++)\n        {\n            sum += BEAD(i, j);// count the beads\n            BEAD(i, j) = 0; // clear the post\n        }\n        \n        for (int i = len - sum; i < len; i++)\n        {\n            BEAD(i, j) = 1; // gravity down \n        }\n    }\n    \n    for (int i = 0; i < len; i++)\n    {\n        int j;\n        for (j = 0; j < max && BEAD(i, j); j++); // j < max and BEAD(i, j) != null\n \n        a[i] = j;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 参考\n\n * 珠排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n珠排序是一种自然排序算法。无论是电子还是实物上的实现，珠排序都能在 o (n) 时间内完成；然而，该算法 在电子上的实现明显比实物要慢很多，并且只能用于对正整数序列进行排序 。并且，即使在最好的情况，该算法也需要 o (n^2) 的空间。\n\n\n# 原理\n\n\n\n当给定一个数组，数组里有多少个数字，就要有多少行；数组里最大的数字是几，就要准备多少根杆子。\n\n\n\n准备就绪后，释放珠子，珠子按重力下落，就完成了排序。如果我们要允许珠子掉落，那么每行表示已排序的整数。第 1 行表示在集合中最大的数，而第 n 行表示最小的数。\n\n允许珠子掉落的行为在物理意义上就是允许珠子从高的行掉落至低的行。如果被行 a 表示的值小于被行 a+1 表示的值，那么一些珠子就会从 a+1 掉落至 a；因为行 a 不包含足够的珠子防止珠从 a+1 行掉落，所以这一定会发生。\n\n用机械设备实现的珠排序类似于计数排序；每一杆上的数字与那些在所有数中等于或大于该数字的数量相当。\n\n\n# 复杂度\n\n珠排序可以是以下复杂度级别：\n\n * o(1)o(1)o(1)：即所有珠子都同时移动，但这种算法只是概念上的，无法在计算机中实现。\n * o(n)o(\\sqrt{n})o(n )：在真实的物理世界中用引力实现，所需时间正比于珠子最大高度的平方根，而最大高度正比于 n。\n * o(n)o(n)o(n)：一次移动一行珠子，可以用模拟和数字的硬件实现。\n * o(s)o(s)o(s)，s 是所有输入数据的和：一次移动一个珠子，能在软件中实现。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * bead sort, also known as gravity sort.\n *\n * this algorithm was inspired from natural phenomena and was designed keeping in mind objects (or beads) falling under\n * the influence of gravity.\n *\n * note: it only works for arrays of positive integers.\n *\n * wikipedia: https://en.wikipedia.org/wiki/bead_sort\n */\nexport function beadsort (sequence) {\n  /* let's ensure our sequence has only positive integers */\n  if (sequence.some((integer) => integer < 0)) {\n    throw rangeerror('sequence must be a list of positive integers only!')\n  }\n\n  const sequencelength = sequence.length\n  const max = math.max(...sequence)\n\n  // set initial grid\n  const grid = sequence.map(number => {\n    const maxarr = new array(max)\n\n    for (let i = 0; i < number; i++) {\n      maxarr[i] = '*'\n    }\n\n    return maxarr\n  })\n\n  // drop the beads!\n  for (let col = 0; col < max; col++) {\n    let beadscount = 0\n\n    for (let row = 0; row < sequencelength; row++) {\n      if (grid[row][col] === '*') {\n        beadscount++\n      }\n    }\n\n    for (let row = sequencelength - 1; row > -1; row--) {\n      if (beadscount) {\n        grid[row][col] = '*'\n        beadscount--\n      } else {\n        grid[row][col] = undefined\n      }\n    }\n  }\n\n  /* finally, let's turn our bead rows into their respective numbers */\n  return grid.map((beadarray) => {\n    const beadsarray = beadarray.filter(bead => bead === '*')\n    return beadsarray.length\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# python\n\ndef bead_sort(l):\n    b = []\n    l_len = len(l) - 1 \n    index = 0 \n    count = 0 \n \n    while(any(l)):\n        if l[index] != 0:\n            count += 1\n            l[index] -= 1\n \n        if index == l_len:\n            b.append(count)\n            index = 0 \n            count = 0 \n        else:\n            index += 1\n \n    if count != 0:\n        b.append(count)\n\n    result = []\n    for i, v in enumerate(b[:-1]):\n        if v == b[i+1]:\n            continue\n        else:\n            result.extend([i + 1 for _ in range(v - b[i + 1])])\n \n    result.extend([len(b) for _ in range(max(b) - len(result))])\n \n    return result\n\nif __name__ == \"__main__\":\n    print(bead_sort([2, 4, 1, 3, 3]))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# cpp\n\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n \nusing namespace std;\n \n#define bead(i, j) beads[i*max + j]\n \nvoid beadsort(int *a, int len)\n{\n    int max = a[0];\n    for(int i = 1; i < len; i++)\n    {\n        if(a[i] > max)\n        {\n            max = a[i];\n        }\n    }\n \n    unsigned int beads[max * len]; //positive int only\n    memset(beads, 0, sizeof(beads));\n \n    for (int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < a[i]; j++)\n        {\n            bead(i, j) = 1;\n        }\n    }\n \n    for(int j = 0; j < max; j++)\n    {\n        int sum = 0;\n        for (int i = 0; i < len; i++)\n        {\n            sum += bead(i, j);// count the beads\n            bead(i, j) = 0; // clear the post\n        }\n        \n        for (int i = len - sum; i < len; i++)\n        {\n            bead(i, j) = 1; // gravity down \n        }\n    }\n    \n    for (int i = 0; i < len; i++)\n    {\n        int j;\n        for (j = 0; j < max && bead(i, j); j++); // j < max and bead(i, j) != null\n \n        a[i] = j;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 参考\n\n * 珠排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"PigeonHoleSort [鸽巢排序]",frontmatter:{title:"PigeonHoleSort [鸽巢排序]",date:"2022-04-26T23:16:39.000Z",permalink:"/algorithm/sort/pigeonHoleSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/200.pigeonHoleSort.html",relativePath:"20.算法/10.Sort 排序/200.pigeonHoleSort.md",key:"v-526958bd",path:"/algorithm/sort/pigeonHoleSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:301},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:308},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1165}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n鸽巢排序（Pigeonhole sort），也被称作基数分类，是一种时间复杂度为 O(n){\\displaystyle O(n)}O(n) 且在不可避免遍历每一个元素并且排序的情况下效率最好的一种排序算法。但它只有在差值（或者可被映射在差值）很小的范围内的数值排序的情况下实用.\n\n当涉及到多个不相等的元素，且将这些元素放在同一个 “鸽巢” 的时候，算法的效率会有所降低。为了简便和保持鸽巢排序在适应不同的情况，比如两个在同一个存储桶中结束的元素必然相等\n\n我们一般很少使用鸽巢排序，因为它很少可以在灵活性，简便性，尤是速度上超过其他排序算法。事实上，桶排序较鸽巢排序更加的实用。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nhttps://en.wikipedia.org/wiki/Pigeonhole_sort\n*Pigeonhole sorting is a sorting algorithm that is suitable\n* for sorting lists of elements where the number of elements\n* (n) and the length of the range of possible key values (N)\n* are approximately the same.\n */\nfunction pigeonHoleSort (arr) {\n  let min = arr[0]\n  let max = arr[0]\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) { max = arr[i] }\n    if (arr[i] < min) { min = arr[i] }\n  }\n\n  const range = max - min + 1\n  const pigeonhole = Array(range).fill(0)\n\n  for (let i = 0; i < arr.length; i++) {\n    pigeonhole[arr[i] - min]++\n  }\n\n  let index = 0\n\n  for (let j = 0; j < range; j++) {\n    while (pigeonhole[j]-- > 0) {\n      arr[index++] = j + min\n    }\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * 鸽巢排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n鸽巢排序（pigeonhole sort），也被称作基数分类，是一种时间复杂度为 o(n){\\displaystyle o(n)}o(n) 且在不可避免遍历每一个元素并且排序的情况下效率最好的一种排序算法。但它只有在差值（或者可被映射在差值）很小的范围内的数值排序的情况下实用.\n\n当涉及到多个不相等的元素，且将这些元素放在同一个 “鸽巢” 的时候，算法的效率会有所降低。为了简便和保持鸽巢排序在适应不同的情况，比如两个在同一个存储桶中结束的元素必然相等\n\n我们一般很少使用鸽巢排序，因为它很少可以在灵活性，简便性，尤是速度上超过其他排序算法。事实上，桶排序较鸽巢排序更加的实用。\n\n\n# 实现\n\n\n# javascript\n\n/*\nhttps://en.wikipedia.org/wiki/pigeonhole_sort\n*pigeonhole sorting is a sorting algorithm that is suitable\n* for sorting lists of elements where the number of elements\n* (n) and the length of the range of possible key values (n)\n* are approximately the same.\n */\nfunction pigeonholesort (arr) {\n  let min = arr[0]\n  let max = arr[0]\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) { max = arr[i] }\n    if (arr[i] < min) { min = arr[i] }\n  }\n\n  const range = max - min + 1\n  const pigeonhole = array(range).fill(0)\n\n  for (let i = 0; i < arr.length; i++) {\n    pigeonhole[arr[i] - min]++\n  }\n\n  let index = 0\n\n  for (let j = 0; j < range; j++) {\n    while (pigeonhole[j]-- > 0) {\n      arr[index++] = j + min\n    }\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * 鸽巢排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/05/09, 13:34:14",lastUpdatedTimestamp:1652074454e3},{title:"QuickSort [快速排序]",frontmatter:{title:"QuickSort [快速排序]",date:"2022-04-26T23:17:23.000Z",permalink:"/algorithm/sort/quickSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/210.quickSort.html",relativePath:"20.算法/10.Sort 排序/210.quickSort.md",key:"v-79404cc6",path:"/algorithm/sort/quickSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:331},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:659},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:1124},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1131},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1138},{level:4,title:"QuickSortRecursive",slug:"quicksortrecursive",normalizedTitle:"quicksortrecursive",charIndex:1839},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4171}],headersStr:"介绍 原理 伪代码 动画 实现 JavaScript QuickSortRecursive 参考",content:'# 介绍\n\n快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼・霍尔提出。在平均状况下，排序 n 个项目要  O(nlog⁡n){\\displaystyle \\ O(n\\log n)} O(nlogn)（大 O 符号）次比较。在最坏状况下则需要 O(n2){\\displaystyle O(n^{2})}O(n2) 次比较，但这种状况并不常见。事实上，快速排序 Θ(nlog⁡n){\\displaystyle \\Theta (n\\log n)}Θ(nlogn) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。\n\n\n# 原理\n\n快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的 2 个子序列，然后递归地排序两个子序列。\n\n步骤为：\n\n * 挑选基准值：从数列中挑出一个元素，称为 “基准”（pivot），\n * 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，\n * 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。\n * 递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。\n\n选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。\n\n\n# 伪代码\n\nfunction quicksort(q) {\n     var list less, pivotList, greater\n     if length(q) ≤ 1 return q\n     else {\n         select a pivot value pivot from q\n         for each x in q except the pivot element {\n             if x < pivot then add x to less\n             if x ≥ pivot then add x to greater\n         }\n         add pivot to pivotList\n         return concatenate(quicksort(less), pivotList, quicksort(greater))\n     }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function QuickSort\n * @description Quick sort is a comparison sorting algorithm that uses a divide and conquer strategy.\n * @param {Integer[]} items - Array of integers\n * @return {Integer[]} - Sorted array.\n * @see [QuickSort](https://en.wikipedia.org/wiki/Quicksort)\n */\nfunction quickSort (items) {\n  const length = items.length\n\n  if (length <= 1) return items\n  const PIVOT = items[0]\n  const GREATER = []\n  const LESSER = []\n\n  for (let i = 1; i < length; i++) {\n    if (items[i] > PIVOT) GREATER.push(items[i])\n    else LESSER.push(items[i])\n  }\n\n  return [...quickSort(LESSER), PIVOT, ...quickSort(GREATER)]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# QuickSortRecursive\n\n/*\n    Quicksort is the most popular sorting algorithm and there have\n    lots of different implementations but the "recursive" or "Partition in place"\n    is one of the most efficient implementations below we have discussed how to\n    implement it.\n    Partition in place => "in place" Partition in place indicates that we\n    do not need any other space to store the auxiliary array and the term\n    "partition" denotes that we split the list into two parts one is less\n    than the pivot and the other is greater than the pivot and repeats this\n    process recursively and breaks the problem into sub-problems and makes\n    it singular so that the behavior or "divide and conquer" get involved\n    too.\n    Problem & Source of Explanation => https://www.cs.auckland.ac.nz/software/AlgAnim/qsort1a.html\n*/\n\n/**\n * Partition in place QuickSort.\n * @param {number[]} inputList list of values.\n * @param {number} low lower index for partition.\n * @param {number} high higher index for partition.\n */\nconst quickSort = (inputList, low, high) => {\n  if (!Array.isArray(inputList)) {\n    throw new TypeError(\'Please input a valid list or array.\')\n  }\n  if (low < high) {\n    // get the partition index.\n    const pIndex = partition(inputList, low, high)\n    // recursively call the quickSort method again.\n    quickSort(inputList, low, pIndex - 1)\n    quickSort(inputList, pIndex + 1, high)\n  }\n  return inputList\n}\n\n/**\n * Partition In Place method.\n * @param {number[]} partitionList list for partitioning.\n * @param {number} low lower index for partition.\n * @param {number} high higher index for partition.\n * @returns {number} `pIndex` pivot index value.\n */\nconst partition = (partitionList, low, high) => {\n  const pivot = partitionList[high]\n  let pIndex = low\n  for (let index = low; index <= high - 1; index++) {\n    if (partitionList[index] < pivot) {\n      // swap variables using array destructuring\n      [partitionList[index], partitionList[pIndex]] = [partitionList[pIndex], partitionList[index]]\n      pIndex += 1\n    }\n  }\n  [partitionList[pIndex], partitionList[high]] = [partitionList[high], partitionList[pIndex]]\n  return pIndex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 参考\n\n * 快速排序 - 维基百科，自由的百科全书',normalizedContent:'# 介绍\n\n快速排序（英语：quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼・霍尔提出。在平均状况下，排序 n 个项目要  o(nlog⁡n){\\displaystyle \\ o(n\\log n)} o(nlogn)（大 o 符号）次比较。在最坏状况下则需要 o(n2){\\displaystyle o(n^{2})}o(n2) 次比较，但这种状况并不常见。事实上，快速排序 θ(nlog⁡n){\\displaystyle \\theta (n\\log n)}θ(nlogn) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。\n\n\n# 原理\n\n快速排序使用分治法（divide and conquer）策略来把一个序列（list）分为较小和较大的 2 个子序列，然后递归地排序两个子序列。\n\n步骤为：\n\n * 挑选基准值：从数列中挑出一个元素，称为 “基准”（pivot），\n * 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，\n * 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。\n * 递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。\n\n选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。\n\n\n# 伪代码\n\nfunction quicksort(q) {\n     var list less, pivotlist, greater\n     if length(q) ≤ 1 return q\n     else {\n         select a pivot value pivot from q\n         for each x in q except the pivot element {\n             if x < pivot then add x to less\n             if x ≥ pivot then add x to greater\n         }\n         add pivot to pivotlist\n         return concatenate(quicksort(less), pivotlist, quicksort(greater))\n     }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function quicksort\n * @description quick sort is a comparison sorting algorithm that uses a divide and conquer strategy.\n * @param {integer[]} items - array of integers\n * @return {integer[]} - sorted array.\n * @see [quicksort](https://en.wikipedia.org/wiki/quicksort)\n */\nfunction quicksort (items) {\n  const length = items.length\n\n  if (length <= 1) return items\n  const pivot = items[0]\n  const greater = []\n  const lesser = []\n\n  for (let i = 1; i < length; i++) {\n    if (items[i] > pivot) greater.push(items[i])\n    else lesser.push(items[i])\n  }\n\n  return [...quicksort(lesser), pivot, ...quicksort(greater)]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# quicksortrecursive\n\n/*\n    quicksort is the most popular sorting algorithm and there have\n    lots of different implementations but the "recursive" or "partition in place"\n    is one of the most efficient implementations below we have discussed how to\n    implement it.\n    partition in place => "in place" partition in place indicates that we\n    do not need any other space to store the auxiliary array and the term\n    "partition" denotes that we split the list into two parts one is less\n    than the pivot and the other is greater than the pivot and repeats this\n    process recursively and breaks the problem into sub-problems and makes\n    it singular so that the behavior or "divide and conquer" get involved\n    too.\n    problem & source of explanation => https://www.cs.auckland.ac.nz/software/alganim/qsort1a.html\n*/\n\n/**\n * partition in place quicksort.\n * @param {number[]} inputlist list of values.\n * @param {number} low lower index for partition.\n * @param {number} high higher index for partition.\n */\nconst quicksort = (inputlist, low, high) => {\n  if (!array.isarray(inputlist)) {\n    throw new typeerror(\'please input a valid list or array.\')\n  }\n  if (low < high) {\n    // get the partition index.\n    const pindex = partition(inputlist, low, high)\n    // recursively call the quicksort method again.\n    quicksort(inputlist, low, pindex - 1)\n    quicksort(inputlist, pindex + 1, high)\n  }\n  return inputlist\n}\n\n/**\n * partition in place method.\n * @param {number[]} partitionlist list for partitioning.\n * @param {number} low lower index for partition.\n * @param {number} high higher index for partition.\n * @returns {number} `pindex` pivot index value.\n */\nconst partition = (partitionlist, low, high) => {\n  const pivot = partitionlist[high]\n  let pindex = low\n  for (let index = low; index <= high - 1; index++) {\n    if (partitionlist[index] < pivot) {\n      // swap variables using array destructuring\n      [partitionlist[index], partitionlist[pindex]] = [partitionlist[pindex], partitionlist[index]]\n      pindex += 1\n    }\n  }\n  [partitionlist[pindex], partitionlist[high]] = [partitionlist[high], partitionlist[pindex]]\n  return pindex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 参考\n\n * 快速排序 - 维基百科，自由的百科全书',charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"RadixSort [基数排序]",frontmatter:{title:"RadixSort [基数排序]",date:"2022-04-26T23:19:40.000Z",permalink:"/algorithm/sort/radixSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/230.radixSort.html",relativePath:"20.算法/10.Sort 排序/230.radixSort.md",key:"v-db6ed89a",path:"/algorithm/sort/radixSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:40},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:338},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:416},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:423},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:430},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1573}],headersStr:"介绍 原理 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n\n# 原理\n\n\n\n将所有待比较数值（ 正整数 ）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。\n\n基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。\n\n\n# 复杂度\n\n * 最坏时间复杂度O(kN)O(kN)O(kN)\n * 空间复杂度O(k+N){\\displaystyle O(k+N)}O(k+N)\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n* Radix sorts an integer array without comparing the integers.\n* It groups the integers by their digits which share the same\n* significant position.\n* For more information see: https://en.wikipedia.org/wiki/Radix_sort\n*/\nfunction radixSort (items, RADIX) {\n  // default radix is then because we usually count to base 10\n  if (RADIX === undefined || RADIX < 1) {\n    RADIX = 10\n  }\n\n  let maxLength = false\n  let placement = 1\n\n  while (!maxLength) {\n    maxLength = true\n    const buckets = []\n\n    for (let i = 0; i < RADIX; i++) {\n      buckets.push([])\n    }\n\n    for (let j = 0; j < items.length; j++) {\n      const tmp = items[j] / placement\n      buckets[Math.floor(tmp % RADIX)].push(items[j])\n      if (maxLength && tmp > 0) {\n        maxLength = false\n      }\n    }\n\n    let a = 0\n    for (let b = 0; b < RADIX; b++) {\n      const buck = buckets[b]\n      for (let k = 0; k < buck.length; k++) {\n        items[a] = buck[k]\n        a++\n      }\n    }\n    placement *= RADIX\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * 基数排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n基数排序（英语：radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n\n# 原理\n\n\n\n将所有待比较数值（ 正整数 ）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。\n\n基数排序的方式可以采用 lsd（least significant digital）或 msd（most significant digital），lsd 的排序方式由键值的最右边开始，而 msd 则相反，由键值的最左边开始。\n\n\n# 复杂度\n\n * 最坏时间复杂度o(kn)o(kn)o(kn)\n * 空间复杂度o(k+n){\\displaystyle o(k+n)}o(k+n)\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/*\n* radix sorts an integer array without comparing the integers.\n* it groups the integers by their digits which share the same\n* significant position.\n* for more information see: https://en.wikipedia.org/wiki/radix_sort\n*/\nfunction radixsort (items, radix) {\n  // default radix is then because we usually count to base 10\n  if (radix === undefined || radix < 1) {\n    radix = 10\n  }\n\n  let maxlength = false\n  let placement = 1\n\n  while (!maxlength) {\n    maxlength = true\n    const buckets = []\n\n    for (let i = 0; i < radix; i++) {\n      buckets.push([])\n    }\n\n    for (let j = 0; j < items.length; j++) {\n      const tmp = items[j] / placement\n      buckets[math.floor(tmp % radix)].push(items[j])\n      if (maxlength && tmp > 0) {\n        maxlength = false\n      }\n    }\n\n    let a = 0\n    for (let b = 0; b < radix; b++) {\n      const buck = buckets[b]\n      for (let k = 0; k < buck.length; k++) {\n        items[a] = buck[k]\n        a++\n      }\n    }\n    placement *= radix\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * 基数排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"SelectionSort [选择排序]",frontmatter:{title:"SelectionSort [选择排序]",date:"2022-04-26T23:20:37.000Z",permalink:"/algorithm/sort/selectionSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/240.selectionSort.html",relativePath:"20.算法/10.Sort 排序/240.selectionSort.md",key:"v-0fbcee25",path:"/algorithm/sort/selectionSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:310},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:439},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:446},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:453},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2073}],headersStr:"介绍 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 (n−1){\\displaystyle (n-1)}(n−1) 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。\n\n\n# 复杂度\n\n * 平均时间复杂度О(n²)О(n²)О(n²)\n * 最坏时间复杂度О(n²)О(n²)О(n²)\n * 最优时间复杂度О(n²)О(n²)О(n²)\n * 空间复杂度总共О(n)О(n)О(n)，需要辅助空间O(1)O(1)O(1)\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/* The selection sort algorithm sorts an array by repeatedly finding the minimum element\n *(considering ascending order) from unsorted part and putting it at the beginning. The\n *algorithm maintains two subArrays in a given array.\n *1) The subArray which is already sorted.\n *2) Remaining subArray which is unsorted.\n *\n *In every iteration of selection sort, the minimum element (considering ascending order)\n *from the unsorted subArray is picked and moved to the sorted subArray.\n */\n\nexport const selectionSort = (list) => {\n  if (!Array.isArray(list)) {\n    throw new TypeError('Given input is not an array')\n  }\n  const items = [...list] // We don't want to modify the original array\n  const length = items.length\n  for (let i = 0; i < length - 1; i++) {\n    if (typeof items[i] !== 'number') {\n      throw new TypeError('One of the items in your array is not a number')\n    }\n    // Number of passes\n    let min = i // min holds the current minimum number position for each pass; i holds the Initial min number\n    for (let j = i + 1; j < length; j++) { // Note that j = i + 1 as we only need to go through unsorted array\n      if (items[j] < items[min]) { // Compare the numbers\n        min = j // Change the current min number position if a smaller num is found\n      }\n    }\n    if (min !== i) {\n      // After each pass, if the current min num != initial min num, exchange the position.\n      // Swap the numbers\n      [items[i], items[min]] = [items[min], items[i]]\n    }\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 参考\n\n * 选择排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n选择排序（selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 (n−1){\\displaystyle (n-1)}(n−1) 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。\n\n\n# 复杂度\n\n * 平均时间复杂度о(n²)о(n²)о(n²)\n * 最坏时间复杂度о(n²)о(n²)о(n²)\n * 最优时间复杂度о(n²)о(n²)о(n²)\n * 空间复杂度总共о(n)о(n)о(n)，需要辅助空间o(1)o(1)o(1)\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/* the selection sort algorithm sorts an array by repeatedly finding the minimum element\n *(considering ascending order) from unsorted part and putting it at the beginning. the\n *algorithm maintains two subarrays in a given array.\n *1) the subarray which is already sorted.\n *2) remaining subarray which is unsorted.\n *\n *in every iteration of selection sort, the minimum element (considering ascending order)\n *from the unsorted subarray is picked and moved to the sorted subarray.\n */\n\nexport const selectionsort = (list) => {\n  if (!array.isarray(list)) {\n    throw new typeerror('given input is not an array')\n  }\n  const items = [...list] // we don't want to modify the original array\n  const length = items.length\n  for (let i = 0; i < length - 1; i++) {\n    if (typeof items[i] !== 'number') {\n      throw new typeerror('one of the items in your array is not a number')\n    }\n    // number of passes\n    let min = i // min holds the current minimum number position for each pass; i holds the initial min number\n    for (let j = i + 1; j < length; j++) { // note that j = i + 1 as we only need to go through unsorted array\n      if (items[j] < items[min]) { // compare the numbers\n        min = j // change the current min number position if a smaller num is found\n      }\n    }\n    if (min !== i) {\n      // after each pass, if the current min num != initial min num, exchange the position.\n      // swap the numbers\n      [items[i], items[min]] = [items[min], items[i]]\n    }\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 参考\n\n * 选择排序 - 维基百科，自由的百科全书",charsets:{cyrillic:!0,cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"ShellSort [希尔排序]",frontmatter:{title:"ShellSort [希尔排序]",date:"2022-04-26T23:21:18.000Z",permalink:"/algorithm/sort/shellSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/250.shellSort.html",relativePath:"20.算法/10.Sort 排序/250.shellSort.md",key:"v-77378f5f",path:"/algorithm/sort/shellSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:177},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:322},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:329},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:336},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1085}],headersStr:"介绍 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n希尔排序（ShellSort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。\n * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。\n\n\n\n\n# 复杂度\n\n * 平均时间复杂度：根据步长序列的不同而不同。\n * 最坏时间复杂度：根据步长序列的不同而不同。已知最好的：O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。\n * 最优时间复杂度：O(n)O(n)O(n)。\n * 空间复杂度：O(1)O(1)O(1)。\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Shell Sort sorts an array based on  insertion sort algorithm\n * more information: https://en.wikipedia.org/wiki/Shellsort\n */\nexport function shellSort (items) {\n  let interval = 1\n\n  while (interval < items.length / 3) {\n    interval = interval * 3 + 1\n  }\n\n  while (interval > 0) {\n    for (let outer = interval; outer < items.length; outer++) {\n      const value = items[outer]\n      let inner = outer\n\n      while (inner > interval - 1 && items[inner - interval] >= value) {\n        items[inner] = items[inner - interval]\n        inner = inner - interval\n      }\n      items[inner] = value\n    }\n    interval = (interval - 1) / 3\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 参考\n\n * 希尔排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n希尔排序（shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。\n * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。\n\n\n\n\n# 复杂度\n\n * 平均时间复杂度：根据步长序列的不同而不同。\n * 最坏时间复杂度：根据步长序列的不同而不同。已知最好的：o(nlog⁡2n)o(n\\log^2 n)o(nlog2n)。\n * 最优时间复杂度：o(n)o(n)o(n)。\n * 空间复杂度：o(1)o(1)o(1)。\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/*\n * shell sort sorts an array based on  insertion sort algorithm\n * more information: https://en.wikipedia.org/wiki/shellsort\n */\nexport function shellsort (items) {\n  let interval = 1\n\n  while (interval < items.length / 3) {\n    interval = interval * 3 + 1\n  }\n\n  while (interval > 0) {\n    for (let outer = interval; outer < items.length; outer++) {\n      const value = items[outer]\n      let inner = outer\n\n      while (inner > interval - 1 && items[inner - interval] >= value) {\n        items[inner] = items[inner - interval]\n        inner = inner - interval\n      }\n      items[inner] = value\n    }\n    interval = (interval - 1) / 3\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 参考\n\n * 希尔排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"TimSort [Tim 排序]",frontmatter:{title:"TimSort [Tim 排序]",date:"2022-04-26T23:22:03.000Z",permalink:"/algorithm/sort/timSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/260.timSort.html",relativePath:"20.算法/10.Sort 排序/260.timSort.md",key:"v-103bfede",path:"/algorithm/sort/timSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:263},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:444},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:451}],headersStr:"介绍 原理 实现 JavaScript",content:"# 介绍\n\nTimSort 是一种混合稳定的排序算法，源自合并排序和插入排序，旨在较好地处理真实世界中各种各样的数据。它的特點是速度快．在最佳狀況只有 O (n)，平均和最糟狀況也有 O (n log (n))。\n\n从 2.3 版本起，TimSort 一直是 Python 的标准排序算法，被 Python 預設的排序函數 sorted () 和 sort () 使用。 它还被 Java SE7, Android platform, GNU Octave, 谷歌浏览器，和 Swift 用于对非原始类型的数组排序。\n\n\n# 原理\n\n先把整个资料分成小区块 (称作 Run，一般建议是 32 到 64 个数值，这个数值是 2 的倍数，因为 merge function 对于 2 的倍数的资料数目，处理得比较好。)，分别把小区块的资料以 Insertion Sort 排序，然后再把这些区块以 Merge Sort 的合并阶段作法 (merge function) 来合并起来。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n  *  @function Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,\n  *  designed to perform well on many kinds of real-world data.\n  *  It was implemented by Tim Peters in 2002 for use in the Python programming language.\n  *  It is also used to sort arrays of non-primitive type in Java SE 7,\n  *  on the Android platform, in GNU Octave, on V8, Swift and Rust.\n  *  1) It sorts small partitions using Insertion Sort.\n  *  2) Merges the partition using Merge Sort.\n  *  @see [Timsort](https://en.wikipedia.org/wiki/Timsort)\n  *  @param {Array} array\n  */\n\nconst TimSort = (array) => {\n  // Default size of a partition\n  const RUN = 32\n  const n = array.length\n  // Sorting the partitions using Insertion Sort\n  for (let i = 0; i < n; i += RUN) {\n    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))\n  }\n  for (let size = RUN; size < n; size *= 2) {\n    for (let left = 0; left < n; left += 2 * size) {\n      const mid = left + size - 1\n      const right = Math.min(left + 2 * size - 1, n - 1)\n      Merge(array, left, mid, right)\n    }\n  }\n  return array\n}\n\n/**\n * @function performs insertion sort on the partition\n * @param {Array} array array to be sorted\n * @param {Number} left left index of partition\n * @param {Number} right right index of partition\n */\n\nconst InsertionSort = (array, left, right) => {\n  for (let i = left + 1; i <= right; i++) {\n    const key = array[i]\n    let j = i - 1\n    while (j >= left && array[j] > key) {\n      array[j + 1] = array[j]\n      j--\n    }\n    array[j + 1] = key\n  }\n}\n\n/**\n * @function merges two sorted partitions\n * @param {Array} array array to be sorted\n * @param {Number} left left index of partition\n * @param {Number} mid mid index of partition\n * @param {Number} right right index of partition\n */\n\nconst Merge = (array, left, mid, right) => {\n  if (mid >= right) return\n  const len1 = mid - left + 1\n  const len2 = right - mid\n  const larr = Array(len1)\n  const rarr = Array(len2)\n  for (let i = 0; i < len1; i++) {\n    larr[i] = array[left + i]\n  }\n  for (let i = 0; i < len2; i++) {\n    rarr[i] = array[mid + 1 + i]\n  }\n  let i = 0; let j = 0; let k = left\n  while (i < larr.length && j < rarr.length) {\n    if (larr[i] < rarr[j]) {\n      array[k++] = larr[i++]\n    } else {\n      array[k++] = rarr[j++]\n    }\n  }\n  while (i < larr.length) {\n    array[k++] = larr[i++]\n  }\n  while (j < rarr.length) {\n    array[k++] = rarr[j++]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n",normalizedContent:"# 介绍\n\ntimsort 是一种混合稳定的排序算法，源自合并排序和插入排序，旨在较好地处理真实世界中各种各样的数据。它的特點是速度快．在最佳狀況只有 o (n)，平均和最糟狀況也有 o (n log (n))。\n\n从 2.3 版本起，timsort 一直是 python 的标准排序算法，被 python 預設的排序函數 sorted () 和 sort () 使用。 它还被 java se7, android platform, gnu octave, 谷歌浏览器，和 swift 用于对非原始类型的数组排序。\n\n\n# 原理\n\n先把整个资料分成小区块 (称作 run，一般建议是 32 到 64 个数值，这个数值是 2 的倍数，因为 merge function 对于 2 的倍数的资料数目，处理得比较好。)，分别把小区块的资料以 insertion sort 排序，然后再把这些区块以 merge sort 的合并阶段作法 (merge function) 来合并起来。\n\n\n# 实现\n\n\n# javascript\n\n/**\n  *  @function timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,\n  *  designed to perform well on many kinds of real-world data.\n  *  it was implemented by tim peters in 2002 for use in the python programming language.\n  *  it is also used to sort arrays of non-primitive type in java se 7,\n  *  on the android platform, in gnu octave, on v8, swift and rust.\n  *  1) it sorts small partitions using insertion sort.\n  *  2) merges the partition using merge sort.\n  *  @see [timsort](https://en.wikipedia.org/wiki/timsort)\n  *  @param {array} array\n  */\n\nconst timsort = (array) => {\n  // default size of a partition\n  const run = 32\n  const n = array.length\n  // sorting the partitions using insertion sort\n  for (let i = 0; i < n; i += run) {\n    insertionsort(array, i, math.min(i + run - 1, n - 1))\n  }\n  for (let size = run; size < n; size *= 2) {\n    for (let left = 0; left < n; left += 2 * size) {\n      const mid = left + size - 1\n      const right = math.min(left + 2 * size - 1, n - 1)\n      merge(array, left, mid, right)\n    }\n  }\n  return array\n}\n\n/**\n * @function performs insertion sort on the partition\n * @param {array} array array to be sorted\n * @param {number} left left index of partition\n * @param {number} right right index of partition\n */\n\nconst insertionsort = (array, left, right) => {\n  for (let i = left + 1; i <= right; i++) {\n    const key = array[i]\n    let j = i - 1\n    while (j >= left && array[j] > key) {\n      array[j + 1] = array[j]\n      j--\n    }\n    array[j + 1] = key\n  }\n}\n\n/**\n * @function merges two sorted partitions\n * @param {array} array array to be sorted\n * @param {number} left left index of partition\n * @param {number} mid mid index of partition\n * @param {number} right right index of partition\n */\n\nconst merge = (array, left, mid, right) => {\n  if (mid >= right) return\n  const len1 = mid - left + 1\n  const len2 = right - mid\n  const larr = array(len1)\n  const rarr = array(len2)\n  for (let i = 0; i < len1; i++) {\n    larr[i] = array[left + i]\n  }\n  for (let i = 0; i < len2; i++) {\n    rarr[i] = array[mid + 1 + i]\n  }\n  let i = 0; let j = 0; let k = left\n  while (i < larr.length && j < rarr.length) {\n    if (larr[i] < rarr[j]) {\n      array[k++] = larr[i++]\n    } else {\n      array[k++] = rarr[j++]\n    }\n  }\n  while (i < larr.length) {\n    array[k++] = larr[i++]\n  }\n  while (j < rarr.length) {\n    array[k++] = rarr[j++]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n",charsets:{cjk:!0},lastUpdated:"2022/05/09, 22:36:44",lastUpdatedTimestamp:1652107004e3},{title:"TopologicalSorter [拓扑排序器]",frontmatter:{title:"TopologicalSorter [拓扑排序器]",date:"2022-04-26T23:23:18.000Z",permalink:"/algorithm/sort/topologicalSorter/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/270.topologicalSorter.html",relativePath:"20.算法/10.Sort 排序/270.topologicalSorter.md",key:"v-301e60cb",path:"/algorithm/sort/topologicalSorter/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:96},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:103},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1414}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n拓扑排序要解决的问题是给一个图的所有节点排序。拓扑排序是指图中顶点的线性排序，使得对于每条从顶点 u 到顶点 v 的有向边 u -> v，顶点 u 都排在顶点 v 之前。\n\n\n# 实现\n\n\n# JavaScript\n\nexport function TopologicalSorter () {\n  const graph = {}\n  let isVisitedNode\n  let finishTimeCount\n  let finishingTimeList\n  let nextNode\n\n  this.addOrder = function (nodeA, nodeB) {\n    nodeA = String(nodeA)\n    nodeB = String(nodeB)\n    graph[nodeA] = graph[nodeA] || []\n    graph[nodeA].push(nodeB)\n  }\n\n  this.sortAndGetOrderedItems = function () {\n    isVisitedNode = Object.create(null)\n    finishTimeCount = 0\n    finishingTimeList = []\n\n    for (const node in graph) {\n      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {\n        dfsTraverse(node)\n      }\n    }\n\n    finishingTimeList.sort(function (item1, item2) {\n      return item1.finishTime > item2.finishTime ? -1 : 1\n    })\n\n    return finishingTimeList.map(function (value) { return value.node })\n  }\n\n  function dfsTraverse (node) {\n    isVisitedNode[node] = true\n    if (graph[node]) {\n      for (let i = 0; i < graph[node].length; i++) {\n        nextNode = graph[node][i]\n        if (isVisitedNode[nextNode]) continue\n        dfsTraverse(nextNode)\n      }\n    }\n\n    finishingTimeList.push({\n      node,\n      finishTime: ++finishTimeCount\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 参考\n\n * Topological Sort (DFS) Visualization\n * graphlib — Functionality to operate with graph-like structures — Python 3.10.4 documentation\n * graphlib --- 操作类似图的结构的功能 — Python 3.10.4 文档\n * 拓扑排序 - OI Wiki",normalizedContent:"# 介绍\n\n拓扑排序要解决的问题是给一个图的所有节点排序。拓扑排序是指图中顶点的线性排序，使得对于每条从顶点 u 到顶点 v 的有向边 u -> v，顶点 u 都排在顶点 v 之前。\n\n\n# 实现\n\n\n# javascript\n\nexport function topologicalsorter () {\n  const graph = {}\n  let isvisitednode\n  let finishtimecount\n  let finishingtimelist\n  let nextnode\n\n  this.addorder = function (nodea, nodeb) {\n    nodea = string(nodea)\n    nodeb = string(nodeb)\n    graph[nodea] = graph[nodea] || []\n    graph[nodea].push(nodeb)\n  }\n\n  this.sortandgetordereditems = function () {\n    isvisitednode = object.create(null)\n    finishtimecount = 0\n    finishingtimelist = []\n\n    for (const node in graph) {\n      if (object.prototype.hasownproperty.call(graph, node) && !isvisitednode[node]) {\n        dfstraverse(node)\n      }\n    }\n\n    finishingtimelist.sort(function (item1, item2) {\n      return item1.finishtime > item2.finishtime ? -1 : 1\n    })\n\n    return finishingtimelist.map(function (value) { return value.node })\n  }\n\n  function dfstraverse (node) {\n    isvisitednode[node] = true\n    if (graph[node]) {\n      for (let i = 0; i < graph[node].length; i++) {\n        nextnode = graph[node][i]\n        if (isvisitednode[nextnode]) continue\n        dfstraverse(nextnode)\n      }\n    }\n\n    finishingtimelist.push({\n      node,\n      finishtime: ++finishtimecount\n    })\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 参考\n\n * topological sort (dfs) visualization\n * graphlib — functionality to operate with graph-like structures — python 3.10.4 documentation\n * graphlib --- 操作类似图的结构的功能 — python 3.10.4 文档\n * 拓扑排序 - oi wiki",charsets:{cjk:!0},lastUpdated:"2022/05/10, 23:46:22",lastUpdatedTimestamp:1652197582e3},{title:"WiggleSort [摆动排序]",frontmatter:{title:"WiggleSort [摆动排序]",date:"2022-04-26T23:24:19.000Z",permalink:"/algorithm/sort/wiggleSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/280.wiggleSort.html",relativePath:"20.算法/10.Sort 排序/280.wiggleSort.md",key:"v-6133e59d",path:"/algorithm/sort/wiggleSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:28},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:35},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:544}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n摆动排序，是队列满足波浪式的顺序。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Wiggle sort sorts the array into a wave like array.\n * An array ‘arr[0..n-1]’ is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= …..\n */\n\nexport const wiggleSort = function (arr) {\n  for (let i = 0; i < arr.length; ++i) {\n    const shouldNotBeLessThan = i % 2\n    const isLessThan = arr[i] < arr[i + 1]\n    if (shouldNotBeLessThan && isLessThan) {\n      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\n    }\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 参考\n\n * [LeetCode] 280. Wiggle Sort 摆动排序\n * [LeetCode] Wiggle Sort II 摆动排序之二",normalizedContent:"# 介绍\n\n摆动排序，是队列满足波浪式的顺序。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * wiggle sort sorts the array into a wave like array.\n * an array ‘arr[0..n-1]’ is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= …..\n */\n\nexport const wigglesort = function (arr) {\n  for (let i = 0; i < arr.length; ++i) {\n    const shouldnotbelessthan = i % 2\n    const islessthan = arr[i] < arr[i + 1]\n    if (shouldnotbelessthan && islessthan) {\n      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\n    }\n  }\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 参考\n\n * [leetcode] 280. wiggle sort 摆动排序\n * [leetcode] wiggle sort ii 摆动排序之二",charsets:{cjk:!0},lastUpdated:"2022/05/10, 23:46:22",lastUpdatedTimestamp:1652197582e3},{title:"BogoSort [Bogo 排序]",frontmatter:{title:"BogoSort [Bogo 排序]",date:"2022-04-26T22:49:22.000Z",permalink:"/algorithm/sort/bogoSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/30.bogoSort.html",relativePath:"20.算法/10.Sort 排序/30.bogoSort.md",key:"v-a164921e",path:"/algorithm/sort/bogoSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:48},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:237},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:244},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1182}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>Bogo 排序（bogo-sort）是个非常低效率的排序算法，通常用在教学或测试。其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次。</p>\n',headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\nBogo 排序（bogo-sort）是个非常低效率的排序算法，通常用在教学或测试。其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次。\n\n\n# 原理\n\n以下是伪代码：\n\nfunction bogosort(arr)\n  while arr is not ordered\n      arr := 隨機排列(arr)\n\n\n1\n2\n3\n\n\n其平均时间复杂度是 O (n × n!)，在最坏情况所需时间是无限。它并非一个稳定的算法。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Checks whether the given array is sorted in ascending order.\n */\nexport function isSorted (array) {\n  const length = array.length\n  for (let i = 0; i < length - 1; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Shuffles the given array randomly in place.\n */\nfunction shuffle (array) {\n  for (let i = array.length - 1; i; i--) {\n    const m = Math.floor(Math.random() * i)\n    const n = array[i - 1]\n    array[i - 1] = array[m]\n    array[m] = n\n  }\n}\n\n/**\n * Implementation of the bogoSort algorithm.\n *\n * This sorting algorithm randomly rearranges the array until it is sorted.\n *\n * For more information see: https://en.wikipedia.org/wiki/Bogosort\n */\nexport function bogoSort (items) {\n  while (!isSorted(items)) {\n    shuffle(items)\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 参考\n\n * Bogo 排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\nbogo 排序（bogo-sort）是个非常低效率的排序算法，通常用在教学或测试。其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次。\n\n\n# 原理\n\n以下是伪代码：\n\nfunction bogosort(arr)\n  while arr is not ordered\n      arr := 隨機排列(arr)\n\n\n1\n2\n3\n\n\n其平均时间复杂度是 o (n × n!)，在最坏情况所需时间是无限。它并非一个稳定的算法。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * checks whether the given array is sorted in ascending order.\n */\nexport function issorted (array) {\n  const length = array.length\n  for (let i = 0; i < length - 1; i++) {\n    if (array[i] > array[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * shuffles the given array randomly in place.\n */\nfunction shuffle (array) {\n  for (let i = array.length - 1; i; i--) {\n    const m = math.floor(math.random() * i)\n    const n = array[i - 1]\n    array[i - 1] = array[m]\n    array[m] = n\n  }\n}\n\n/**\n * implementation of the bogosort algorithm.\n *\n * this sorting algorithm randomly rearranges the array until it is sorted.\n *\n * for more information see: https://en.wikipedia.org/wiki/bogosort\n */\nexport function bogosort (items) {\n  while (!issorted(items)) {\n    shuffle(items)\n  }\n  return items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 参考\n\n * bogo 排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"BubbleSort [冒泡排序]",frontmatter:{title:"BubbleSort [冒泡排序]",date:"2022-04-26T22:50:25.000Z",permalink:"/algorithm/sort/bubbleSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/40.bubbleSort.html",relativePath:"20.算法/10.Sort 排序/40.bubbleSort.md",key:"v-e701027e",path:"/algorithm/sort/bubbleSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:164},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:336},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:472},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:723},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:730},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:737},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2470}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>\n',headersStr:"介绍 原理 复杂度 伪代码 动画 实现 JavaScript 参考",content:"# 介绍\n\n冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。\n\n\n# 原理\n\n\n\n冒泡排序算法的运作如下：\n\n * 比较相邻的元素。如果第一个比第二个大，就交换它们两个。\n * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n * 针对所有的元素重复以上的步骤，除了最后一个。\n * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n\n# 复杂度\n\n * 平均时间复杂度 O(n2)O(n^{2})O(n2)\n * 最坏时间复杂度 O(n2)O(n^{2})O(n2)\n * 最优时间复杂度 O(n)O(n)O(n)\n * 空间复杂度总共 O(n)O(n)O(n)，需要辅助空间O(1)O(1)O(1)\n\n\n# 伪代码\n\nfunction bubble_sort (array, length) {\n    var i, j;\n    for(i from 0 to length-1){\n        for(j from 0 to length-1-i){\n            if (array[j] > array[j+1])\n                swap(array[j], array[j+1])\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/* Bubble Sort is an algorithm to sort an array. It\n*  compares adjacent element and swaps their position\n*  The big O on bubble sort in worst and best case is O(N^2).\n*  Not efficient.\n*  Somehow if the array is sorted or nearly sorted then we can optimize bubble sort by adding a flag.\n*\n*  In bubble sort, we keep iterating while something was swapped in\n*  the previous inner-loop iteration. By swapped I mean, in the\n*  inner loop iteration, we check each number if the number proceeding\n*  it is greater than itself, if so we swap them.\n*\n*  Wikipedia: https://en.wikipedia.org/wiki/Bubble_sort\n*  Animated Visual: https://www.toptal.com/developers/sorting-algorithms/bubble-sort\n*/\n\n/**\n * Using 2 for loops.\n */\nfunction bubbleSort (items) {\n  const length = items.length\n  let noSwaps\n\n  for (let i = length; i > 0; i--) {\n    // flag for optimization\n    noSwaps = true\n    // Number of passes\n    for (let j = 0; j < (i - 1); j++) {\n      // Compare the adjacent positions\n      if (items[j] > items[j + 1]) {\n        // Swap the numbers\n        [items[j], items[j + 1]] = [items[j + 1], items[j]]\n        noSwaps = false\n      }\n    }\n    if (noSwaps) {\n      break\n    }\n  }\n\n  return items\n}\n\n/**\n * Using a while loop and a for loop.\n */\nfunction alternativeBubbleSort (arr) {\n  let swapped = true\n\n  while (swapped) {\n    swapped = false\n    for (let i = 0; i < arr.length - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\n        swapped = true\n      }\n    }\n  }\n\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 参考\n\n * 冒泡排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n冒泡排序（英语：bubble sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。\n\n\n# 原理\n\n\n\n冒泡排序算法的运作如下：\n\n * 比较相邻的元素。如果第一个比第二个大，就交换它们两个。\n * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n * 针对所有的元素重复以上的步骤，除了最后一个。\n * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n\n# 复杂度\n\n * 平均时间复杂度 o(n2)o(n^{2})o(n2)\n * 最坏时间复杂度 o(n2)o(n^{2})o(n2)\n * 最优时间复杂度 o(n)o(n)o(n)\n * 空间复杂度总共 o(n)o(n)o(n)，需要辅助空间o(1)o(1)o(1)\n\n\n# 伪代码\n\nfunction bubble_sort (array, length) {\n    var i, j;\n    for(i from 0 to length-1){\n        for(j from 0 to length-1-i){\n            if (array[j] > array[j+1])\n                swap(array[j], array[j+1])\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/* bubble sort is an algorithm to sort an array. it\n*  compares adjacent element and swaps their position\n*  the big o on bubble sort in worst and best case is o(n^2).\n*  not efficient.\n*  somehow if the array is sorted or nearly sorted then we can optimize bubble sort by adding a flag.\n*\n*  in bubble sort, we keep iterating while something was swapped in\n*  the previous inner-loop iteration. by swapped i mean, in the\n*  inner loop iteration, we check each number if the number proceeding\n*  it is greater than itself, if so we swap them.\n*\n*  wikipedia: https://en.wikipedia.org/wiki/bubble_sort\n*  animated visual: https://www.toptal.com/developers/sorting-algorithms/bubble-sort\n*/\n\n/**\n * using 2 for loops.\n */\nfunction bubblesort (items) {\n  const length = items.length\n  let noswaps\n\n  for (let i = length; i > 0; i--) {\n    // flag for optimization\n    noswaps = true\n    // number of passes\n    for (let j = 0; j < (i - 1); j++) {\n      // compare the adjacent positions\n      if (items[j] > items[j + 1]) {\n        // swap the numbers\n        [items[j], items[j + 1]] = [items[j + 1], items[j]]\n        noswaps = false\n      }\n    }\n    if (noswaps) {\n      break\n    }\n  }\n\n  return items\n}\n\n/**\n * using a while loop and a for loop.\n */\nfunction alternativebubblesort (arr) {\n  let swapped = true\n\n  while (swapped) {\n    swapped = false\n    for (let i = 0; i < arr.length - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\n        swapped = true\n      }\n    }\n  }\n\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 参考\n\n * 冒泡排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"BucketSort [桶排序]",frontmatter:{title:"BucketSort [桶排序]",date:"2022-04-26T22:51:56.000Z",permalink:"/algorithm/sort/bucketSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/50.bucketSort.html",relativePath:"20.算法/10.Sort 排序/50.bucketSort.md",key:"v-0902897a",path:"/algorithm/sort/bucketSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:41},{level:3,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:338},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:637},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:644},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:651},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3086}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是 <code>鸽巢排序</code> 的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\\Theta (n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>）。但桶排序并不是比较排序，他不受到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n\\log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 下限的影响。</p>\n',headersStr:"介绍 原理 伪代码 动画 实现 JavaScript 参考",content:"# 介绍\n\n桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是 鸽巢排序 的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n){\\Theta (n)}Θ(n)）。但桶排序并不是比较排序，他不受到O(nlog⁡n){O(n\\log n)}O(nlogn) 下限的影响。\n\n\n# 原理\n\n桶排序以下列程序进行：\n\n\n\n * 设置一个定量的数组当作空桶。\n * 寻访序列，并且把项目一个一个放到对应的桶子去。\n\n\n\n * 对每个不是空的桶子进行排序。\n * 从非空的桶里把项目再放回原来的序列中。\n\n\n# 伪代码\n\nfunction bucket-sort(array, n) is\n  buckets ← new array of n empty lists\n  for i = 0 to (length(array)-1) do\n    insert array[i] into buckets[msbits(array[i], k)]\n  for i = 0 to n - 1 do\n    next-sort(buckets[i])\n  return the concatenation of buckets[0], ..., buckets[n-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * BucketSort implementation.\n *\n * Wikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array\n * into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by\n * recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the\n * most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Bucket sort can be\n * implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational\n * complexity estimates involve the number of buckets.\n *\n * @see https://en.wikipedia.org/wiki/Bucket_sort#:~:text=Bucket%20sort%2C%20or%20bin%20sort,applying%20the%20bucket%20sorting%20algorithm.&text=Sort%20each%20non%2Dempty%20bucket.\n *\n * Time Complexity of Solution:\n * Best Case O(n); Average Case O(n); Worst Case O(n)\n *\n * @param {number[]} list The array of numbers to be sorted.\n * @param {number} size The size of the buckets used. If not provided, size will be 5.\n * @return {number[]} An array of numbers sorted in increasing order.\n */\nexport function bucketSort (list, size) {\n  if (undefined === size) {\n    size = 5\n  }\n  if (list.length === 0) {\n    return list\n  }\n  let min = list[0]\n  let max = list[0]\n  // find min and max\n  for (let iList = 0; iList < list.length; iList++) {\n    if (list[iList] < min) {\n      min = list[iList]\n    } else if (list[iList] > max) {\n      max = list[iList]\n    }\n  }\n  // how many buckets we need\n  const count = Math.floor((max - min) / size) + 1\n\n  // create buckets\n  const buckets = []\n  for (let iCount = 0; iCount < count; iCount++) {\n    buckets.push([])\n  }\n\n  // bucket fill\n  for (let iBucket = 0; iBucket < list.length; iBucket++) {\n    const key = Math.floor((list[iBucket] - min) / size)\n    buckets[key].push(list[iBucket])\n  }\n  const sorted = []\n  // now sort every bucket and merge it to the sorted list\n  for (let iBucket = 0; iBucket < buckets.length; iBucket++) {\n    const arr = buckets[iBucket].sort((a, b) => a - b)\n    for (let iSorted = 0; iSorted < arr.length; iSorted++) {\n      sorted.push(arr[iSorted])\n    }\n  }\n  return sorted\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 参考\n\n * 桶排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n桶排序（bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是 鸽巢排序 的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（θ(n){\\theta (n)}θ(n)）。但桶排序并不是比较排序，他不受到o(nlog⁡n){o(n\\log n)}o(nlogn) 下限的影响。\n\n\n# 原理\n\n桶排序以下列程序进行：\n\n\n\n * 设置一个定量的数组当作空桶。\n * 寻访序列，并且把项目一个一个放到对应的桶子去。\n\n\n\n * 对每个不是空的桶子进行排序。\n * 从非空的桶里把项目再放回原来的序列中。\n\n\n# 伪代码\n\nfunction bucket-sort(array, n) is\n  buckets ← new array of n empty lists\n  for i = 0 to (length(array)-1) do\n    insert array[i] into buckets[msbits(array[i], k)]\n  for i = 0 to n - 1 do\n    next-sort(buckets[i])\n  return the concatenation of buckets[0], ..., buckets[n-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/**\n * bucketsort implementation.\n *\n * wikipedia says: bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array\n * into a number of buckets. each bucket is then sorted individually, either using a different sorting algorithm, or by\n * recursively applying the bucket sorting algorithm. it is a distribution sort, and is a cousin of radix sort in the\n * most to least significant digit flavour. bucket sort is a generalization of pigeonhole sort. bucket sort can be\n * implemented with comparisons and therefore can also be considered a comparison sort algorithm. the computational\n * complexity estimates involve the number of buckets.\n *\n * @see https://en.wikipedia.org/wiki/bucket_sort#:~:text=bucket%20sort%2c%20or%20bin%20sort,applying%20the%20bucket%20sorting%20algorithm.&text=sort%20each%20non%2dempty%20bucket.\n *\n * time complexity of solution:\n * best case o(n); average case o(n); worst case o(n)\n *\n * @param {number[]} list the array of numbers to be sorted.\n * @param {number} size the size of the buckets used. if not provided, size will be 5.\n * @return {number[]} an array of numbers sorted in increasing order.\n */\nexport function bucketsort (list, size) {\n  if (undefined === size) {\n    size = 5\n  }\n  if (list.length === 0) {\n    return list\n  }\n  let min = list[0]\n  let max = list[0]\n  // find min and max\n  for (let ilist = 0; ilist < list.length; ilist++) {\n    if (list[ilist] < min) {\n      min = list[ilist]\n    } else if (list[ilist] > max) {\n      max = list[ilist]\n    }\n  }\n  // how many buckets we need\n  const count = math.floor((max - min) / size) + 1\n\n  // create buckets\n  const buckets = []\n  for (let icount = 0; icount < count; icount++) {\n    buckets.push([])\n  }\n\n  // bucket fill\n  for (let ibucket = 0; ibucket < list.length; ibucket++) {\n    const key = math.floor((list[ibucket] - min) / size)\n    buckets[key].push(list[ibucket])\n  }\n  const sorted = []\n  // now sort every bucket and merge it to the sorted list\n  for (let ibucket = 0; ibucket < buckets.length; ibucket++) {\n    const arr = buckets[ibucket].sort((a, b) => a - b)\n    for (let isorted = 0; isorted < arr.length; isorted++) {\n      sorted.push(arr[isorted])\n    }\n  }\n  return sorted\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 参考\n\n * 桶排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"CocktailShakerSort [鸡尾酒排序]",frontmatter:{title:"CocktailShakerSort [鸡尾酒排序]",date:"2022-04-26T22:53:06.000Z",permalink:"/algorithm/sort/cocktailShakerSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/60.cocktailShakerSort.html",relativePath:"20.算法/10.Sort 排序/60.cocktailShakerSort.md",key:"v-11223575",path:"/algorithm/sort/cocktailShakerSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:114},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:123},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:130},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2390}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p>\n',headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\n鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。\n\n\n# 原理\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Cocktail Shaker Sort is an algorithm that is a Bidirectional（双向的） Bubble Sort.\n *\n * The algorithm extends bubble sort by operating in two directions.\n * While it improves on bubble sort by more quickly moving items to the beginning of the list, it provides only marginal（微小的）\n * performance improvements.\n *\n * Wikipedia (Cocktail Shaker Sort): https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n * Wikipedia (Bubble Sort): https://en.wikipedia.org/wiki/Bubble_sort\n */\nfunction cocktailShakerSort (items) {\n  for (let i = items.length - 1; i > 0; i--) {\n    let j\n\n    // Backwards\n    for (j = items.length - 1; j > i; j--) {\n      if (items[j] < items[j - 1]) {\n        [items[j], items[j - 1]] = [items[j - 1], items[j]]\n      }\n    }\n\n    // Forwards\n    for (j = 0; j < i; j++) {\n      if (items[j] > items[j + 1]) {\n        [items[j], items[j + 1]] = [items[j + 1], items[j]]\n      }\n    }\n  }\n\n  return items\n}\n\nfunction cocktail_sort(list, list_length){ // the first element of list has index 0\n    bottom = 0;\n    top = list_length - 1;\n    swapped = true; \n    while(swapped == true) // if no elements have been swapped, then the list is sorted\n    {\n        swapped = false; \n        for(i = bottom; i < top; i = i + 1)\n        {\n            if(list[i] > list[i + 1])  // test whether the two elements are in the correct order\n            {\n                swap(list[i], list[i + 1]); // let the two elements change places\n                swapped = true;\n            }\n        }\n        // decreases top the because the element with the largest value in the unsorted\n        // part of the list is now on the position top \n        top = top - 1; \n        for(i = top; i > bottom; i = i - 1)\n        {\n            if(list[i] < list[i - 1]) \n            {\n                swap(list[i], list[i - 1]);\n                swapped = true;\n            }\n        }\n        // increases bottom because the element with the smallest value in the unsorted \n        // part of the list is now on the position bottom \n        bottom = bottom + 1;  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 参考\n\n * 鸡尾酒排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。\n\n\n# 原理\n\n\n\n\n# 实现\n\n\n# javascript\n\n/**\n * cocktail shaker sort is an algorithm that is a bidirectional（双向的） bubble sort.\n *\n * the algorithm extends bubble sort by operating in two directions.\n * while it improves on bubble sort by more quickly moving items to the beginning of the list, it provides only marginal（微小的）\n * performance improvements.\n *\n * wikipedia (cocktail shaker sort): https://en.wikipedia.org/wiki/cocktail_shaker_sort\n * wikipedia (bubble sort): https://en.wikipedia.org/wiki/bubble_sort\n */\nfunction cocktailshakersort (items) {\n  for (let i = items.length - 1; i > 0; i--) {\n    let j\n\n    // backwards\n    for (j = items.length - 1; j > i; j--) {\n      if (items[j] < items[j - 1]) {\n        [items[j], items[j - 1]] = [items[j - 1], items[j]]\n      }\n    }\n\n    // forwards\n    for (j = 0; j < i; j++) {\n      if (items[j] > items[j + 1]) {\n        [items[j], items[j + 1]] = [items[j + 1], items[j]]\n      }\n    }\n  }\n\n  return items\n}\n\nfunction cocktail_sort(list, list_length){ // the first element of list has index 0\n    bottom = 0;\n    top = list_length - 1;\n    swapped = true; \n    while(swapped == true) // if no elements have been swapped, then the list is sorted\n    {\n        swapped = false; \n        for(i = bottom; i < top; i = i + 1)\n        {\n            if(list[i] > list[i + 1])  // test whether the two elements are in the correct order\n            {\n                swap(list[i], list[i + 1]); // let the two elements change places\n                swapped = true;\n            }\n        }\n        // decreases top the because the element with the largest value in the unsorted\n        // part of the list is now on the position top \n        top = top - 1; \n        for(i = top; i > bottom; i = i - 1)\n        {\n            if(list[i] < list[i - 1]) \n            {\n                swap(list[i], list[i - 1]);\n                swapped = true;\n            }\n        }\n        // increases bottom because the element with the smallest value in the unsorted \n        // part of the list is now on the position bottom \n        bottom = bottom + 1;  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 参考\n\n * 鸡尾酒排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"CombSort [梳排序]",frontmatter:{title:"CombSort [梳排序]",date:"2022-04-26T22:54:30.000Z",permalink:"/algorithm/sort/combSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/70.combSort.html",relativePath:"20.算法/10.Sort 排序/70.combSort.md",key:"v-b55c4a5e",path:"/algorithm/sort/combSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:97},{level:3,title:"递减率",slug:"递减率",normalizedTitle:"递减率",charIndex:208},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:416},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:597},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:604},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2265}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>梳排序是改良自冒泡排序和快速排序，其要旨在于消除乌龟，亦即在数组尾部的小数值，这些数值是造成冒泡排序缓慢的主因。相对地，兔子，亦即在数组前端的大数值，不影响冒泡排序的性能。</p>\n',headersStr:"介绍 原理 递减率 复杂度 实现 JavaScript 参考",content:'# 介绍\n\n梳排序是改良自冒泡排序和快速排序，其要旨在于消除乌龟，亦即在数组尾部的小数值，这些数值是造成冒泡排序缓慢的主因。相对地，兔子，亦即在数组前端的大数值，不影响冒泡排序的性能。\n\n\n# 原理\n\n在冒泡排序中，只比较数组中相邻的二项，即比较的二项的间距（Gap）是 1，梳排序提出此间距其实可大于 1，改自插入排序的希尔排序同样提出相同观点。梳排序中，开始时的间距设置为数组长度，并在循环中以固定比率递减，通常递减率设置为 1.3。在一次循环中，梳排序如同冒泡排序一样把数组从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于 1。如果间距递减至 1，梳排序假定输入数组大致排序好，并以冒泡排序作最后检查及修正。\n\n\n\n\n# 递减率\n\n递减率的设置影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为 1.3 的。如果此比率太小，则导致一循环中有过多的比较，如果比率太大，则未能有效消除数组中的乌龟。\n\n\n# 复杂度\n\n * 平均时间复杂度 Ω(n2/2p){\\displaystyle \\Omega (n^{2}/2^{p})}Ω(n2/2p)，其中 p 表示增量。\n * 最坏时间复杂度Ω(n2)\\Omega (n^{2})Ω(n2)。\n * 最优时间复杂度O(nlog⁡n)O(n\\log n)O(nlogn)。\n * 空间复杂度O(1)O(1)O(1)。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Comb sort improves on bubble sort.\n *\n * The basic idea is to eliminate turtles, or small values\n * near the end of the list, since in a bubble sort these slow the sorting\n * down tremendously. Rabbits, large values around the beginning of the list,\n * do not pose a problem in bubble sort.\n *\n * In bubble sort, when any two elements are compared, they always have a\n * gap (distance from each other) of 1. The basic idea of comb sort is\n * that the gap can be much more than 1. The inner loop of bubble sort,\n * which does the actual swap, is modified such that gap between swapped\n * elements goes down (for each iteration of outer loop) in steps of\n * a "shrink factor" k: [ n/k, n/k2, n/k3, ..., 1 ].\n *\n * Wikipedia: https://en.wikipedia.org/wiki/Comb_sort\n */\n\n/**\n * combSort returns an array of numbers sorted in increasing order.\n *\n * @param {number[]} list The array of numbers to sort.\n * @return {number[]} The array of numbers sorted in increasing order.\n */\nfunction combSort (list) {\n  if (list.length === 0) {\n    return list\n  }\n  const shrink = 1.3\n  let gap = list.length\n  let isSwapped = true\n  let i = 0\n\n  while (gap > 1 || isSwapped) {\n    // Update the gap value for a next comb\n    gap = parseInt(parseFloat(gap) / shrink, 10)\n\n    isSwapped = false\n    i = 0\n\n    while (gap + i < list.length) {\n      if (list[i] > list[i + gap]) {\n        [list[i], list[i + gap]] = [list[i + gap], list[i]]\n        isSwapped = true\n      }\n      i += 1\n    }\n  }\n  return list\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 参考\n\n * 梳排序 - 维基百科，自由的百科全书',normalizedContent:'# 介绍\n\n梳排序是改良自冒泡排序和快速排序，其要旨在于消除乌龟，亦即在数组尾部的小数值，这些数值是造成冒泡排序缓慢的主因。相对地，兔子，亦即在数组前端的大数值，不影响冒泡排序的性能。\n\n\n# 原理\n\n在冒泡排序中，只比较数组中相邻的二项，即比较的二项的间距（gap）是 1，梳排序提出此间距其实可大于 1，改自插入排序的希尔排序同样提出相同观点。梳排序中，开始时的间距设置为数组长度，并在循环中以固定比率递减，通常递减率设置为 1.3。在一次循环中，梳排序如同冒泡排序一样把数组从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于 1。如果间距递减至 1，梳排序假定输入数组大致排序好，并以冒泡排序作最后检查及修正。\n\n\n\n\n# 递减率\n\n递减率的设置影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为 1.3 的。如果此比率太小，则导致一循环中有过多的比较，如果比率太大，则未能有效消除数组中的乌龟。\n\n\n# 复杂度\n\n * 平均时间复杂度 ω(n2/2p){\\displaystyle \\omega (n^{2}/2^{p})}ω(n2/2p)，其中 p 表示增量。\n * 最坏时间复杂度ω(n2)\\omega (n^{2})ω(n2)。\n * 最优时间复杂度o(nlog⁡n)o(n\\log n)o(nlogn)。\n * 空间复杂度o(1)o(1)o(1)。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * comb sort improves on bubble sort.\n *\n * the basic idea is to eliminate turtles, or small values\n * near the end of the list, since in a bubble sort these slow the sorting\n * down tremendously. rabbits, large values around the beginning of the list,\n * do not pose a problem in bubble sort.\n *\n * in bubble sort, when any two elements are compared, they always have a\n * gap (distance from each other) of 1. the basic idea of comb sort is\n * that the gap can be much more than 1. the inner loop of bubble sort,\n * which does the actual swap, is modified such that gap between swapped\n * elements goes down (for each iteration of outer loop) in steps of\n * a "shrink factor" k: [ n/k, n/k2, n/k3, ..., 1 ].\n *\n * wikipedia: https://en.wikipedia.org/wiki/comb_sort\n */\n\n/**\n * combsort returns an array of numbers sorted in increasing order.\n *\n * @param {number[]} list the array of numbers to sort.\n * @return {number[]} the array of numbers sorted in increasing order.\n */\nfunction combsort (list) {\n  if (list.length === 0) {\n    return list\n  }\n  const shrink = 1.3\n  let gap = list.length\n  let isswapped = true\n  let i = 0\n\n  while (gap > 1 || isswapped) {\n    // update the gap value for a next comb\n    gap = parseint(parsefloat(gap) / shrink, 10)\n\n    isswapped = false\n    i = 0\n\n    while (gap + i < list.length) {\n      if (list[i] > list[i + gap]) {\n        [list[i], list[i + gap]] = [list[i + gap], list[i]]\n        isswapped = true\n      }\n      i += 1\n    }\n  }\n  return list\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 参考\n\n * 梳排序 - 维基百科，自由的百科全书',charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"CountingSort [计数排序]",frontmatter:{title:"CountingSort [计数排序]",date:"2022-04-26T22:56:00.000Z",permalink:"/algorithm/sort/countingSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/80.countingSort.html",relativePath:"20.算法/10.Sort 排序/80.countingSort.md",key:"v-695ad56b",path:"/algorithm/sort/countingSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:45},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:442},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:569},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:576},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:583},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2016}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。</p>\n',headersStr:"介绍 原理 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n计数排序（Counting sort）是一种稳定的线性时间排序算法。\n\n\n# 原理\n\n计数排序使用一个额外的数组 CCC ，其中第 i 个元素是待排序数组 AAA 中值等于 iii 的元素的个数。然后根据数组 CCC 来将 AAA 中的元素排到正确的位置。\n\n由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\n\n算法的步骤如下：\n\n * 找出待排序的数组中最大和最小的元素\n * 统计数组中每个值为 iii 的元素出现的次数，存入数组 CCC 的第 iii 项\n * 对所有的计数累加（从 CCC 中的第一个元素开始，每一项和前一项相加）\n * 反向填充目标数组：将每个元素 iii 放在新数组的第 C[i]{\\displaystyle C[i]}C[i] 项，每放一个元素就将 C[i]{\\displaystyle C[i]}C[i] 减去 1\n\n\n# 复杂度\n\n * 平均时间复杂度O(n+k)O(n+k)O(n+k)。\n * 最坏时间复杂度O(n+k)O(n+k)O(n+k)。\n * 最优时间复杂度O(n+k)O(n+k)O(n+k)。\n * 空间复杂度O(n+k)O(n+k)O(n+k)。\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Counting sort is an algorithm for sorting a collection\n * of objects according to keys that are small integers.\n *\n * It is an integer sorting algorithm.\n *\n * Wikipedia: https://en.wikipedia.org/wiki/Counting_sort\n * Animated Visual: https://www.cs.usfca.edu/~galles/visualization/CountingSort.html\n */\n\nconst countingSort = (arr, min, max) => {\n  // Create an auxiliary resultant array\n  const res = []\n  // Create and initialize the frequency[count] array\n  const count = new Array(max - min + 1).fill(0)\n  // Populate the freq array\n  for (let i = 0; i < arr.length; i++) {\n    count[arr[i] - min]++\n  }\n  // Create a prefix sum array out of the frequency[count] array\n  count[0] -= 1\n  for (let i = 1; i < count.length; i++) {\n    count[i] += count[i - 1]\n  }\n  // Populate the result array using the prefix sum array\n  for (let i = arr.length - 1; i >= 0; i--) {\n    res[count[arr[i] - min]] = arr[i]\n    count[arr[i] - min]--\n  }\n  return res\n}\n\nArray.prototype.countSort = function() {\n  const C = []\n  for(let i = 0; i < this.length; i++) {\n    const j = this[i]\n    C[j] >= 1 ? C[j] ++ : (C[j] = 1)\n  }\n  const D = []\n  for(let j = 0; j < C.length; j++) {\n    if(C[j]) {\n      while(C[j] > 0) {\n        D.push(j)\n        C[j]--\n      }\n    }\n  }\n  return D\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 参考\n\n * Counting Sort Visualization\n * 计数排序 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n计数排序（counting sort）是一种稳定的线性时间排序算法。\n\n\n# 原理\n\n计数排序使用一个额外的数组 ccc ，其中第 i 个元素是待排序数组 aaa 中值等于 iii 的元素的个数。然后根据数组 ccc 来将 aaa 中的元素排到正确的位置。\n\n由于用来计数的数组 c 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\n\n算法的步骤如下：\n\n * 找出待排序的数组中最大和最小的元素\n * 统计数组中每个值为 iii 的元素出现的次数，存入数组 ccc 的第 iii 项\n * 对所有的计数累加（从 ccc 中的第一个元素开始，每一项和前一项相加）\n * 反向填充目标数组：将每个元素 iii 放在新数组的第 c[i]{\\displaystyle c[i]}c[i] 项，每放一个元素就将 c[i]{\\displaystyle c[i]}c[i] 减去 1\n\n\n# 复杂度\n\n * 平均时间复杂度o(n+k)o(n+k)o(n+k)。\n * 最坏时间复杂度o(n+k)o(n+k)o(n+k)。\n * 最优时间复杂度o(n+k)o(n+k)o(n+k)。\n * 空间复杂度o(n+k)o(n+k)o(n+k)。\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/**\n * counting sort is an algorithm for sorting a collection\n * of objects according to keys that are small integers.\n *\n * it is an integer sorting algorithm.\n *\n * wikipedia: https://en.wikipedia.org/wiki/counting_sort\n * animated visual: https://www.cs.usfca.edu/~galles/visualization/countingsort.html\n */\n\nconst countingsort = (arr, min, max) => {\n  // create an auxiliary resultant array\n  const res = []\n  // create and initialize the frequency[count] array\n  const count = new array(max - min + 1).fill(0)\n  // populate the freq array\n  for (let i = 0; i < arr.length; i++) {\n    count[arr[i] - min]++\n  }\n  // create a prefix sum array out of the frequency[count] array\n  count[0] -= 1\n  for (let i = 1; i < count.length; i++) {\n    count[i] += count[i - 1]\n  }\n  // populate the result array using the prefix sum array\n  for (let i = arr.length - 1; i >= 0; i--) {\n    res[count[arr[i] - min]] = arr[i]\n    count[arr[i] - min]--\n  }\n  return res\n}\n\narray.prototype.countsort = function() {\n  const c = []\n  for(let i = 0; i < this.length; i++) {\n    const j = this[i]\n    c[j] >= 1 ? c[j] ++ : (c[j] = 1)\n  }\n  const d = []\n  for(let j = 0; j < c.length; j++) {\n    if(c[j]) {\n      while(c[j] > 0) {\n        d.push(j)\n        c[j]--\n      }\n    }\n  }\n  return d\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 参考\n\n * counting sort visualization\n * 计数排序 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"CycleSort [圈排序]",frontmatter:{title:"CycleSort [圈排序]",date:"2022-04-26T22:56:57.000Z",permalink:"/algorithm/sort/cycleSort/",categories:["算法","Sort 排序"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/10.Sort%20%E6%8E%92%E5%BA%8F/90.cycleSort.html",relativePath:"20.算法/10.Sort 排序/90.cycleSort.md",key:"v-0dd76b46",path:"/algorithm/sort/cycleSort/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:78},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:297},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:442},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:449},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2266}],excerpt:'<h2 id="介绍"><a class="header-anchor" href="#介绍">#</a> 介绍</h2>\n<p>圈排序是一种比较排序算法，它强制将数组分解为圈数，其中每个圈可以旋转以生成排序数组。它在理论上是最优的，它减少了对原始数组的写入次数。</p>\n',headersStr:"介绍 原理 复杂度 实现 JavaScript 参考",content:"# 介绍\n\n圈排序是一种比较排序算法，它强制将数组分解为圈数，其中每个圈可以旋转以生成排序数组。它在理论上是最优的，它减少了对原始数组的写入次数。\n\n\n# 原理\n\n考虑一组 n 个不同的元素。 给出元素 a，可以通过计算小于 a 的元素的数量来计算 a 的索引。\n\n\n\n * 如果找到元素处于正确的位置，只需保持原样。\n * 否则，通过计算小于 a 的元素总数来找到 a 的正确位置。它必须出现在排序数组中。被替换的另一个元素 b 将被移动到其正确的位置。 这个过程一直持续到在 a 的原始位置得到一个元素。所示过程构成一个循环圈，为列表的每个元素重复此循环。 结果列表将被排序。\n\n\n\n\n# 复杂度\n\n * Worst-case performance: Θ(n^2)\n * Best-case performance: Θ(n^2)\n * Average performance: Θ(n^2)\n * Worst-case space: Θ(n) total, Θ(1)\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Cycle sort is an in-place, unstable sorting algorithm,\n * a comparison sort that is theoretically optimal in terms of the total\n * number of writes to the original array, unlike any other in-place sorting\n * algorithm. It is based on the idea that the permutation(置换) to be sorted can\n * be factored into cycles, which can individually be rotated to give a sorted result.\n *\n * Wikipedia: https://en.wikipedia.org/wiki/Cycle_sort\n */\n\n/**\n * cycleSort takes an input array of numbers and returns the array sorted in increasing order.\n *\n * @param {number[]} list An array of numbers to be sorted.\n * @return {number[]} An array of numbers sorted in increasing order.\n */\nfunction cycleSort (list) {\n  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {\n    let value = list[cycleStart]\n    let position = cycleStart\n\n    // search position\n    for (let i = cycleStart + 1; i < list.length; i++) {\n      if (list[i] < value) {\n        position++\n      }\n    }\n    // if it is the same, continue\n    if (position === cycleStart) {\n      continue\n    }\n    while (value === list[position]) {\n      position++\n    }\n\n    const oldValue = list[position]\n    list[position] = value\n    value = oldValue\n\n    // rotate the rest\n    while (position !== cycleStart) {\n      position = cycleStart\n      for (let i = cycleStart + 1; i < list.length; i++) {\n        if (list[i] < value) {\n          position++\n        }\n      }\n      while (value === list[position]) {\n        position++\n      }\n      const oldValueCycle = list[position]\n      list[position] = value\n      value = oldValueCycle\n    }\n  }\n  return list\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 参考\n\n * Cycle sort - Wikipedia",normalizedContent:"# 介绍\n\n圈排序是一种比较排序算法，它强制将数组分解为圈数，其中每个圈可以旋转以生成排序数组。它在理论上是最优的，它减少了对原始数组的写入次数。\n\n\n# 原理\n\n考虑一组 n 个不同的元素。 给出元素 a，可以通过计算小于 a 的元素的数量来计算 a 的索引。\n\n\n\n * 如果找到元素处于正确的位置，只需保持原样。\n * 否则，通过计算小于 a 的元素总数来找到 a 的正确位置。它必须出现在排序数组中。被替换的另一个元素 b 将被移动到其正确的位置。 这个过程一直持续到在 a 的原始位置得到一个元素。所示过程构成一个循环圈，为列表的每个元素重复此循环。 结果列表将被排序。\n\n\n\n\n# 复杂度\n\n * worst-case performance: θ(n^2)\n * best-case performance: θ(n^2)\n * average performance: θ(n^2)\n * worst-case space: θ(n) total, θ(1)\n\n\n# 实现\n\n\n# javascript\n\n/**\n * cycle sort is an in-place, unstable sorting algorithm,\n * a comparison sort that is theoretically optimal in terms of the total\n * number of writes to the original array, unlike any other in-place sorting\n * algorithm. it is based on the idea that the permutation(置换) to be sorted can\n * be factored into cycles, which can individually be rotated to give a sorted result.\n *\n * wikipedia: https://en.wikipedia.org/wiki/cycle_sort\n */\n\n/**\n * cyclesort takes an input array of numbers and returns the array sorted in increasing order.\n *\n * @param {number[]} list an array of numbers to be sorted.\n * @return {number[]} an array of numbers sorted in increasing order.\n */\nfunction cyclesort (list) {\n  for (let cyclestart = 0; cyclestart < list.length; cyclestart++) {\n    let value = list[cyclestart]\n    let position = cyclestart\n\n    // search position\n    for (let i = cyclestart + 1; i < list.length; i++) {\n      if (list[i] < value) {\n        position++\n      }\n    }\n    // if it is the same, continue\n    if (position === cyclestart) {\n      continue\n    }\n    while (value === list[position]) {\n      position++\n    }\n\n    const oldvalue = list[position]\n    list[position] = value\n    value = oldvalue\n\n    // rotate the rest\n    while (position !== cyclestart) {\n      position = cyclestart\n      for (let i = cyclestart + 1; i < list.length; i++) {\n        if (list[i] < value) {\n          position++\n        }\n      }\n      while (value === list[position]) {\n        position++\n      }\n      const oldvaluecycle = list[position]\n      list[position] = value\n      value = oldvaluecycle\n    }\n  }\n  return list\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 参考\n\n * cycle sort - wikipedia",charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"GeneratePermutations [排列]",frontmatter:{title:"GeneratePermutations [排列]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/generatePermutations/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/20.GeneratePermutations.html",relativePath:"20.算法/100.Backtracking 回溯/20.GeneratePermutations.md",key:"v-4078729f",path:"/algorithm/backtracking/generatePermutations/",headers:[{level:2,title:"排列与组合",slug:"排列与组合",normalizedTitle:"排列与组合",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:137},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:144},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1082}],headersStr:"排列与组合 实现 JavaScript 参考",content:"# 排列与组合\n\n排列和组合（permutations and combinations），是指从一个集合中选择对象的各种方式，一般不替换（replacement），以形成子集。当选择的顺序是一个元素时，这种子集的选择被称为排列，当顺序不是一个元素时，被称为组合。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Problem Statement: Generate all distinct permutations of a an array (all permutations should be in sorted order);\n *\n * What is permutations?\n * - Permutation means possible arrangements in a set (here it is an array);\n *\n * Reference to know more about permutations:\n * - https://www.britannica.com/science/permutation\n *\n */\n\nconst swap = (arr, i, j) => {\n  const newArray = [...arr];\n\n  [newArray[i], newArray[j]] = [newArray[j], newArray[i]] // Swapping elements ES6 way\n\n  return newArray\n}\n\nconst permutations = arr => {\n  const P = []\n  const permute = (arr, low, high) => {\n    if (low === high) {\n      P.push([...arr])\n      return P\n    }\n    for (let i = low; i <= high; i++) {\n      arr = swap(arr, low, i)\n      permute(arr, low + 1, high)\n    }\n    return P\n  }\n  return permute(arr, 0, arr.length - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参考\n\n * permutations and combinations | Description, Examples, & Formula | Britannica",normalizedContent:"# 排列与组合\n\n排列和组合（permutations and combinations），是指从一个集合中选择对象的各种方式，一般不替换（replacement），以形成子集。当选择的顺序是一个元素时，这种子集的选择被称为排列，当顺序不是一个元素时，被称为组合。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * problem statement: generate all distinct permutations of a an array (all permutations should be in sorted order);\n *\n * what is permutations?\n * - permutation means possible arrangements in a set (here it is an array);\n *\n * reference to know more about permutations:\n * - https://www.britannica.com/science/permutation\n *\n */\n\nconst swap = (arr, i, j) => {\n  const newarray = [...arr];\n\n  [newarray[i], newarray[j]] = [newarray[j], newarray[i]] // swapping elements es6 way\n\n  return newarray\n}\n\nconst permutations = arr => {\n  const p = []\n  const permute = (arr, low, high) => {\n    if (low === high) {\n      p.push([...arr])\n      return p\n    }\n    for (let i = low; i <= high; i++) {\n      arr = swap(arr, low, i)\n      permute(arr, low + 1, high)\n    }\n    return p\n  }\n  return permute(arr, 0, arr.length - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参考\n\n * permutations and combinations | description, examples, & formula | britannica",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"AllCombinationsOfSizeK [全组合]",frontmatter:{title:"AllCombinationsOfSizeK [全组合]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/allCombinationsOfSizeK/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/10.AllCombinationsOfSizeK.html",relativePath:"20.算法/100.Backtracking 回溯/10.AllCombinationsOfSizeK.md",key:"v-0ad06882",path:"/algorithm/backtracking/allCombinationsOfSizeK/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"回溯法",slug:"回溯法",normalizedTitle:"回溯法",charIndex:102},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:479},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:698},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2195},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2210}],headersStr:"介绍 回溯法 实现 JavaScript 扩展 参考",content:"# 介绍\n\n在组合数学，一个集的元素的组合是一个子集。S 的一个 k - 组合是 S 的一个有 k 个元素的子集。若两个子集的元素完全相同并顺序相异，它仍视为同一个组合，这是组合和排列不同之处。\n\n\n# 回溯法\n\n回溯法（英语：backtracking）是暴力搜寻法中的一种。\n\n对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。\n\n在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）\n\n回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n * 找到一个可能存在的正确的答案\n * 在尝试了所有可能的分步方法后宣告该问题没有答案\n\n在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。\n\n尝试错误法\n\n尝试错误法，又称试误法（英语：trial and error），简称试错，是用来解决问题、获取知识的常见方法。此种方法可以视为简易解决问题的方法中的一种，与使用洞察力／直觉或理论推理的方法正好相反。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  Problem: Given two numbers, n and k, make all unique combinations of k numbers from 1 to n and in sorted order\n\n  What is combinations?\n  - Combinations is selecting items from a collections without considering order of selection\n\n  Example:\n  - We have an apple, a banana, and a jackfruit\n  - We have three objects, and need to choose two items, then combinations will be\n\n  1. Apple & Banana\n  2. Apple & Jackfruit\n  3. Banana & Jackfruit\n\n  To read more about combinations, you can visit the following link:\n  - https://betterexplained.com/articles/easy-permutations-and-combinations/\n\n  Solution:\n  - We will be using backtracking to solve this questions\n  - Take one element, and make all them combinations for k-1 elements\n  - Once we get all combinations of that element, pop it and do same for next element\n*/\n\nclass Combinations {\n  constructor (n, k) {\n    this.n = n\n    this.k = k\n    this.current = [] // will be used for storing current combination\n    this.combinations = []\n  }\n\n  findCombinations (high = this.n, total = this.k, low = 1) {\n    if (total === 0) {\n      this.combinations.push([...this.current])\n      return this.combinations\n    }\n    for (let i = low; i <= high; i++) {\n      this.current.push(i)\n      this.findCombinations(high, total - 1, i + 1)\n      this.current.pop()\n    }\n    return this.combinations\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 扩展\n\n注意组合与排列的区别，参考：\n\n * CreatePermutations [全排列] | Fancy DSA\n * 回溯算法 —— 子集、组合、排列问题\n\n\n# 参考\n\n * Combination - Wikiwand\n * 组合 - Wikiwand\n * Easy Permutations and Combinations – BetterExplained\n * Backtracking - Wikiwand\n * 回溯法 - Wikiwand",normalizedContent:"# 介绍\n\n在组合数学，一个集的元素的组合是一个子集。s 的一个 k - 组合是 s 的一个有 k 个元素的子集。若两个子集的元素完全相同并顺序相异，它仍视为同一个组合，这是组合和排列不同之处。\n\n\n# 回溯法\n\n回溯法（英语：backtracking）是暴力搜寻法中的一种。\n\n对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。\n\n在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）\n\n回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n * 找到一个可能存在的正确的答案\n * 在尝试了所有可能的分步方法后宣告该问题没有答案\n\n在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。\n\n尝试错误法\n\n尝试错误法，又称试误法（英语：trial and error），简称试错，是用来解决问题、获取知识的常见方法。此种方法可以视为简易解决问题的方法中的一种，与使用洞察力／直觉或理论推理的方法正好相反。\n\n\n# 实现\n\n\n# javascript\n\n/*\n  problem: given two numbers, n and k, make all unique combinations of k numbers from 1 to n and in sorted order\n\n  what is combinations?\n  - combinations is selecting items from a collections without considering order of selection\n\n  example:\n  - we have an apple, a banana, and a jackfruit\n  - we have three objects, and need to choose two items, then combinations will be\n\n  1. apple & banana\n  2. apple & jackfruit\n  3. banana & jackfruit\n\n  to read more about combinations, you can visit the following link:\n  - https://betterexplained.com/articles/easy-permutations-and-combinations/\n\n  solution:\n  - we will be using backtracking to solve this questions\n  - take one element, and make all them combinations for k-1 elements\n  - once we get all combinations of that element, pop it and do same for next element\n*/\n\nclass combinations {\n  constructor (n, k) {\n    this.n = n\n    this.k = k\n    this.current = [] // will be used for storing current combination\n    this.combinations = []\n  }\n\n  findcombinations (high = this.n, total = this.k, low = 1) {\n    if (total === 0) {\n      this.combinations.push([...this.current])\n      return this.combinations\n    }\n    for (let i = low; i <= high; i++) {\n      this.current.push(i)\n      this.findcombinations(high, total - 1, i + 1)\n      this.current.pop()\n    }\n    return this.combinations\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 扩展\n\n注意组合与排列的区别，参考：\n\n * createpermutations [全排列] | fancy dsa\n * 回溯算法 —— 子集、组合、排列问题\n\n\n# 参考\n\n * combination - wikiwand\n * 组合 - wikiwand\n * easy permutations and combinations – betterexplained\n * backtracking - wikiwand\n * 回溯法 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"KnightTour [骑士巡逻]",frontmatter:{title:"KnightTour [骑士巡逻]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/knightTour/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/30.KnightTour.html",relativePath:"20.算法/100.Backtracking 回溯/30.KnightTour.md",key:"v-fa1be2c2",path:"/algorithm/backtracking/knightTour/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实质",slug:"实质",normalizedTitle:"实质",charIndex:425},{level:2,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:730},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1121},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1128},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2986}],headersStr:"介绍 实质 解决方法 实现 JavaScript 参考",content:"# 介绍\n\n骑士巡逻（英语：Knight's tour）是指在按照国际象棋中骑士的规定走法走遍整个棋盘的每一个方格，而且每个网格只能够经过一次。假若骑士能够从走回到最初位置，则称此巡逻为 “封闭巡逻”，否则，称为 “开巡逻”。对于 8*8 棋盘，一共有 26,534,728,821,064 种封闭巡逻，有 19,591,828,170,979,904 种开巡逻。\n\n\n\n由骑士巡逻引申出了一个著名的数学问题 ：骑士巡逻问题 -- 找出所有的骑士巡逻路径。骑士巡逻问题的变种包括各种尺寸的棋盘甚至非正方形的棋盘。\n\nCull 和 Conrad 证明了对于任何一个 m×n（5<=m<=n）棋盘，至少有一个（可能是开巡逻）骑士巡逻路径。\n\nSchwenk 证明了，除了以下 3 种情况外，任何的 m×n（m<=n）棋盘都至少有 1 个闭巡逻。\n\n * m 和 n 都为奇数\n * m= 1, 2, 4\n * m= 3 且 n= 4, 6, 8\n\n\n# 实质\n\n骑士巡逻问题实际上是哈密顿路径问题的一种特殊形式，寻找骑士巡逻的闭巡逻路径的个数实际上也是哈密顿循环问题的一种特殊形式。但是和一般的哈密顿路径问题不同，骑士巡逻问题可以在线性时间内解决。\n\n哈密顿路径问题\n\n图论中的经典问题哈密顿路径问题（台湾作汉米顿路径问题）（Hamiltonian path problem）与哈密顿环问题（台湾作汉米顿环问题）（Hamiltonian cycle problem）分别是来确定在一个给定的图上是否存在哈密顿路径（一条经过图上每个顶点的路径）和哈密顿环（一条经过图上每个顶点的环）。两个问题皆为 NP 完全。\n\n参见：哈密顿路径问题 - Wikiwand\n\n\n# 解决方法\n\n借助计算机的帮助，人们已经发现了很多种寻找骑士巡逻路径的方法。其中一部分依靠算法，而另外一些则依靠启发法。\n\n * 穷举法：用穷举法来寻找骑士巡逻路径适用于格数较小的棋盘，因为当方格数过多时，可能的路径过多。例如，8×8 棋盘中大约有 4×10^51 种可能的路径。如此大的运算量已经超出了现代计算机的运算能力。\n * 分治法：利用分治法将棋盘分成很多小块，计算出每一小块中的所有可能路径，然后将这些小块合并再计算所有可能的路径。\n * 人工神经网络方法：骑士巡逻问题同样可以使用人工神经网络来解决。\n * Warnsdorff 规则：Warnsdorff 规则指在所有可走且未经过的方格中，马只可能走这样一个方格：从该方格出发，马能跳的方格数最少；如果可跳的方格数相等，则从当前位置看，方格序号小的优先。依照这一规则往往可以找到一条路径但是并不一定能够成功。\n\n\n# 实现\n\n\n# JavaScript\n\n// Wikipedia: https://en.wikipedia.org/wiki/Knight%27s_tour\n\nclass OpenKnightTour {\n  constructor (size) {\n    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))\n    this.size = size\n  }\n\n  getMoves ([i, j]) {\n    // helper function to get the valid moves of the knight from the current position\n    const moves = [\n      [i + 2, j - 1],\n      [i + 2, j + 1],\n      [i - 2, j - 1],\n      [i - 2, j + 1],\n      [i + 1, j - 2],\n      [i + 1, j + 2],\n      [i - 1, j - 2],\n      [i - 1, j + 2]\n    ]\n\n    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)\n  }\n\n  isComplete () {\n    // helper function to check if the board is complete\n    return !this.board.map(row => row.includes(0)).includes(true)\n  }\n\n  solve () {\n    // function to find the solution for the given board\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        if (this.solveHelper([i, j], 0)) return true\n      }\n    }\n    return false\n  }\n\n  solveHelper ([i, j], curr) {\n    // helper function for the main computation\n    if (this.isComplete()) return true\n\n    for (const [y, x] of this.getMoves([i, j])) {\n      if (this.board[y][x] === 0) {\n        this.board[y][x] = curr + 1\n        if (this.solveHelper([y, x], curr + 1)) return true\n        // backtracking\n        this.board[y][x] = 0\n      }\n    }\n    return false\n  }\n\n  printBoard (output = value => console.log(value)) {\n    // utility function to display the board\n    for (const row of this.board) {\n      let string = ''\n      for (const elem of row) {\n        string += elem + '\\t'\n      }\n      output(string)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 参考\n\n * Knight's tour - Wikiwand\n * 骑士巡逻 - Wikiwand",normalizedContent:"# 介绍\n\n骑士巡逻（英语：knight's tour）是指在按照国际象棋中骑士的规定走法走遍整个棋盘的每一个方格，而且每个网格只能够经过一次。假若骑士能够从走回到最初位置，则称此巡逻为 “封闭巡逻”，否则，称为 “开巡逻”。对于 8*8 棋盘，一共有 26,534,728,821,064 种封闭巡逻，有 19,591,828,170,979,904 种开巡逻。\n\n\n\n由骑士巡逻引申出了一个著名的数学问题 ：骑士巡逻问题 -- 找出所有的骑士巡逻路径。骑士巡逻问题的变种包括各种尺寸的棋盘甚至非正方形的棋盘。\n\ncull 和 conrad 证明了对于任何一个 m×n（5<=m<=n）棋盘，至少有一个（可能是开巡逻）骑士巡逻路径。\n\nschwenk 证明了，除了以下 3 种情况外，任何的 m×n（m<=n）棋盘都至少有 1 个闭巡逻。\n\n * m 和 n 都为奇数\n * m= 1, 2, 4\n * m= 3 且 n= 4, 6, 8\n\n\n# 实质\n\n骑士巡逻问题实际上是哈密顿路径问题的一种特殊形式，寻找骑士巡逻的闭巡逻路径的个数实际上也是哈密顿循环问题的一种特殊形式。但是和一般的哈密顿路径问题不同，骑士巡逻问题可以在线性时间内解决。\n\n哈密顿路径问题\n\n图论中的经典问题哈密顿路径问题（台湾作汉米顿路径问题）（hamiltonian path problem）与哈密顿环问题（台湾作汉米顿环问题）（hamiltonian cycle problem）分别是来确定在一个给定的图上是否存在哈密顿路径（一条经过图上每个顶点的路径）和哈密顿环（一条经过图上每个顶点的环）。两个问题皆为 np 完全。\n\n参见：哈密顿路径问题 - wikiwand\n\n\n# 解决方法\n\n借助计算机的帮助，人们已经发现了很多种寻找骑士巡逻路径的方法。其中一部分依靠算法，而另外一些则依靠启发法。\n\n * 穷举法：用穷举法来寻找骑士巡逻路径适用于格数较小的棋盘，因为当方格数过多时，可能的路径过多。例如，8×8 棋盘中大约有 4×10^51 种可能的路径。如此大的运算量已经超出了现代计算机的运算能力。\n * 分治法：利用分治法将棋盘分成很多小块，计算出每一小块中的所有可能路径，然后将这些小块合并再计算所有可能的路径。\n * 人工神经网络方法：骑士巡逻问题同样可以使用人工神经网络来解决。\n * warnsdorff 规则：warnsdorff 规则指在所有可走且未经过的方格中，马只可能走这样一个方格：从该方格出发，马能跳的方格数最少；如果可跳的方格数相等，则从当前位置看，方格序号小的优先。依照这一规则往往可以找到一条路径但是并不一定能够成功。\n\n\n# 实现\n\n\n# javascript\n\n// wikipedia: https://en.wikipedia.org/wiki/knight%27s_tour\n\nclass openknighttour {\n  constructor (size) {\n    this.board = new array(size).fill(0).map(() => new array(size).fill(0))\n    this.size = size\n  }\n\n  getmoves ([i, j]) {\n    // helper function to get the valid moves of the knight from the current position\n    const moves = [\n      [i + 2, j - 1],\n      [i + 2, j + 1],\n      [i - 2, j - 1],\n      [i - 2, j + 1],\n      [i + 1, j - 2],\n      [i + 1, j + 2],\n      [i - 1, j - 2],\n      [i - 1, j + 2]\n    ]\n\n    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)\n  }\n\n  iscomplete () {\n    // helper function to check if the board is complete\n    return !this.board.map(row => row.includes(0)).includes(true)\n  }\n\n  solve () {\n    // function to find the solution for the given board\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        if (this.solvehelper([i, j], 0)) return true\n      }\n    }\n    return false\n  }\n\n  solvehelper ([i, j], curr) {\n    // helper function for the main computation\n    if (this.iscomplete()) return true\n\n    for (const [y, x] of this.getmoves([i, j])) {\n      if (this.board[y][x] === 0) {\n        this.board[y][x] = curr + 1\n        if (this.solvehelper([y, x], curr + 1)) return true\n        // backtracking\n        this.board[y][x] = 0\n      }\n    }\n    return false\n  }\n\n  printboard (output = value => console.log(value)) {\n    // utility function to display the board\n    for (const row of this.board) {\n      let string = ''\n      for (const elem of row) {\n        string += elem + '\\t'\n      }\n      output(string)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 参考\n\n * knight's tour - wikiwand\n * 骑士巡逻 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"NQueens [N皇后问题]",frontmatter:{title:"NQueens [N皇后问题]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/nQueens/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/40.NQueen.html",relativePath:"20.算法/100.Backtracking 回溯/40.NQueen.md",key:"v-23d00e9f",path:"/algorithm/backtracking/nQueens/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:279},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:286},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2035}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的 n 皇后摆放问题：这时棋盘的大小变为 n×n，而皇后个数也变成 n。当且仅当 n = 1 或 n ≥ 4 时问题有解。\n\n\n\n八个皇后在 8x8 棋盘上共有 4,426,165,368（64C8）种摆放方法，但只有 92 个可行（皇后間互不攻擊）的解。如果将旋转和对称的解归为一种的话，则一共有 12 个独立解。\n\n\n# 实现\n\n\n# JavaScript\n\nclass NQueens {\n  constructor (size) {\n     if (size < 0) {\n      throw RangeError('Invalid board size')\n    }\n    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))\n    this.size = size\n    this.solutionCount = 0\n  }\n\n  isValid ([row, col]) {\n    // function to check if the placement of the queen in the given location is valid\n\n    // checking the left of the current row\n    for (let i = 0; i < col; i++) {\n      if (this.board[row][i] === 'Q') return false\n    }\n\n    // checking the upper left diagonal\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n      if (this.board[i][j] === 'Q') return false\n    }\n\n    // checking the lower left diagonal\n    for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {\n      if (this.board[i][j] === 'Q') return false\n    }\n\n    return true\n  }\n\n  placeQueen (row, col) {\n    this.board[row][col] = 'Q'\n  }\n\n  removeQueen (row, col) {\n    this.board[row][col] = '.'\n  }\n\n  solve (col = 0) {\n    if (col >= this.size) {\n      this.solutionCount++\n      return true\n    }\n\n    for (let i = 0; i < this.size; i++) {\n      if (this.isValid([i, col])) {\n        this.placeQueen(i, col)\n        this.solve(col + 1)\n        this.removeQueen(i, col)\n      }\n    }\n\n    return false\n  }\n\n  printBoard (output = value => console.log(value)) {\n    if (!output._isMockFunction) {\n      output('\\n')\n    }\n    for (const row of this.board) {\n      output(row)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n * 注意，无论 resolve 成功还是失败，都需要回溯，继续回溯是为了找出下一个正确的解。\n * isValid 只需要在左侧检查横向、斜向即可，因为右侧和竖向还没有放皇后不需要检测。\n\n\n# 参考\n\n * 八皇后问题 - Wikiwand",normalizedContent:"# 介绍\n\n八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的 n 皇后摆放问题：这时棋盘的大小变为 n×n，而皇后个数也变成 n。当且仅当 n = 1 或 n ≥ 4 时问题有解。\n\n\n\n八个皇后在 8x8 棋盘上共有 4,426,165,368（64c8）种摆放方法，但只有 92 个可行（皇后間互不攻擊）的解。如果将旋转和对称的解归为一种的话，则一共有 12 个独立解。\n\n\n# 实现\n\n\n# javascript\n\nclass nqueens {\n  constructor (size) {\n     if (size < 0) {\n      throw rangeerror('invalid board size')\n    }\n    this.board = new array(size).fill('.').map(() => new array(size).fill('.'))\n    this.size = size\n    this.solutioncount = 0\n  }\n\n  isvalid ([row, col]) {\n    // function to check if the placement of the queen in the given location is valid\n\n    // checking the left of the current row\n    for (let i = 0; i < col; i++) {\n      if (this.board[row][i] === 'q') return false\n    }\n\n    // checking the upper left diagonal\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n      if (this.board[i][j] === 'q') return false\n    }\n\n    // checking the lower left diagonal\n    for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {\n      if (this.board[i][j] === 'q') return false\n    }\n\n    return true\n  }\n\n  placequeen (row, col) {\n    this.board[row][col] = 'q'\n  }\n\n  removequeen (row, col) {\n    this.board[row][col] = '.'\n  }\n\n  solve (col = 0) {\n    if (col >= this.size) {\n      this.solutioncount++\n      return true\n    }\n\n    for (let i = 0; i < this.size; i++) {\n      if (this.isvalid([i, col])) {\n        this.placequeen(i, col)\n        this.solve(col + 1)\n        this.removequeen(i, col)\n      }\n    }\n\n    return false\n  }\n\n  printboard (output = value => console.log(value)) {\n    if (!output._ismockfunction) {\n      output('\\n')\n    }\n    for (const row of this.board) {\n      output(row)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n * 注意，无论 resolve 成功还是失败，都需要回溯，继续回溯是为了找出下一个正确的解。\n * isvalid 只需要在左侧检查横向、斜向即可，因为右侧和竖向还没有放皇后不需要检测。\n\n\n# 参考\n\n * 八皇后问题 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"RatInAMaze [迷宫之鼠]",frontmatter:{title:"RatInAMaze [迷宫之鼠]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/ratInAMaze/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/50.RatInAMaze.html",relativePath:"20.算法/100.Backtracking 回溯/50.RatInAMaze.md",key:"v-1214d082",path:"/algorithm/backtracking/ratInAMaze/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:409},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:416},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:4634},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6745}],headersStr:"介绍 实现 JavaScript 扩展 参考",content:"# 介绍\n\n一个迷宫是由 N*N 个区块组成的二进制矩阵，其中源区块是最左上方的区块，即 maze[0][0] ，目的地区块是最右下方的区块，即 maze[N-1][N-1] 。一只老鼠从源头开始，必须到达目的地。大鼠只能在两个方向移动：向前和向下。\n\n在迷宫矩阵中，0 表示该区块是一个死胡同，1 表示该区块可以用于从源头到目的地的路径中。请注意，这是典型迷宫问题的一个简单版本。例如，更复杂的版本可以是老鼠可以在 4 个方向移动，更复杂的版本可以是有限制的移动次数。\n\n回溯算法：回溯是一种算法技术，通过尝试逐步建立一个解决方案来递归地解决问题。一次解决一个问题，并删除那些在任何时间点上不能满足问题约束的解决方案（这里的时间是指到达搜索树的任何一级所花费的时间），这就是回溯的过程。\n\n方法：形成一个递归函数，它将遵循一个路径并检查该路径是否到达目的地。如果该路径没有到达目的地，则回溯并尝试其他路径。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Problem Statement:\n * - Given a NxN grid, find whether rat in cell [0, 0] can reach the target in cell [N-1, N-1]\n * - The grid is represented as an array of rows. Each row is represented as an array of 0 or 1 values.\n * - A cell with value 0 can not be moved through. Value 1 means the rat can move here.\n * - The rat can not move diagonally（对角地）.\n *\n * Reference for this problem: https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/\n *\n * Based on the original implementation contributed by Chiranjeev Thapliyal (https://github.com/chiranjeev-thapliyal).\n */\n\n/**\n * Checks if the given grid is valid.\n *\n * A grid needs to satisfy these conditions:\n * - must not be empty\n * - must be a square\n * - must not contain values other than {@code 0} and {@code 1}\n *\n * @param grid The grid to check.\n * @throws TypeError When the given grid is invalid.\n */\nfunction validateGrid (grid) {\n  if (!Array.isArray(grid) || grid.length === 0) throw new TypeError('Grid must be a non-empty array')\n\n  const allRowsHaveCorrectLength = grid.every(row => row.length === grid.length)\n  if (!allRowsHaveCorrectLength) throw new TypeError('Grid must be a square')\n\n  const allCellsHaveValidValues = grid.every(row => {\n    return row.every(cell => cell === 0 || cell === 1)\n  })\n  if (!allCellsHaveValidValues) throw new TypeError('Grid must only contain 0s and 1s')\n}\n\nfunction isSafe (grid, x, y) {\n  const n = grid.length\n  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1\n}\n\n/**\n * Attempts to calculate the remaining path to the target.\n *\n * @param grid The full grid.\n * @param x The current X coordinate.\n * @param y The current Y coordinate.\n * @param solution The current solution matrix.\n * @param path The path we took to get from the source cell to the current location.\n * @returns {string|boolean} Either the path to the target cell or false.\n */\nfunction getPathPart (grid, x, y, solution, path) {\n  const n = grid.length\n\n  // are we there yet?\n  if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {\n    solution[y][x] = 1\n    return path\n  }\n\n  // did we step on a 0 cell or outside the grid?\n  if (!isSafe(grid, x, y)) return false\n\n  // are we walking onto an already-marked solution coordinate?\n  if (solution[y][x] === 1) return false\n\n  // none of the above? let's dig deeper!\n\n  // mark the current coordinates on the solution matrix\n  solution[y][x] = 1\n\n  // attempt to move right\n  const right = getPathPart(grid, x + 1, y, solution, path + 'R')\n  if (right) return right\n\n  // right didn't work: attempt to move down\n  const down = getPathPart(grid, x, y + 1, solution, path + 'D')\n  if (down) return down\n\n  // down didn't work: attempt to move up\n  const up = getPathPart(grid, x, y - 1, solution, path + 'U')\n  if (up) return up\n\n  // up didn't work: attempt to move left\n  const left = getPathPart(grid, x - 1, y, solution, path + 'L')\n  if (left) return left\n\n  // no direction was successful: remove this cell from the solution matrix and backtrack\n  solution[y][x] = 0\n  return false\n}\n\nfunction getPath (grid) {\n  // grid dimensions\n  const n = grid.length\n\n  // prepare solution matrix\n  const solution = []\n  for (let i = 0; i < n; i++) {\n    const row = Array(n)\n    row.fill(0)\n    solution[i] = row\n  }\n\n  return getPathPart(grid, 0, 0, solution, '')\n}\n\n/**\n * Creates an instance of the \"rat in a maze\" based on a given grid (maze).\n */\nexport class RatInAMaze {\n  constructor (grid) {\n    // first, let's do some error checking on the input\n    validateGrid(grid)\n\n    // attempt to solve the maze now - all public methods only query the result state later\n    const solution = getPath(grid)\n\n    if (solution !== false) {\n      this.path = solution\n      this.solved = true\n    } else {\n      this.path = ''\n      this.solved = false\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n\n\n\n# 扩展\n\n给定一个有障碍物的迷宫，计算从最上面的最下面的单元格到达最右边的最下面的单元格的路径数量。在给定的迷宫中，如果一个单元格是障碍物或死胡同，其值为 - 1，否则为 0。\n\n从一个给定的单元格，我们只允许移动到单元格（i+1，j）和（i，j+1）。\n\nInput: maze[R][C] =  {{0,  0, 0, 0},\n                      {0, -1, 0, 0},\n                      {-1, 0, 0, 0},\n                      {0,  0, 0, 0}};\nOutput: 4\nThere are four possible paths.\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们的想法是修改给定的 grid[][] ，使 grid[i][j] 包含从 （0，0） 到达 （i，j） 的路径数，如果 （i，j） 不是障碍物，否则 grid[i][j] 仍然是 - 1。\n\n// JavaScript program to count number of paths in a maze with obstacles.\n// R C means maze[R][C]\nlet R = 4;\nlet C = 4;\n   \n// Returns count of possible paths in\n// a maze[R][C] from (0,0) to (R-1,C-1)\nfunction countPaths(maze){\n  // If the initial cell is blocked, there is no way of moving anywhere\n  if (maze[0][0] == -1) return 0;\n \n  // Initializing the leftmost column\n  for(let i = 0; i < R; i++) {\n    if (maze[i][0] == 0) maze[i][0] = 1;\n    // If we encounter a blocked cell in leftmost row, there is no way of visiting any cell directly below it.\n    else break;\n  }\n \n  // Similarly initialize the topmost row\n  for(let i = 1; i < C; i++) {\n    if (maze[0][i] == 0) maze[0][i] = 1;\n    // If we encounter a blocked cell in bottommost row, there is no way of visiting any cell directly below it.\n    else break;\n  }\n \n  // The only difference is that if a cell is -1, simply ignore it else recursively compute count value maze[i][j]\n  for(let i = 1; i < R; i++) {\n    for(let j = 1; j < C; j++) {\n      // If blockage is found, ignore this cell\n      if (maze[i][j] == -1) continue;\n      // If we can reach maze[i][j] from maze[i-1][j] then increment count.\n      if (maze[i - 1][j] > 0) maze[i][j] = (maze[i][j] + maze[i - 1][j]);\n      // If we can reach maze[i][j] from maze[i][j-1] then increment count.\n      if (maze[i][j - 1] > 0) maze[i][j] = (maze[i][j] + maze[i][j - 1]);\n    }\n  }\n \n  // If the final cell is blocked, output 0, otherwise the answer\n  return (maze[R - 1][C - 1] > 0) ? maze[R - 1][C - 1] : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n时间复杂度：O (R x C) 辅助空间：O (1)\n\n\n# 参考\n\n * Rat in a Maze | Backtracking-2 - GeeksforGeeks\n * Count number of ways to reach destination in a Maze - GeeksforGeeks",normalizedContent:"# 介绍\n\n一个迷宫是由 n*n 个区块组成的二进制矩阵，其中源区块是最左上方的区块，即 maze[0][0] ，目的地区块是最右下方的区块，即 maze[n-1][n-1] 。一只老鼠从源头开始，必须到达目的地。大鼠只能在两个方向移动：向前和向下。\n\n在迷宫矩阵中，0 表示该区块是一个死胡同，1 表示该区块可以用于从源头到目的地的路径中。请注意，这是典型迷宫问题的一个简单版本。例如，更复杂的版本可以是老鼠可以在 4 个方向移动，更复杂的版本可以是有限制的移动次数。\n\n回溯算法：回溯是一种算法技术，通过尝试逐步建立一个解决方案来递归地解决问题。一次解决一个问题，并删除那些在任何时间点上不能满足问题约束的解决方案（这里的时间是指到达搜索树的任何一级所花费的时间），这就是回溯的过程。\n\n方法：形成一个递归函数，它将遵循一个路径并检查该路径是否到达目的地。如果该路径没有到达目的地，则回溯并尝试其他路径。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * problem statement:\n * - given a nxn grid, find whether rat in cell [0, 0] can reach the target in cell [n-1, n-1]\n * - the grid is represented as an array of rows. each row is represented as an array of 0 or 1 values.\n * - a cell with value 0 can not be moved through. value 1 means the rat can move here.\n * - the rat can not move diagonally（对角地）.\n *\n * reference for this problem: https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/\n *\n * based on the original implementation contributed by chiranjeev thapliyal (https://github.com/chiranjeev-thapliyal).\n */\n\n/**\n * checks if the given grid is valid.\n *\n * a grid needs to satisfy these conditions:\n * - must not be empty\n * - must be a square\n * - must not contain values other than {@code 0} and {@code 1}\n *\n * @param grid the grid to check.\n * @throws typeerror when the given grid is invalid.\n */\nfunction validategrid (grid) {\n  if (!array.isarray(grid) || grid.length === 0) throw new typeerror('grid must be a non-empty array')\n\n  const allrowshavecorrectlength = grid.every(row => row.length === grid.length)\n  if (!allrowshavecorrectlength) throw new typeerror('grid must be a square')\n\n  const allcellshavevalidvalues = grid.every(row => {\n    return row.every(cell => cell === 0 || cell === 1)\n  })\n  if (!allcellshavevalidvalues) throw new typeerror('grid must only contain 0s and 1s')\n}\n\nfunction issafe (grid, x, y) {\n  const n = grid.length\n  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1\n}\n\n/**\n * attempts to calculate the remaining path to the target.\n *\n * @param grid the full grid.\n * @param x the current x coordinate.\n * @param y the current y coordinate.\n * @param solution the current solution matrix.\n * @param path the path we took to get from the source cell to the current location.\n * @returns {string|boolean} either the path to the target cell or false.\n */\nfunction getpathpart (grid, x, y, solution, path) {\n  const n = grid.length\n\n  // are we there yet?\n  if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {\n    solution[y][x] = 1\n    return path\n  }\n\n  // did we step on a 0 cell or outside the grid?\n  if (!issafe(grid, x, y)) return false\n\n  // are we walking onto an already-marked solution coordinate?\n  if (solution[y][x] === 1) return false\n\n  // none of the above? let's dig deeper!\n\n  // mark the current coordinates on the solution matrix\n  solution[y][x] = 1\n\n  // attempt to move right\n  const right = getpathpart(grid, x + 1, y, solution, path + 'r')\n  if (right) return right\n\n  // right didn't work: attempt to move down\n  const down = getpathpart(grid, x, y + 1, solution, path + 'd')\n  if (down) return down\n\n  // down didn't work: attempt to move up\n  const up = getpathpart(grid, x, y - 1, solution, path + 'u')\n  if (up) return up\n\n  // up didn't work: attempt to move left\n  const left = getpathpart(grid, x - 1, y, solution, path + 'l')\n  if (left) return left\n\n  // no direction was successful: remove this cell from the solution matrix and backtrack\n  solution[y][x] = 0\n  return false\n}\n\nfunction getpath (grid) {\n  // grid dimensions\n  const n = grid.length\n\n  // prepare solution matrix\n  const solution = []\n  for (let i = 0; i < n; i++) {\n    const row = array(n)\n    row.fill(0)\n    solution[i] = row\n  }\n\n  return getpathpart(grid, 0, 0, solution, '')\n}\n\n/**\n * creates an instance of the \"rat in a maze\" based on a given grid (maze).\n */\nexport class ratinamaze {\n  constructor (grid) {\n    // first, let's do some error checking on the input\n    validategrid(grid)\n\n    // attempt to solve the maze now - all public methods only query the result state later\n    const solution = getpath(grid)\n\n    if (solution !== false) {\n      this.path = solution\n      this.solved = true\n    } else {\n      this.path = ''\n      this.solved = false\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n\n\n\n# 扩展\n\n给定一个有障碍物的迷宫，计算从最上面的最下面的单元格到达最右边的最下面的单元格的路径数量。在给定的迷宫中，如果一个单元格是障碍物或死胡同，其值为 - 1，否则为 0。\n\n从一个给定的单元格，我们只允许移动到单元格（i+1，j）和（i，j+1）。\n\ninput: maze[r][c] =  {{0,  0, 0, 0},\n                      {0, -1, 0, 0},\n                      {-1, 0, 0, 0},\n                      {0,  0, 0, 0}};\noutput: 4\nthere are four possible paths.\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们的想法是修改给定的 grid[][] ，使 grid[i][j] 包含从 （0，0） 到达 （i，j） 的路径数，如果 （i，j） 不是障碍物，否则 grid[i][j] 仍然是 - 1。\n\n// javascript program to count number of paths in a maze with obstacles.\n// r c means maze[r][c]\nlet r = 4;\nlet c = 4;\n   \n// returns count of possible paths in\n// a maze[r][c] from (0,0) to (r-1,c-1)\nfunction countpaths(maze){\n  // if the initial cell is blocked, there is no way of moving anywhere\n  if (maze[0][0] == -1) return 0;\n \n  // initializing the leftmost column\n  for(let i = 0; i < r; i++) {\n    if (maze[i][0] == 0) maze[i][0] = 1;\n    // if we encounter a blocked cell in leftmost row, there is no way of visiting any cell directly below it.\n    else break;\n  }\n \n  // similarly initialize the topmost row\n  for(let i = 1; i < c; i++) {\n    if (maze[0][i] == 0) maze[0][i] = 1;\n    // if we encounter a blocked cell in bottommost row, there is no way of visiting any cell directly below it.\n    else break;\n  }\n \n  // the only difference is that if a cell is -1, simply ignore it else recursively compute count value maze[i][j]\n  for(let i = 1; i < r; i++) {\n    for(let j = 1; j < c; j++) {\n      // if blockage is found, ignore this cell\n      if (maze[i][j] == -1) continue;\n      // if we can reach maze[i][j] from maze[i-1][j] then increment count.\n      if (maze[i - 1][j] > 0) maze[i][j] = (maze[i][j] + maze[i - 1][j]);\n      // if we can reach maze[i][j] from maze[i][j-1] then increment count.\n      if (maze[i][j - 1] > 0) maze[i][j] = (maze[i][j] + maze[i][j - 1]);\n    }\n  }\n \n  // if the final cell is blocked, output 0, otherwise the answer\n  return (maze[r - 1][c - 1] > 0) ? maze[r - 1][c - 1] : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n时间复杂度：o (r x c) 辅助空间：o (1)\n\n\n# 参考\n\n * rat in a maze | backtracking-2 - geeksforgeeks\n * count number of ways to reach destination in a maze - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"Sudoku [数独]",frontmatter:{title:"Sudoku [数独]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/sudoku/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/60.Sudoku.html",relativePath:"20.算法/100.Backtracking 回溯/60.Sudoku.md",key:"v-e5a79402",path:"/algorithm/backtracking/sudoku/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"Backtracking",slug:"backtracking",normalizedTitle:"backtracking",charIndex:323},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:769},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:776},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:3089},{level:2,title:"Crook’s Algorithm",slug:"crook-s-algorithm",normalizedTitle:"crook’s algorithm",charIndex:5453},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5803}],headersStr:"介绍 Backtracking 实现 JavaScript 扩展 Crook’s Algorithm 参考",content:"# 介绍\n\n数独（日语：数独／すうどく Sūdoku */?）是一种数学逻辑游戏，游戏由 9×9 个格子组成，玩家需要根据格子提供的数字推理出其他格子的数字。游戏设计者会提供最少 17 个数字使得解答谜题只有一个答案。\n\n\n\n规则：\n\n * 游戏一般由 9 个 3×3 个的九宫格组成。\n * 每一列的数字均须包含 1～9，不能缺少，也不能重复。\n * 每一宫 (粗黑线围起来的区域，通常是 3*3 的九宫格) 的数字均须包含 1～9，不能缺少，也不能重复。\n\n有几种计算机算法可以在几分之一秒内解决 9×9 的谜题（n=9），但是随着 n 的增加会出现组合爆炸，从而对可以构建、分析和解决 n 增加的 Sudokus 的属性造成限制。\n\n\n# Backtracking\n\n一些业余爱好者开发了计算机程序，将使用回溯算法来解决数独谜题，这是一种蛮力搜索（brute force）。\n\n\n\n蛮力算法以某种顺序访问空单元格，按顺序填入数字，或者在发现数字无效时进行回溯。简而言之，一个程序会通过在第一个单元格放置数字 \"1\" 并检查是否允许它出现在那里来解决一个谜题。如果没有违反规定（检查行、列和框的约束），那么算法就会推进到下一个单元格，并在该单元格中放置一个 \"1\"。在检查违规情况时，如果发现 \"1\" 是不允许的，该值就会被推进到 \"2\"。如果发现一个单元格中的 9 位数字都不允许，那么该算法将该单元格留空，并移回前一个单元格。然后，该单元格中的值将被增加 1。如此反复，直到发现最后一个（第 81 个）单元格中的允许值。\n\n这种方法的优点是：\n\n * 保证有一个解决方案（只要谜题是有效的）。\n * 解题时间大多与难度无关。\n * 该算法（也就是程序代码）比其他算法更简单，尤其是与确保最难的谜题得到解决的复杂算法相比。\n\n\n# 实现\n\n\n# JavaScript\n\nclass Sudoku {\n  // Sudoku Class to hold the board and related functions\n  constructor (board) {\n    this.board = board\n  }\n\n  findEmptyCell () {\n    // Find a empty cell in the board (returns [-1, -1] if all cells are filled)\n    for (let i = 0; i < 9; i++) {\n      for (let j = 0; j < 9; j++) {\n        if (this.board[i][j] === 0) return [i, j]\n      }\n    }\n    return [-1, -1]\n  }\n\n  check ([y, x], value) {\n    // checks if the value to be added in the board is an acceptable value for the cell\n\n    // checking through the row\n    for (let i = 0; i < 9; i++) {\n      if (this.board[i][x] === value) return false\n    }\n    // checking through the column\n    for (let i = 0; i < 9; i++) {\n      if (this.board[y][i] === value) return false\n    }\n\n    // checking through the 3x3 block of the cell\n    const secRow = Math.floor(y / 3)\n    const secCol = Math.floor(x / 3)\n    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {\n      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {\n        if (y !== i && x !== j && this.board[i][j] === value) return false\n      }\n    }\n\n    return true\n  }\n\n  solve () {\n    const [y, x] = this.findEmptyCell()\n\n    // checking if the board is complete\n    if (y === -1 && x === -1) return true\n\n    for (let val = 1; val < 10; val++) {\n      if (this.check([y, x], val)) {\n        this.board[y][x] = val\n        if (this.solve()) return true\n        // backtracking if the board cannot be solved using current configuration\n        this.board[y][x] = 0\n      }\n    }\n    // returning false the board cannot be solved using current configuration\n    return false\n  }\n\n  getSection (row, [start, end]) {\n    return this.board[row].slice(start, end)\n  }\n\n  printBoard (output = (...v) => console.log(...v)) {\n    // helper function to display board\n    for (let i = 0; i < 9; i++) {\n      if (i % 3 === 0 && i !== 0) {\n        output('- - - - - - - - - - - -')\n      }\n      output(\n        ...this.getSection(i, [0, 3]), ' | ',\n        ...this.getSection(i, [3, 6]), ' | ',\n        ...this.getSection(i, [6, 9]))\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 扩展\n\n使用 Bit Masks 解决 Sudoku 问题：\n\n对于每一行 / 每一列 / 每一个 Box 都创建一个 Bit Mask，对于网格中的每一个元素，在相应的 Bit Mask 中把位置 ' 值' 的比特设置为 1，进行 O（1）检查。\n\n按照下面的步骤来解决问题：\n\n * 创建 3 个大小为 N 的数组（行、列、盒各一个）。\n * 盒子的索引从 0 到 8。（为了找到一个元素的盒子索引，我们使用以下公式：行 / 3*3 + 列 / 3）。\n * 首先映射网格的初始值。\n * 每次我们向 / 从网格中添加 / 删除一个元素时，都要把相应的位掩码设置为 1/0。\n\nconst N = 9\n \n// Bitmasks for each row/column/box\nlet row = new Array(N), col = new Array(N), box = new Array(N);\nlet seted = false;\n \n// Utility function to find the box index\n// of an element at position [i][j] in the grid\nfunction getBox(i,j) {\n  return Math.floor(i / 3) * 3 + Math.floor(j / 3);\n}\n \n// Utility function to check if a number\n// is present in the corresponding row/column/box\nfunction isSafe(i,j,number) {\n  return !((row[i] >> number) & 1) && !((col[j] >> number) & 1) && !((box[getBox(i,j)] >> number) & 1);\n}\n \n// Utility function to set the initial values of a Sudoku board\n// (map the values in the bitmasks)\nfunction setInitialValues(grid) {\n  for (let i = 0; i < N;i++)\n      for (let j = 0; j < N; j++)\n          row[i] |= 1 << grid[i][j],\n          col[j] |= 1 << grid[i][j],\n          box[getBox(i, j)] |= 1 << grid[i][j];\n}\n \n/* Takes a partially filled-in grid and attempts to assign values to all unassigned locations in\nsuch a way to meet the requirements for Sudoku solution (non-duplication across rows, columns, and boxes) */\nfunction SolveSudoku(grid ,i, j) {\n  // Set the initial values\n  if(!seted){\n      seted = true,\n      setInitialValues(grid);\n  }\n\n  if(i == N - 1 && j == N) return true;\n  if(j == N){\n      j = 0;\n      i++;\n  }\n\n  if(grid[i][j]) return SolveSudoku(grid, i, j + 1);\n\n  for (let nr = 1; nr <= N;nr++) {\n      if(isSafe(i, j, nr)) {\n        /* Assign nr in the current (i, j) position and add nr to each bitmask */\n        grid[i][j] = nr;\n        row[i] |= 1 << nr;\n        col[j] |= 1 << nr;\n        box[getBox(i, j)] |= 1 << nr;\n\n        if(SolveSudoku(grid, i,j + 1)) return true;\n\n        // Remove nr from each bitmask and search for another possibility\n        row[i] &= ~(1 << nr);\n        col[j] &= ~(1 << nr);\n        box[getBox(i, j)] &= ~(1 << nr);\n      }\n\n      grid[i][j] = 0;\n  }\n\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# Crook’s Algorithm\n\n温斯洛普大学计算机科学教授詹姆斯 - 克鲁克发表了一篇名为《解决数独谜题的纸笔算法》的论文。在论文中，Crook 提到，如果没有进一步的可能步骤，猜测是必要的。这种猜测并没有加入到如下算法中。因此，当你使用这个算法来解决数独问题时，有可能无法得到答案。\n\n步骤：\n\n * Markup：列出每个单元格中所有可能的数字。\n * Find singleton：找到如果有一个行、列或框，里只有一个可能的值，成为 singleton。所以你在这个单元格里填上这个数字，然后在受影响的行、列或框里更新标记。\n * Find Preemptive Sets：\n * Eliminate possible numbers outside preemptive sets。\n\n参考：\n\n * Solve Sudoku more elegantly with Crook’s algorithm in Python | by WY Fok | Towards Data Science\n * wyfok/Solve_Sudoku_with_Crook_algorithm: Apply Sudoku rules and Crook's algorithm to solve Sudoku\n * Mathematics and Sudokus: Solving Algorithms (II)\n * www.ams.org/notices/200904/rtx090400460p.pdf\n\n\n# 参考\n\n * Sudoku - Wikiwand\n * Sudoku solving algorithms - Wikiwand\n * Sudoku | Backtracking-7 - GeeksforGeeks",normalizedContent:"# 介绍\n\n数独（日语：数独／すうどく sudoku */?）是一种数学逻辑游戏，游戏由 9×9 个格子组成，玩家需要根据格子提供的数字推理出其他格子的数字。游戏设计者会提供最少 17 个数字使得解答谜题只有一个答案。\n\n\n\n规则：\n\n * 游戏一般由 9 个 3×3 个的九宫格组成。\n * 每一列的数字均须包含 1～9，不能缺少，也不能重复。\n * 每一宫 (粗黑线围起来的区域，通常是 3*3 的九宫格) 的数字均须包含 1～9，不能缺少，也不能重复。\n\n有几种计算机算法可以在几分之一秒内解决 9×9 的谜题（n=9），但是随着 n 的增加会出现组合爆炸，从而对可以构建、分析和解决 n 增加的 sudokus 的属性造成限制。\n\n\n# backtracking\n\n一些业余爱好者开发了计算机程序，将使用回溯算法来解决数独谜题，这是一种蛮力搜索（brute force）。\n\n\n\n蛮力算法以某种顺序访问空单元格，按顺序填入数字，或者在发现数字无效时进行回溯。简而言之，一个程序会通过在第一个单元格放置数字 \"1\" 并检查是否允许它出现在那里来解决一个谜题。如果没有违反规定（检查行、列和框的约束），那么算法就会推进到下一个单元格，并在该单元格中放置一个 \"1\"。在检查违规情况时，如果发现 \"1\" 是不允许的，该值就会被推进到 \"2\"。如果发现一个单元格中的 9 位数字都不允许，那么该算法将该单元格留空，并移回前一个单元格。然后，该单元格中的值将被增加 1。如此反复，直到发现最后一个（第 81 个）单元格中的允许值。\n\n这种方法的优点是：\n\n * 保证有一个解决方案（只要谜题是有效的）。\n * 解题时间大多与难度无关。\n * 该算法（也就是程序代码）比其他算法更简单，尤其是与确保最难的谜题得到解决的复杂算法相比。\n\n\n# 实现\n\n\n# javascript\n\nclass sudoku {\n  // sudoku class to hold the board and related functions\n  constructor (board) {\n    this.board = board\n  }\n\n  findemptycell () {\n    // find a empty cell in the board (returns [-1, -1] if all cells are filled)\n    for (let i = 0; i < 9; i++) {\n      for (let j = 0; j < 9; j++) {\n        if (this.board[i][j] === 0) return [i, j]\n      }\n    }\n    return [-1, -1]\n  }\n\n  check ([y, x], value) {\n    // checks if the value to be added in the board is an acceptable value for the cell\n\n    // checking through the row\n    for (let i = 0; i < 9; i++) {\n      if (this.board[i][x] === value) return false\n    }\n    // checking through the column\n    for (let i = 0; i < 9; i++) {\n      if (this.board[y][i] === value) return false\n    }\n\n    // checking through the 3x3 block of the cell\n    const secrow = math.floor(y / 3)\n    const seccol = math.floor(x / 3)\n    for (let i = (secrow * 3); i < ((secrow * 3) + 3); i++) {\n      for (let j = (seccol * 3); j < ((seccol * 3) + 3); j++) {\n        if (y !== i && x !== j && this.board[i][j] === value) return false\n      }\n    }\n\n    return true\n  }\n\n  solve () {\n    const [y, x] = this.findemptycell()\n\n    // checking if the board is complete\n    if (y === -1 && x === -1) return true\n\n    for (let val = 1; val < 10; val++) {\n      if (this.check([y, x], val)) {\n        this.board[y][x] = val\n        if (this.solve()) return true\n        // backtracking if the board cannot be solved using current configuration\n        this.board[y][x] = 0\n      }\n    }\n    // returning false the board cannot be solved using current configuration\n    return false\n  }\n\n  getsection (row, [start, end]) {\n    return this.board[row].slice(start, end)\n  }\n\n  printboard (output = (...v) => console.log(...v)) {\n    // helper function to display board\n    for (let i = 0; i < 9; i++) {\n      if (i % 3 === 0 && i !== 0) {\n        output('- - - - - - - - - - - -')\n      }\n      output(\n        ...this.getsection(i, [0, 3]), ' | ',\n        ...this.getsection(i, [3, 6]), ' | ',\n        ...this.getsection(i, [6, 9]))\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 扩展\n\n使用 bit masks 解决 sudoku 问题：\n\n对于每一行 / 每一列 / 每一个 box 都创建一个 bit mask，对于网格中的每一个元素，在相应的 bit mask 中把位置 ' 值' 的比特设置为 1，进行 o（1）检查。\n\n按照下面的步骤来解决问题：\n\n * 创建 3 个大小为 n 的数组（行、列、盒各一个）。\n * 盒子的索引从 0 到 8。（为了找到一个元素的盒子索引，我们使用以下公式：行 / 3*3 + 列 / 3）。\n * 首先映射网格的初始值。\n * 每次我们向 / 从网格中添加 / 删除一个元素时，都要把相应的位掩码设置为 1/0。\n\nconst n = 9\n \n// bitmasks for each row/column/box\nlet row = new array(n), col = new array(n), box = new array(n);\nlet seted = false;\n \n// utility function to find the box index\n// of an element at position [i][j] in the grid\nfunction getbox(i,j) {\n  return math.floor(i / 3) * 3 + math.floor(j / 3);\n}\n \n// utility function to check if a number\n// is present in the corresponding row/column/box\nfunction issafe(i,j,number) {\n  return !((row[i] >> number) & 1) && !((col[j] >> number) & 1) && !((box[getbox(i,j)] >> number) & 1);\n}\n \n// utility function to set the initial values of a sudoku board\n// (map the values in the bitmasks)\nfunction setinitialvalues(grid) {\n  for (let i = 0; i < n;i++)\n      for (let j = 0; j < n; j++)\n          row[i] |= 1 << grid[i][j],\n          col[j] |= 1 << grid[i][j],\n          box[getbox(i, j)] |= 1 << grid[i][j];\n}\n \n/* takes a partially filled-in grid and attempts to assign values to all unassigned locations in\nsuch a way to meet the requirements for sudoku solution (non-duplication across rows, columns, and boxes) */\nfunction solvesudoku(grid ,i, j) {\n  // set the initial values\n  if(!seted){\n      seted = true,\n      setinitialvalues(grid);\n  }\n\n  if(i == n - 1 && j == n) return true;\n  if(j == n){\n      j = 0;\n      i++;\n  }\n\n  if(grid[i][j]) return solvesudoku(grid, i, j + 1);\n\n  for (let nr = 1; nr <= n;nr++) {\n      if(issafe(i, j, nr)) {\n        /* assign nr in the current (i, j) position and add nr to each bitmask */\n        grid[i][j] = nr;\n        row[i] |= 1 << nr;\n        col[j] |= 1 << nr;\n        box[getbox(i, j)] |= 1 << nr;\n\n        if(solvesudoku(grid, i,j + 1)) return true;\n\n        // remove nr from each bitmask and search for another possibility\n        row[i] &= ~(1 << nr);\n        col[j] &= ~(1 << nr);\n        box[getbox(i, j)] &= ~(1 << nr);\n      }\n\n      grid[i][j] = 0;\n  }\n\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# crook’s algorithm\n\n温斯洛普大学计算机科学教授詹姆斯 - 克鲁克发表了一篇名为《解决数独谜题的纸笔算法》的论文。在论文中，crook 提到，如果没有进一步的可能步骤，猜测是必要的。这种猜测并没有加入到如下算法中。因此，当你使用这个算法来解决数独问题时，有可能无法得到答案。\n\n步骤：\n\n * markup：列出每个单元格中所有可能的数字。\n * find singleton：找到如果有一个行、列或框，里只有一个可能的值，成为 singleton。所以你在这个单元格里填上这个数字，然后在受影响的行、列或框里更新标记。\n * find preemptive sets：\n * eliminate possible numbers outside preemptive sets。\n\n参考：\n\n * solve sudoku more elegantly with crook’s algorithm in python | by wy fok | towards data science\n * wyfok/solve_sudoku_with_crook_algorithm: apply sudoku rules and crook's algorithm to solve sudoku\n * mathematics and sudokus: solving algorithms (ii)\n * www.ams.org/notices/200904/rtx090400460p.pdf\n\n\n# 参考\n\n * sudoku - wikiwand\n * sudoku solving algorithms - wikiwand\n * sudoku | backtracking-7 - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"SumOfSubset [子集之和]",frontmatter:{title:"SumOfSubset [子集之和]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/backtracking/sumOfSubset/",categories:["算法","Backtracking 回溯"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/100.Backtracking%20%E5%9B%9E%E6%BA%AF/70.SumOfSubset.html",relativePath:"20.算法/100.Backtracking 回溯/70.SumOfSubset.md",key:"v-322335c9",path:"/algorithm/backtracking/sumOfSubset/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:969},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:976},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3284}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n子集之和问题是指从一个给定的集合中找到元素的子集，这些元素的总和等于一个给定的数字 K，我们考虑的是这个集合只包含非负值。假设输入的集合是唯一的（没有重复的）。\n\n子集之和的穷举式搜索算法：\n\n寻找和为 K 的子集的一种方法是考虑所有可能的子集。一个幂集包含了从一个给定的集合产生的所有子集。这样一个幂集的大小是 2N。集合的幂集（英语：power set），定义为由该集合全部子集为元素构成的集合。\n\n子集之和的回溯算法：\n\n使用穷举搜索，我们考虑所有的子集，不管它们是否满足给定的约束。回溯算法（Backtracking）可以用来对要选择的元素进行系统的考虑。 假设给定的 4 个元素的集合，例如 w[1]...w[4] 。树可以用来设计回溯算法。下面的树描述了生成可变大小元组（tuple）的方法。\n\n\n\n当我们沿着树的深度往下走时，我们会添加到目前为止的元素，如果添加的总和满足明确的约束，我们将继续进一步生成子节点。只要不满足约束条件，我们就停止进一步生成该节点的子树，并回溯到前一个节点，探索尚未探索的节点。在许多情况下，它可以节省大量的处理时间。\n\n伪代码：\n\nif(subset is satisfying the constraint)\n    print the subset\n    exclude the current element and consider next element\nelse\n    generate the nodes of present level along breadth of tree and\n    recur for next levels\n\n\n1\n2\n3\n4\n5\n6\n\n\n当我们结合显性和隐性约束（constraints）时，回溯的力量就出现了，当这些检查失败时，我们就停止生成节点。我们可以通过加强约束检查和对数据进行预排序（presorting）来改进上述算法。通过对初始数组进行排序，一旦到目前为止的总和大于目标数，我们就不需要考虑数组的其他部分（如果子树不满足约束条件，它就会修剪子树）。我们可以回溯并检查其他的可能性。\n\n同样地，假设数组被预排序，我们找到了一个子集。只有当下一个节点满足约束条件时，我们才能生成排除当前节点的下一个节点。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n *\n *  Sum of Subset problem\n *\n *  Given an ordered set W of non-negative integers and a value K,\n *  determine all possible subsets from the given set W whose sum\n *  of its elements equals to the given value K.\n *\n *  More info: https://www.geeksforgeeks.org/subset-sum-backtracking-4/\n */\n\n/*\n * @param {number[]} set Original set of numbers\n * @param {number[]} subset Subset being evaluated\n * @param {number} setIndex Index from set of last element in subset\n * @param {number} Sum of elements from subset\n * @param {targetSum} The target sum on which the subset sum is compared to\n * @returns {number[][]} Subsets whose elements add up to targetSum\n */\nconst sumOfSubset = (set, subset, setindex, sum, targetSum) => {\n  // Base case where the subset sum is equal to target sum\n  // Evaluation of following subsets on this path will always add up to\n  // greater than targetSum, so no need to continue\n  if (sum === targetSum) return [subset]\n\n  // This and following subsets on this path will always add up to\n  // greater than targetSum, so no need to continue\n  if (sum > targetSum) return []\n\n  // Initialize results array. Will contain only valid subsets\n  let results = []\n\n  // Slice gets from the set all the elements at the right of the last element\n  // to be evaluated (last element of subset)\n  // forEach iterated on the resulting array\n  set.slice(setindex).forEach((num, index) => {\n    // The next subset to be evaluated, current subset plus next element\n    const nextSubset = [...subset, num]\n\n    // Next index from the set. Current set index plus iteration index\n    // index starts at 0, so a + 1 is required\n    const nextSetIndex = setindex + index + 1\n\n    // Sum of elements from the next subset to be evaluated\n    const nextSum = sum + num\n\n    // Call recursively the sumOfSubset for the nextSubset\n    const subsetResult = sumOfSubset(\n      set,\n      nextSubset,\n      nextSetIndex,\n      nextSum,\n      targetSum\n    )\n\n    // Concat the recursive result with current result array\n    results = [...results, ...subsetResult]\n  })\n\n  // Return results\n  return results\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 参考\n\n * Subset Sum | Backtracking-4 - GeeksforGeeks",normalizedContent:"# 介绍\n\n子集之和问题是指从一个给定的集合中找到元素的子集，这些元素的总和等于一个给定的数字 k，我们考虑的是这个集合只包含非负值。假设输入的集合是唯一的（没有重复的）。\n\n子集之和的穷举式搜索算法：\n\n寻找和为 k 的子集的一种方法是考虑所有可能的子集。一个幂集包含了从一个给定的集合产生的所有子集。这样一个幂集的大小是 2n。集合的幂集（英语：power set），定义为由该集合全部子集为元素构成的集合。\n\n子集之和的回溯算法：\n\n使用穷举搜索，我们考虑所有的子集，不管它们是否满足给定的约束。回溯算法（backtracking）可以用来对要选择的元素进行系统的考虑。 假设给定的 4 个元素的集合，例如 w[1]...w[4] 。树可以用来设计回溯算法。下面的树描述了生成可变大小元组（tuple）的方法。\n\n\n\n当我们沿着树的深度往下走时，我们会添加到目前为止的元素，如果添加的总和满足明确的约束，我们将继续进一步生成子节点。只要不满足约束条件，我们就停止进一步生成该节点的子树，并回溯到前一个节点，探索尚未探索的节点。在许多情况下，它可以节省大量的处理时间。\n\n伪代码：\n\nif(subset is satisfying the constraint)\n    print the subset\n    exclude the current element and consider next element\nelse\n    generate the nodes of present level along breadth of tree and\n    recur for next levels\n\n\n1\n2\n3\n4\n5\n6\n\n\n当我们结合显性和隐性约束（constraints）时，回溯的力量就出现了，当这些检查失败时，我们就停止生成节点。我们可以通过加强约束检查和对数据进行预排序（presorting）来改进上述算法。通过对初始数组进行排序，一旦到目前为止的总和大于目标数，我们就不需要考虑数组的其他部分（如果子树不满足约束条件，它就会修剪子树）。我们可以回溯并检查其他的可能性。\n\n同样地，假设数组被预排序，我们找到了一个子集。只有当下一个节点满足约束条件时，我们才能生成排除当前节点的下一个节点。\n\n\n# 实现\n\n\n# javascript\n\n/*\n *\n *  sum of subset problem\n *\n *  given an ordered set w of non-negative integers and a value k,\n *  determine all possible subsets from the given set w whose sum\n *  of its elements equals to the given value k.\n *\n *  more info: https://www.geeksforgeeks.org/subset-sum-backtracking-4/\n */\n\n/*\n * @param {number[]} set original set of numbers\n * @param {number[]} subset subset being evaluated\n * @param {number} setindex index from set of last element in subset\n * @param {number} sum of elements from subset\n * @param {targetsum} the target sum on which the subset sum is compared to\n * @returns {number[][]} subsets whose elements add up to targetsum\n */\nconst sumofsubset = (set, subset, setindex, sum, targetsum) => {\n  // base case where the subset sum is equal to target sum\n  // evaluation of following subsets on this path will always add up to\n  // greater than targetsum, so no need to continue\n  if (sum === targetsum) return [subset]\n\n  // this and following subsets on this path will always add up to\n  // greater than targetsum, so no need to continue\n  if (sum > targetsum) return []\n\n  // initialize results array. will contain only valid subsets\n  let results = []\n\n  // slice gets from the set all the elements at the right of the last element\n  // to be evaluated (last element of subset)\n  // foreach iterated on the resulting array\n  set.slice(setindex).foreach((num, index) => {\n    // the next subset to be evaluated, current subset plus next element\n    const nextsubset = [...subset, num]\n\n    // next index from the set. current set index plus iteration index\n    // index starts at 0, so a + 1 is required\n    const nextsetindex = setindex + index + 1\n\n    // sum of elements from the next subset to be evaluated\n    const nextsum = sum + num\n\n    // call recursively the sumofsubset for the nextsubset\n    const subsetresult = sumofsubset(\n      set,\n      nextsubset,\n      nextsetindex,\n      nextsum,\n      targetsum\n    )\n\n    // concat the recursive result with current result array\n    results = [...results, ...subsetresult]\n  })\n\n  // return results\n  return results\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 参考\n\n * subset sum | backtracking-4 - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"ClimbingStairs [爬楼梯]",frontmatter:{title:"ClimbingStairs [爬楼梯]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/climbingStairs/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/10.ClimbingStairs.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/10.ClimbingStairs.md",key:"v-2b567a55",path:"/algorithm/dp/climbingStairs/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"方案",slug:"方案",normalizedTitle:"方案",charIndex:74},{level:3,title:"递归法",slug:"递归法",normalizedTitle:"递归法",charIndex:81},{level:3,title:"问题的一般化",slug:"问题的一般化",normalizedTitle:"问题的一般化",charIndex:678},{level:3,title:"缓存法",slug:"缓存法",normalizedTitle:"缓存法",charIndex:1194},{level:3,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:1750},{level:3,title:"优化空间的动态规划",slug:"优化空间的动态规划",normalizedTitle:"优化空间的动态规划",charIndex:2351},{level:3,title:"滑窗法",slug:"滑窗法",normalizedTitle:"滑窗法",charIndex:3468},{level:3,title:"数学公式法",slug:"数学公式法",normalizedTitle:"数学公式法",charIndex:4031},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4430}],headersStr:"介绍 方案 递归法 问题的一般化 缓存法 动态规划 优化空间的动态规划 滑窗法 数学公式法 参考",content:"# 介绍\n\n有 n 个楼梯，一个站在底部的人想到达顶部。这个人可以一次爬 1 个楼梯或 2 个楼梯。数一数这个人有多少种方法可以到达顶层。\n\n\n# 方案\n\n\n# 递归法\n\n这种方法的表达式为：\n\nways(n) = ways(n-1) + ways(n-2)\n\n\n1\n\n\n上述表达式实际上是斐波那契数（Fibonacci numbers）的表达式，但有一点需要注意，way (n) 的值等于 fibonacci(n+1) 。\n\nways(1) = fib(2) = 1\nways(2) = fib(3) = 2\nways(3) = fib(4) = 3\n\n\n1\n2\n3\n\n\n实现：\n\n// A simple recursive function to find n'th fibonacci number\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n \n// Returns number of ways to reach s'th stair\nfunction countWays(s) {\n  return fib(s + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n复杂度：\n\n * 时间复杂度： O(2^n) 。由于冗余计算，上述实现的时间复杂度是指数级的（黄金分割率（golden ratio）提高到 n 次方）。使用斐波那契函数优化，它可以在 O（logn）时间内工作。\n * 空间复杂度： O(1) 。\n\n\n# 问题的一般化\n\n例如，如果 m 是 4，这个人每次可以爬 1 个楼梯或 2 个楼梯或 3 个楼梯或 4 个楼梯，如何计算这个人可以爬到 m 个楼梯的方式。\n\n对于上述方法的一般化，可以使用以下递归关系： ways(n, m) = ways(n-1, m) + ways(n-2, m) + ... ways(n-m, m) 。\n\n实现：\n\n// A recursive function used by countWays\nfunction countWaysUtil(n, m) {\n  if (n <= 1) return n;\n  let res = 0;\n  for (let i = 1; i <= m && i <= n; i++) res += countWaysUtil(n - i, m);\n  return res;\n}\n \n// Returns number of ways to reach s'th stair\nfunction countWays(s, m) {\n  return countWaysUtil(s + 1, m);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 缓存法\n\n我们也可以使用 dp 的自下而上的方法来解决这个问题，为此，我们可以创建一个数组 dp []，并将其初始化为 - 1。每当我们看到一个子问题没有得到解决，我们就可以调用递归方法。否则，如果子问题已经解决了，我们就停止递归。\n\n实现：\n\n// A simple recursive program to find N'th fibonacci number\nfunction fib(n, dp) {\n  if (n <= 1) return dp[n] = 1;\n  if(dp[n] != -1 ) { return dp[n]; }\n  dp[n] = fib(n - 1, dp) + fib(n - 2, dp);\n  return dp[n] ;\n}\n \n// Returns number of ways to reach s'th stair\nfunction countWays(n) {\n  let dp = new Array(n+1).fill(-1) ;\n  fib(n, dp);\n  return dp[n] ;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n复杂度分析：\n\n * 时间复杂度：O (n)\n * 辅助空间：O (n)\n\n\n# 动态规划\n\n我们用以下关系自下而上地创建一个表 res []， res[i] = res[i] + res[i-j] for every (i-j) >= 0 。这样，数组的第 i 个索引将包含考虑到所有攀登的可能性（即从 1 到 i），到达第 i 个步骤所需的方法数。\n\n实现：\n\n \n// A recursive function used by countWays\nfunction countWaysUtil(n, m) {\n  let res = [];\n  res[0] = 1;\n  res[1] = 1;\n  for (let i = 2; i < n; i++) {\n    res[i] = 0;\n    for (let j = 1; j <= m && j <= i; j++) res[i] += res[i - j];\n  }\n  return res[n - 1];\n}\n \n// Returns number of ways to reach s'th stair\nfunction countWays(s, m) {\n  return countWaysUtil(s + 1, m);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n复杂度分析：\n\n * 时间复杂度： O(m*n)\n * 辅助空间： O(n)\n\n\n# 优化空间的动态规划\n\n在这种方法中，我们可以通过不使用任何额外的空间来优化 DP 方法。首先，我们可以创建两个变量 prev 和 prev2 来存储爬一个楼梯或两个楼梯的方法数量。然后，我们可以运行一个 for 循环来计算到达顶部的方法总数。下面是上述想法的代码实现：\n\nint countWays(int n) {\n  // declaring  two variables to store the count\n  int prev = 1;\n  int prev2 = 1;\n  // Running for loop to count all possible ways\n  for (int i = 2; i <= n; i++) {\n    int curr = prev + prev2;\n    prev2 = prev;\n    prev = curr;\n  }\n  return prev;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nJavaScript：\n\n/**\n * @function ClimbStairs\n * @description You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n * @param {Integer} n - The input integer\n * @return {Integer} distinct ways can you climb to the top.\n * @see [Climb_Stairs](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)\n */\n\nconst climbStairs = (n) => {\n  let prev = 0\n  let cur = 1\n  let temp\n\n  for (let i = 0; i < n; i++) {\n    temp = prev\n    prev = cur\n    cur += temp\n  }\n  return cur\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n复杂度分析：\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n\n# 滑窗法\n\n这种方法有效地实现了上述 DP 方法。在这个方法中，对于第 1 个楼梯，我们保持一个窗口，即最后 m 个可能的楼梯的总和，我们可以从中爬到第 1 个楼梯。我们不运行内循环，而是将内循环的结果保存在一个临时变量中。我们删除前一个窗口的元素，加入当前窗口的元素并更新总和。\n\n实现：\n\n// Returns number of ways\n// to reach s'th stair\nfunction countWays(n , m) {\n  const res = Array(n + 1).fill(0);\n  let temp = 0;\n  res[0] = 1;\n\n  for (i = 1; i <= n; i++) {\n    const s = i - m - 1;\n    const e = i - 1;\n    if (s >= 0) {\n      temp -= res[s];\n    }\n    temp += res[e];\n    res[i] = temp;\n  }\n  return res[n];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n复杂度分析：\n\n * 时间复杂度：O (n)\n * 辅助空间：O (n)\n\n\n# 数学公式法\n\n这只适用于这个问题，如果（计算步骤中顺序并不重要）。在这种方法中，我们只需计算有 2 的集合的数量。顺序不重要是指对于 n = 4， {1 2 1}，{2 1 1}。 ,{2 1 1} ，{1 1 2} 被认为是相同的。\n\n// Here n/2 is done to count the number 2's in n\n// 1 is added for case where there is no 2.\n// eg: if n=4 ans will be 3.\n// {1,1,1,1} set having no 2.\n// {1,1,2} ans {2,2} (n/2) sets containing 2.\nparseInt(1 + (n / 2)); \n\n\n1\n2\n3\n4\n5\n6\n\n\n复杂度分析：\n\n * 时间复杂度：O (1)\n * 空间复杂度：O (1)\n\n\n# 参考\n\n * Count ways to reach the n'th stair - GeeksforGeeks",normalizedContent:"# 介绍\n\n有 n 个楼梯，一个站在底部的人想到达顶部。这个人可以一次爬 1 个楼梯或 2 个楼梯。数一数这个人有多少种方法可以到达顶层。\n\n\n# 方案\n\n\n# 递归法\n\n这种方法的表达式为：\n\nways(n) = ways(n-1) + ways(n-2)\n\n\n1\n\n\n上述表达式实际上是斐波那契数（fibonacci numbers）的表达式，但有一点需要注意，way (n) 的值等于 fibonacci(n+1) 。\n\nways(1) = fib(2) = 1\nways(2) = fib(3) = 2\nways(3) = fib(4) = 3\n\n\n1\n2\n3\n\n\n实现：\n\n// a simple recursive function to find n'th fibonacci number\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n \n// returns number of ways to reach s'th stair\nfunction countways(s) {\n  return fib(s + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n复杂度：\n\n * 时间复杂度： o(2^n) 。由于冗余计算，上述实现的时间复杂度是指数级的（黄金分割率（golden ratio）提高到 n 次方）。使用斐波那契函数优化，它可以在 o（logn）时间内工作。\n * 空间复杂度： o(1) 。\n\n\n# 问题的一般化\n\n例如，如果 m 是 4，这个人每次可以爬 1 个楼梯或 2 个楼梯或 3 个楼梯或 4 个楼梯，如何计算这个人可以爬到 m 个楼梯的方式。\n\n对于上述方法的一般化，可以使用以下递归关系： ways(n, m) = ways(n-1, m) + ways(n-2, m) + ... ways(n-m, m) 。\n\n实现：\n\n// a recursive function used by countways\nfunction countwaysutil(n, m) {\n  if (n <= 1) return n;\n  let res = 0;\n  for (let i = 1; i <= m && i <= n; i++) res += countwaysutil(n - i, m);\n  return res;\n}\n \n// returns number of ways to reach s'th stair\nfunction countways(s, m) {\n  return countwaysutil(s + 1, m);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 缓存法\n\n我们也可以使用 dp 的自下而上的方法来解决这个问题，为此，我们可以创建一个数组 dp []，并将其初始化为 - 1。每当我们看到一个子问题没有得到解决，我们就可以调用递归方法。否则，如果子问题已经解决了，我们就停止递归。\n\n实现：\n\n// a simple recursive program to find n'th fibonacci number\nfunction fib(n, dp) {\n  if (n <= 1) return dp[n] = 1;\n  if(dp[n] != -1 ) { return dp[n]; }\n  dp[n] = fib(n - 1, dp) + fib(n - 2, dp);\n  return dp[n] ;\n}\n \n// returns number of ways to reach s'th stair\nfunction countways(n) {\n  let dp = new array(n+1).fill(-1) ;\n  fib(n, dp);\n  return dp[n] ;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n复杂度分析：\n\n * 时间复杂度：o (n)\n * 辅助空间：o (n)\n\n\n# 动态规划\n\n我们用以下关系自下而上地创建一个表 res []， res[i] = res[i] + res[i-j] for every (i-j) >= 0 。这样，数组的第 i 个索引将包含考虑到所有攀登的可能性（即从 1 到 i），到达第 i 个步骤所需的方法数。\n\n实现：\n\n \n// a recursive function used by countways\nfunction countwaysutil(n, m) {\n  let res = [];\n  res[0] = 1;\n  res[1] = 1;\n  for (let i = 2; i < n; i++) {\n    res[i] = 0;\n    for (let j = 1; j <= m && j <= i; j++) res[i] += res[i - j];\n  }\n  return res[n - 1];\n}\n \n// returns number of ways to reach s'th stair\nfunction countways(s, m) {\n  return countwaysutil(s + 1, m);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n复杂度分析：\n\n * 时间复杂度： o(m*n)\n * 辅助空间： o(n)\n\n\n# 优化空间的动态规划\n\n在这种方法中，我们可以通过不使用任何额外的空间来优化 dp 方法。首先，我们可以创建两个变量 prev 和 prev2 来存储爬一个楼梯或两个楼梯的方法数量。然后，我们可以运行一个 for 循环来计算到达顶部的方法总数。下面是上述想法的代码实现：\n\nint countways(int n) {\n  // declaring  two variables to store the count\n  int prev = 1;\n  int prev2 = 1;\n  // running for loop to count all possible ways\n  for (int i = 2; i <= n; i++) {\n    int curr = prev + prev2;\n    prev2 = prev;\n    prev = curr;\n  }\n  return prev;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\njavascript：\n\n/**\n * @function climbstairs\n * @description you are climbing a stair case. it takes n steps to reach to the top.each time you can either climb 1 or 2 steps. in how many distinct ways can you climb to the top?\n * @param {integer} n - the input integer\n * @return {integer} distinct ways can you climb to the top.\n * @see [climb_stairs](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)\n */\n\nconst climbstairs = (n) => {\n  let prev = 0\n  let cur = 1\n  let temp\n\n  for (let i = 0; i < n; i++) {\n    temp = prev\n    prev = cur\n    cur += temp\n  }\n  return cur\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n复杂度分析：\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n\n# 滑窗法\n\n这种方法有效地实现了上述 dp 方法。在这个方法中，对于第 1 个楼梯，我们保持一个窗口，即最后 m 个可能的楼梯的总和，我们可以从中爬到第 1 个楼梯。我们不运行内循环，而是将内循环的结果保存在一个临时变量中。我们删除前一个窗口的元素，加入当前窗口的元素并更新总和。\n\n实现：\n\n// returns number of ways\n// to reach s'th stair\nfunction countways(n , m) {\n  const res = array(n + 1).fill(0);\n  let temp = 0;\n  res[0] = 1;\n\n  for (i = 1; i <= n; i++) {\n    const s = i - m - 1;\n    const e = i - 1;\n    if (s >= 0) {\n      temp -= res[s];\n    }\n    temp += res[e];\n    res[i] = temp;\n  }\n  return res[n];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n复杂度分析：\n\n * 时间复杂度：o (n)\n * 辅助空间：o (n)\n\n\n# 数学公式法\n\n这只适用于这个问题，如果（计算步骤中顺序并不重要）。在这种方法中，我们只需计算有 2 的集合的数量。顺序不重要是指对于 n = 4， {1 2 1}，{2 1 1}。 ,{2 1 1} ，{1 1 2} 被认为是相同的。\n\n// here n/2 is done to count the number 2's in n\n// 1 is added for case where there is no 2.\n// eg: if n=4 ans will be 3.\n// {1,1,1,1} set having no 2.\n// {1,1,2} ans {2,2} (n/2) sets containing 2.\nparseint(1 + (n / 2)); \n\n\n1\n2\n3\n4\n5\n6\n\n\n复杂度分析：\n\n * 时间复杂度：o (1)\n * 空间复杂度：o (1)\n\n\n# 参考\n\n * count ways to reach the n'th stair - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"LongestPalindromicSubsequence [最长回文子序列]",frontmatter:{title:"LongestPalindromicSubsequence [最长回文子序列]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/longestPalindromicSubsequence/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/100.LongestPalindromicSubsequence.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/100.LongestPalindromicSubsequence.md",key:"v-016423d6",path:"/algorithm/dp/longestPalindromicSubsequence/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:552},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1228},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4180}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n给定一个字符串 s，找出 s 中最长的回文子序列的长度。你可以假设 s 的最大长度为 1000。\n\n下面是一个处理了所有情况的递归解决方案：\n\n// Every single character is a palindrome of length 1\nL(i, i) = 1 for all indexes i in given sequence\n\n// IF first and last characters are not same\nIf (X[i] != X[j])  L(i, j) =  max{L(i + 1, j),L(i, j - 1)} \n\n// If there are only 2 characters and both are same\nElse if (j == i + 1) L(i, j) = 2  \n\n// If there are more than two characters, and first and last \n// characters are same\nElse L(i, j) =  L(i + 1, j - 1) + 2 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n重叠子问题：下面是 LPS 问题的一个简单的递归实现。该实现简单地遵循了上述的递归结构。\n\n// A utility function to get max of two integers \nfunction max(x, y) {\n  return (x > y) ? x : y;\n}\n \n// Returns the length of the longest palindromic subsequence in seq    \nfunction lps(seq, i, j)\n{\n  // Base Case 1: If there is only 1 character\n  if (i == j) return 1;\n  // Base Case 2: If there are only 2 characters and both are same \n  if (seq[i] == seq[j] && i + 1 == j) return 2;\n  // If the first and last characters match \n  if (seq[i] == seq[j]) return lps(seq, i + 1, j - 1) + 2;\n  // If the first and last characters do not match \n  return max(lps(seq, i, j - 1), lps(seq, i + 1, j));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 实现\n\n\n# JavaScript\n\n// A utility function to get max of two integers\nfunction max(x,y) {\n  return (x > y)? x : y;\n}\n \n// Returns the length of the longest palindromic subsequence in seq\nfunction lps(seq)\n{\n  let n = seq.length;\n  let i, j, cl;\n  // Create a table to store results of subproblems\n  let L = new Array(n);\n  for(let x=0;x<n;x++) {\n      L[x] = new Array(n);\n      for(let y = 0; y < n; y++) L[x][y] = 0;\n  }\n    \n  // Strings of length 1 are palindrome of length 1\n  for (i = 0; i < n; i++) L[i][i] = 1;\n            \n  // Build the table. Note that the lower diagonal values of table are useless and not filled in the process.\n  // The values are filled in a manner similar to Matrix Chain Multiplication DP solution (See https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/).\n  // cl is length of substring\n  for (cl = 2; cl <= n; cl++) {\n    for (i = 0; i < n -cl + 1; i++) {\n        j = i + cl - 1;\n        if (seq[i] == seq[j] && cl == 2) L[i][j] = 2;\n        else if (seq[i] == seq[j]) L[i][j] = L[i + 1][j - 1] + 2;\n        else L[i][j] = max(L[i][j - 1], L[i + 1][j]);\n    }\n  }\n            \n  return L[0][n - 1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n或者：\n\n/*\n  LeetCode -> https://leetcode.com/problems/longest-palindromic-subsequence/\n\n  Given a string s, find the longest palindromic subsequence's length in s.\n  You may assume that the maximum length of s is 1000.\n\n*/\n\nconst longestPalindromeSubsequence = function (s) {\n  const n = s.length\n\n  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))\n\n  // fill predefined for single character\n  for (let i = 0; i < n; i++) dp[i][i] = 1;\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < n - i; j++) {\n      const col = j + i\n      if (s[j] === s[col]) dp[j][col] = 2 + dp[j + 1][col - 1]\n      else dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])\n    }\n  }\n\n  return dp[0][n - 1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n时间复杂度：O (n^2)，比 Naive Recursive 实现的最坏情况下的时间复杂度好得多。\n\n辅助空间：O (n^2), 创建一个表\n\n使用动态规划的缓存技术：想法是反转给定的输入字符串并检查最长的公共子序列的长度。这将是最长的公共子序列的答案。\n\n// A Dynamic Programming based JavaScript program for LPS problem\n// Returns the length of the longest palindromic subsequence in seq\nlet dp;\n \n// Returns the length of the longest palindromic subsequence in seq\nfunction lps(s1, s2, n1, n2) {\n  if (n1 == 0 || n2 == 0) return 0;\n  if (dp[n1][n2] != -1) return dp[n1][n2];\n  if (s1[n1 - 1] == s2[n2 - 1]) return dp[n1][n2] = 1 + lps(s1, s2, n1 - 1, n2 - 1);\n  return dp[n1][n2] = Math.max(lps(s1, s2, n1 - 1, n2), lps(s1, s2, n1, n2 - 1));\n}\n\n// * Driver program to test above functions */\n \nlet seq = \"GEEKSFORGEEKS\";\nlet n = seq.length;\ndp = new Array(1001);\nfor(let i=0;i<1001;i++) dp[i] = new Array(1001).fill(-1);\nlet s2 = seq.split('').reverse().join('');\nlps(s2, seq, n, n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * Longest Palindromic Subsequence | DP-12 - GeeksforGeeks",normalizedContent:"# 介绍\n\n给定一个字符串 s，找出 s 中最长的回文子序列的长度。你可以假设 s 的最大长度为 1000。\n\n下面是一个处理了所有情况的递归解决方案：\n\n// every single character is a palindrome of length 1\nl(i, i) = 1 for all indexes i in given sequence\n\n// if first and last characters are not same\nif (x[i] != x[j])  l(i, j) =  max{l(i + 1, j),l(i, j - 1)} \n\n// if there are only 2 characters and both are same\nelse if (j == i + 1) l(i, j) = 2  \n\n// if there are more than two characters, and first and last \n// characters are same\nelse l(i, j) =  l(i + 1, j - 1) + 2 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n重叠子问题：下面是 lps 问题的一个简单的递归实现。该实现简单地遵循了上述的递归结构。\n\n// a utility function to get max of two integers \nfunction max(x, y) {\n  return (x > y) ? x : y;\n}\n \n// returns the length of the longest palindromic subsequence in seq    \nfunction lps(seq, i, j)\n{\n  // base case 1: if there is only 1 character\n  if (i == j) return 1;\n  // base case 2: if there are only 2 characters and both are same \n  if (seq[i] == seq[j] && i + 1 == j) return 2;\n  // if the first and last characters match \n  if (seq[i] == seq[j]) return lps(seq, i + 1, j - 1) + 2;\n  // if the first and last characters do not match \n  return max(lps(seq, i, j - 1), lps(seq, i + 1, j));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 实现\n\n\n# javascript\n\n// a utility function to get max of two integers\nfunction max(x,y) {\n  return (x > y)? x : y;\n}\n \n// returns the length of the longest palindromic subsequence in seq\nfunction lps(seq)\n{\n  let n = seq.length;\n  let i, j, cl;\n  // create a table to store results of subproblems\n  let l = new array(n);\n  for(let x=0;x<n;x++) {\n      l[x] = new array(n);\n      for(let y = 0; y < n; y++) l[x][y] = 0;\n  }\n    \n  // strings of length 1 are palindrome of length 1\n  for (i = 0; i < n; i++) l[i][i] = 1;\n            \n  // build the table. note that the lower diagonal values of table are useless and not filled in the process.\n  // the values are filled in a manner similar to matrix chain multiplication dp solution (see https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/).\n  // cl is length of substring\n  for (cl = 2; cl <= n; cl++) {\n    for (i = 0; i < n -cl + 1; i++) {\n        j = i + cl - 1;\n        if (seq[i] == seq[j] && cl == 2) l[i][j] = 2;\n        else if (seq[i] == seq[j]) l[i][j] = l[i + 1][j - 1] + 2;\n        else l[i][j] = max(l[i][j - 1], l[i + 1][j]);\n    }\n  }\n            \n  return l[0][n - 1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n或者：\n\n/*\n  leetcode -> https://leetcode.com/problems/longest-palindromic-subsequence/\n\n  given a string s, find the longest palindromic subsequence's length in s.\n  you may assume that the maximum length of s is 1000.\n\n*/\n\nconst longestpalindromesubsequence = function (s) {\n  const n = s.length\n\n  const dp = new array(n).fill(0).map(item => new array(n).fill(0).map(item => 0))\n\n  // fill predefined for single character\n  for (let i = 0; i < n; i++) dp[i][i] = 1;\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < n - i; j++) {\n      const col = j + i\n      if (s[j] === s[col]) dp[j][col] = 2 + dp[j + 1][col - 1]\n      else dp[j][col] = math.max(dp[j][col - 1], dp[j + 1][col])\n    }\n  }\n\n  return dp[0][n - 1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n时间复杂度：o (n^2)，比 naive recursive 实现的最坏情况下的时间复杂度好得多。\n\n辅助空间：o (n^2), 创建一个表\n\n使用动态规划的缓存技术：想法是反转给定的输入字符串并检查最长的公共子序列的长度。这将是最长的公共子序列的答案。\n\n// a dynamic programming based javascript program for lps problem\n// returns the length of the longest palindromic subsequence in seq\nlet dp;\n \n// returns the length of the longest palindromic subsequence in seq\nfunction lps(s1, s2, n1, n2) {\n  if (n1 == 0 || n2 == 0) return 0;\n  if (dp[n1][n2] != -1) return dp[n1][n2];\n  if (s1[n1 - 1] == s2[n2 - 1]) return dp[n1][n2] = 1 + lps(s1, s2, n1 - 1, n2 - 1);\n  return dp[n1][n2] = math.max(lps(s1, s2, n1 - 1, n2), lps(s1, s2, n1, n2 - 1));\n}\n\n// * driver program to test above functions */\n \nlet seq = \"geeksforgeeks\";\nlet n = seq.length;\ndp = new array(1001);\nfor(let i=0;i<1001;i++) dp[i] = new array(1001).fill(-1);\nlet s2 = seq.split('').reverse().join('');\nlps(s2, seq, n, n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * longest palindromic subsequence | dp-12 - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/11/01, 18:11:55",lastUpdatedTimestamp:1667297515e3},{title:"LongestValidParentheses [最长合法括号]",frontmatter:{title:"LongestValidParentheses [最长合法括号]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/longestValidParentheses/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/110.LongestValidParentheses.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/110.LongestValidParentheses.md",key:"v-2a5dea95",path:"/algorithm/dp/longestValidParentheses/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:345},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:352},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2201}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n给出一个由开括号和闭括号组成的字符串，找出最长的有效括号子串的长度。\n\n一个简单的方法是找到给定字符串的所有子串。对于每个字符串，检查它是否是一个有效的字符串。如果是有效的并且长度超过了目前的最大长度，那么就更新最大长度。我们可以使用堆栈在线性时间内检查一个子串是否有效（详见 Check for Balanced Brackets in an expression (well-formedness) using Stack）。这个方案的时间复杂度是 O (n^2).\n\n一个高效的解决方案可以在 O (n) 时间内解决这个问题，其思路是将以前的起始括号的索引存储在一个堆栈中。栈的第一个元素是一个特殊的元素，它提供了有效子串开始前的索引（下一个有效字符串的基数）。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  LeetCode -> https://leetcode.com/problems/longest-valid-parentheses/\n\n  Given a string containing just the characters '(' and ')',\n  find the length of the longest valid (well-formed) parentheses substring.\n*/\n\nexport const longestValidParentheses = (s) => {\n  const n = s.length\n  const stack = []\n\n  // storing results\n  const res = new Array(n).fill(-Infinity)\n\n  for (let i = 0; i < n; i++) {\n    const bracket = s[i]\n\n    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {\n      res[i] = 1\n      res[stack[stack.length - 1]] = 1\n      stack.pop()\n    } else stack.push(i)\n  }\n\n  // summing all adjacent valid\n  for (let i = 1; i < n; i++) res[i] = Math.max(res[i], res[i] + res[i - 1])\n\n  // adding 0 if there are none so it will return 0 instead of -Infinity\n  res.push(0)\n  return Math.max(...res)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n或者：\n\n// JavaScript Program for the above approach\nfunction findMaxLen(str) {\n let n = str.length;\n // Create a stack and push -1 as initial index to it.\n let stk = [];\n stk.push(-1);\n // Initialize result\n let result = 0;\n\n // Traverse all characters of given string\n for (let i = 0; i < n; i++) {\n   // If opening bracket, push index of it\n   if (str.charAt(i) == '(') stk.push(i);\n   // If closing bracket, i.e.,str[i] = ')'\n   else if (stk.length != 0) {\n     // Pop the previous opening bracket's index\n     stk.pop();\n     // Check if this length formed with base of current valid substring is more than max so far\n     // 检查该长度与当前有效子串的基数形成的长度是否超过迄今为止的最大值\n     result = Math.max(result, i - stk[stk.length - 1]);\n     // If stack is empty. push current index as base for next valid substring (if any)\n   } else stk.push(i);\n }\n\n return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 参考\n\n * Length of the longest valid substring - GeeksforGeeks",normalizedContent:"# 介绍\n\n给出一个由开括号和闭括号组成的字符串，找出最长的有效括号子串的长度。\n\n一个简单的方法是找到给定字符串的所有子串。对于每个字符串，检查它是否是一个有效的字符串。如果是有效的并且长度超过了目前的最大长度，那么就更新最大长度。我们可以使用堆栈在线性时间内检查一个子串是否有效（详见 check for balanced brackets in an expression (well-formedness) using stack）。这个方案的时间复杂度是 o (n^2).\n\n一个高效的解决方案可以在 o (n) 时间内解决这个问题，其思路是将以前的起始括号的索引存储在一个堆栈中。栈的第一个元素是一个特殊的元素，它提供了有效子串开始前的索引（下一个有效字符串的基数）。\n\n\n# 实现\n\n\n# javascript\n\n/*\n  leetcode -> https://leetcode.com/problems/longest-valid-parentheses/\n\n  given a string containing just the characters '(' and ')',\n  find the length of the longest valid (well-formed) parentheses substring.\n*/\n\nexport const longestvalidparentheses = (s) => {\n  const n = s.length\n  const stack = []\n\n  // storing results\n  const res = new array(n).fill(-infinity)\n\n  for (let i = 0; i < n; i++) {\n    const bracket = s[i]\n\n    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {\n      res[i] = 1\n      res[stack[stack.length - 1]] = 1\n      stack.pop()\n    } else stack.push(i)\n  }\n\n  // summing all adjacent valid\n  for (let i = 1; i < n; i++) res[i] = math.max(res[i], res[i] + res[i - 1])\n\n  // adding 0 if there are none so it will return 0 instead of -infinity\n  res.push(0)\n  return math.max(...res)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n或者：\n\n// javascript program for the above approach\nfunction findmaxlen(str) {\n let n = str.length;\n // create a stack and push -1 as initial index to it.\n let stk = [];\n stk.push(-1);\n // initialize result\n let result = 0;\n\n // traverse all characters of given string\n for (let i = 0; i < n; i++) {\n   // if opening bracket, push index of it\n   if (str.charat(i) == '(') stk.push(i);\n   // if closing bracket, i.e.,str[i] = ')'\n   else if (stk.length != 0) {\n     // pop the previous opening bracket's index\n     stk.pop();\n     // check if this length formed with base of current valid substring is more than max so far\n     // 检查该长度与当前有效子串的基数形成的长度是否超过迄今为止的最大值\n     result = math.max(result, i - stk[stk.length - 1]);\n     // if stack is empty. push current index as base for next valid substring (if any)\n   } else stk.push(i);\n }\n\n return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 参考\n\n * length of the longest valid substring - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"MaxNonAdjacentSum [最大非连接子集和]",frontmatter:{title:"MaxNonAdjacentSum [最大非连接子集和]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/maxNonAdjacentSum/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/120.MaxNonAdjacentSum.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/120.MaxNonAdjacentSum.md",key:"v-4bb15016",path:"/algorithm/dp/maxNonAdjacentSum/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:155},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:933},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:1866},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2436}],headersStr:"介绍 实现 JavaScript 扩展 参考",content:"# 介绍\n\n给定一个由 N 个整数组成的数组 arr [] 和一个整数 K，任务是选择一些不相邻的数组元素，其最大和不超过 K。\n\n最简单的方法是递归地生成给定数组的所有可能的子集，对于每个子集，检查它是否不包含相邻的元素，并且其总和不超过 K。在发现上述条件为真的所有子集中，打印任何子集获得的最大总和。\n\n实现如下：\n\n// Function to find the maximum sum not exceeding K possible by selecting a subset of non-adjacent elements\nfunction maxSum(a, n, k) {\n  // Base Case\n  if (n <= 0) return 0;\n  // Not selecting current element\n  let option = maxSum(a, n - 1, k);\n  // If selecting current element is possible\n  if (k >= a[n - 1]) option = Math.max(option, a[n - 1] + maxSum(a, n - 2, k - a[n - 1]));\n  // Return answer\n  return option;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n时间复杂度：O (2N) 辅助空间：O (N)\n\n为了优化上述方法，可以使用动态规划。每个数组元素都有两种可能的选择：跳过当前元素，进入下一个元素；只有当当前元素小于或等于 K 时才选择它。\n\n按照下面的步骤来解决这个问题：\n\n * 用 - 1 初始化一个数组 dp[N][K+1] ，其中 dp[i][j] 将存储最大和，以利用索引 i 之前的元素求和 j。\n * 从上述过渡中，如果当前元素被选中，找到最大和，如果没有被选中，则递归。\n * 存储当前状态的最小答案。\n * 同时，如果当前状态 (i，j) 已经被访问，即 dp[i][j]！=-1 返回 dp[i][j] 。\n * 打印 dp[N][K] 作为最大和。\n\n\n# 实现\n\n\n# JavaScript\n\n// Function find the maximum sum that doesn't exceeds K by choosing elements\nfunction maxSum(a, n, k, dp) {\n  // Base Case\n  if (n <= 0) return 0;\n  // Return the memoized state\n  if (dp[n][k] != -1) return dp[n][k];\n  // Dont pick the current element\n  let option = maxSum(a, n - 1, k, dp);\n  // Pick the current element\n  if (k >= a[n - 1]) option = Math.max(option, a[n - 1] + maxSum(a, n - 2, k - a[n - 1], dp));\n  // Return and store the result\n  return dp[n][k] = option;\n}\n\n// Driver Code\n\n// Given array\nlet arr = [ 50, 10, 20, 30, 40 ];\nlet N = arr.length;\nlet K = 100;\n\n// Initialize dp\nlet dp = new Array(N + 1);\n// Loop to create 2D array using 1D array\nfor (var i = 0; i < 1000; i++) dp[i] = new Array(2);\n\nfor (var i = 0; i < 1000; i++) for (var j = 0; j < 1000; j++) dp[i][j] = -1;\n// Print answer\nmaxSum(arr, N, K, dp);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 扩展\n\n求 nums 整数数组中的最大非相邻和。\n\n/*\n * Find the maximum non-adjacent sum of the integers in the nums input list\n * :param nums: Array of Numbers\n * :return: The maximum non-adjacent sum\n */\nfunction maximumNonAdjacentSum (nums) {\n  if (nums.length < 0) return 0\n\n  let maxIncluding = nums[0]\n  let maxExcluding = 0\n\n  for (const num of nums.slice(1)) {\n    const temp = maxIncluding\n    maxIncluding = maxExcluding + num\n    maxExcluding = Math.max(temp, maxExcluding)\n  }\n\n  return Math.max(maxExcluding, maxIncluding)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 参考\n\n * Maximum possible sum of non-adjacent array elements not exceeding K - GeeksforGeeks",normalizedContent:"# 介绍\n\n给定一个由 n 个整数组成的数组 arr [] 和一个整数 k，任务是选择一些不相邻的数组元素，其最大和不超过 k。\n\n最简单的方法是递归地生成给定数组的所有可能的子集，对于每个子集，检查它是否不包含相邻的元素，并且其总和不超过 k。在发现上述条件为真的所有子集中，打印任何子集获得的最大总和。\n\n实现如下：\n\n// function to find the maximum sum not exceeding k possible by selecting a subset of non-adjacent elements\nfunction maxsum(a, n, k) {\n  // base case\n  if (n <= 0) return 0;\n  // not selecting current element\n  let option = maxsum(a, n - 1, k);\n  // if selecting current element is possible\n  if (k >= a[n - 1]) option = math.max(option, a[n - 1] + maxsum(a, n - 2, k - a[n - 1]));\n  // return answer\n  return option;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n时间复杂度：o (2n) 辅助空间：o (n)\n\n为了优化上述方法，可以使用动态规划。每个数组元素都有两种可能的选择：跳过当前元素，进入下一个元素；只有当当前元素小于或等于 k 时才选择它。\n\n按照下面的步骤来解决这个问题：\n\n * 用 - 1 初始化一个数组 dp[n][k+1] ，其中 dp[i][j] 将存储最大和，以利用索引 i 之前的元素求和 j。\n * 从上述过渡中，如果当前元素被选中，找到最大和，如果没有被选中，则递归。\n * 存储当前状态的最小答案。\n * 同时，如果当前状态 (i，j) 已经被访问，即 dp[i][j]！=-1 返回 dp[i][j] 。\n * 打印 dp[n][k] 作为最大和。\n\n\n# 实现\n\n\n# javascript\n\n// function find the maximum sum that doesn't exceeds k by choosing elements\nfunction maxsum(a, n, k, dp) {\n  // base case\n  if (n <= 0) return 0;\n  // return the memoized state\n  if (dp[n][k] != -1) return dp[n][k];\n  // dont pick the current element\n  let option = maxsum(a, n - 1, k, dp);\n  // pick the current element\n  if (k >= a[n - 1]) option = math.max(option, a[n - 1] + maxsum(a, n - 2, k - a[n - 1], dp));\n  // return and store the result\n  return dp[n][k] = option;\n}\n\n// driver code\n\n// given array\nlet arr = [ 50, 10, 20, 30, 40 ];\nlet n = arr.length;\nlet k = 100;\n\n// initialize dp\nlet dp = new array(n + 1);\n// loop to create 2d array using 1d array\nfor (var i = 0; i < 1000; i++) dp[i] = new array(2);\n\nfor (var i = 0; i < 1000; i++) for (var j = 0; j < 1000; j++) dp[i][j] = -1;\n// print answer\nmaxsum(arr, n, k, dp);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 扩展\n\n求 nums 整数数组中的最大非相邻和。\n\n/*\n * find the maximum non-adjacent sum of the integers in the nums input list\n * :param nums: array of numbers\n * :return: the maximum non-adjacent sum\n */\nfunction maximumnonadjacentsum (nums) {\n  if (nums.length < 0) return 0\n\n  let maxincluding = nums[0]\n  let maxexcluding = 0\n\n  for (const num of nums.slice(1)) {\n    const temp = maxincluding\n    maxincluding = maxexcluding + num\n    maxexcluding = math.max(temp, maxexcluding)\n  }\n\n  return math.max(maxexcluding, maxincluding)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 参考\n\n * maximum possible sum of non-adjacent array elements not exceeding k - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"MaxProductOfThree [最大三数积]",frontmatter:{title:"MaxProductOfThree [最大三数积]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/maxProductOfThree/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/130.MaxProductOfThree.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/130.MaxProductOfThree.md",key:"v-65cde415",path:"/algorithm/dp/maxProductOfThree/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1852},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1859},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3138}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n给定一个整数数组，找出你能从三个整数中得到的最大乘积。\n\nBrute Force 方法：\n\n我们可以用三个循环来迭代 arr。\n\n// O(n^3) time\nconst threeSum = (arr) => {\n  let maxProduct = 0;\n  for (let i=0; i<arr.length - 2; i++) {\n    for (let j=i+1; j<arr.length - 1; j++) {\n      for (let k=j+1; k<arr.length; k++) {\n        let product = arr[i] * arr[j] * arr[k];\n        if (product > maxProduct) {\n          maxProduct = product;\n        }\n      }\n    }\n  }\n  return maxProduct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n排序法：\n\n如果我们对数组进行排序 -- 我们可以在O(nlogn)O(nlogn)O(nlogn) 时间内完成，那么我们可以简单地将最后的最大的三个整数相乘。\n\n// O(n log n)\nconst threeSum = (arr) => {\n  sortedArr = arr.sort((a, b) => a - b);\n  let len = arr.length;\n  let maxProduct = sortedArr[len-1] * sortedArr[len-2] * sortedArr[len-3];\n  return maxProduct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n贪婪算法：\n\n如果我们使用贪婪算法，可以获得O(n)O(n)O(n) 的时间。\n\nconst threeSum = (arr) => {\n\n    let highest = Math.max(arr[0], arr[1]);\n    let lowest  = Math.min(arr[0], arr[1]);\n    let highestProductOf2 = arr[0] * arr[1];\n    let lowestProductOf2  = arr[0] * arr[1];\n    let highestProductOf3 = arr[0] * arr[1] * arr[2];\n\n    for (let i=2; i<arr.length; i++) {\n        let current = arr[i];\n\n        highestProductOf3 = Math.max(\n            highestProductOf3,\n            current * highestProductOf2,\n            current * lowestProductOf2\n        );\n\n        highestProductOf2 = Math.max(\n            highestProductOf2,\n            current * highest,\n            current * lowest\n        );\n\n        lowestProductOf2 = Math.min(\n            lowestProductOf2,\n            current * highest,\n            current * lowest\n        );\n\n        highest = Math.max(highest, current);\n\n        lowest = Math.min(lowest, current);\n    }\n\n    return highestProductOf3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n还要注意的是，目前的解决方案不能正确处理负数。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n *  Given an array of numbers, return the maximum product\n *  of 3 numbers from the array\n *  https://wsvincent.com/javascript-three-sum-highest-product-of-three-numbers/\n * @param {number[]} arrayItems\n * @returns number\n */\nexport function maxProductOfThree (arrayItems) {\n  // if size is less than 3, no triplet exists\n  const n = arrayItems.length\n  if (n < 3) throw new Error('Triplet cannot exist with the given array')\n  let max1 = arrayItems[0]\n  let max2 = -1\n  let max3 = -1\n  let min1 = arrayItems[0]\n  let min2 = -1\n  for (let i = 1; i < n; i++) {\n    if (arrayItems[i] > max1) {\n      max3 = max2\n      max2 = max1\n      max1 = arrayItems[i]\n    } else if (max2 === -1 || arrayItems[i] > max2) {\n      max3 = max2\n      max2 = arrayItems[i]\n    } else if (max3 === -1 || arrayItems[i] > max3) {\n      max3 = arrayItems[i]\n    }\n    if (arrayItems[i] < min1) {\n      min2 = min1\n      min1 = arrayItems[i]\n    } else if (min2 === -1 || arrayItems[i] < min2) {\n      min2 = arrayItems[i]\n    }\n  }\n  const prod1 = max1 * max2 * max3\n  const prod2 = max1 * min1 * min2\n  return Math.max(prod1, prod2)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n注意，max2、max3、min2 需要尽快初始化以免乘以 -1 出错。\n\n\n# 参考\n\n * JavaScript Three Sum: Find the Highest Product of Three Numbers - Will Vincent",normalizedContent:"# 介绍\n\n给定一个整数数组，找出你能从三个整数中得到的最大乘积。\n\nbrute force 方法：\n\n我们可以用三个循环来迭代 arr。\n\n// o(n^3) time\nconst threesum = (arr) => {\n  let maxproduct = 0;\n  for (let i=0; i<arr.length - 2; i++) {\n    for (let j=i+1; j<arr.length - 1; j++) {\n      for (let k=j+1; k<arr.length; k++) {\n        let product = arr[i] * arr[j] * arr[k];\n        if (product > maxproduct) {\n          maxproduct = product;\n        }\n      }\n    }\n  }\n  return maxproduct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n排序法：\n\n如果我们对数组进行排序 -- 我们可以在o(nlogn)o(nlogn)o(nlogn) 时间内完成，那么我们可以简单地将最后的最大的三个整数相乘。\n\n// o(n log n)\nconst threesum = (arr) => {\n  sortedarr = arr.sort((a, b) => a - b);\n  let len = arr.length;\n  let maxproduct = sortedarr[len-1] * sortedarr[len-2] * sortedarr[len-3];\n  return maxproduct;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n贪婪算法：\n\n如果我们使用贪婪算法，可以获得o(n)o(n)o(n) 的时间。\n\nconst threesum = (arr) => {\n\n    let highest = math.max(arr[0], arr[1]);\n    let lowest  = math.min(arr[0], arr[1]);\n    let highestproductof2 = arr[0] * arr[1];\n    let lowestproductof2  = arr[0] * arr[1];\n    let highestproductof3 = arr[0] * arr[1] * arr[2];\n\n    for (let i=2; i<arr.length; i++) {\n        let current = arr[i];\n\n        highestproductof3 = math.max(\n            highestproductof3,\n            current * highestproductof2,\n            current * lowestproductof2\n        );\n\n        highestproductof2 = math.max(\n            highestproductof2,\n            current * highest,\n            current * lowest\n        );\n\n        lowestproductof2 = math.min(\n            lowestproductof2,\n            current * highest,\n            current * lowest\n        );\n\n        highest = math.max(highest, current);\n\n        lowest = math.min(lowest, current);\n    }\n\n    return highestproductof3;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n还要注意的是，目前的解决方案不能正确处理负数。\n\n\n# 实现\n\n\n# javascript\n\n/**\n *  given an array of numbers, return the maximum product\n *  of 3 numbers from the array\n *  https://wsvincent.com/javascript-three-sum-highest-product-of-three-numbers/\n * @param {number[]} arrayitems\n * @returns number\n */\nexport function maxproductofthree (arrayitems) {\n  // if size is less than 3, no triplet exists\n  const n = arrayitems.length\n  if (n < 3) throw new error('triplet cannot exist with the given array')\n  let max1 = arrayitems[0]\n  let max2 = -1\n  let max3 = -1\n  let min1 = arrayitems[0]\n  let min2 = -1\n  for (let i = 1; i < n; i++) {\n    if (arrayitems[i] > max1) {\n      max3 = max2\n      max2 = max1\n      max1 = arrayitems[i]\n    } else if (max2 === -1 || arrayitems[i] > max2) {\n      max3 = max2\n      max2 = arrayitems[i]\n    } else if (max3 === -1 || arrayitems[i] > max3) {\n      max3 = arrayitems[i]\n    }\n    if (arrayitems[i] < min1) {\n      min2 = min1\n      min1 = arrayitems[i]\n    } else if (min2 === -1 || arrayitems[i] < min2) {\n      min2 = arrayitems[i]\n    }\n  }\n  const prod1 = max1 * max2 * max3\n  const prod2 = max1 * min1 * min2\n  return math.max(prod1, prod2)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n注意，max2、max3、min2 需要尽快初始化以免乘以 -1 出错。\n\n\n# 参考\n\n * javascript three sum: find the highest product of three numbers - will vincent",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"MinimumCostPath [最小代价路径]",frontmatter:{title:"MinimumCostPath [最小代价路径]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/minimumCostPath/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/140.MinimumCostPath.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/140.MinimumCostPath.md",key:"v-f5c59296",path:"/algorithm/dp/minimumCostPath/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:58},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:65},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:72}],headersStr:"介绍 演示 实现 JavaScript",content:"# 介绍\n\n给定一个二维矩阵，其中每一个元素代表通过该格子的代价，计算从左上角到右下角的最小代价及其路径。\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\n// Problem Statement => https://www.youtube.com/watch?v=lBRtnuxg-gU\n/*\nFind the min cost path from top-left to bottom-right in matrix\n>>> minCostPath([[2, 1], [3, 1], [4, 2]])\n>>> 6\n*/\nconst minCostPath = (matrix) => {\n  const n = matrix.length\n  const m = matrix[0].length\n\n  // moves[i][j] => minimum number of moves to reach cell i, j\n  const moves = new Array(n)\n  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)\n\n  // base conditions\n  moves[0][0] = matrix[0][0] // to reach cell (0, 0) from (0, 0) is of no moves\n  for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]\n  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j]\n  }\n\n  return moves[n - 1][m - 1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",normalizedContent:"# 介绍\n\n给定一个二维矩阵，其中每一个元素代表通过该格子的代价，计算从左上角到右下角的最小代价及其路径。\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\n// problem statement => https://www.youtube.com/watch?v=lbrtnuxg-gu\n/*\nfind the min cost path from top-left to bottom-right in matrix\n>>> mincostpath([[2, 1], [3, 1], [4, 2]])\n>>> 6\n*/\nconst mincostpath = (matrix) => {\n  const n = matrix.length\n  const m = matrix[0].length\n\n  // moves[i][j] => minimum number of moves to reach cell i, j\n  const moves = new array(n)\n  for (let i = 0; i < moves.length; i++) moves[i] = new array(m)\n\n  // base conditions\n  moves[0][0] = matrix[0][0] // to reach cell (0, 0) from (0, 0) is of no moves\n  for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]\n  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) moves[i][j] = math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j]\n  }\n\n  return moves[n - 1][m - 1]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"NumberOfSubsetEqualToGivenSum [等和子集]",frontmatter:{title:"NumberOfSubsetEqualToGivenSum [等和子集]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/numberOfSubsetEqualToGivenSum/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/150.NumberOfSubsetEqualToGivenSum.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/150.NumberOfSubsetEqualToGivenSum.md",key:"v-2d1854f5",path:"/algorithm/dp/numberOfSubsetEqualToGivenSum/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:5373},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:5380},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6087}],headersStr:"介绍 实现 JavaScript 参考",content:'# 介绍\n\n给定一个长度为 N 的数组 arr [] 和一个整数 X，任务是找出总和等于 X 的子集的数量。\n\n一个简单的方法是通过生成所有可能的子集来解决这个问题，然后检查子集是否具有所需的和。这种方法的时间复杂度将是指数级的。\n\n// Naive Approach\n\n#include <stdio.h>\n\nvoid printBool(int n, int len) {\n\n while (n) {\n  if (n & 1) printf("1 ");\n  else printf("0 ");\n  n >>= 1;\n  len--;\n }\n\n // This is used for padding zeros\n while (len) {\n  printf("0 ");\n  len--;\n }\n printf("\\n");\n}\n\n// Function Prints all the subsets of given set[]\nvoid printSubsetsCount(int set[], int n, int val) {\n int sum; // it stores the current sum\n int count = 0;\n for (int i = 0; i < (1 << n); i++) {\n  sum = 0;\n  // Print current subset\n  for (int j = 0; j < n; j++)\n\n   // (1<<j) is a number with jth bit 1\n   // so when we \'and\' them with the subset number we get which numbers are present in the subset and which are not\n   // Refer: https://www.geeksforgeeks.org/finding-all-subsets-of-a-given-set-in-java/?ref=lbp\n   if ((i & (1 << j)) > 0) {\n    sum += set[j]; // elements are added one by one of a subset to the sum\n   }\n  // It checks if the sum is equal to desired sum. If\n  // it is true then it prints the elements of the sum\n  // to the output\n  if (sum == val) {\n   /*\n   * Uncomment printBool(i,n) to get the boolean\n   * representation of the selected elements from\n   * set. For this example output of this\n   * representation will be 0 1 1 1 0 // 2,3,4\n   * makes sum 9 1 0 1 0 1 // 1,3,5 also makes sum\n   * 9 0 0 0 1 1 // 4,5 also makes sum 9\n   *\n   * \'i\' is used for \'and\' operation so the\n   * position of set bits in \'i\' will be the\n   * selected element. and as we have to give\n   * padding with zeros to represent the complete\n   * set , so length of the set (\'n\') is passed to\n   * the function.\n   * */\n   // printBool(i,n);\n   count++;\n  }\n }\n // it means no subset is found with given sum\n if (count == 0) printf("No subset is found");\n else printf("%d", count);\n}\n\n// Driver code\nvoid main() {\n int set[] = { 1, 2, 3, 4, 5 };\n printSubsetsCount(set, 5, 9);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n然而，对于较小的 X 值和数组元素，这个问题可以用动态规划来解决。我们先看一下递归关系。这个方法对所有的整数都有效。\n\ndp[i][C] = dp[i - 1][C - arr[i]] + dp[i - 1][C] \n\n\n1\n\n\n现在我们来了解一下 DP 的状态。这里， dp[i][C] 存储了子数组 arr[i...N-1] 的子集数量，使得它们的总和等于 C。因此，递归是非常琐碎的，因为只有两个选择，即要么考虑子集中的第 i 个元素，要么不考虑。\n\n// Javascript implementation of the approach\nconst maxN = 20\nconst maxSum = 50\nconst minSum = 50\nconst base = 50\n \n// To store the states of DP\nconst dp = Array.from(Array(maxN), ()=>Array(maxSum+minSum));\nconst v = Array.from(Array(maxN), ()=>Array(maxSum+minSum));\n \n// Function to return the required count\nfunction findCnt(arr, i, required_sum, n) {\n  // Base case\n  if (i == n) {\n    if (required_sum == 0) return 1;\n    return 0;\n  }\n  // If the state has been solved before return the value of the state\n  if (v[i][required_sum + base]) return dp[i][required_sum + base];\n  // Setting the state as solved\n  v[i][required_sum + base] = 1;\n  // Recurrence relation\n  dp[i][required_sum + base] = findCnt(arr, i + 1, required_sum, n) + findCnt(arr, i + 1, required_sum - arr[i], n);\n  return dp[i][required_sum + base];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n使用制表法：\n\n这个方法只对那些包含正数元素的数组有效。在这个方法中，我们使用一个大小为 (arr.size() + 1) * (target + 1) 的整数类型的二维数组。 矩阵的初始化： mat[0][0] = 1 因为如果总和为 0，那么存在总和为 0 的空子集 {}。\n\nif (A[i] > j) DP[i][j] = DP[i-1][j]\nelse DP[i][j] = DP[i-1][j] + DP[i-1][j-A[i]]\n\n\n1\n2\n\n\n这意味着，如果当前元素的值大于 "当前总和值"，我们将复制以前案例的答案。而如果当前的和值大于 \' 第 1 个 \' 元素，我们将看到之前的任何状态是否已经经历了 sum=\'j\'，以及任何之前的状态经历了一个值 \'j-A [i]\'。\n\nfunction subsetSum( a,  n, sum) {\n  // Initializing the matrix\n  var tab = new Array(n + 1);\n  for (let i = 0; i< n+1; i++) tab[i] = new Array(sum + 1);\n  // Initializing the first value of matrix\n  tab[0][0] = 1;\n  for (let i = 1; i <= sum; i++) tab[0][i] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j <= sum; j++) {\n      // if the value is greater than the sum\n      if (a[i - 1] > j) tab[i][j] = tab[i - 1][j];\n      else tab[i][j] = tab[i - 1][j] + tab[i - 1][j - a[i - 1]];\n    }\n  }\n\n  return tab[n][sum];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n时间复杂度：O (sumn)，其中 sum 是 "目标和"，"n" 是数组的大小。 辅助空间：O (sumn)，因为二维阵列的大小是 sum*n。\n\n空间优化：\n\n我们可以通过关注最后的状态和当前的状态来解决这个问题，所以我们可以在 O (target+1) 的空间复杂度下解决问题。\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint CountSubsetSum(vector<int>& arr, int val, int n) {\n int count = 0;\n vector<int> PresentState(val + 1, 0),\n LastState(val + 1, 0);\n // consider only last and present state we dont need the (present-2)th state and above and we know for val to be 0 if we dont pick the current index element we can achieve\n PresentState[0] = LastState[0] = 1;\n if (arr[0] <= val) LastState[arr[0]] = 1;\n for (int i = 1; i < n; i++) {\n  for (int j = 1; j <= val; j++)\n   PresentState[j] = ((j >= arr[i]) ? LastState[j - arr[i]] : 0) + LastState[j];\n   // this we will need in the next iteration so just swap current and last state.\n   LastState = PresentState;\n }\n // Note after exit from loop we will having a present state which is nothing but the laststate itself;\n return PresentState[val]; // or return CurrentState[val];\n}\nint main() {\n vector<int> arr = { 3, 3, 3, 3 };\n cout << CountSubsetSum(arr, 6, arr.size());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nGiven an array of non-negative integers and a value sum,\ndetermine the total number of the subset with sum equal to the given sum.\n*/\n/* Given solution is O(n*sum) Time complexity and O(sum) Space complexity */\nfunction NumberOfSubsetSum (array, sum) {\n  const dp = [] // create an dp array where dp[i] denote number of subset with sum equal to i\n  for (let i = 1; i <= sum; i++) dp[i] = 0\n  dp[0] = 1 // since sum equal to 0 is always possible with no element in subset\n\n  for (let i = 0; i < array.length; i++) {\n    for (let j = sum; j >= array[i]; j--) {\n      if (j - array[i] >= 0) dp[j] += dp[j - array[i]]\n    }\n  }\n  return dp[sum]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\n * Count of subsets with sum equal to X - GeeksforGeeks',normalizedContent:'# 介绍\n\n给定一个长度为 n 的数组 arr [] 和一个整数 x，任务是找出总和等于 x 的子集的数量。\n\n一个简单的方法是通过生成所有可能的子集来解决这个问题，然后检查子集是否具有所需的和。这种方法的时间复杂度将是指数级的。\n\n// naive approach\n\n#include <stdio.h>\n\nvoid printbool(int n, int len) {\n\n while (n) {\n  if (n & 1) printf("1 ");\n  else printf("0 ");\n  n >>= 1;\n  len--;\n }\n\n // this is used for padding zeros\n while (len) {\n  printf("0 ");\n  len--;\n }\n printf("\\n");\n}\n\n// function prints all the subsets of given set[]\nvoid printsubsetscount(int set[], int n, int val) {\n int sum; // it stores the current sum\n int count = 0;\n for (int i = 0; i < (1 << n); i++) {\n  sum = 0;\n  // print current subset\n  for (int j = 0; j < n; j++)\n\n   // (1<<j) is a number with jth bit 1\n   // so when we \'and\' them with the subset number we get which numbers are present in the subset and which are not\n   // refer: https://www.geeksforgeeks.org/finding-all-subsets-of-a-given-set-in-java/?ref=lbp\n   if ((i & (1 << j)) > 0) {\n    sum += set[j]; // elements are added one by one of a subset to the sum\n   }\n  // it checks if the sum is equal to desired sum. if\n  // it is true then it prints the elements of the sum\n  // to the output\n  if (sum == val) {\n   /*\n   * uncomment printbool(i,n) to get the boolean\n   * representation of the selected elements from\n   * set. for this example output of this\n   * representation will be 0 1 1 1 0 // 2,3,4\n   * makes sum 9 1 0 1 0 1 // 1,3,5 also makes sum\n   * 9 0 0 0 1 1 // 4,5 also makes sum 9\n   *\n   * \'i\' is used for \'and\' operation so the\n   * position of set bits in \'i\' will be the\n   * selected element. and as we have to give\n   * padding with zeros to represent the complete\n   * set , so length of the set (\'n\') is passed to\n   * the function.\n   * */\n   // printbool(i,n);\n   count++;\n  }\n }\n // it means no subset is found with given sum\n if (count == 0) printf("no subset is found");\n else printf("%d", count);\n}\n\n// driver code\nvoid main() {\n int set[] = { 1, 2, 3, 4, 5 };\n printsubsetscount(set, 5, 9);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n然而，对于较小的 x 值和数组元素，这个问题可以用动态规划来解决。我们先看一下递归关系。这个方法对所有的整数都有效。\n\ndp[i][c] = dp[i - 1][c - arr[i]] + dp[i - 1][c] \n\n\n1\n\n\n现在我们来了解一下 dp 的状态。这里， dp[i][c] 存储了子数组 arr[i...n-1] 的子集数量，使得它们的总和等于 c。因此，递归是非常琐碎的，因为只有两个选择，即要么考虑子集中的第 i 个元素，要么不考虑。\n\n// javascript implementation of the approach\nconst maxn = 20\nconst maxsum = 50\nconst minsum = 50\nconst base = 50\n \n// to store the states of dp\nconst dp = array.from(array(maxn), ()=>array(maxsum+minsum));\nconst v = array.from(array(maxn), ()=>array(maxsum+minsum));\n \n// function to return the required count\nfunction findcnt(arr, i, required_sum, n) {\n  // base case\n  if (i == n) {\n    if (required_sum == 0) return 1;\n    return 0;\n  }\n  // if the state has been solved before return the value of the state\n  if (v[i][required_sum + base]) return dp[i][required_sum + base];\n  // setting the state as solved\n  v[i][required_sum + base] = 1;\n  // recurrence relation\n  dp[i][required_sum + base] = findcnt(arr, i + 1, required_sum, n) + findcnt(arr, i + 1, required_sum - arr[i], n);\n  return dp[i][required_sum + base];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n使用制表法：\n\n这个方法只对那些包含正数元素的数组有效。在这个方法中，我们使用一个大小为 (arr.size() + 1) * (target + 1) 的整数类型的二维数组。 矩阵的初始化： mat[0][0] = 1 因为如果总和为 0，那么存在总和为 0 的空子集 {}。\n\nif (a[i] > j) dp[i][j] = dp[i-1][j]\nelse dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]]\n\n\n1\n2\n\n\n这意味着，如果当前元素的值大于 "当前总和值"，我们将复制以前案例的答案。而如果当前的和值大于 \' 第 1 个 \' 元素，我们将看到之前的任何状态是否已经经历了 sum=\'j\'，以及任何之前的状态经历了一个值 \'j-a [i]\'。\n\nfunction subsetsum( a,  n, sum) {\n  // initializing the matrix\n  var tab = new array(n + 1);\n  for (let i = 0; i< n+1; i++) tab[i] = new array(sum + 1);\n  // initializing the first value of matrix\n  tab[0][0] = 1;\n  for (let i = 1; i <= sum; i++) tab[0][i] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j <= sum; j++) {\n      // if the value is greater than the sum\n      if (a[i - 1] > j) tab[i][j] = tab[i - 1][j];\n      else tab[i][j] = tab[i - 1][j] + tab[i - 1][j - a[i - 1]];\n    }\n  }\n\n  return tab[n][sum];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n时间复杂度：o (sumn)，其中 sum 是 "目标和"，"n" 是数组的大小。 辅助空间：o (sumn)，因为二维阵列的大小是 sum*n。\n\n空间优化：\n\n我们可以通过关注最后的状态和当前的状态来解决这个问题，所以我们可以在 o (target+1) 的空间复杂度下解决问题。\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint countsubsetsum(vector<int>& arr, int val, int n) {\n int count = 0;\n vector<int> presentstate(val + 1, 0),\n laststate(val + 1, 0);\n // consider only last and present state we dont need the (present-2)th state and above and we know for val to be 0 if we dont pick the current index element we can achieve\n presentstate[0] = laststate[0] = 1;\n if (arr[0] <= val) laststate[arr[0]] = 1;\n for (int i = 1; i < n; i++) {\n  for (int j = 1; j <= val; j++)\n   presentstate[j] = ((j >= arr[i]) ? laststate[j - arr[i]] : 0) + laststate[j];\n   // this we will need in the next iteration so just swap current and last state.\n   laststate = presentstate;\n }\n // note after exit from loop we will having a present state which is nothing but the laststate itself;\n return presentstate[val]; // or return currentstate[val];\n}\nint main() {\n vector<int> arr = { 3, 3, 3, 3 };\n cout << countsubsetsum(arr, 6, arr.size());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 实现\n\n\n# javascript\n\n/*\ngiven an array of non-negative integers and a value sum,\ndetermine the total number of the subset with sum equal to the given sum.\n*/\n/* given solution is o(n*sum) time complexity and o(sum) space complexity */\nfunction numberofsubsetsum (array, sum) {\n  const dp = [] // create an dp array where dp[i] denote number of subset with sum equal to i\n  for (let i = 1; i <= sum; i++) dp[i] = 0\n  dp[0] = 1 // since sum equal to 0 is always possible with no element in subset\n\n  for (let i = 0; i < array.length; i++) {\n    for (let j = sum; j >= array[i]; j--) {\n      if (j - array[i] >= 0) dp[j] += dp[j - array[i]]\n    }\n  }\n  return dp[sum]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\n * count of subsets with sum equal to x - geeksforgeeks',charsets:{cjk:!0},lastUpdated:"2022/10/25, 21:47:42",lastUpdatedTimestamp:1666705662e3},{title:"RodCutting [棒材切割问题]",frontmatter:{title:"RodCutting [棒材切割问题]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/rodCutting/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/160.RodCutting.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/160.RodCutting.md",key:"v-1058a9ab",path:"/algorithm/dp/rodCutting/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"递归法",slug:"递归法",normalizedTitle:"递归法",charIndex:67},{level:2,title:"动态规划法",slug:"动态规划法",normalizedTitle:"动态规划法",charIndex:922},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1547},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1554},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2086}],headersStr:"介绍 递归法 动态规划法 实现 JavaScript 参考",content:"# 介绍\n\n给你一根长度为 n 的杆子和一个与所有长度小于 n 的价格数组。通过切割杆子和出售这些杆子，找出可能的最大利润。\n\n\n# 递归法\n\n我们得到一个数组 price []，其中长度的杆 i 有价值 price [i-1]. 这个想法很简单 —— 一根一根地分割给定的长度棒 n 分为两部分： i 和 n-i。重复分割 n-1 长度的棒，但不要分割长度为 i 的棒。最后，取所有值中的最大值。这产生以下递归的关系： rodcut(n) = max { price[i – 1] + rodCut(n – i) } where 1 <= i <= n 。\n\ndef rodCut(price, n):\n    if n == 0:\n        return 0\n \n    maxValue = -sys.maxsize\n    # 将给定的长度为`n`的杆分成两部分长度\n    # (1, n-1), (2, n-2), (3, n-3), … ,(n-1, 1), (n, 0) 取最大值\n    for i in range(1, n + 1):\n        # 长度为 `i` 的杆的成本为 `price[i-1]`\n        cost = price[i - 1] + rodCut(price, n - i)\n        if cost > maxValue:\n            maxValue = cost\n \n    return maxValue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上述解决方案的时间复杂度为 O (nn) 并占用调用堆栈中的空间，其中 n 是杆长。\n\n我们已经看到问题可以分解为更小的子问题，这些子问题可以进一步分解为更小的子问题，依此类推。所以，问题有最优子结构。让我们考虑一个长度为 4 的杆的递归树。\n\n\n\n正如我们所看到的，相同的子问题 (以相同的颜色突出显示) 被重复计算。所以，重叠子问题特征也表现出来了。我们知道具有最优子结构和重叠子问题的问题可以通过动态规划来解决，其中子问题的解决方案是缓存化而不必重复计算。\n\n\n# 动态规划法\n\n动态规划和分治法的区别：\n\n * 分治法是将问题划分成一些独立的子问题，递归求解各个子问题，然后合并子问题的解而得到原问题的解\n * 动态规划使用于子问题不独立的情况，也就是各个子问题包含公共的部分。若采用分治法，会有重复的求解公共部分，而动态规划算法对每个子问题只求解一次，然后将结果保存在一张表中，从而避免重复的运算。\n\n动态规划具有如下特征：\n\n * 最优子结构\n * 重叠子问题\n\n动态规划算法设计可以分为如下步骤：\n\n * 描述最优解的结构\n * 递归定义最优解的值\n * 按自底向上的方式计算最优解的值\n * 由计算出的结果构造一个最优解\n\n我们将以自下而上的方式解决这个问题。在自下而上的方法中，我们首先解决较小的子问题，然后从中解决较大的子问题。以下自下而上的方法计算 T [i]，它存储从长度为 i 的杆获得的最大利润。\n\ndef rodCut(price, n):\n    T = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            T[i] = max(T[i], price[j - 1] + T[i - j])\n    return T[n]\n\n\n1\n2\n3\n4\n5\n6\n\n\n上述自下而上解的时间复杂度为 O (n^2) 并要求 O (n) 额外的空间，其中 n 是杆长。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  * You are given a rod of 'n' length and an array of prices associated with all the lengths less than 'n'.\n  * Find the maximum profit possible by cutting the rod and selling the pieces.\n*/\n\nfunction rodCut (prices, n) {\n  const memo = new Array(n + 1)\n  memo[0] = 0\n\n  for (let i = 1; i <= n; i++) {\n    let maxVal = Number.MIN_VALUE\n    for (let j = 0; j < i; j++) maxVal = Math.max(maxVal, prices[j] + memo[i - j - 1])\n    memo[i] = maxVal\n  }\n\n  return memo[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\n * Cutting a Rod | DP-13 - GeeksforGeeks",normalizedContent:"# 介绍\n\n给你一根长度为 n 的杆子和一个与所有长度小于 n 的价格数组。通过切割杆子和出售这些杆子，找出可能的最大利润。\n\n\n# 递归法\n\n我们得到一个数组 price []，其中长度的杆 i 有价值 price [i-1]. 这个想法很简单 —— 一根一根地分割给定的长度棒 n 分为两部分： i 和 n-i。重复分割 n-1 长度的棒，但不要分割长度为 i 的棒。最后，取所有值中的最大值。这产生以下递归的关系： rodcut(n) = max { price[i – 1] + rodcut(n – i) } where 1 <= i <= n 。\n\ndef rodcut(price, n):\n    if n == 0:\n        return 0\n \n    maxvalue = -sys.maxsize\n    # 将给定的长度为`n`的杆分成两部分长度\n    # (1, n-1), (2, n-2), (3, n-3), … ,(n-1, 1), (n, 0) 取最大值\n    for i in range(1, n + 1):\n        # 长度为 `i` 的杆的成本为 `price[i-1]`\n        cost = price[i - 1] + rodcut(price, n - i)\n        if cost > maxvalue:\n            maxvalue = cost\n \n    return maxvalue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上述解决方案的时间复杂度为 o (nn) 并占用调用堆栈中的空间，其中 n 是杆长。\n\n我们已经看到问题可以分解为更小的子问题，这些子问题可以进一步分解为更小的子问题，依此类推。所以，问题有最优子结构。让我们考虑一个长度为 4 的杆的递归树。\n\n\n\n正如我们所看到的，相同的子问题 (以相同的颜色突出显示) 被重复计算。所以，重叠子问题特征也表现出来了。我们知道具有最优子结构和重叠子问题的问题可以通过动态规划来解决，其中子问题的解决方案是缓存化而不必重复计算。\n\n\n# 动态规划法\n\n动态规划和分治法的区别：\n\n * 分治法是将问题划分成一些独立的子问题，递归求解各个子问题，然后合并子问题的解而得到原问题的解\n * 动态规划使用于子问题不独立的情况，也就是各个子问题包含公共的部分。若采用分治法，会有重复的求解公共部分，而动态规划算法对每个子问题只求解一次，然后将结果保存在一张表中，从而避免重复的运算。\n\n动态规划具有如下特征：\n\n * 最优子结构\n * 重叠子问题\n\n动态规划算法设计可以分为如下步骤：\n\n * 描述最优解的结构\n * 递归定义最优解的值\n * 按自底向上的方式计算最优解的值\n * 由计算出的结果构造一个最优解\n\n我们将以自下而上的方式解决这个问题。在自下而上的方法中，我们首先解决较小的子问题，然后从中解决较大的子问题。以下自下而上的方法计算 t [i]，它存储从长度为 i 的杆获得的最大利润。\n\ndef rodcut(price, n):\n    t = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            t[i] = max(t[i], price[j - 1] + t[i - j])\n    return t[n]\n\n\n1\n2\n3\n4\n5\n6\n\n\n上述自下而上解的时间复杂度为 o (n^2) 并要求 o (n) 额外的空间，其中 n 是杆长。\n\n\n# 实现\n\n\n# javascript\n\n/*\n  * you are given a rod of 'n' length and an array of prices associated with all the lengths less than 'n'.\n  * find the maximum profit possible by cutting the rod and selling the pieces.\n*/\n\nfunction rodcut (prices, n) {\n  const memo = new array(n + 1)\n  memo[0] = 0\n\n  for (let i = 1; i <= n; i++) {\n    let maxval = number.min_value\n    for (let j = 0; j < i; j++) maxval = math.max(maxval, prices[j] + memo[i - j - 1])\n    memo[i] = maxval\n  }\n\n  return memo[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\n * cutting a rod | dp-13 - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"Shuf [随机样本]",frontmatter:{title:"Shuf [随机样本]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/shuf/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/170.Shuf.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/170.Shuf.md",key:"v-1b91e26f",path:"/algorithm/dp/shuf/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:81},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:88},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3038}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n给定一个未知大小的数据集，按随机顺序获得一个随机样本。这通常被用于数据分析，作为一种从数据池或仓库或 CSV 文件中获取小的随机样本的方法。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nGiven a data set of an unknown size, Get a random sample in a random order\nIt's used in data analytics, often as a way to get a small random sample from a data lake or warehouse, or from a large CSV file\n*/\nfunction shuf (datasetSource, sampleSize) {\n  const output = fillBaseSample(datasetSource, sampleSize)\n  return randomizeOutputFromDataset(datasetSource, output)\n}\n\n/**\n * Fills the output if possible, with the minimum number of values\n * @param {Iterable.<T>} datasetSource The iterable source of data\n * @param {number} sampleSize The size of the sample to extract from the dataset\n * @returns {Array.<T>} The random sample, as an array\n * @template T\n */\nfunction fillBaseSample (datasetSource, sampleSize) {\n  let filledIndexes = []\n  let output = new Array(sampleSize)\n\n  // Spread data out filling the array\n  while (true) {\n    const iterator = datasetSource.next()\n    if (iterator.done) break\n\n    let insertTo = Math.floor(Math.random() * output.length)\n    while (filledIndexes.includes(insertTo)) {\n      insertTo++\n      if (insertTo === output.length) {\n        insertTo = 0\n      }\n    }\n    output[insertTo] = {\n      value: iterator.value\n    }\n\n    filledIndexes = [...filledIndexes, insertTo]\n\n    if (filledIndexes.length === sampleSize) {\n      break\n    }\n  }\n\n  if (filledIndexes.length < output.length) {\n    // Not a large enough dataset to fill the sample - trim empty values\n    output = output.filter((_, i) => filledIndexes.includes(i))\n  }\n\n  return output.map((o) => o.value)\n}\n\n/**\n * Replaces values in the output randomly with new ones from the dataset\n * @param {Iterable.<T>} datasetSource The iterable source of data\n * @param {Array.<T>} output The output so far, filled with data\n * @returns {Array.<T>} The random sample, as an array\n * @template T\n */\nfunction randomizeOutputFromDataset (datasetSource, output) {\n  const newOutput = [...output]\n  let readSoFar = output.length\n\n  while (true) {\n    const iterator = datasetSource.next()\n    if (iterator.done) break\n    readSoFar++\n\n    const insertTo = Math.floor(Math.random() * readSoFar)\n    if (insertTo < newOutput.length) {\n      newOutput[insertTo] = iterator.value\n    }\n  }\n\n  return newOutput\n}\n\n// Example\n\n/**\n * Generates a random range of data, with values between 0 and 2^31 - 1\n * @param {number} length The number of data items to generate\n * @returns {Iterable<number>} Random iterable data\n*/\nfunction * generateRandomData (length) {\n  const maxValue = Math.pow(2, 31) - 1\n  for (let i = 0; i < length; i++) {\n    yield Math.floor(Math.random() * maxValue)\n  }\n}\n\n// const source = generateRandomData(1000)\n// const result = shuf(source, 10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n\n# 参考\n\n * Sampling from a population of unknown size | by Andrea C. | Towards Data Science",normalizedContent:"# 介绍\n\n给定一个未知大小的数据集，按随机顺序获得一个随机样本。这通常被用于数据分析，作为一种从数据池或仓库或 csv 文件中获取小的随机样本的方法。\n\n\n# 实现\n\n\n# javascript\n\n/*\ngiven a data set of an unknown size, get a random sample in a random order\nit's used in data analytics, often as a way to get a small random sample from a data lake or warehouse, or from a large csv file\n*/\nfunction shuf (datasetsource, samplesize) {\n  const output = fillbasesample(datasetsource, samplesize)\n  return randomizeoutputfromdataset(datasetsource, output)\n}\n\n/**\n * fills the output if possible, with the minimum number of values\n * @param {iterable.<t>} datasetsource the iterable source of data\n * @param {number} samplesize the size of the sample to extract from the dataset\n * @returns {array.<t>} the random sample, as an array\n * @template t\n */\nfunction fillbasesample (datasetsource, samplesize) {\n  let filledindexes = []\n  let output = new array(samplesize)\n\n  // spread data out filling the array\n  while (true) {\n    const iterator = datasetsource.next()\n    if (iterator.done) break\n\n    let insertto = math.floor(math.random() * output.length)\n    while (filledindexes.includes(insertto)) {\n      insertto++\n      if (insertto === output.length) {\n        insertto = 0\n      }\n    }\n    output[insertto] = {\n      value: iterator.value\n    }\n\n    filledindexes = [...filledindexes, insertto]\n\n    if (filledindexes.length === samplesize) {\n      break\n    }\n  }\n\n  if (filledindexes.length < output.length) {\n    // not a large enough dataset to fill the sample - trim empty values\n    output = output.filter((_, i) => filledindexes.includes(i))\n  }\n\n  return output.map((o) => o.value)\n}\n\n/**\n * replaces values in the output randomly with new ones from the dataset\n * @param {iterable.<t>} datasetsource the iterable source of data\n * @param {array.<t>} output the output so far, filled with data\n * @returns {array.<t>} the random sample, as an array\n * @template t\n */\nfunction randomizeoutputfromdataset (datasetsource, output) {\n  const newoutput = [...output]\n  let readsofar = output.length\n\n  while (true) {\n    const iterator = datasetsource.next()\n    if (iterator.done) break\n    readsofar++\n\n    const insertto = math.floor(math.random() * readsofar)\n    if (insertto < newoutput.length) {\n      newoutput[insertto] = iterator.value\n    }\n  }\n\n  return newoutput\n}\n\n// example\n\n/**\n * generates a random range of data, with values between 0 and 2^31 - 1\n * @param {number} length the number of data items to generate\n * @returns {iterable<number>} random iterable data\n*/\nfunction * generaterandomdata (length) {\n  const maxvalue = math.pow(2, 31) - 1\n  for (let i = 0; i < length; i++) {\n    yield math.floor(math.random() * maxvalue)\n  }\n}\n\n// const source = generaterandomdata(1000)\n// const result = shuf(source, 10)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n\n# 参考\n\n * sampling from a population of unknown size | by andrea c. | towards data science",charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"SieveOfEratosthenes [埃拉托斯特尼筛法]",frontmatter:{title:"SieveOfEratosthenes [埃拉托斯特尼筛法]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/180SieveOfEratosthenes/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/180.SieveOfEratosthenes.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/180.SieveOfEratosthenes.md",key:"v-d2c44896",path:"/algorithm/dp/180SieveOfEratosthenes/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:187},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:470},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:477},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:80}],headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\n给定一个数 n，打印出所有小于或等于 n 的素数。\n\n当 n 小于 1000 万左右时，埃拉托斯特尼筛法是寻找所有小于 n 的素数的最有效方法之一（参考埃拉托斯特尼筛法 - Wikiwand）。\n\n埃拉托斯特尼筛法（英语：sieve of Eratosthenes ），简称埃氏筛，也称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的质数。所使用的原理是从 2 开始，将每个质数的各个倍数，标记成合数。一个质数的各个倍数，是一个差为此质数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以质数来测试每个待测数能否被整除。\n\n\n# 原理\n\n给出要筛数值的范围 n，找出n)\\sqrt{n})n ) 以内的素数p1,p2,…,pkp1,p2,\\dots ,pkp1,p2,…,pk。先用 2 去筛，即把 2 留下，把 2 的倍数剔除掉；再用下一个质数，也就是 3 筛，把 3 留下，把 3 的倍数剔除掉；接下去用下一个质数 5 筛，把 5 留下，把 5 的倍数剔除掉；不断重复下去......。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function SieveOfEratosthenes\n * @description Calculates prime numbers（素数） till input number n\n * @param {Number} n - The input integer\n * @return {Number[]} List of Primes till n.\n * @see [Sieve_of_Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)\n */\nfunction sieveOfEratosthenes (n) {\n  if (n <= 1) return []\n  const primes = new Array(n + 1).fill(true) // set all as true initially\n  primes[0] = primes[1] = false // Handling case for 0 and 1\n  for (let i = 2; i * i <= n; i++) {\n    if (primes[i]) {\n      for (let j = i * i; j <= n; j += i) primes[j] = false\n    }\n  }\n\n  return primes.reduce((result, isPrime, index) => {\n    if (isPrime) result.push(index)\n    return result\n  }, [])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 参考\n\n * Sieve of Eratosthenes - Wikiwand\n * 埃拉托斯特尼筛法 - Wikiwand",normalizedContent:"# 介绍\n\n给定一个数 n，打印出所有小于或等于 n 的素数。\n\n当 n 小于 1000 万左右时，埃拉托斯特尼筛法是寻找所有小于 n 的素数的最有效方法之一（参考埃拉托斯特尼筛法 - wikiwand）。\n\n埃拉托斯特尼筛法（英语：sieve of eratosthenes ），简称埃氏筛，也称素数筛。这是一种简单且历史悠久的筛法，用来找出一定范围内所有的质数。所使用的原理是从 2 开始，将每个质数的各个倍数，标记成合数。一个质数的各个倍数，是一个差为此质数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以质数来测试每个待测数能否被整除。\n\n\n# 原理\n\n给出要筛数值的范围 n，找出n)\\sqrt{n})n ) 以内的素数p1,p2,…,pkp1,p2,\\dots ,pkp1,p2,…,pk。先用 2 去筛，即把 2 留下，把 2 的倍数剔除掉；再用下一个质数，也就是 3 筛，把 3 留下，把 3 的倍数剔除掉；接下去用下一个质数 5 筛，把 5 留下，把 5 的倍数剔除掉；不断重复下去......。\n\n\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function sieveoferatosthenes\n * @description calculates prime numbers（素数） till input number n\n * @param {number} n - the input integer\n * @return {number[]} list of primes till n.\n * @see [sieve_of_eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)\n */\nfunction sieveoferatosthenes (n) {\n  if (n <= 1) return []\n  const primes = new array(n + 1).fill(true) // set all as true initially\n  primes[0] = primes[1] = false // handling case for 0 and 1\n  for (let i = 2; i * i <= n; i++) {\n    if (primes[i]) {\n      for (let j = i * i; j <= n; j += i) primes[j] = false\n    }\n  }\n\n  return primes.reduce((result, isprime, index) => {\n    if (isprime) result.push(index)\n    return result\n  }, [])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 参考\n\n * sieve of eratosthenes - wikiwand\n * 埃拉托斯特尼筛法 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"SlidingWindow [滑窗]",frontmatter:{title:"SlidingWindow [滑窗]",date:"2022-10-18T09:49:43.000Z",permalink:"/algorithm/dp/slidingWindow/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/190.SlidingWindow.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/190.SlidingWindow.md",key:"v-0bb20215",path:"/algorithm/dp/slidingWindow/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:459},{level:3,title:"最长不重复子串",slug:"最长不重复子串",normalizedTitle:"最长不重复子串",charIndex:466},{level:3,title:"是否包含排列",slug:"是否包含排列",normalizedTitle:"是否包含排列",charIndex:1211},{level:3,title:"最大和子数组",slug:"最大和子数组",normalizedTitle:"最大和子数组",charIndex:2762},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3145}],headersStr:"介绍 案例 最长不重复子串 是否包含排列 最大和子数组 参考",content:'# 介绍\n\n滑窗技术是一种计算技术，其目的是减少嵌套循环的使用，用单个循环代替，从而降低时间复杂性。\n\n什么是滑窗？考虑一条连接在一起的长链。假设你想用你的手在整条链条上涂油，而不从上面倒油。一种方法是：将一些油涂抹在链条的一个部分，然后再次将一些油涂在下一个尚未涂油的部分，以此类推，直到整条链条都上了油。另一种方法是用一块布，蘸上油，然后用这块布抓住链条的一端。然后不用再重复蘸油，只需用手将布滑到下一节，再下一节，以此类推，直到另一端。\n\n第二种方法被称为滑动窗口技术，从一端滑动到另一端的部分，被称为滑动窗口（Sliding Window）。\n\n使用滑动窗口技术的先决条件：\n\n滑动窗口技术的使用可以在一个非常特殊的情况下进行，在整个嵌套循环中，计算窗口的大小是固定的。只有这样才能降低时间的复杂性。\n\n如何使用滑动窗口技术？\n\n滑动窗口技术的一般使用方法可以演示如下：\n\n * 找到所需的窗口大小。\n * 从数据结构的开始计算第一个窗口的结果。\n * 然后用一个循环来滑动窗口，并继续逐窗计算结果。\n\n\n# 案例\n\n\n# 最长不重复子串\n\n获取不含重复字符的最长子串的长度。\n\n/**\n * @function LongestSubstringWithoutRepeatingCharacters\n * @description Get the length of the longest substring without repeating characters\n * @param {String} s - The input string\n */\nfunction LongestSubstringWithoutRepeatingCharacters (s) {\n  let maxLength = 0\n  let start = 0\n  let end = 0\n  const map = {}\n  while (end < s.length) {\n    if (map[s[end]] === undefined) {\n      map[s[end]] = 1\n      maxLength = Math.max(maxLength, end - start + 1)\n      end++\n    } else {\n      while (s[start] !== s[end]) {\n        delete map[s[start]]\n        start++\n      }\n      delete map[s[start]]\n      start++\n    }\n  }\n  return maxLength\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 是否包含排列\n\n给定两个字符串 s1 和 s2，如果 s2 包含 s1 的排列，则返回真，否则返回假。\n\n/**\n * @function PermutationinString\n * @description Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n * @param {String} s1 - The input string\n * @param {String} s2 - The input string\n * @return {boolean} - Returns true if s2 contains a permutation of s1, or false otherwise.\n */\n\nfunction PermutationinString (s1, s2) {\n  if (s1.length > s2.length) return false\n  let start = 0\n  let end = s1.length - 1\n  const s1Set = SetHash()\n  const s2Set = SetHash()\n  for (let i = 0; i < s1.length; i++) {\n    s1Set[s1[i]]++\n    s2Set[s2[i]]++\n  }\n  if (equals(s1Set, s2Set)) return true\n  while (end < s2.length - 1) {\n    if (equals(s1Set, s2Set)) return true\n    end++\n    const c1 = s2[start]\n    const c2 = s2[end]\n    if (s2Set[c1] > 0) s2Set[c1]--\n    s2Set[c2]++\n    start++\n    if (equals(s1Set, s2Set)) return true\n  }\n  return false\n}\nfunction equals (a, b) {\n  return JSON.stringify(a) === JSON.stringify(b)\n}\n\nfunction SetHash () {\n  const set = new Set()\n  const alphabets = \'abcdefghijklmnopqrstuvwxyz\'\n  for (let i = 0; i < alphabets.length; i++) {\n    set[alphabets[i]] = 0\n  }\n  return set\n}\n\n// Example 1:\n// Input: s1 = "ab", s2 = "eidbaooo"\n// Output: true\n// Explanation: s2 contains one permutation of s1 ("ba").\n\n// Example 2:\n// Input: s1 = "ab", s2 = "eidboaoo"\n// Output: false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 最大和子数组\n\n给定一个正整数数组和一个正数 k，找到长度为 k 的连续子数组的最大和。\n\ndef getMaxSum(arr, k): \n    maxSum = 0 \n    windowSum = 0 \n    start = 0 \n\n    for i in range(len(arr)): \n        windowSum += arr[i] \n\n        if ((i - start + 1) == k): \n            maxSum = max(maxSum, windowSum) \n            windowSum -= arr[start] \n            start += 1 \n\n    return maxSum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 参考\n\n * Window Sliding Technique - GeeksforGeeks\n * 一文详解滑动窗口技术 - 知乎',normalizedContent:'# 介绍\n\n滑窗技术是一种计算技术，其目的是减少嵌套循环的使用，用单个循环代替，从而降低时间复杂性。\n\n什么是滑窗？考虑一条连接在一起的长链。假设你想用你的手在整条链条上涂油，而不从上面倒油。一种方法是：将一些油涂抹在链条的一个部分，然后再次将一些油涂在下一个尚未涂油的部分，以此类推，直到整条链条都上了油。另一种方法是用一块布，蘸上油，然后用这块布抓住链条的一端。然后不用再重复蘸油，只需用手将布滑到下一节，再下一节，以此类推，直到另一端。\n\n第二种方法被称为滑动窗口技术，从一端滑动到另一端的部分，被称为滑动窗口（sliding window）。\n\n使用滑动窗口技术的先决条件：\n\n滑动窗口技术的使用可以在一个非常特殊的情况下进行，在整个嵌套循环中，计算窗口的大小是固定的。只有这样才能降低时间的复杂性。\n\n如何使用滑动窗口技术？\n\n滑动窗口技术的一般使用方法可以演示如下：\n\n * 找到所需的窗口大小。\n * 从数据结构的开始计算第一个窗口的结果。\n * 然后用一个循环来滑动窗口，并继续逐窗计算结果。\n\n\n# 案例\n\n\n# 最长不重复子串\n\n获取不含重复字符的最长子串的长度。\n\n/**\n * @function longestsubstringwithoutrepeatingcharacters\n * @description get the length of the longest substring without repeating characters\n * @param {string} s - the input string\n */\nfunction longestsubstringwithoutrepeatingcharacters (s) {\n  let maxlength = 0\n  let start = 0\n  let end = 0\n  const map = {}\n  while (end < s.length) {\n    if (map[s[end]] === undefined) {\n      map[s[end]] = 1\n      maxlength = math.max(maxlength, end - start + 1)\n      end++\n    } else {\n      while (s[start] !== s[end]) {\n        delete map[s[start]]\n        start++\n      }\n      delete map[s[start]]\n      start++\n    }\n  }\n  return maxlength\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 是否包含排列\n\n给定两个字符串 s1 和 s2，如果 s2 包含 s1 的排列，则返回真，否则返回假。\n\n/**\n * @function permutationinstring\n * @description given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n * @param {string} s1 - the input string\n * @param {string} s2 - the input string\n * @return {boolean} - returns true if s2 contains a permutation of s1, or false otherwise.\n */\n\nfunction permutationinstring (s1, s2) {\n  if (s1.length > s2.length) return false\n  let start = 0\n  let end = s1.length - 1\n  const s1set = sethash()\n  const s2set = sethash()\n  for (let i = 0; i < s1.length; i++) {\n    s1set[s1[i]]++\n    s2set[s2[i]]++\n  }\n  if (equals(s1set, s2set)) return true\n  while (end < s2.length - 1) {\n    if (equals(s1set, s2set)) return true\n    end++\n    const c1 = s2[start]\n    const c2 = s2[end]\n    if (s2set[c1] > 0) s2set[c1]--\n    s2set[c2]++\n    start++\n    if (equals(s1set, s2set)) return true\n  }\n  return false\n}\nfunction equals (a, b) {\n  return json.stringify(a) === json.stringify(b)\n}\n\nfunction sethash () {\n  const set = new set()\n  const alphabets = \'abcdefghijklmnopqrstuvwxyz\'\n  for (let i = 0; i < alphabets.length; i++) {\n    set[alphabets[i]] = 0\n  }\n  return set\n}\n\n// example 1:\n// input: s1 = "ab", s2 = "eidbaooo"\n// output: true\n// explanation: s2 contains one permutation of s1 ("ba").\n\n// example 2:\n// input: s1 = "ab", s2 = "eidboaoo"\n// output: false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 最大和子数组\n\n给定一个正整数数组和一个正数 k，找到长度为 k 的连续子数组的最大和。\n\ndef getmaxsum(arr, k): \n    maxsum = 0 \n    windowsum = 0 \n    start = 0 \n\n    for i in range(len(arr)): \n        windowsum += arr[i] \n\n        if ((i - start + 1) == k): \n            maxsum = max(maxsum, windowsum) \n            windowsum -= arr[start] \n            start += 1 \n\n    return maxsum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 参考\n\n * window sliding technique - geeksforgeeks\n * 一文详解滑动窗口技术 - 知乎',charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"CoinChange [钱币兑换]",frontmatter:{title:"CoinChange [钱币兑换]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/coinChange/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20.CoinChange.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/20.CoinChange.md",key:"v-1dc711f5",path:"/algorithm/dp/coinChange/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"递归法",slug:"递归法",normalizedTitle:"递归法",charIndex:85},{level:2,title:"动态规划法",slug:"动态规划法",normalizedTitle:"动态规划法",charIndex:1335},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:90},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4186}],headersStr:"介绍 递归法 动态规划法 应用 参考",content:'# 介绍\n\n给出一个大小为 N 的硬币的整数数组 coins [] ，代表不同类型的货币和一个整数的总和 sum，任务是通过使用硬币的不同组合来找出求和的方法。\n\n\n# 递归法\n\n应用递归来遍历数组，并不断寻找可能的方式来找到出现的情况。\n\n遵循以下步骤：\n\n * 对于一个特定面额的硬币，我们有两个选择，一是包括，二是排除。\n * 如果我们在 coins[n-1] ，我们可以尽可能多地选择该硬币的实例（无限制的包含），即 count(coins, n, sum - coins[n-1]) ；然后我们移动到 coins[n-2] 。\n * 在移动到硬币 [n-2] 之后，我们不能再往回移动，也不能对硬币 [n-1] 进行选择，即 count(coins, n-1, sum) 。\n * 最后，由于我们要找出总的方法，所以我们要把这两个可能的选择加起来，即 count(coins, n, sum - coins[n-1] ) + count(coins, n-1, sum ) 。\n\nJavaScript：\n\n// Returns the count of ways we can sum coins[0...n-1] coins to get sum "sum"\nfunction count(coins , n , sum ) {\n    // If sum is 0 then there is 1 solution (do not include any coin)\n    if (sum == 0) return 1;\n    // If sum is less than 0 then no solution exists\n    if (sum < 0) return 0; \n    // If there are no coins and sum is greater than 0, then no solution exist\n    if (n <=0) return 0;\n    // count is sum of solutions (i) including coins[n-1] (ii) excluding coins[n-1]\n    return count( coins, n - 1, sum ) + count( coins, n, sum - coins[n - 1] );\n}\n \n// Driver program to test above function\nvar coins = [1, 2, 3];\nvar n = coins.length;\ndocument.write( count(coins, n, 4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 时间复杂度：O (2sum)\n * 辅助空间：O (target)\n\n由于相同的子问题被再次调用，这个问题具有重叠子问题的特性。所以硬币变化问题具有动态规划问题的两个属性。像其他典型的动态编程 (DP) 问题一样，可以通过自下而上的方式构造一个临时数组表来避免相同子问题的重新计算。\n\n\n# 动态规划法\n\n解决这个问题的想法是通过使用自下而上的记忆法（Bottom Up Memoization）。以下是解决这个问题的自下而上的方法。\n\n按照下面的步骤：\n\n * 使用二维矢量来存储重叠的子问题（Overlapping subproblems）。\n * 遍历整个数组以找到解决方案并存储在缓存表（memoization table）中。\n * 使用缓存表来寻找最佳解决方案。\n\nJavaScript：\n\n/* Dynamic Programming javascript implementation of Coin Change problem */\nfunction countWays(coins , n , sum) {\n  // table[i] will be storing the number of solutions for value i. We need sum+1 rows as the table is\n  // constructed in bottom up manner using the base case (sum = 0)\n  // Initialize all table values as 0\n  const table = Array(sum+1).fill(0);\n  // Base case (If given value is 0)\n  table[0] = 1;\n\n  // Pick all coins one by one and update the table values after the index greater than or equal to the value of the picked coin\n  for (i=0; i<n; i++)\n    for (j=coins[i]; j<=sum; j++)\n      table[j] += table[j-coins[i]];\n\n  return table[sum];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n或者：\n\n/**\n * @params {Array} coins\n * @params {Number} amount\n */\nconst change = (coins, amount) => {\n  // Create and initialize the storage\n  const combinations = new Array(amount + 1).fill(0)\n  combinations[0] = 1\n  // Determine the direction of smallest sub-problem\n  for (let i = 0; i < coins.length; i++) {\n    // Travel and fill the combinations array\n    for (let j = coins[i]; j < combinations.length; j++) {\n      combinations[j] += combinations[j - coins[i]]\n    }\n  }\n  return combinations[amount]\n}\n/**\n * @params {Array} coins\n * @params {Number} amount\n */\nexport const coinChangeMin = (coins, amount) => {\n  const map = { 0: 1 }\n  for (let i = 1; i <= amount; i++) {\n    let min = Infinity\n    for (const coin of coins) {\n      if (i < coin) continue\n      min = Math.min(min, 1 + map[i - coin])\n    }\n    map[i] = min\n  }\n  return map[amount] === Infinity ? -1 : map[amount] - 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 应用\n\n给定不同面值的硬币和总金额，你必须返回组成该金额所需的最少的硬币，如果不可能组成该金额，则返回 - 1。注意，我们有无限量的每种类型的硬币。\n\n递归法：\n\n检查每个硬币组合的给定金额。在这种方法中，我们可以使用递归来解决这个问题，因为我们必须遍历所有可能的硬币组合，每次都要更新产生这个总和所需的最小硬币数量。\n\nint coinChange(vector<int> const &S, int sum) {\n  if (sum == 0) return 0;\n  if (sum < 0) return INT_MAX;\n  int coins = INT_MAX;\n  for (int i: S) {\n    int result = coinChange(S, sum - i);\n    if (result != INT_MAX) coins = min(coins, result + 1);\n  }\n  return coins;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n动态规划法：\n\n由于该问题可以被分解成更小的子问题，因为在递归树中有许多重叠的子问题，我们将避免重复解决这些问题。我们采用自下而上的方法，即先解决小问题，然后从小问题转到较大的子问题，因为我们将计算 dp[i] (1<=i<=subproblems)，将答案存储为创建和所需的最少硬币。\n\nint coinChange(vector<int> const &arr, int sum) {\n  int dp[sum + 1];\n  for (int i = 1; i <= sum; i++) {\n    dp[i] = INT_MAX;\n    int result = INT_MAX;\n\n    for (int c: arr) {\n      if (i - c >= 0) result = dp[i - c];\n      if (result != INT_MAX) dp[i] = min(dp[i], result + 1);\n    }\n  }\n\n    return dp[sum];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 参考\n\n * Coin Change Problem - InterviewBit\n * Coin Change | DP-7 - GeeksforGeeks\n * Understanding The Coin Change Problem With Dynamic Programming - GeeksforGeeks',normalizedContent:'# 介绍\n\n给出一个大小为 n 的硬币的整数数组 coins [] ，代表不同类型的货币和一个整数的总和 sum，任务是通过使用硬币的不同组合来找出求和的方法。\n\n\n# 递归法\n\n应用递归来遍历数组，并不断寻找可能的方式来找到出现的情况。\n\n遵循以下步骤：\n\n * 对于一个特定面额的硬币，我们有两个选择，一是包括，二是排除。\n * 如果我们在 coins[n-1] ，我们可以尽可能多地选择该硬币的实例（无限制的包含），即 count(coins, n, sum - coins[n-1]) ；然后我们移动到 coins[n-2] 。\n * 在移动到硬币 [n-2] 之后，我们不能再往回移动，也不能对硬币 [n-1] 进行选择，即 count(coins, n-1, sum) 。\n * 最后，由于我们要找出总的方法，所以我们要把这两个可能的选择加起来，即 count(coins, n, sum - coins[n-1] ) + count(coins, n-1, sum ) 。\n\njavascript：\n\n// returns the count of ways we can sum coins[0...n-1] coins to get sum "sum"\nfunction count(coins , n , sum ) {\n    // if sum is 0 then there is 1 solution (do not include any coin)\n    if (sum == 0) return 1;\n    // if sum is less than 0 then no solution exists\n    if (sum < 0) return 0; \n    // if there are no coins and sum is greater than 0, then no solution exist\n    if (n <=0) return 0;\n    // count is sum of solutions (i) including coins[n-1] (ii) excluding coins[n-1]\n    return count( coins, n - 1, sum ) + count( coins, n, sum - coins[n - 1] );\n}\n \n// driver program to test above function\nvar coins = [1, 2, 3];\nvar n = coins.length;\ndocument.write( count(coins, n, 4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 时间复杂度：o (2sum)\n * 辅助空间：o (target)\n\n由于相同的子问题被再次调用，这个问题具有重叠子问题的特性。所以硬币变化问题具有动态规划问题的两个属性。像其他典型的动态编程 (dp) 问题一样，可以通过自下而上的方式构造一个临时数组表来避免相同子问题的重新计算。\n\n\n# 动态规划法\n\n解决这个问题的想法是通过使用自下而上的记忆法（bottom up memoization）。以下是解决这个问题的自下而上的方法。\n\n按照下面的步骤：\n\n * 使用二维矢量来存储重叠的子问题（overlapping subproblems）。\n * 遍历整个数组以找到解决方案并存储在缓存表（memoization table）中。\n * 使用缓存表来寻找最佳解决方案。\n\njavascript：\n\n/* dynamic programming javascript implementation of coin change problem */\nfunction countways(coins , n , sum) {\n  // table[i] will be storing the number of solutions for value i. we need sum+1 rows as the table is\n  // constructed in bottom up manner using the base case (sum = 0)\n  // initialize all table values as 0\n  const table = array(sum+1).fill(0);\n  // base case (if given value is 0)\n  table[0] = 1;\n\n  // pick all coins one by one and update the table values after the index greater than or equal to the value of the picked coin\n  for (i=0; i<n; i++)\n    for (j=coins[i]; j<=sum; j++)\n      table[j] += table[j-coins[i]];\n\n  return table[sum];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n或者：\n\n/**\n * @params {array} coins\n * @params {number} amount\n */\nconst change = (coins, amount) => {\n  // create and initialize the storage\n  const combinations = new array(amount + 1).fill(0)\n  combinations[0] = 1\n  // determine the direction of smallest sub-problem\n  for (let i = 0; i < coins.length; i++) {\n    // travel and fill the combinations array\n    for (let j = coins[i]; j < combinations.length; j++) {\n      combinations[j] += combinations[j - coins[i]]\n    }\n  }\n  return combinations[amount]\n}\n/**\n * @params {array} coins\n * @params {number} amount\n */\nexport const coinchangemin = (coins, amount) => {\n  const map = { 0: 1 }\n  for (let i = 1; i <= amount; i++) {\n    let min = infinity\n    for (const coin of coins) {\n      if (i < coin) continue\n      min = math.min(min, 1 + map[i - coin])\n    }\n    map[i] = min\n  }\n  return map[amount] === infinity ? -1 : map[amount] - 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 应用\n\n给定不同面值的硬币和总金额，你必须返回组成该金额所需的最少的硬币，如果不可能组成该金额，则返回 - 1。注意，我们有无限量的每种类型的硬币。\n\n递归法：\n\n检查每个硬币组合的给定金额。在这种方法中，我们可以使用递归来解决这个问题，因为我们必须遍历所有可能的硬币组合，每次都要更新产生这个总和所需的最小硬币数量。\n\nint coinchange(vector<int> const &s, int sum) {\n  if (sum == 0) return 0;\n  if (sum < 0) return int_max;\n  int coins = int_max;\n  for (int i: s) {\n    int result = coinchange(s, sum - i);\n    if (result != int_max) coins = min(coins, result + 1);\n  }\n  return coins;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n动态规划法：\n\n由于该问题可以被分解成更小的子问题，因为在递归树中有许多重叠的子问题，我们将避免重复解决这些问题。我们采用自下而上的方法，即先解决小问题，然后从小问题转到较大的子问题，因为我们将计算 dp[i] (1<=i<=subproblems)，将答案存储为创建和所需的最少硬币。\n\nint coinchange(vector<int> const &arr, int sum) {\n  int dp[sum + 1];\n  for (int i = 1; i <= sum; i++) {\n    dp[i] = int_max;\n    int result = int_max;\n\n    for (int c: arr) {\n      if (i - c >= 0) result = dp[i - c];\n      if (result != int_max) dp[i] = min(dp[i], result + 1);\n    }\n  }\n\n    return dp[sum];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 参考\n\n * coin change problem - interviewbit\n * coin change | dp-7 - geeksforgeeks\n * understanding the coin change problem with dynamic programming - geeksforgeeks',charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"SudokuSolver [数独]",frontmatter:{title:"SudokuSolver [数独]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/sudokuSolver/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/200.SudokuSolver.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/200.SudokuSolver.md",key:"v-7c5caa77",path:"/algorithm/dp/sudokuSolver/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1413}],headersStr:"实现 JavaScript 参考",content:"# 实现\n\n\n# JavaScript\n\nconst isValid = (board, row, col, k) => {\n  for (let i = 0; i < 9; i++) {\n    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)\n    const n = 3 * Math.floor(col / 3) + i % 3\n    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {\n      return false\n    }\n  }\n  return true\n}\n\nconst sudokuSolver = (data) => {\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n      if (data[i][j] === '.') {\n        for (let k = 1; k <= 9; k++) {\n          if (isValid(data, i, j, `${k}`)) {\n            data[i][j] = `${k}`\n            if (sudokuSolver(data)) return true\n            else data[i][j] = '.'\n          }\n        }\n        return false\n      }\n    }\n  }\n  return true\n}\n\n// testing\n\n// const board = [\n//   ['.', '9', '.', '.', '4', '2', '1', '3', '6'],\n//   ['.', '.', '.', '9', '6', '.', '4', '8', '5'],\n//   ['.', '.', '.', '5', '8', '1', '.', '.', '.'],\n//   ['.', '.', '4', '.', '.', '.', '.', '.', '.'],\n//   ['5', '1', '7', '2', '.', '.', '9', '.', '.'],\n//   ['6', '.', '2', '.', '.', '.', '3', '7', '.'],\n//   ['1', '.', '.', '8', '.', '4', '.', '2', '.'],\n//   ['7', '.', '6', '.', '.', '.', '8', '1', '.'],\n//   ['3', '.', '.', '.', '9', '.', '.', '.', '.']\n// ]\n// sudokuSolver(board) // -> board updated by reference\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * Sudoku [数独] | Fancy DSA",normalizedContent:"# 实现\n\n\n# javascript\n\nconst isvalid = (board, row, col, k) => {\n  for (let i = 0; i < 9; i++) {\n    const m = 3 * math.floor(row / 3) + math.floor(i / 3)\n    const n = 3 * math.floor(col / 3) + i % 3\n    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {\n      return false\n    }\n  }\n  return true\n}\n\nconst sudokusolver = (data) => {\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n      if (data[i][j] === '.') {\n        for (let k = 1; k <= 9; k++) {\n          if (isvalid(data, i, j, `${k}`)) {\n            data[i][j] = `${k}`\n            if (sudokusolver(data)) return true\n            else data[i][j] = '.'\n          }\n        }\n        return false\n      }\n    }\n  }\n  return true\n}\n\n// testing\n\n// const board = [\n//   ['.', '9', '.', '.', '4', '2', '1', '3', '6'],\n//   ['.', '.', '.', '9', '6', '.', '4', '8', '5'],\n//   ['.', '.', '.', '5', '8', '1', '.', '.', '.'],\n//   ['.', '.', '4', '.', '.', '.', '.', '.', '.'],\n//   ['5', '1', '7', '2', '.', '.', '9', '.', '.'],\n//   ['6', '.', '2', '.', '.', '.', '3', '7', '.'],\n//   ['1', '.', '.', '8', '.', '4', '.', '2', '.'],\n//   ['7', '.', '6', '.', '.', '.', '8', '1', '.'],\n//   ['3', '.', '.', '.', '9', '.', '.', '.', '.']\n// ]\n// sudokusolver(board) // -> board updated by reference\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * sudoku [数独] | fancy dsa",charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"TrappingRainWater [接住雨水]",frontmatter:{title:"TrappingRainWater [接住雨水]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/trappingRainWater/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/210.TrappingRainWater.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/210.TrappingRainWater.md",key:"v-3b854396",path:"/algorithm/dp/trappingRainWater/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:62},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:69}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @param {number[]} height\n * @return {number}\n */\n\n/* 42. Trapping Rain Water\nhttps://leetcode.com/problems/trapping-rain-water/\n\nHelpful animation of this prompt: https://youtu.be/HmBbcDiJapY?t=51\n\nGiven n non-negative integers representing an elevation map where\nthe width of each bar is 1, compute how much water it is able to trap\nafter raining.\n\nVIEW ELEVATION MAP ON LEETCODE\n\nExample:\n\nInput:            [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n\nPlan:\niterate through and find left maxes\niterate through and find right maxes\ncreate minheight and assign it to the min(leftmax, rightmax)\nif current height(element) < minheight\n  push minheight - height into water array\nelse\n  push 0 onto water array\n\nsum up water array and return\n\nleft maxes =      [0,0,1,1,2,2,2,2,3,3,3,3]\nright maxes =     [3,3,3,3,3,3,3,2,2,2,1,0]\nwater contained = [0,0,1,0,1,2,1,0,0,1,0,0] -> sum = 6\n*/\n\nconst trap = (heights) => {\n  const maxes = new Array(heights.length).fill(0)\n\n  let leftMax = 0\n  for (let i = 0; i < heights.length; i++) {\n    const height = heights[i]\n    maxes[i] = leftMax\n    leftMax = Math.max(leftMax, height)\n  }\n\n  let rightMax = 0\n  for (let i = heights.length - 1; i >= 0; i -= 1) {\n    const height = heights[i]\n    const minHeight = Math.min(rightMax, maxes[i])\n\n    if (height < minHeight) maxes[i] = minHeight - height\n    else maxes[i] = 0\n    rightMax = Math.max(rightMax, height)\n  }\n  return maxes.reduce((a, b) => a + b, 0)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n",normalizedContent:"# 介绍\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @param {number[]} height\n * @return {number}\n */\n\n/* 42. trapping rain water\nhttps://leetcode.com/problems/trapping-rain-water/\n\nhelpful animation of this prompt: https://youtu.be/hmbbcdijapy?t=51\n\ngiven n non-negative integers representing an elevation map where\nthe width of each bar is 1, compute how much water it is able to trap\nafter raining.\n\nview elevation map on leetcode\n\nexample:\n\ninput:            [0,1,0,2,1,0,1,3,2,1,2,1]\noutput: 6\n\nplan:\niterate through and find left maxes\niterate through and find right maxes\ncreate minheight and assign it to the min(leftmax, rightmax)\nif current height(element) < minheight\n  push minheight - height into water array\nelse\n  push 0 onto water array\n\nsum up water array and return\n\nleft maxes =      [0,0,1,1,2,2,2,2,3,3,3,3]\nright maxes =     [3,3,3,3,3,3,3,2,2,2,1,0]\nwater contained = [0,0,1,0,1,2,1,0,0,1,0,0] -> sum = 6\n*/\n\nconst trap = (heights) => {\n  const maxes = new array(heights.length).fill(0)\n\n  let leftmax = 0\n  for (let i = 0; i < heights.length; i++) {\n    const height = heights[i]\n    maxes[i] = leftmax\n    leftmax = math.max(leftmax, height)\n  }\n\n  let rightmax = 0\n  for (let i = heights.length - 1; i >= 0; i -= 1) {\n    const height = heights[i]\n    const minheight = math.min(rightmax, maxes[i])\n\n    if (height < minheight) maxes[i] = minheight - height\n    else maxes[i] = 0\n    rightmax = math.max(rightmax, height)\n  }\n  return maxes.reduce((a, b) => a + b, 0)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n",charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"TribonacciNumber [翠波那契数]",frontmatter:{title:"TribonacciNumber [翠波那契数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/tribonacciNumber/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/220.TribonacciNumber.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/220.TribonacciNumber.md",key:"v-494ae7f9",path:"/algorithm/dp/tribonacciNumber/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:357},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4103}],headersStr:"介绍 实现 参考",content:"# 介绍\n\n泰波那契数列是斐波那契数列的一般化，其中每项都是前面三项的总和。其一般形式为 a(n) = a(n-1) + a(n-2) + a(n-3) 。\n\n翠波那契序列：\n\n0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852... 以此类推。\n\n\n# 实现\n\n一个简单的解决方案是递归。\n\n// A simple recursive Javascript program to print first n Tribinocci numbers.\n \nfunction printTribRec(n) {\n    if (n == 0 || n == 1 || n == 2) return 0;\n    if (n == 3) return 1;\n    return printTribRec(n - 1) + printTribRec(n - 2) + printTribRec(n - 3);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用动态规划：\n\nTop-Down Dp Memoization：\n\nfunction printTribRec(n, dp) {\n    if (n == 0 || n == 1 || n == 2) return 0;\n    if(dp[n] != -1) return dp[n];\n    if (n == 3) return 1;\n    return dp[n] = printTribRec(n - 1, dp) + printTribRec(n - 2, dp) + printTribRec(n - 3, dp);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nBottom-Up DP Tabulation：\n\nfunction printTrib(n) {\n  let dp = Array.from({length: n}, (_, i) => 0);\n  dp[0] = dp[1] = 0;\n  dp[2] = 1;\n\n  for (let i = 3; i < n; i++) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n  return dp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n或者：\n\n/**\n * @function Tribonacci\n * @description Tribonacci is the sum of previous three tribonacci numbers.\n * @param {Integer} n - The input integer\n * @return {Integer} tribonacci of n.\n * @see [Tribonacci_Numbers](https://www.geeksforgeeks.org/tribonacci-numbers/)\n */\nconst tribonacci = (n) => {\n  // creating array to store previous tribonacci numbers\n  const dp = new Array(n + 1)\n  dp[0] = 0\n  dp[1] = 1\n  dp[2] = 1\n  for (let i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n  return dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上述的时间复杂度是线性的，但它需要额外的空间。我们可以使用三个变量来跟踪前三个数字，以优化上述解决方案的空间。\n\n// A space optimized based Javascript program to print first n Tribonacci numbers.\nfunction printTrib(n) {\n    if (n < 1) return;\n    // Initialize first three numbers\n    let first = 0, second = 0, third = 1;\n    // Loop to add previous three numbers for each number starting from 3 and then assign first, second, third to second, third, and curr to third respectively\n    for (let i = 3; i < n; i++) {\n      let curr = first + second + third;\n      first = second;\n      second = third;\n      third = curr;\n    }\n\n    return third;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n更有效的解决方案：使用矩阵指数化。\n\n// javascript Program to print first n tribonacci numbers\n// Matrix Multiplication function for 3*3 matrix\nfunction multiply(T , M) {\n    var a, b, c, d, e, f, g, h, i;\n    a = T[0][0] * M[0][0] + T[0][1] * M[1][0] + T[0][2] * M[2][0];\n    b = T[0][0] * M[0][1] + T[0][1] * M[1][1] + T[0][2] * M[2][1];\n    c = T[0][0] * M[0][2] + T[0][1] * M[1][2] + T[0][2] * M[2][2];\n    d = T[1][0] * M[0][0] + T[1][1] * M[1][0] + T[1][2] * M[2][0];\n    e = T[1][0] * M[0][1] + T[1][1] * M[1][1] + T[1][2] * M[2][1];\n    f = T[1][0] * M[0][2] + T[1][1] * M[1][2] + T[1][2] * M[2][2];\n    g = T[2][0] * M[0][0] + T[2][1] * M[1][0] + T[2][2] * M[2][0];\n    h = T[2][0] * M[0][1] + T[2][1] * M[1][1] + T[2][2] * M[2][1];\n    i = T[2][0] * M[0][2] + T[2][1] * M[1][2] + T[2][2] * M[2][2];\n    T[0][0] = a;\n    T[0][1] = b;\n    T[0][2] = c;\n    T[1][0] = d;\n    T[1][1] = e;\n    T[1][2] = f;\n    T[2][0] = g;\n    T[2][1] = h;\n    T[2][2] = i;\n}\n \n// Recursive function to raise the matrix T to the power n\nfunction power(T , n) {\n    // base condition.\n    if (n == 0 || n == 1) return;\n    var M = [[ 1, 1, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ]];\n    // recursively call to square the matrix\n    power(T, parseInt(n / 2));\n    // calculating square of the matrix T\n    multiply(T, T);\n    // if n is odd multiply it one time with M\n    if (n % 2 != 0) multiply(T, M);\n}\nfunction tribonacci(n) {\n    var T = [[ 1, 1, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ]];\n    // base condition\n    if (n == 0 || n == 1) return 0;\n    else power(T, n - 2);\n    // T[0][0] contains the tribonacci number so return it\n    return T[0][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n参考：Matrix Exponentiation - GeeksforGeeks。\n\n\n# 参考\n\n * Tribonacci Numbers - GeeksforGeeks\n * Tribonacci Number -- from Wolfram MathWorld\n * Fibonacci Number -- from Wolfram MathWorld",normalizedContent:"# 介绍\n\n泰波那契数列是斐波那契数列的一般化，其中每项都是前面三项的总和。其一般形式为 a(n) = a(n-1) + a(n-2) + a(n-3) 。\n\n翠波那契序列：\n\n0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852... 以此类推。\n\n\n# 实现\n\n一个简单的解决方案是递归。\n\n// a simple recursive javascript program to print first n tribinocci numbers.\n \nfunction printtribrec(n) {\n    if (n == 0 || n == 1 || n == 2) return 0;\n    if (n == 3) return 1;\n    return printtribrec(n - 1) + printtribrec(n - 2) + printtribrec(n - 3);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用动态规划：\n\ntop-down dp memoization：\n\nfunction printtribrec(n, dp) {\n    if (n == 0 || n == 1 || n == 2) return 0;\n    if(dp[n] != -1) return dp[n];\n    if (n == 3) return 1;\n    return dp[n] = printtribrec(n - 1, dp) + printtribrec(n - 2, dp) + printtribrec(n - 3, dp);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nbottom-up dp tabulation：\n\nfunction printtrib(n) {\n  let dp = array.from({length: n}, (_, i) => 0);\n  dp[0] = dp[1] = 0;\n  dp[2] = 1;\n\n  for (let i = 3; i < n; i++) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n  return dp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n或者：\n\n/**\n * @function tribonacci\n * @description tribonacci is the sum of previous three tribonacci numbers.\n * @param {integer} n - the input integer\n * @return {integer} tribonacci of n.\n * @see [tribonacci_numbers](https://www.geeksforgeeks.org/tribonacci-numbers/)\n */\nconst tribonacci = (n) => {\n  // creating array to store previous tribonacci numbers\n  const dp = new array(n + 1)\n  dp[0] = 0\n  dp[1] = 1\n  dp[2] = 1\n  for (let i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n  return dp[n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上述的时间复杂度是线性的，但它需要额外的空间。我们可以使用三个变量来跟踪前三个数字，以优化上述解决方案的空间。\n\n// a space optimized based javascript program to print first n tribonacci numbers.\nfunction printtrib(n) {\n    if (n < 1) return;\n    // initialize first three numbers\n    let first = 0, second = 0, third = 1;\n    // loop to add previous three numbers for each number starting from 3 and then assign first, second, third to second, third, and curr to third respectively\n    for (let i = 3; i < n; i++) {\n      let curr = first + second + third;\n      first = second;\n      second = third;\n      third = curr;\n    }\n\n    return third;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n更有效的解决方案：使用矩阵指数化。\n\n// javascript program to print first n tribonacci numbers\n// matrix multiplication function for 3*3 matrix\nfunction multiply(t , m) {\n    var a, b, c, d, e, f, g, h, i;\n    a = t[0][0] * m[0][0] + t[0][1] * m[1][0] + t[0][2] * m[2][0];\n    b = t[0][0] * m[0][1] + t[0][1] * m[1][1] + t[0][2] * m[2][1];\n    c = t[0][0] * m[0][2] + t[0][1] * m[1][2] + t[0][2] * m[2][2];\n    d = t[1][0] * m[0][0] + t[1][1] * m[1][0] + t[1][2] * m[2][0];\n    e = t[1][0] * m[0][1] + t[1][1] * m[1][1] + t[1][2] * m[2][1];\n    f = t[1][0] * m[0][2] + t[1][1] * m[1][2] + t[1][2] * m[2][2];\n    g = t[2][0] * m[0][0] + t[2][1] * m[1][0] + t[2][2] * m[2][0];\n    h = t[2][0] * m[0][1] + t[2][1] * m[1][1] + t[2][2] * m[2][1];\n    i = t[2][0] * m[0][2] + t[2][1] * m[1][2] + t[2][2] * m[2][2];\n    t[0][0] = a;\n    t[0][1] = b;\n    t[0][2] = c;\n    t[1][0] = d;\n    t[1][1] = e;\n    t[1][2] = f;\n    t[2][0] = g;\n    t[2][1] = h;\n    t[2][2] = i;\n}\n \n// recursive function to raise the matrix t to the power n\nfunction power(t , n) {\n    // base condition.\n    if (n == 0 || n == 1) return;\n    var m = [[ 1, 1, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ]];\n    // recursively call to square the matrix\n    power(t, parseint(n / 2));\n    // calculating square of the matrix t\n    multiply(t, t);\n    // if n is odd multiply it one time with m\n    if (n % 2 != 0) multiply(t, m);\n}\nfunction tribonacci(n) {\n    var t = [[ 1, 1, 1 ], [ 1, 0, 0 ], [ 0, 1, 0 ]];\n    // base condition\n    if (n == 0 || n == 1) return 0;\n    else power(t, n - 2);\n    // t[0][0] contains the tribonacci number so return it\n    return t[0][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n参考：matrix exponentiation - geeksforgeeks。\n\n\n# 参考\n\n * tribonacci numbers - geeksforgeeks\n * tribonacci number -- from wolfram mathworld\n * fibonacci number -- from wolfram mathworld",charsets:{cjk:!0},lastUpdated:"2022/10/27, 20:28:55",lastUpdatedTimestamp:1666873735e3},{title:"ZeroOneKnapsack  [零一背包]",frontmatter:{title:"ZeroOneKnapsack  [零一背包]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/zeroOneKnapsack/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/230.ZeroOneKnapsack.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/230.ZeroOneKnapsack.md",key:"v-93bae096",path:"/algorithm/dp/zeroOneKnapsack/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"背包问题",slug:"背包问题",normalizedTitle:"背包问题",charIndex:9},{level:2,title:"零一背包",slug:"零一背包",normalizedTitle:"零一背包",charIndex:332},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:709},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:716},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2741},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2892}],headersStr:"介绍 背包问题 零一背包 实现 JavaScript 扩展 参考",content:"# 介绍\n\n\n# 背包问题\n\n背包问题（Knapsack problem）是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中，背包的空间有限，但我们需要最大化背包内所装物品的价值。背包问题通常出现在资源分配中，决策者必须分别从一组不可分割的项目或任务中进行选择，而这些项目又有时间或预算的限制。\n\nNPC 问题是没有多项式时间复杂度的解法的，但是利用动态规划，我们可以以伪多项式时间复杂度求解背包问题。一般来讲，背包问题有以下几种分类：\n\n * 01 背包问题\n * 完全背包问题\n * 多重背包问题\n\n\n# 零一背包\n\n原理：\n\n状态转换方程： dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i])\n\n * 如果装不下当前物品，那么前 n 个物品的最佳组合和前 n-1 个物品的最佳组合是一样的。\n\n * 如果装得下当前物品。选取假设 1 和假设 2 中较大的价值，为当前最佳组合的价值。\n   \n   * 假设 1：装当前物品，在给当前物品预留了相应空间的情况下，前 - 1 个物品的最佳组合加上当前物品的价值就是总价值。\n   * 假设 2：不装当前物品，那么前 n 个物品的最佳组合和前 n-1 个物品的最佳组合是一样的。\n\n背包的回溯：\n\n从表的右下角开始回溯，如果发现前 n 个物品最佳组合的价值和前 n-1 个物品最佳组合的价值一样，说明第 n 个物品没有被装入。否则，第 n 个物品被装入。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * A Dynamic Programming based solution for calculating Zero One Knapsack\n * https://en.wikipedia.org/wiki/Knapsack_problem\n */\n\nconst zeroOneKnapsack = (arr, n, cap, cache) => {\n  if (cap === 0 || n === 0) return cache[n][cap] = 0\n  if (cache[n][cap] !== -1) return cache[n][cap]\n  if (arr[n - 1][0] <= cap) return cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))\n  return cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)\n}\n\nconst example = () => {\n  /*\n  Problem Statement:\n  You are a thief carrying a single bag with limited capacity S. The museum you stole had N artifact that you could steal. Unfortunately you might not be able to steal all the artifact because of your limited bag capacity.\n  You have to cherry pick the artifact in order to maximize the total value of the artifacts you stole.\n\n  Link for the Problem: https://www.hackerrank.com/contests/srin-aadc03/challenges/classic-01-knapsack\n  */\n  let input = `1\n    4 5\n    1 8\n    2 4\n    3 0\n    2 5\n    2 3`\n\n  input = input.trim().split('\\n')\n  input.shift()\n  const length = input.length\n\n  const output = []\n\n  let i = 0\n  while (i < length) {\n    const cap = Number(input[i].trim().split(' ')[0])\n    const currlen = Number(input[i].trim().split(' ')[1])\n    let j = i + 1\n    const arr = []\n    while (j <= i + currlen) {\n      arr.push(input[j])\n      j++\n    }\n    const newArr = arr.map(e =>\n      e.trim().split(' ').map(Number)\n    )\n    const cache = []\n    for (let i = 0; i <= currlen; i++) {\n      const temp = []\n      for (let j = 0; j <= cap; j++) {\n        temp.push(-1)\n      }\n      cache.push(temp)\n    }\n    const result = zeroOneKnapsack(newArr, currlen, cap, cache)\n    output.push(result)\n    i += currlen + 1\n  }\n\n  return output\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 扩展\n\n完全背包：每个物品可以无限制的取。 多重背包：每个物品可以取给定次数。多重背包问题可以转换为零一背包问题，将重复的物品看做不同的物品即可。\n\n背包问题详解参见：\n\n完全背包状态转换方程： dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + c[i])\n\n\n# 参考\n\n * Knapsack problem - Wikiwand\n * 背包问题 - Wikiwand\n * 动态规划之背包问题系列 - 知乎",normalizedContent:"# 介绍\n\n\n# 背包问题\n\n背包问题（knapsack problem）是一种组合优化的 np 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中，背包的空间有限，但我们需要最大化背包内所装物品的价值。背包问题通常出现在资源分配中，决策者必须分别从一组不可分割的项目或任务中进行选择，而这些项目又有时间或预算的限制。\n\nnpc 问题是没有多项式时间复杂度的解法的，但是利用动态规划，我们可以以伪多项式时间复杂度求解背包问题。一般来讲，背包问题有以下几种分类：\n\n * 01 背包问题\n * 完全背包问题\n * 多重背包问题\n\n\n# 零一背包\n\n原理：\n\n状态转换方程： dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i])\n\n * 如果装不下当前物品，那么前 n 个物品的最佳组合和前 n-1 个物品的最佳组合是一样的。\n\n * 如果装得下当前物品。选取假设 1 和假设 2 中较大的价值，为当前最佳组合的价值。\n   \n   * 假设 1：装当前物品，在给当前物品预留了相应空间的情况下，前 - 1 个物品的最佳组合加上当前物品的价值就是总价值。\n   * 假设 2：不装当前物品，那么前 n 个物品的最佳组合和前 n-1 个物品的最佳组合是一样的。\n\n背包的回溯：\n\n从表的右下角开始回溯，如果发现前 n 个物品最佳组合的价值和前 n-1 个物品最佳组合的价值一样，说明第 n 个物品没有被装入。否则，第 n 个物品被装入。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * a dynamic programming based solution for calculating zero one knapsack\n * https://en.wikipedia.org/wiki/knapsack_problem\n */\n\nconst zerooneknapsack = (arr, n, cap, cache) => {\n  if (cap === 0 || n === 0) return cache[n][cap] = 0\n  if (cache[n][cap] !== -1) return cache[n][cap]\n  if (arr[n - 1][0] <= cap) return cache[n][cap] = math.max(arr[n - 1][1] + zerooneknapsack(arr, n - 1, cap - arr[n - 1][0], cache), zerooneknapsack(arr, n - 1, cap, cache))\n  return cache[n][cap] = zerooneknapsack(arr, n - 1, cap, cache)\n}\n\nconst example = () => {\n  /*\n  problem statement:\n  you are a thief carrying a single bag with limited capacity s. the museum you stole had n artifact that you could steal. unfortunately you might not be able to steal all the artifact because of your limited bag capacity.\n  you have to cherry pick the artifact in order to maximize the total value of the artifacts you stole.\n\n  link for the problem: https://www.hackerrank.com/contests/srin-aadc03/challenges/classic-01-knapsack\n  */\n  let input = `1\n    4 5\n    1 8\n    2 4\n    3 0\n    2 5\n    2 3`\n\n  input = input.trim().split('\\n')\n  input.shift()\n  const length = input.length\n\n  const output = []\n\n  let i = 0\n  while (i < length) {\n    const cap = number(input[i].trim().split(' ')[0])\n    const currlen = number(input[i].trim().split(' ')[1])\n    let j = i + 1\n    const arr = []\n    while (j <= i + currlen) {\n      arr.push(input[j])\n      j++\n    }\n    const newarr = arr.map(e =>\n      e.trim().split(' ').map(number)\n    )\n    const cache = []\n    for (let i = 0; i <= currlen; i++) {\n      const temp = []\n      for (let j = 0; j <= cap; j++) {\n        temp.push(-1)\n      }\n      cache.push(temp)\n    }\n    const result = zerooneknapsack(newarr, currlen, cap, cache)\n    output.push(result)\n    i += currlen + 1\n  }\n\n  return output\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 扩展\n\n完全背包：每个物品可以无限制的取。 多重背包：每个物品可以取给定次数。多重背包问题可以转换为零一背包问题，将重复的物品看做不同的物品即可。\n\n背包问题详解参见：\n\n完全背包状态转换方程： dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + c[i])\n\n\n# 参考\n\n * knapsack problem - wikiwand\n * 背包问题 - wikiwand\n * 动态规划之背包问题系列 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/27, 22:22:22",lastUpdatedTimestamp:1666880542e3},{title:"EditDistance [编辑距离]",frontmatter:{title:"EditDistance [编辑距离]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/editDistance/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/30.EditDistance.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/30.EditDistance.md",key:"v-12469ad5",path:"/algorithm/dp/editDistance/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:524},{level:2,title:"递归法",slug:"递归法",normalizedTitle:"递归法",charIndex:1030},{level:2,title:"动态规划法",slug:"动态规划法",normalizedTitle:"动态规划法",charIndex:2406},{level:2,title:"降低空间复杂度",slug:"降低空间复杂度",normalizedTitle:"降低空间复杂度",charIndex:5207},{level:2,title:"带缓存的递归",slug:"带缓存的递归",normalizedTitle:"带缓存的递归",charIndex:7106},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:8352}],headersStr:"介绍 问题 递归法 动态规划法 降低空间复杂度 带缓存的递归 参考",content:'# 介绍\n\n编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。DNA 也可以视为用 A、C、G 和 T 组成的字符串，因此编辑距离也用在生物信息学中，判断二个 DNA 的类似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。\n\n编辑距离有几种不同的定义，差异在可以对字符串进行的处理。\n\n * 在莱文斯坦距离中，可以删除、加入、取代字符串中的任何一个字元，也是较常用的编辑距离定义，常常提到编辑距离时，指的就是莱文斯坦距离。\n * 也存在其他编辑距离的定义方式，例如 Damerau-Levenshtein 距离是一种莱文斯坦距离的变种，但允许以单一操作交换相邻的两个字符（称为字符转置），如 AB→BA 的距离是 1（交换）而非 2（先删除再插入、或者两次替换）。\n * LCS（最长公共子序列）距离只允许删除、加入字元。\n * Jaro 距离只允许字符转置。\n * 汉明距离只允许取代字元。\n\n\n# 问题\n\n给出两个字符串 str1 和 str2，以及以下可以对 str1 进行的操作。请找出将 "str1" 转换为 "str2" 所需的最少编辑（操作）次数。\n\n * 插入\n * 删除\n * 替换\n\n上述所有操作的成本都相同。\n\n在这种情况下，有哪些子问题？从两个字符串的左边或右边开始，一个一个地处理所有字符。让我们从右边开始遍历，每一对被遍历的字符都有两种可能。\n\nm: Length of str1 (first string)\nn: Length of str2 (second string)\n\n\n1\n2\n\n\n * 如果两个字符串的最后一个字符相同，则什么都不做。忽略最后一个字符，获得其余字符串的计数。所以我们对长度为 m-1 和 n-1 的字符串进行递归。\n\n * 否则（如果最后一个字符不一样），我们考虑对\'str1\' 的所有操作，考虑对第一个字符串的最后一个字符的所有三个操作，递归计算所有三个操作的最小成本，取三个值中的最小值。\n   \n   * 插入。递归计算 m 和 n-1。\n   * 删除。对 m-1 和 n 进行递归。\n   * 替换。对 m-1 和 n-1 进行递归。\n\n\n# 递归法\n\n// Javascript program to find minimum numberoperations to convert str1 to str2\nfunction min(x, y, z) {\n  if (x <= y && x <= z) return x;\n  if (y <= x && y <= z) return y;\n  else return z;\n}\n \nfunction editDist(str1, str2, m, n) {\n  // If first string is empty, the only option is to insert all characters of second string into first\n  if (m == 0) return n;\n  // If second string is empty, the only option is to remove all characters of first string\n  if (n == 0) return m;\n\n  // If last characters of two strings are same, nothing much to do. Ignore last\n  // characters and get count for remaining strings.\n  if (str1[m - 1] == str2[n - 1]) return editDist(str1, str2, m - 1, n - 1);\n\n  // If last characters are not same, consider all three operations on last character of first\n  // string, recursively compute minimum cost for all three operations and take minimum of three values.\n  return 1 + min(editDist(str1, str2, m, n - 1), // Insert\n    editDist(str1, str2, m - 1, n), // Remove\n    editDist(str1, str2, m - 1, n - 1)); // Replace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上述解决方案的时间复杂性是指数级的。在最坏的情况下，我们最终可能要进行 O (3m) 次操作。最坏的情况是，两个字符串中没有一个字符匹配。下面是最坏情况下的递归调用图。辅助空间是 O (1)，因为没有额外的空间被利用。\n\n\n\n我们可以看到，许多子问题被反复解决，例如，eD (2, 2) 被调用三次。由于相同的子问题被再次调用，这个问题具有重叠子问题的特性。因此，编辑距离问题具有动态规划问题的两种属性。像其他典型的动态规划 (DP) 问题一样，可以通过构建一个存储子问题结果的临时数组来避免相同子问题的重新计算。\n\n\n# 动态规划法\n\n// A Dynamic Programming based Javascript program to find minimum number operations to convert str1 to str2\nfunction min(x,y,z) {\n  if (x <= y && x <= z) return x;\n  if (y <= x && y <= z) return y;\n  else return z;\n}\n \nfunction editDistDP(str1,str2,m,n) {\n  // Create a table to store results of subproblems\n  let dp = new Array(m + 1);\n  for(let i=0;i<m+1;i++) {\n    dp[i]=new Array(n+1);\n    for(let j=0;j<n+1;j++) dp[i][j]=0;\n  }\n\n  // Fill d[][] in bottom up manner\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      // If first string is empty, only option is to insert all characters of second string\n      if (i == 0) dp[i][j] = j; // Min. operations = j\n\n      // If second string is empty, only option is to remove all characters of second string\n      else if (j == 0) dp[i][j] = i; // Min. operations = i\n\n      // If last characters are same, ignore last char and recur for remaining string\n      else if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n\n      // If the last character is different, consider all possibilities and find the minimum\n      else dp[i][j] = 1 + min(dp[i][j - 1], // Insert\n                           dp[i - 1][j], // Remove\n                           dp[i - 1][j - 1]); // Replace\n    }\n  }\n\n  return dp[m][n];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n或者：\n\n/*\nWikipedia -> https://en.wikipedia.org/wiki/Edit_distance\n\nQ. -> Given two strings `word1` and `word2`. You can perform these operations on any of the string to make both strings similar.\n    - Insert\n    - Remove\n    - Replace\nFind the minimum operation cost required to make both same. Each operation cost is 1.\n\nAlgorithm details ->\ntime complexity - O(n*m)\nspace complexity - O(n*m)\n*/\n\nconst minimumEditDistance = (word1, word2) => {\n  const n = word1.length\n  const m = word2.length\n  const dp = new Array(m + 1).fill(0).map(item => [])\n\n  /*\n    fill dp matrix with default values -\n        - first row is filled considering no elements in word2.\n        - first column filled considering no elements in word1.\n    */\n  for (let i = 0; i < n + 1; i++) dp[0][i] = i;\n  for (let i = 0; i < m + 1; i++) dp[i][0] = i;\n\n  /*indexing is 1 based for dp matrix as we defined some known values at first row and first column/*/\n  for (let i = 1; i < m + 1; i++) {\n    for (let j = 1; j < n + 1; j++) {\n      const letter1 = word1[j - 1]\n      const letter2 = word2[i - 1]\n\n      if (letter1 === letter2) dp[i][j] = dp[i - 1][j - 1];\n      else dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1;\n    }\n  }\n\n  return dp[m][n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * 时间复杂度：O (m x n)\n * 辅助空间：O (m x n)\n\n\n# 降低空间复杂度\n\n在上面给出的方法中，我们需要 O (m x n) 空间。如果字符串的长度大于 2000，这就不合适了，因为它只能创建 2000×2000 的二维数组。为了填补 DP 数组中的一行，我们只需要一行，即上面的一行。例如，如果我们要在 DP 数组中填充 i = 10 行，我们只需要第 9 行的值。所以我们只需创建一个 2 x str1 长度的 DP 数组。这种方法减少了空间的复杂性。\n\n// A Space efficient Dynamic Programming based Javascript program to find minimum number operations to convert str1 to str2\nfunction EditDistDP(str1, str2) {\n  let len1 = str1.length;\n  let len2 = str2.length;\n\n  // Create a DP array to memoize result of previous computations\n  let DP = new Array(2);\n  for(let i = 0; i < 2; i++) {\n    DP[i] = new Array(len1+1);\n    for(let j = 0; j < len1 + 1; j++) DP[i][j] = 0;\n  }\n\n  // Base condition when second String is empty then we remove all characters\n  for (let i = 0; i <= len1; i++) DP[0][i] = i;\n\n  // Start filling the DP, This loop run for every character in second String\n  for (let i = 1; i <= len2; i++) {\n      // This loop compares the char from second String with first String characters\n      for (let j = 0; j <= len1; j++) {\n          // if first String is empty then we have to perform add character operation to get second String\n          if (j == 0) DP[i % 2][j] = i;\n          // if character from both String is same then we do not perform any operation . here i % 2 is for bound the row number.\n          else if (str1[j-1] == str2[i-1]) DP[i % 2][j] = DP[(i - 1) % 2][j - 1];\n          // if character from both String is not same then we take the minimum from three specified operation\n          else DP[i % 2][j] = 1 + Math.min(DP[(i - 1) % 2][j], Math.min(DP[i % 2][j - 1], DP[(i - 1) % 2][j - 1]));\n      }\n  }\n\n  // after complete fill the DP array if the len2 is even then we end up in the 0th row else we end up\n  // in the 1th row so we take len2 % 2 to get row\n  return DP[len2 % 2][len1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 时间复杂度：O (m x n)\n * 辅助空间：O (m)\n\n\n# 带缓存的递归\n\n这是递归的缓存版本，即自上而下的 DP。\n\nfunction minDis(s1,s2,n,m,dp) {\n  // If any String is empty, return the remaining characters of other String\n  if(n == 0) return m;\n  if(m == 0) return n;\n               \n  // To check if the recursive tree for given n & m has already been executed\n  if(dp[n][m] != -1) return dp[n][m];\n                  \n  // If characters are equal, execute recursive function for n-1, m-1\n  if(s1[n - 1] == s2[m - 1]) {         \n    if(dp[n - 1][m - 1] == -1) return dp[n][m] = minDis(s1, s2, n - 1, m - 1, dp);         \n    else return dp[n][m] = dp[n - 1][m - 1]; \n  }\n    \n  // If characters are nt equal, we need to find the minimum cost out of all 3 operations.    \n  else {         \n    let m1, m2, m3; // temp variables \n    if(dp[n-1][m] != -1) m1 = dp[n - 1][m];             \n    else m1 = minDis(s1, s2, n - 1, m, dp);    \n              \n    if(dp[n][m - 1] != -1) m2 = dp[n][m - 1];          \n    else m2 = minDis(s1, s2, n, m - 1, dp);    \n     \n    if(dp[n - 1][m - 1] != -1) m3 = dp[n - 1][m - 1];    \n    else m3 = minDis(s1, s2, n - 1, m - 1, dp);     \n    \n    return dp[n][m] = 1 + Math.min(m1, Math.min(m2, m3));      \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 参考\n\n * Edit distance - Wikiwand\n * 编辑距离 - Wikiwand\n * Edit Distance | DP-5 - GeeksforGeeks',normalizedContent:'# 介绍\n\n编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。dna 也可以视为用 a、c、g 和 t 组成的字符串，因此编辑距离也用在生物信息学中，判断二个 dna 的类似程度。unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。\n\n编辑距离有几种不同的定义，差异在可以对字符串进行的处理。\n\n * 在莱文斯坦距离中，可以删除、加入、取代字符串中的任何一个字元，也是较常用的编辑距离定义，常常提到编辑距离时，指的就是莱文斯坦距离。\n * 也存在其他编辑距离的定义方式，例如 damerau-levenshtein 距离是一种莱文斯坦距离的变种，但允许以单一操作交换相邻的两个字符（称为字符转置），如 ab→ba 的距离是 1（交换）而非 2（先删除再插入、或者两次替换）。\n * lcs（最长公共子序列）距离只允许删除、加入字元。\n * jaro 距离只允许字符转置。\n * 汉明距离只允许取代字元。\n\n\n# 问题\n\n给出两个字符串 str1 和 str2，以及以下可以对 str1 进行的操作。请找出将 "str1" 转换为 "str2" 所需的最少编辑（操作）次数。\n\n * 插入\n * 删除\n * 替换\n\n上述所有操作的成本都相同。\n\n在这种情况下，有哪些子问题？从两个字符串的左边或右边开始，一个一个地处理所有字符。让我们从右边开始遍历，每一对被遍历的字符都有两种可能。\n\nm: length of str1 (first string)\nn: length of str2 (second string)\n\n\n1\n2\n\n\n * 如果两个字符串的最后一个字符相同，则什么都不做。忽略最后一个字符，获得其余字符串的计数。所以我们对长度为 m-1 和 n-1 的字符串进行递归。\n\n * 否则（如果最后一个字符不一样），我们考虑对\'str1\' 的所有操作，考虑对第一个字符串的最后一个字符的所有三个操作，递归计算所有三个操作的最小成本，取三个值中的最小值。\n   \n   * 插入。递归计算 m 和 n-1。\n   * 删除。对 m-1 和 n 进行递归。\n   * 替换。对 m-1 和 n-1 进行递归。\n\n\n# 递归法\n\n// javascript program to find minimum numberoperations to convert str1 to str2\nfunction min(x, y, z) {\n  if (x <= y && x <= z) return x;\n  if (y <= x && y <= z) return y;\n  else return z;\n}\n \nfunction editdist(str1, str2, m, n) {\n  // if first string is empty, the only option is to insert all characters of second string into first\n  if (m == 0) return n;\n  // if second string is empty, the only option is to remove all characters of first string\n  if (n == 0) return m;\n\n  // if last characters of two strings are same, nothing much to do. ignore last\n  // characters and get count for remaining strings.\n  if (str1[m - 1] == str2[n - 1]) return editdist(str1, str2, m - 1, n - 1);\n\n  // if last characters are not same, consider all three operations on last character of first\n  // string, recursively compute minimum cost for all three operations and take minimum of three values.\n  return 1 + min(editdist(str1, str2, m, n - 1), // insert\n    editdist(str1, str2, m - 1, n), // remove\n    editdist(str1, str2, m - 1, n - 1)); // replace\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上述解决方案的时间复杂性是指数级的。在最坏的情况下，我们最终可能要进行 o (3m) 次操作。最坏的情况是，两个字符串中没有一个字符匹配。下面是最坏情况下的递归调用图。辅助空间是 o (1)，因为没有额外的空间被利用。\n\n\n\n我们可以看到，许多子问题被反复解决，例如，ed (2, 2) 被调用三次。由于相同的子问题被再次调用，这个问题具有重叠子问题的特性。因此，编辑距离问题具有动态规划问题的两种属性。像其他典型的动态规划 (dp) 问题一样，可以通过构建一个存储子问题结果的临时数组来避免相同子问题的重新计算。\n\n\n# 动态规划法\n\n// a dynamic programming based javascript program to find minimum number operations to convert str1 to str2\nfunction min(x,y,z) {\n  if (x <= y && x <= z) return x;\n  if (y <= x && y <= z) return y;\n  else return z;\n}\n \nfunction editdistdp(str1,str2,m,n) {\n  // create a table to store results of subproblems\n  let dp = new array(m + 1);\n  for(let i=0;i<m+1;i++) {\n    dp[i]=new array(n+1);\n    for(let j=0;j<n+1;j++) dp[i][j]=0;\n  }\n\n  // fill d[][] in bottom up manner\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      // if first string is empty, only option is to insert all characters of second string\n      if (i == 0) dp[i][j] = j; // min. operations = j\n\n      // if second string is empty, only option is to remove all characters of second string\n      else if (j == 0) dp[i][j] = i; // min. operations = i\n\n      // if last characters are same, ignore last char and recur for remaining string\n      else if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n\n      // if the last character is different, consider all possibilities and find the minimum\n      else dp[i][j] = 1 + min(dp[i][j - 1], // insert\n                           dp[i - 1][j], // remove\n                           dp[i - 1][j - 1]); // replace\n    }\n  }\n\n  return dp[m][n];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n或者：\n\n/*\nwikipedia -> https://en.wikipedia.org/wiki/edit_distance\n\nq. -> given two strings `word1` and `word2`. you can perform these operations on any of the string to make both strings similar.\n    - insert\n    - remove\n    - replace\nfind the minimum operation cost required to make both same. each operation cost is 1.\n\nalgorithm details ->\ntime complexity - o(n*m)\nspace complexity - o(n*m)\n*/\n\nconst minimumeditdistance = (word1, word2) => {\n  const n = word1.length\n  const m = word2.length\n  const dp = new array(m + 1).fill(0).map(item => [])\n\n  /*\n    fill dp matrix with default values -\n        - first row is filled considering no elements in word2.\n        - first column filled considering no elements in word1.\n    */\n  for (let i = 0; i < n + 1; i++) dp[0][i] = i;\n  for (let i = 0; i < m + 1; i++) dp[i][0] = i;\n\n  /*indexing is 1 based for dp matrix as we defined some known values at first row and first column/*/\n  for (let i = 1; i < m + 1; i++) {\n    for (let j = 1; j < n + 1; j++) {\n      const letter1 = word1[j - 1]\n      const letter2 = word2[i - 1]\n\n      if (letter1 === letter2) dp[i][j] = dp[i - 1][j - 1];\n      else dp[i][j] = math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1;\n    }\n  }\n\n  return dp[m][n]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * 时间复杂度：o (m x n)\n * 辅助空间：o (m x n)\n\n\n# 降低空间复杂度\n\n在上面给出的方法中，我们需要 o (m x n) 空间。如果字符串的长度大于 2000，这就不合适了，因为它只能创建 2000×2000 的二维数组。为了填补 dp 数组中的一行，我们只需要一行，即上面的一行。例如，如果我们要在 dp 数组中填充 i = 10 行，我们只需要第 9 行的值。所以我们只需创建一个 2 x str1 长度的 dp 数组。这种方法减少了空间的复杂性。\n\n// a space efficient dynamic programming based javascript program to find minimum number operations to convert str1 to str2\nfunction editdistdp(str1, str2) {\n  let len1 = str1.length;\n  let len2 = str2.length;\n\n  // create a dp array to memoize result of previous computations\n  let dp = new array(2);\n  for(let i = 0; i < 2; i++) {\n    dp[i] = new array(len1+1);\n    for(let j = 0; j < len1 + 1; j++) dp[i][j] = 0;\n  }\n\n  // base condition when second string is empty then we remove all characters\n  for (let i = 0; i <= len1; i++) dp[0][i] = i;\n\n  // start filling the dp, this loop run for every character in second string\n  for (let i = 1; i <= len2; i++) {\n      // this loop compares the char from second string with first string characters\n      for (let j = 0; j <= len1; j++) {\n          // if first string is empty then we have to perform add character operation to get second string\n          if (j == 0) dp[i % 2][j] = i;\n          // if character from both string is same then we do not perform any operation . here i % 2 is for bound the row number.\n          else if (str1[j-1] == str2[i-1]) dp[i % 2][j] = dp[(i - 1) % 2][j - 1];\n          // if character from both string is not same then we take the minimum from three specified operation\n          else dp[i % 2][j] = 1 + math.min(dp[(i - 1) % 2][j], math.min(dp[i % 2][j - 1], dp[(i - 1) % 2][j - 1]));\n      }\n  }\n\n  // after complete fill the dp array if the len2 is even then we end up in the 0th row else we end up\n  // in the 1th row so we take len2 % 2 to get row\n  return dp[len2 % 2][len1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 时间复杂度：o (m x n)\n * 辅助空间：o (m)\n\n\n# 带缓存的递归\n\n这是递归的缓存版本，即自上而下的 dp。\n\nfunction mindis(s1,s2,n,m,dp) {\n  // if any string is empty, return the remaining characters of other string\n  if(n == 0) return m;\n  if(m == 0) return n;\n               \n  // to check if the recursive tree for given n & m has already been executed\n  if(dp[n][m] != -1) return dp[n][m];\n                  \n  // if characters are equal, execute recursive function for n-1, m-1\n  if(s1[n - 1] == s2[m - 1]) {         \n    if(dp[n - 1][m - 1] == -1) return dp[n][m] = mindis(s1, s2, n - 1, m - 1, dp);         \n    else return dp[n][m] = dp[n - 1][m - 1]; \n  }\n    \n  // if characters are nt equal, we need to find the minimum cost out of all 3 operations.    \n  else {         \n    let m1, m2, m3; // temp variables \n    if(dp[n-1][m] != -1) m1 = dp[n - 1][m];             \n    else m1 = mindis(s1, s2, n - 1, m, dp);    \n              \n    if(dp[n][m - 1] != -1) m2 = dp[n][m - 1];          \n    else m2 = mindis(s1, s2, n, m - 1, dp);    \n     \n    if(dp[n - 1][m - 1] != -1) m3 = dp[n - 1][m - 1];    \n    else m3 = mindis(s1, s2, n - 1, m - 1, dp);     \n    \n    return dp[n][m] = 1 + math.min(m1, math.min(m2, m3));      \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 参考\n\n * edit distance - wikiwand\n * 编辑距离 - wikiwand\n * edit distance | dp-5 - geeksforgeeks',charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"FibonacciNumber [斐波那契数]",frontmatter:{title:"FibonacciNumber [斐波那契数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/fibonacciNumber/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/40.FibonacciNumber.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/40.FibonacciNumber.md",key:"v-530e2e09",path:"/algorithm/dp/fibonacciNumber/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:419},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:426},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1187}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n斐波那契数（意大利语：Successione di Fibonacci），又译为菲波拿契数、菲波那西数、斐氏数、黄金分割数。所形成的数列称为斐波那契数列（意大利语：Successione di Fibonacci），又译为菲波拿契数列、菲波那西数列、斐氏数列、黄金分割数列。\n\n在数学上，斐波那契数是以递归的方法来定义：\n\nF0=0;F1=1;Fn=F(n−1)+F(n−2)(n≧2)F{0}=0; F{1}=1; F{n}=F(n-1)+F(n-2) (n≧2) F0=0;F1=1;Fn=F(n−1)+F(n−2)(n≧2)\n\n用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。首几个斐波那契数是：1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……\n\n特别指出：0 不是第一项，而是第零项。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function fibonacci\n * @description Fibonacci is the sum of previous two fibonacci numbers.\n * @param {Integer} N - The input integer\n * @return {Integer} fibonacci of N.\n * @see [Fibonacci_Numbers](https://en.wikipedia.org/wiki/Fibonacci_number)\n */\nconst fibonacci = (N) => {\n  if (!Number.isInteger(N)) {\n    throw new TypeError('Input should be integer')\n  }\n\n  // memoize the last two numbers\n  let firstNumber = 0\n  let secondNumber = 1\n\n  for (let i = 1; i < N; i++) {\n    const sumOfNumbers = firstNumber + secondNumber\n    // update last two numbers\n    firstNumber = secondNumber\n    secondNumber = sumOfNumbers\n  }\n\n  return N ? secondNumber : firstNumber\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 参考\n\n * Fibonacci number - Wikiwand\n * 斐波那契数 - Wikiwand",normalizedContent:"# 介绍\n\n斐波那契数（意大利语：successione di fibonacci），又译为菲波拿契数、菲波那西数、斐氏数、黄金分割数。所形成的数列称为斐波那契数列（意大利语：successione di fibonacci），又译为菲波拿契数列、菲波那西数列、斐氏数列、黄金分割数列。\n\n在数学上，斐波那契数是以递归的方法来定义：\n\nf0=0;f1=1;fn=f(n−1)+f(n−2)(n≧2)f{0}=0; f{1}=1; f{n}=f(n-1)+f(n-2) (n≧2) f0=0;f1=1;fn=f(n−1)+f(n−2)(n≧2)\n\n用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。首几个斐波那契数是：1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……\n\n特别指出：0 不是第一项，而是第零项。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function fibonacci\n * @description fibonacci is the sum of previous two fibonacci numbers.\n * @param {integer} n - the input integer\n * @return {integer} fibonacci of n.\n * @see [fibonacci_numbers](https://en.wikipedia.org/wiki/fibonacci_number)\n */\nconst fibonacci = (n) => {\n  if (!number.isinteger(n)) {\n    throw new typeerror('input should be integer')\n  }\n\n  // memoize the last two numbers\n  let firstnumber = 0\n  let secondnumber = 1\n\n  for (let i = 1; i < n; i++) {\n    const sumofnumbers = firstnumber + secondnumber\n    // update last two numbers\n    firstnumber = secondnumber\n    secondnumber = sumofnumbers\n  }\n\n  return n ? secondnumber : firstnumber\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 参考\n\n * fibonacci number - wikiwand\n * 斐波那契数 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"FindMonthCalendar [月历]",frontmatter:{title:"FindMonthCalendar [月历]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/findMonthCalendar/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/50.FindMonthCalendar.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/50.FindMonthCalendar.md",key:"v-7664ccdf",path:"/algorithm/dp/findMonthCalendar/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:35},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:42},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:3838},{level:3,title:"通过年月计算月中天数",slug:"通过年月计算月中天数",normalizedTitle:"通过年月计算月中天数",charIndex:3845},{level:3,title:"计算两日相差天数",slug:"计算两日相差天数",normalizedTitle:"计算两日相差天数",charIndex:4570},{level:3,title:"计算某日周几",slug:"计算某日周几",normalizedTitle:"计算某日周几",charIndex:6350}],headersStr:"介绍 实现 JavaScript 扩展 通过年月计算月中天数 计算两日相差天数 计算某日周几",content:"# 介绍\n\n给定 mm/yyyy 的月份，打印次月份的月历。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n*  This algorithm accepts a month in the format mm/yyyy.\n*  And prints out the month's calendar.\n*  It uses an epoch of 1/1/1900, Monday.\n*/\n\nclass Month {\n  constructor () {\n    this.Days = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su']\n    this.BDays = ['M', 'Su', 'S', 'F', 'Th', 'W', 'T']\n    this.epoch = { month: 1, year: 1900 }\n    this.monthDays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    this.monthDaysLeap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  }\n\n  printCal (days, startDay, output = value => console.log(value)) {\n    output('M   T   W   Th  F   S   Su')\n    const dates = []; let i;\n    for (i = 1; i <= days; i++) {\n      dates.push(i)\n    }\n    for (i = 0; i < this.Days.indexOf(startDay); i++) {\n      dates.unshift(' ')\n    }\n    while (true) {\n      let row = ''\n      for (i = 0; (i < 7) && (dates.length !== 0); i++) {\n        row += dates.shift()\n        while ((row.length % 4) !== 0) {\n          row += ' '\n        }\n      }\n      output(row)\n      if (dates.length === 0) break\n    }\n  }\n\n  parseDate (date) {\n    const dateAr = []; let block = ''; let i\n    for (i = 0; i < date.length; i++) {\n      if (date[i] === '/') {\n        dateAr.push(parseInt(block))\n        block = ''\n        continue\n      }\n      block += date[i]\n    }\n    dateAr.push(parseInt(block))\n    if (dateAr.length !== 2) throw new Error('Improper string encoding')\n    const dateOb = { month: dateAr[0], year: dateAr[1] }\n    return dateOb\n  }\n\n  isLeapYear (year) {\n    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true\n    return false\n  }\n\n  isGreater (startDate, endDate) {\n    if (startDate.year > endDate.year) {\n      return true\n    } else if (startDate.year < endDate.year) {\n      return false\n    } else if (startDate.month > endDate.month) {\n      return true\n    } else if (startDate.month < endDate.month) {\n      return false\n    }\n    return true\n  }\n\n  getDayDiff (startDate, endDate) {\n    if (this.isGreater(startDate, endDate) === null) {\n      return 0\n    } else if ((this.isGreater(startDate, endDate) === true)) {\n      const midDate = startDate\n      startDate = endDate\n      endDate = midDate\n    }\n    let diff = 0\n    while (startDate.year !== endDate.year) {\n      diff += (this.isLeapYear(startDate.year)) ? 366 : 365\n      startDate.year = startDate.year + 1\n    }\n    while (startDate.month !== endDate.month) {\n      if (startDate.month < endDate.month) {\n        if (this.isLeapYear(startDate.year)) diff += this.monthDaysLeap[startDate.month]\n        else diff += this.monthDays[startDate.month]\n        startDate.month = startDate.month + 1\n      } else {\n        if (this.isLeapYear(startDate.year)) diff -= this.monthDaysLeap[startDate.month - 1]\n        else diff -= this.monthDays[startDate.month - 1]\n        startDate.month = startDate.month - 1\n      }\n    }\n    return diff\n  }\n\n  generateMonthCal (date) {\n    const Month = this.parseDate(date); let day = ''\n    let difference = this.getDayDiff(this.epoch, Month)\n    difference = difference % 7\n    let Month2 = this.parseDate(date)\n    day = (this.isGreater(Month2, this.epoch)) ? this.Days[difference] : this.BDays[difference]\n    Month2 = this.parseDate(date)\n    if (this.isLeapYear(Month2.year)) this.printCal(this.monthDaysLeap[Month2.month], day)\n    else this.printCal(this.monthDays[Month2.month], day)\n  }\n}\n\n// const x = new Month()\n// x.generateMonthCal('1/2021')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n\n\n\n# 扩展\n\n\n# 通过年月计算月中天数\n\nconst getMonthDays = (monthNumber, year) => {\n  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]\n  const the30DaysMonths = [4, 6, 9, 11]\n\n  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) && (monthNumber !== 2)) {\n    throw new TypeError('Invalid Month Number.')\n  }\n\n  if (the31DaysMonths.includes(monthNumber)) return 31 \n  if (the30DaysMonths.includes(monthNumber)) return 30 \n\n  // Check for Leap year\n  // (year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))\n  if (year % 4 === 0) {\n    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {\n      return 29\n    }\n  }\n\n  return 28\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 计算两日相差天数\n\n/*\n    DateDayDifference Method\n    ------------------------\n    DateDayDifference method calculates the number of days between two dates.\n\n    Algorithm & Explanation : https://ncalculators.com/time-date/date-difference-calculator.htm\n*/\n\n// Internal method for make calculations easier\nconst isLeap = (year) => {\n  if (year % 400 === 0) return true\n  else if (year % 100 === 0) return false\n  else if (year % 4 === 0) return true\n  else return false\n}\nconst DateToDay = (dd, mm, yyyy) => {\n  return Math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isLeap(yyyy) ? -1 : -2))\n}\n\nconst DateDayDifference = (date1, date2) => {\n  // firstly, check that both input are string or not.\n  if (typeof date1 !== 'string' && typeof date2 !== 'string') {\n    return new TypeError('Argument is not a string.')\n  }\n  // extract the first date\n  const [firstDateDay, firstDateMonth, firstDateYear] = date1.split('/').map((ele) => Number(ele))\n  // extract the second date\n  const [secondDateDay, secondDateMonth, secondDateYear] = date2.split('/').map((ele) => Number(ele))\n  // check the both data are valid or not.\n  if (firstDateDay < 0 || firstDateDay > 31 ||\n        firstDateMonth > 12 || firstDateMonth < 0 ||\n        secondDateDay < 0 || secondDateDay > 31 ||\n        secondDateMonth > 12 || secondDateMonth < 0) {\n    return new TypeError('Date is not valid.')\n  }\n  return Math.abs(DateToDay(secondDateDay, secondDateMonth, secondDateYear) - DateToDay(firstDateDay, firstDateMonth, firstDateYear))\n}\n\n// Example : DateDayDifference('17/08/2002', '10/10/2020') => 6630\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 计算某日周几\n\n/*\n                    DateToDay Method\n                    ----------------\n    The DateToDay method takes a date in string format and\n    returns the name of a day. The approach behind this method\n    is very simple, we first take a string date and check\n    whether their date is valid or not, if the date is valid\n    then we do this But apply the algorithm shown below. The\n    algorithm shown below gives us the number of the day and\n    finally converts it to the name of the day.\n\n    Algorithm & Explanation : https://cs.uwaterloo.ca/~alopez-o/math-faq/node73.html\n*/\n\n// March is taken as the first month of the year.\nconst calcMonthList = {\n  1: 11,\n  2: 12,\n  3: 1,\n  4: 2,\n  5: 3,\n  6: 4,\n  7: 5,\n  8: 6,\n  9: 7,\n  10: 8,\n  11: 9,\n  12: 10\n}\n\n// show the week day in a number : Sunday - Saturday => 0 - 6\nconst daysNameList = { // weeks-day\n  0: 'Sunday',\n  1: 'Monday',\n  2: 'Tuesday',\n  3: 'Wednesday',\n  4: 'Thursday',\n  5: 'Friday',\n  6: 'Saturday'\n}\n\nconst DateToDay = (date) => {\n  // firstly, check that input is a string or not.\n  if (typeof date !== 'string') {\n    return new TypeError('Argument is not a string.')\n  }\n  // extract the date\n  const [day, month, year] = date.split('/').map((x) => Number(x))\n  // check the data are valid or not.\n  if (day < 0 || day > 31 || month > 12 || month < 0) {\n    return new TypeError('Date is not valid.')\n  }\n  // divide year to century and yearDigit value.\n  const yearDigit = (year % 100)\n  const century = Math.floor(year / 100)\n  // Apply the algorithm shown above\n  const weekDay = Math.abs((day + Math.floor((2.6 * calcMonthList[month]) - 0.2) - (2 * century) + yearDigit + Math.floor(yearDigit / 4) + Math.floor(century / 4)) % 7)\n  // return the weekDay name.\n  return daysNameList[weekDay]\n}\n\n// Example : DateToDay(\"18/12/2020\") => Friday\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n",normalizedContent:"# 介绍\n\n给定 mm/yyyy 的月份，打印次月份的月历。\n\n\n# 实现\n\n\n# javascript\n\n/*\n*  this algorithm accepts a month in the format mm/yyyy.\n*  and prints out the month's calendar.\n*  it uses an epoch of 1/1/1900, monday.\n*/\n\nclass month {\n  constructor () {\n    this.days = ['m', 't', 'w', 'th', 'f', 's', 'su']\n    this.bdays = ['m', 'su', 's', 'f', 'th', 'w', 't']\n    this.epoch = { month: 1, year: 1900 }\n    this.monthdays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    this.monthdaysleap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  }\n\n  printcal (days, startday, output = value => console.log(value)) {\n    output('m   t   w   th  f   s   su')\n    const dates = []; let i;\n    for (i = 1; i <= days; i++) {\n      dates.push(i)\n    }\n    for (i = 0; i < this.days.indexof(startday); i++) {\n      dates.unshift(' ')\n    }\n    while (true) {\n      let row = ''\n      for (i = 0; (i < 7) && (dates.length !== 0); i++) {\n        row += dates.shift()\n        while ((row.length % 4) !== 0) {\n          row += ' '\n        }\n      }\n      output(row)\n      if (dates.length === 0) break\n    }\n  }\n\n  parsedate (date) {\n    const datear = []; let block = ''; let i\n    for (i = 0; i < date.length; i++) {\n      if (date[i] === '/') {\n        datear.push(parseint(block))\n        block = ''\n        continue\n      }\n      block += date[i]\n    }\n    datear.push(parseint(block))\n    if (datear.length !== 2) throw new error('improper string encoding')\n    const dateob = { month: datear[0], year: datear[1] }\n    return dateob\n  }\n\n  isleapyear (year) {\n    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true\n    return false\n  }\n\n  isgreater (startdate, enddate) {\n    if (startdate.year > enddate.year) {\n      return true\n    } else if (startdate.year < enddate.year) {\n      return false\n    } else if (startdate.month > enddate.month) {\n      return true\n    } else if (startdate.month < enddate.month) {\n      return false\n    }\n    return true\n  }\n\n  getdaydiff (startdate, enddate) {\n    if (this.isgreater(startdate, enddate) === null) {\n      return 0\n    } else if ((this.isgreater(startdate, enddate) === true)) {\n      const middate = startdate\n      startdate = enddate\n      enddate = middate\n    }\n    let diff = 0\n    while (startdate.year !== enddate.year) {\n      diff += (this.isleapyear(startdate.year)) ? 366 : 365\n      startdate.year = startdate.year + 1\n    }\n    while (startdate.month !== enddate.month) {\n      if (startdate.month < enddate.month) {\n        if (this.isleapyear(startdate.year)) diff += this.monthdaysleap[startdate.month]\n        else diff += this.monthdays[startdate.month]\n        startdate.month = startdate.month + 1\n      } else {\n        if (this.isleapyear(startdate.year)) diff -= this.monthdaysleap[startdate.month - 1]\n        else diff -= this.monthdays[startdate.month - 1]\n        startdate.month = startdate.month - 1\n      }\n    }\n    return diff\n  }\n\n  generatemonthcal (date) {\n    const month = this.parsedate(date); let day = ''\n    let difference = this.getdaydiff(this.epoch, month)\n    difference = difference % 7\n    let month2 = this.parsedate(date)\n    day = (this.isgreater(month2, this.epoch)) ? this.days[difference] : this.bdays[difference]\n    month2 = this.parsedate(date)\n    if (this.isleapyear(month2.year)) this.printcal(this.monthdaysleap[month2.month], day)\n    else this.printcal(this.monthdays[month2.month], day)\n  }\n}\n\n// const x = new month()\n// x.generatemonthcal('1/2021')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n\n\n\n# 扩展\n\n\n# 通过年月计算月中天数\n\nconst getmonthdays = (monthnumber, year) => {\n  const the31daysmonths = [1, 3, 5, 7, 8, 10, 12]\n  const the30daysmonths = [4, 6, 9, 11]\n\n  if (!the31daysmonths.includes(monthnumber) && !the30daysmonths.includes(monthnumber) && (monthnumber !== 2)) {\n    throw new typeerror('invalid month number.')\n  }\n\n  if (the31daysmonths.includes(monthnumber)) return 31 \n  if (the30daysmonths.includes(monthnumber)) return 30 \n\n  // check for leap year\n  // (year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))\n  if (year % 4 === 0) {\n    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {\n      return 29\n    }\n  }\n\n  return 28\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 计算两日相差天数\n\n/*\n    datedaydifference method\n    ------------------------\n    datedaydifference method calculates the number of days between two dates.\n\n    algorithm & explanation : https://ncalculators.com/time-date/date-difference-calculator.htm\n*/\n\n// internal method for make calculations easier\nconst isleap = (year) => {\n  if (year % 400 === 0) return true\n  else if (year % 100 === 0) return false\n  else if (year % 4 === 0) return true\n  else return false\n}\nconst datetoday = (dd, mm, yyyy) => {\n  return math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isleap(yyyy) ? -1 : -2))\n}\n\nconst datedaydifference = (date1, date2) => {\n  // firstly, check that both input are string or not.\n  if (typeof date1 !== 'string' && typeof date2 !== 'string') {\n    return new typeerror('argument is not a string.')\n  }\n  // extract the first date\n  const [firstdateday, firstdatemonth, firstdateyear] = date1.split('/').map((ele) => number(ele))\n  // extract the second date\n  const [seconddateday, seconddatemonth, seconddateyear] = date2.split('/').map((ele) => number(ele))\n  // check the both data are valid or not.\n  if (firstdateday < 0 || firstdateday > 31 ||\n        firstdatemonth > 12 || firstdatemonth < 0 ||\n        seconddateday < 0 || seconddateday > 31 ||\n        seconddatemonth > 12 || seconddatemonth < 0) {\n    return new typeerror('date is not valid.')\n  }\n  return math.abs(datetoday(seconddateday, seconddatemonth, seconddateyear) - datetoday(firstdateday, firstdatemonth, firstdateyear))\n}\n\n// example : datedaydifference('17/08/2002', '10/10/2020') => 6630\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 计算某日周几\n\n/*\n                    datetoday method\n                    ----------------\n    the datetoday method takes a date in string format and\n    returns the name of a day. the approach behind this method\n    is very simple, we first take a string date and check\n    whether their date is valid or not, if the date is valid\n    then we do this but apply the algorithm shown below. the\n    algorithm shown below gives us the number of the day and\n    finally converts it to the name of the day.\n\n    algorithm & explanation : https://cs.uwaterloo.ca/~alopez-o/math-faq/node73.html\n*/\n\n// march is taken as the first month of the year.\nconst calcmonthlist = {\n  1: 11,\n  2: 12,\n  3: 1,\n  4: 2,\n  5: 3,\n  6: 4,\n  7: 5,\n  8: 6,\n  9: 7,\n  10: 8,\n  11: 9,\n  12: 10\n}\n\n// show the week day in a number : sunday - saturday => 0 - 6\nconst daysnamelist = { // weeks-day\n  0: 'sunday',\n  1: 'monday',\n  2: 'tuesday',\n  3: 'wednesday',\n  4: 'thursday',\n  5: 'friday',\n  6: 'saturday'\n}\n\nconst datetoday = (date) => {\n  // firstly, check that input is a string or not.\n  if (typeof date !== 'string') {\n    return new typeerror('argument is not a string.')\n  }\n  // extract the date\n  const [day, month, year] = date.split('/').map((x) => number(x))\n  // check the data are valid or not.\n  if (day < 0 || day > 31 || month > 12 || month < 0) {\n    return new typeerror('date is not valid.')\n  }\n  // divide year to century and yeardigit value.\n  const yeardigit = (year % 100)\n  const century = math.floor(year / 100)\n  // apply the algorithm shown above\n  const weekday = math.abs((day + math.floor((2.6 * calcmonthlist[month]) - 0.2) - (2 * century) + yeardigit + math.floor(yeardigit / 4) + math.floor(century / 4)) % 7)\n  // return the weekday name.\n  return daysnamelist[weekday]\n}\n\n// example : datetoday(\"18/12/2020\") => friday\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"KadaneAlgo [最大连续子数组和之Kadane算法]",frontmatter:{title:"KadaneAlgo [最大连续子数组和之Kadane算法]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/kadaneAlgo/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/60.KadaneAlgo.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/60.KadaneAlgo.md",key:"v-419c9df5",path:"/algorithm/dp/kadaneAlgo/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:913},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1018},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1025},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2318}],headersStr:"介绍 示例 实现 JavaScript 参考",content:"# 介绍\n\n给定一个大小为 N 的数组 arr[] ，任务是找出 arr[] 内总和最大的连续子数组。\n\n\n\nKadane 算法的想法是维护一个变量 max_ending_here，它存储了结束于当前索引的最大连续子数，一个变量 max_so_far 存储了迄今为止发现的连续子数的最大总和，每当 max_ending_here 中出现一个正和值时，将其与 max_so_far 进行比较，如果它大于 max_so_far 则更新 max_so_far。\n\n伪代码：\n\nInitialize:\n    max_so_far = INT_MIN\n    max_ending_here = 0\n\nLoop for each element of the array\n\n  (a) max_ending_here = max_ending_here + a[i]\n  (b) if(max_so_far < max_ending_here)\n            max_so_far = max_ending_here\n  (c) if(max_ending_here < 0)\n            max_ending_here = 0\nreturn max_so_far\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意：上述算法只有在至少有一个正数的情况下才起作用，否则就不起作用，即如果一个数组包含所有的负数就不起作用。\n\n遵循以下步骤来实施这一想法：\n\n * 初始化变量 max_so_far = INT_MIN 和 max_ending_here = 0\n * 运行一个 for 循环，从 0 到 N-1，对于每个索引 i。\n   * 将 arr [i] 添加到 max_ending_here。\n   * 如果 max_so_far 小于 max_ending_here，那么更新 max_so_far 到 max_ending_here。\n   * 如果 max_ending_here < 0，则更新 max_ending_here = 0。\n * 返回 max_so_far\n\n\n# 示例\n\n如 [-2,1,-3,4,-1,2,1,-5,4] 。当想要计算某个元素之前的最大连续子数组和时，有两种情况：前面的和加上该元素、该元素本身。因此，在每次循环之中取两者的最大值并不断更新结果。\n\n\n# 实现\n\n\n# JavaScript\n\n/* Kadane's algorithm is one of the most efficient ways to\n * calculate the maximum contiguous subarray sum for a given array.\n * Below is the implementation of kadanes's algorithm along with\n * some sample test cases.\n * There might be a special case in this problem if al the elements\n * of the given array are negative. In such a case, the maximum negative\n * value present in the array is the answer.\n *\n * Reference article :- https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/\n */\n\nfunction kadaneAlgo (array) {\n  let cummulativeSum = 0\n  let maxSum = Number.NEGATIVE_INFINITY // maxSum has the least possible value\n  for (let i = 0; i < array.length; i++) {\n    cummulativeSum = cummulativeSum + array[i]\n    if (maxSum < cummulativeSum) {\n      maxSum = cummulativeSum\n    } else if (cummulativeSum < 0) {\n      cummulativeSum = 0\n    }\n  }\n  return maxSum\n  // This function returns largest sum contiguous sum in a array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n或者：\n\nfunction kadaneAlgo(nums) {\n  let localMax  = nums[0], max = nums[0];\n  for (let i=1;i<nums.length;i++) {\n    localMax = Math.max(nums[i], localMax + nums[i]);\n    max = Math.max(max, localMax);\n  }\n  return max;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果全部是正数，则全数组是最大连续子数组。\n\n\n# 参考\n\n * Largest Sum Contiguous Subarray (Kadane's Algorithm) - GeeksforGeeks\n * 算法面试题 —— 动态规划 Kadane’s algorithm - 知乎",normalizedContent:"# 介绍\n\n给定一个大小为 n 的数组 arr[] ，任务是找出 arr[] 内总和最大的连续子数组。\n\n\n\nkadane 算法的想法是维护一个变量 max_ending_here，它存储了结束于当前索引的最大连续子数，一个变量 max_so_far 存储了迄今为止发现的连续子数的最大总和，每当 max_ending_here 中出现一个正和值时，将其与 max_so_far 进行比较，如果它大于 max_so_far 则更新 max_so_far。\n\n伪代码：\n\ninitialize:\n    max_so_far = int_min\n    max_ending_here = 0\n\nloop for each element of the array\n\n  (a) max_ending_here = max_ending_here + a[i]\n  (b) if(max_so_far < max_ending_here)\n            max_so_far = max_ending_here\n  (c) if(max_ending_here < 0)\n            max_ending_here = 0\nreturn max_so_far\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意：上述算法只有在至少有一个正数的情况下才起作用，否则就不起作用，即如果一个数组包含所有的负数就不起作用。\n\n遵循以下步骤来实施这一想法：\n\n * 初始化变量 max_so_far = int_min 和 max_ending_here = 0\n * 运行一个 for 循环，从 0 到 n-1，对于每个索引 i。\n   * 将 arr [i] 添加到 max_ending_here。\n   * 如果 max_so_far 小于 max_ending_here，那么更新 max_so_far 到 max_ending_here。\n   * 如果 max_ending_here < 0，则更新 max_ending_here = 0。\n * 返回 max_so_far\n\n\n# 示例\n\n如 [-2,1,-3,4,-1,2,1,-5,4] 。当想要计算某个元素之前的最大连续子数组和时，有两种情况：前面的和加上该元素、该元素本身。因此，在每次循环之中取两者的最大值并不断更新结果。\n\n\n# 实现\n\n\n# javascript\n\n/* kadane's algorithm is one of the most efficient ways to\n * calculate the maximum contiguous subarray sum for a given array.\n * below is the implementation of kadanes's algorithm along with\n * some sample test cases.\n * there might be a special case in this problem if al the elements\n * of the given array are negative. in such a case, the maximum negative\n * value present in the array is the answer.\n *\n * reference article :- https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/\n */\n\nfunction kadanealgo (array) {\n  let cummulativesum = 0\n  let maxsum = number.negative_infinity // maxsum has the least possible value\n  for (let i = 0; i < array.length; i++) {\n    cummulativesum = cummulativesum + array[i]\n    if (maxsum < cummulativesum) {\n      maxsum = cummulativesum\n    } else if (cummulativesum < 0) {\n      cummulativesum = 0\n    }\n  }\n  return maxsum\n  // this function returns largest sum contiguous sum in a array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n或者：\n\nfunction kadanealgo(nums) {\n  let localmax  = nums[0], max = nums[0];\n  for (let i=1;i<nums.length;i++) {\n    localmax = math.max(nums[i], localmax + nums[i]);\n    max = math.max(max, localmax);\n  }\n  return max;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果全部是正数，则全数组是最大连续子数组。\n\n\n# 参考\n\n * largest sum contiguous subarray (kadane's algorithm) - geeksforgeeks\n * 算法面试题 —— 动态规划 kadane’s algorithm - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"LevenshteinDistance [莱文斯坦距离]",frontmatter:{title:"LevenshteinDistance [莱文斯坦距离]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/levenshteinDistance/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/70.LevenshteinDistance.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/70.LevenshteinDistance.md",key:"v-053459e1",path:"/algorithm/dp/levenshteinDistance/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:123},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:130},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1073}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n莱文斯坦距离，又称 Levenshtein 距离，是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。\n\n允许的编辑操作包括：\n\n * 将一个字符替换成另一个字符\n * 插入一个字符\n * 删除一个字符\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * A Dynamic Programming based solution for calculation of the Levenshtein Distance\n * https://en.wikipedia.org/wiki/Levenshtein_distance\n */\n\nfunction minimum (a, b, c) {\n  if (a < b && a < c) return a;\n  if (b < a && b < c) return b;\n  return c\n}\n\nfunction costOfSubstitution (x, y) {\n  return x === y ? 0 : 1\n}\n\n// Levenshtein distance between x and y\nfunction calculate (x, y) {\n  const dp = new Array(x.length + 1)\n  for (let i = 0; i < x.length + 1; i++) dp[i] = new Array(y.length + 1);\n\n  for (let i = 0; i < x.length + 1; i++) {\n    for (let j = 0; j < y.length + 1; j++) {\n      if (i === 0) dp[i][j] = j;\n      else if (j === 0) dp[i][j] = i;\n      else dp[i][j] = minimum(dp[i - 1][j - 1] + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1);\n    }\n  }\n\n  return dp[x.length][y.length]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 参考\n\n * Levenshtein distance - Wikiwand\n * 莱文斯坦距离 - Wikiwand\n * EditDistance [编辑距离] | Fancy DSA",normalizedContent:"# 介绍\n\n莱文斯坦距离，又称 levenshtein 距离，是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。\n\n允许的编辑操作包括：\n\n * 将一个字符替换成另一个字符\n * 插入一个字符\n * 删除一个字符\n\n\n# 实现\n\n\n# javascript\n\n/**\n * a dynamic programming based solution for calculation of the levenshtein distance\n * https://en.wikipedia.org/wiki/levenshtein_distance\n */\n\nfunction minimum (a, b, c) {\n  if (a < b && a < c) return a;\n  if (b < a && b < c) return b;\n  return c\n}\n\nfunction costofsubstitution (x, y) {\n  return x === y ? 0 : 1\n}\n\n// levenshtein distance between x and y\nfunction calculate (x, y) {\n  const dp = new array(x.length + 1)\n  for (let i = 0; i < x.length + 1; i++) dp[i] = new array(y.length + 1);\n\n  for (let i = 0; i < x.length + 1; i++) {\n    for (let j = 0; j < y.length + 1; j++) {\n      if (i === 0) dp[i][j] = j;\n      else if (j === 0) dp[i][j] = i;\n      else dp[i][j] = minimum(dp[i - 1][j - 1] + costofsubstitution(x.charat(i - 1), y.charat(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1);\n    }\n  }\n\n  return dp[x.length][y.length]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 参考\n\n * levenshtein distance - wikiwand\n * 莱文斯坦距离 - wikiwand\n * editdistance [编辑距离] | fancy dsa",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"LongestCommonSubsequence [最长公共子序列]",frontmatter:{title:"LongestCommonSubsequence [最长公共子序列]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/longestCommonSubsequence/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/80.LongestCommonSubsequence.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/80.LongestCommonSubsequence.md",key:"v-66abb195",path:"/algorithm/dp/longestCommonSubsequence/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:355},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:362},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2200}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n最长公共子序列（LCS）是一个在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。这与查找最长公共子串的问题不同的地方是：子序列不需要在原序列中占用连续的位置 。最长公共子序列问题是一个经典的计算机科学问题，也是数据比较（英语：data comparison）程序，比如 Diff 工具，和生物信息学应用的基础。它也被广泛地应用在版本控制，比如 Git 用来调和文件之间的改变。\n\n最长公共子串：在计算机科学中，最长公共子串问题是寻找两个或多个已知字符串最长的子串。此问题与最长公共子序列问题的区别在于子序列不必是连续的，而子串却必须是。\n\n定义：一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nProblem:\nGiven two sequences, find the length of longest subsequence present in both of them.\nA subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.\nFor example, “abc”, “abg”, “bdf”, “aeg”, ‘”acefg”, .. etc are subsequences of “abcdefg”\n\nOur Solution:\nWe use recursion with tabular memoization.\nTime complexity: O(M x N)\nSolving each subproblem has a cost of O(1). Again, there are MxN subproblems,\nand so we get a total time complexity of O(MxN).\nSpace complexity: O(M x N)\nWe need to store the answer for each of the MxN subproblems.\n\nImprovement:\nIt's possible to optimize space complexity to O(min(M, N)) or time to O((N + r)log(N))\nwhere r is the number of matches between the two sequences. Try to figure out how.\n\nReferences:\n[wikipedia](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)\n[leetcode](https://leetcode.com/problems/longest-common-subsequence/)\n*/\n\n/**\n * Finds length of the longest common subsequence among the two input string\n * @param {string} str1 Input string #1\n * @param {string} str2 Input string #2\n * @returns {number} Length of the longest common subsequence\n */\nfunction longestCommonSubsequence (str1, str2) {\n  const memo = new Array(str1.length + 1).fill(null).map(() => new Array(str2.length + 1).fill(null))\n\n  function recursive (end1, end2) {\n    if (end1 === -1 || end2 === -1) return 0\n    if (memo[end1][end2] !== null) return memo[end1][end2]\n\n    if (str1[end1] === str2[end2]) return memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)\n    return memo[end1][end2] = Math.max(recursive(end1 - 1, end2), recursive(end1, end2 - 1))\n  }\n\n  return recursive(str1.length - 1, str2.length - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考\n\n * Longest common subsequence problem - Wikiwand\n * 最长公共子序列 - Wikiwand",normalizedContent:"# 介绍\n\n最长公共子序列（lcs）是一个在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。这与查找最长公共子串的问题不同的地方是：子序列不需要在原序列中占用连续的位置 。最长公共子序列问题是一个经典的计算机科学问题，也是数据比较（英语：data comparison）程序，比如 diff 工具，和生物信息学应用的基础。它也被广泛地应用在版本控制，比如 git 用来调和文件之间的改变。\n\n最长公共子串：在计算机科学中，最长公共子串问题是寻找两个或多个已知字符串最长的子串。此问题与最长公共子序列问题的区别在于子序列不必是连续的，而子串却必须是。\n\n定义：一个数列 s，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 s 称为已知序列的最长公共子序列。\n\n\n# 实现\n\n\n# javascript\n\n/*\nproblem:\ngiven two sequences, find the length of longest subsequence present in both of them.\na subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.\nfor example, “abc”, “abg”, “bdf”, “aeg”, ‘”acefg”, .. etc are subsequences of “abcdefg”\n\nour solution:\nwe use recursion with tabular memoization.\ntime complexity: o(m x n)\nsolving each subproblem has a cost of o(1). again, there are mxn subproblems,\nand so we get a total time complexity of o(mxn).\nspace complexity: o(m x n)\nwe need to store the answer for each of the mxn subproblems.\n\nimprovement:\nit's possible to optimize space complexity to o(min(m, n)) or time to o((n + r)log(n))\nwhere r is the number of matches between the two sequences. try to figure out how.\n\nreferences:\n[wikipedia](https://en.wikipedia.org/wiki/longest_common_subsequence_problem)\n[leetcode](https://leetcode.com/problems/longest-common-subsequence/)\n*/\n\n/**\n * finds length of the longest common subsequence among the two input string\n * @param {string} str1 input string #1\n * @param {string} str2 input string #2\n * @returns {number} length of the longest common subsequence\n */\nfunction longestcommonsubsequence (str1, str2) {\n  const memo = new array(str1.length + 1).fill(null).map(() => new array(str2.length + 1).fill(null))\n\n  function recursive (end1, end2) {\n    if (end1 === -1 || end2 === -1) return 0\n    if (memo[end1][end2] !== null) return memo[end1][end2]\n\n    if (str1[end1] === str2[end2]) return memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)\n    return memo[end1][end2] = math.max(recursive(end1 - 1, end2), recursive(end1, end2 - 1))\n  }\n\n  return recursive(str1.length - 1, str2.length - 1)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考\n\n * longest common subsequence problem - wikiwand\n * 最长公共子序列 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"LongestIncreasingSubsequence [最长递增子序列]",frontmatter:{title:"LongestIncreasingSubsequence [最长递增子序列]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/dp/longestIncreasingSubsequence/",categories:["算法","DynamicProgramming 动态规划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/110.DynamicProgramming%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/90.LongestIncreasingSubsequence.html",relativePath:"20.算法/110.DynamicProgramming 动态规划/90.LongestIncreasingSubsequence.md",key:"v-12bb2bb5",path:"/algorithm/dp/longestIncreasingSubsequence/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:266},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:273},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:917},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1951}],headersStr:"介绍 实现 JavaScript 扩展 参考",content:"# 介绍\n\n在计算机科学中，最长递增子序列（longest increasing subsequence）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。许多与数学、算法、随机矩阵理论（英语：random matrix theory）、表示论相关的研究都会涉及最长递增子序列。解决最长递增子序列问题的算法最低要求O(nlogn)O(nlogn)O(nlogn) 的时间复杂度，这里 n 表示输入序列的规模。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * A Dynamic Programming based solution for calculating Longest Increasing Subsequence\n * https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n */\n\n// Return the length of the Longest Increasing Subsequence, given array x\nfunction longestIncreasingSubsequence (x) {\n  const length = x.length\n  const dp = Array(length).fill(1)\n\n  let res = 1\n\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (x[i] > x[j]) {\n        dp[i] = Math.max(dp[i], 1 + dp[j])\n        if (dp[i] > res) res = dp[i]\n      }\n    }\n  }\n\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 扩展\n\n二分查找解决最长递增子序列问题。\n\n思路：\n\n原始数组为 A, 建立一个辅助数组 B, 变量 end 用来记录 B 数组末尾元素的下标。遍历 A 中的所有的元素 x = A [i]：\n\n * 如果 x > B 的末尾元素，则将 x 追加到 B 的末尾，end+=1\n * 如果 x <B 的末尾元素，则利用二分查找，寻找 B 中第一个大于 x 的元素，并用 x 进行替换 e.g. x= 4 B=[1,3,5,6] ==> B=[1,3,4,6]\n\n遍历结束之后，B 的长度则为最长递增子序列的长度。\n\nPython：\n\ndef get_lis_length(arr):\n  temp = [arr[0]]\n  end = 0\n\n  for i in range(1, len(arr)):\n    if arr[i] > temp[end]:\n      end += 1\n      temp.append(arr[i])\n    else :\n      pos = binary_search(temp,0, len(temp), arr[i])\n      temp[pos] = arr[i]\n  return end + 1\n\ndef binary_search(arr, start, end, value):\n  l = start\n  r = end-1\n  while l <= r:\n    m = (l + r) // 2\n    if arr[m] == value:\n      return m\n    elif arr[m] < value:\n      l = m + 1\n    else:\n      r = m - 1\n  return l\n\n# arr = [2, 1, 5, 3, 6, 4, 8, 9, 7]\n# print(get_lis_length(arr))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * // 即 floordiv (a, b)。参见 operator --- 标准运算符替代函数 — Python 3.10.8 文档。\n\n思路\n\n在循环中找到正序的子序列，此时子序列的长度应该继续增加而不能减少。因此通过减小序列递增值（替换较大值）以降低序列长度增加的成本。\n\n\n# 参考\n\n * Longest increasing subsequence - Wikiwand\n * 最长递增子序列 - Wikiwand\n * fucking-algorithm / 动态规划设计：最长递增子序列.md at master・labuladong/fucking-algorithm\n * 最长递增子序列 - 知乎",normalizedContent:"# 介绍\n\n在计算机科学中，最长递增子序列（longest increasing subsequence）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。许多与数学、算法、随机矩阵理论（英语：random matrix theory）、表示论相关的研究都会涉及最长递增子序列。解决最长递增子序列问题的算法最低要求o(nlogn)o(nlogn)o(nlogn) 的时间复杂度，这里 n 表示输入序列的规模。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * a dynamic programming based solution for calculating longest increasing subsequence\n * https://en.wikipedia.org/wiki/longest_increasing_subsequence\n */\n\n// return the length of the longest increasing subsequence, given array x\nfunction longestincreasingsubsequence (x) {\n  const length = x.length\n  const dp = array(length).fill(1)\n\n  let res = 1\n\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (x[i] > x[j]) {\n        dp[i] = math.max(dp[i], 1 + dp[j])\n        if (dp[i] > res) res = dp[i]\n      }\n    }\n  }\n\n  return res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 扩展\n\n二分查找解决最长递增子序列问题。\n\n思路：\n\n原始数组为 a, 建立一个辅助数组 b, 变量 end 用来记录 b 数组末尾元素的下标。遍历 a 中的所有的元素 x = a [i]：\n\n * 如果 x > b 的末尾元素，则将 x 追加到 b 的末尾，end+=1\n * 如果 x <b 的末尾元素，则利用二分查找，寻找 b 中第一个大于 x 的元素，并用 x 进行替换 e.g. x= 4 b=[1,3,5,6] ==> b=[1,3,4,6]\n\n遍历结束之后，b 的长度则为最长递增子序列的长度。\n\npython：\n\ndef get_lis_length(arr):\n  temp = [arr[0]]\n  end = 0\n\n  for i in range(1, len(arr)):\n    if arr[i] > temp[end]:\n      end += 1\n      temp.append(arr[i])\n    else :\n      pos = binary_search(temp,0, len(temp), arr[i])\n      temp[pos] = arr[i]\n  return end + 1\n\ndef binary_search(arr, start, end, value):\n  l = start\n  r = end-1\n  while l <= r:\n    m = (l + r) // 2\n    if arr[m] == value:\n      return m\n    elif arr[m] < value:\n      l = m + 1\n    else:\n      r = m - 1\n  return l\n\n# arr = [2, 1, 5, 3, 6, 4, 8, 9, 7]\n# print(get_lis_length(arr))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * // 即 floordiv (a, b)。参见 operator --- 标准运算符替代函数 — python 3.10.8 文档。\n\n思路\n\n在循环中找到正序的子序列，此时子序列的长度应该继续增加而不能减少。因此通过减小序列递增值（替换较大值）以降低序列长度增加的成本。\n\n\n# 参考\n\n * longest increasing subsequence - wikiwand\n * 最长递增子序列 - wikiwand\n * fucking-algorithm / 动态规划设计：最长递增子序列.md at master・labuladong/fucking-algorithm\n * 最长递增子序列 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"LFUCache [最近最少使用缓存]",frontmatter:{title:"LFUCache [最近最少使用缓存]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cache/LFUCache/",categories:["算法","Cache 缓存"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/120.Cache%20%E7%BC%93%E5%AD%98/10.LFUCache.html",relativePath:"20.算法/120.Cache 缓存/10.LFUCache.md",key:"v-3fa51bdc",path:"/algorithm/cache/LFUCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:280},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:442},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:7487},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7507}],headersStr:"介绍 实现 JavaScript 扩展 参考",content:"# 介绍\n\nLFU（Least Frequently Used ，最近最少使用算法）也是一种常见的缓存算法。LFU 算法的思想是：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。\n\nLFU 算法的描述：\n\n设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：\n\n * set (key,value)：将记录 (key,value) 插入该结构。当缓存满时，将访问频率最低的数据置换掉。\n * get (key)：返回 key 对应的 value 值。\n\n算法实现策略：考虑到 LFU 会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。LFU 算法本质上可以看做是一个 top K 问题 (K = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆 + 哈希表。\n\n\n# 实现\n\n\n# JavaScript\n\nclass CacheNode {\n  constructor (key, value, frequency) {\n    this.key = key\n    this.value = value\n    this.frequency = frequency\n\n    return Object.seal(this)\n  }\n}\n\n// This frequency map class will act like javascript Map DS with more two custom method refresh & insert\nclass FrequencyMap extends Map {\n  static get [Symbol.species] () { return Map } // for using Symbol.species we can access Map constructor  @see -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@species\n  get [Symbol.toStringTag] () { return '' }\n\n  /**\n  * @method refresh\n  * @description - It's revive a CacheNode, increment of this nodes frequency and refresh the frequencyMap via new incremented nodes frequency\n  * @param {CacheNode} node\n  */\n  refresh (node) {\n    const { frequency } = node\n    const freqSet = this.get(frequency)\n    freqSet.delete(node)\n\n    node.frequency++\n\n    this.insert(node)\n  }\n\n  /**\n   * @method insert\n   * @description - Add new CacheNode into HashSet by the frequency\n   * @param {CacheNode} node\n   */\n  insert (node) {\n    const { frequency } = node\n\n    if (!this.has(frequency)) {\n      this.set(frequency, new Set())\n    }\n\n    this.get(frequency).add(node)\n  }\n}\n\nclass LFUCache {\n    #capacity\n    #frequencyMap\n\n    /**\n     * @param {number} capacity - The range of LFUCache\n     * @returns {LFUCache} - sealed\n     */\n    constructor (capacity) {\n      this.#capacity = capacity\n      this.#frequencyMap = new FrequencyMap()\n      this.misses = 0\n      this.hits = 0\n      this.cache = new Map()\n\n      return Object.seal(this)\n    }\n\n    /**\n   * Get the capacity of the LFUCache\n   * @returns {number}\n   */\n    get capacity () {\n      return this.#capacity\n    }\n\n    /**\n   * Get the current size of LFUCache\n   * @returns {number}\n   */\n    get size () {\n      return this.cache.size\n    }\n\n    /**\n     * Set the capacity of the LFUCache if you decrease the capacity its removed CacheNodes following the LFU - least frequency used\n     */\n    set capacity (newCapacity) {\n      if (this.#capacity > newCapacity) {\n        let diff = this.#capacity - newCapacity // get the decrement number of capacity\n\n        while (diff--) {\n          this.#removeCacheNode()\n        }\n\n        this.cache.size === 0 && this.#frequencyMap.clear()\n      }\n\n      this.#capacity = newCapacity\n    }\n\n    get info () {\n      return Object.freeze({\n        misses: this.misses,\n        hits: this.hits,\n        capacity: this.capacity,\n        currentSize: this.size,\n        leastFrequency: this.leastFrequency\n      })\n    }\n\n    get leastFrequency () {\n      const freqCacheIterator = this.#frequencyMap.keys()\n      let leastFrequency = freqCacheIterator.next().value || null\n\n      // select the non-empty frequency Set\n      while (this.#frequencyMap.get(leastFrequency)?.size === 0) {\n        leastFrequency = freqCacheIterator.next().value\n      }\n\n      return leastFrequency\n    }\n\n    #removeCacheNode () {\n      const leastFreqSet = this.#frequencyMap.get(this.leastFrequency)\n      // Select the least recently used node from the least Frequency set\n      const LFUNode = leastFreqSet.values().next().value\n\n      leastFreqSet.delete(LFUNode)\n      this.cache.delete(LFUNode.key)\n    }\n\n    /**\n   * if key exist then return true otherwise false\n   * @param {any} key\n   * @returns {boolean}\n   */\n    has (key) {\n      key = String(key) // converted to string\n\n      return this.cache.has(key)\n    }\n\n    /**\n     * @method get\n     * @description - This method return the value of key & refresh the frequencyMap by the oldNode\n     * @param {string} key\n     * @returns {any}\n     */\n    get (key) {\n      key = String(key) // converted to string\n\n      if (this.cache.has(key)) {\n        const oldNode = this.cache.get(key)\n        this.#frequencyMap.refresh(oldNode)\n\n        this.hits++\n\n        return oldNode.value\n      }\n\n      this.misses++\n      return null\n    }\n\n    /**\n     * @method set\n     * @description - This method stored the value by key & add frequency if it doesn't exist\n     * @param {string} key\n     * @param {any} value\n     * @param {number} frequency\n     * @returns {LFUCache}\n     */\n    set (key, value, frequency = 1) {\n      key = String(key) // converted to string\n\n      if (this.#capacity === 0) {\n        throw new RangeError('LFUCache ERROR: The Capacity is 0')\n      }\n\n      if (this.cache.has(key)) {\n        const node = this.cache.get(key)\n        node.value = value\n\n        this.#frequencyMap.refresh(node)\n\n        return this\n      }\n\n      // if the cache size is full, then it's delete the Least Frequency Used node\n      if (this.#capacity === this.cache.size) {\n        this.#removeCacheNode()\n      }\n\n      const newNode = new CacheNode(key, value, frequency)\n\n      this.cache.set(key, newNode)\n      this.#frequencyMap.insert(newNode)\n\n      return this\n    }\n\n    /**\n     * @method parse\n     * @description - This method receive a valid LFUCache JSON & run JSON.prase() method and merge with existing LFUCache\n     * @param {JSON} json\n     * @returns {LFUCache} - merged\n     */\n    parse (json) {\n      const { misses, hits, cache } = JSON.parse(json)\n\n      this.misses += misses ?? 0\n      this.hits += hits ?? 0\n\n      for (const key in cache) {\n        const { value, frequency } = cache[key]\n        this.set(key, value, frequency)\n      }\n\n      return this\n    }\n\n    /**\n     * @method clear\n     * @description - This method cleared the whole LFUCache\n     * @returns {LFUCache}\n     */\n    clear () {\n      this.cache.clear()\n      this.#frequencyMap.clear()\n\n      return this\n    }\n\n    /**\n     * @method toString\n     * @description - This method generate a JSON format of LFUCache & return it.\n     * @param {number} indent\n     * @returns {string} - JSON\n     */\n    toString (indent) {\n      const replacer = (_, value) => {\n        if (value instanceof Set) {\n          return [...value]\n        }\n\n        if (value instanceof Map) {\n          return Object.fromEntries(value)\n        }\n\n        return value\n      }\n\n      return JSON.stringify(this, replacer, indent)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n\n\n\n# 扩展\n\n操作系统 - 页面置换算法：\n\n参考：\n\n操作系统原理之内存管理\n\n\n# 参考\n\n * LRU & LFU 缓存机制的原理及实现 - 知乎",normalizedContent:"# 介绍\n\nlfu（least frequently used ，最近最少使用算法）也是一种常见的缓存算法。lfu 算法的思想是：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。\n\nlfu 算法的描述：\n\n设计一种缓存结构，该结构在构造时确定大小，假设大小为 k，并有两个功能：\n\n * set (key,value)：将记录 (key,value) 插入该结构。当缓存满时，将访问频率最低的数据置换掉。\n * get (key)：返回 key 对应的 value 值。\n\n算法实现策略：考虑到 lfu 会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。lfu 算法本质上可以看做是一个 top k 问题 (k = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆 + 哈希表。\n\n\n# 实现\n\n\n# javascript\n\nclass cachenode {\n  constructor (key, value, frequency) {\n    this.key = key\n    this.value = value\n    this.frequency = frequency\n\n    return object.seal(this)\n  }\n}\n\n// this frequency map class will act like javascript map ds with more two custom method refresh & insert\nclass frequencymap extends map {\n  static get [symbol.species] () { return map } // for using symbol.species we can access map constructor  @see -> https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/map/@@species\n  get [symbol.tostringtag] () { return '' }\n\n  /**\n  * @method refresh\n  * @description - it's revive a cachenode, increment of this nodes frequency and refresh the frequencymap via new incremented nodes frequency\n  * @param {cachenode} node\n  */\n  refresh (node) {\n    const { frequency } = node\n    const freqset = this.get(frequency)\n    freqset.delete(node)\n\n    node.frequency++\n\n    this.insert(node)\n  }\n\n  /**\n   * @method insert\n   * @description - add new cachenode into hashset by the frequency\n   * @param {cachenode} node\n   */\n  insert (node) {\n    const { frequency } = node\n\n    if (!this.has(frequency)) {\n      this.set(frequency, new set())\n    }\n\n    this.get(frequency).add(node)\n  }\n}\n\nclass lfucache {\n    #capacity\n    #frequencymap\n\n    /**\n     * @param {number} capacity - the range of lfucache\n     * @returns {lfucache} - sealed\n     */\n    constructor (capacity) {\n      this.#capacity = capacity\n      this.#frequencymap = new frequencymap()\n      this.misses = 0\n      this.hits = 0\n      this.cache = new map()\n\n      return object.seal(this)\n    }\n\n    /**\n   * get the capacity of the lfucache\n   * @returns {number}\n   */\n    get capacity () {\n      return this.#capacity\n    }\n\n    /**\n   * get the current size of lfucache\n   * @returns {number}\n   */\n    get size () {\n      return this.cache.size\n    }\n\n    /**\n     * set the capacity of the lfucache if you decrease the capacity its removed cachenodes following the lfu - least frequency used\n     */\n    set capacity (newcapacity) {\n      if (this.#capacity > newcapacity) {\n        let diff = this.#capacity - newcapacity // get the decrement number of capacity\n\n        while (diff--) {\n          this.#removecachenode()\n        }\n\n        this.cache.size === 0 && this.#frequencymap.clear()\n      }\n\n      this.#capacity = newcapacity\n    }\n\n    get info () {\n      return object.freeze({\n        misses: this.misses,\n        hits: this.hits,\n        capacity: this.capacity,\n        currentsize: this.size,\n        leastfrequency: this.leastfrequency\n      })\n    }\n\n    get leastfrequency () {\n      const freqcacheiterator = this.#frequencymap.keys()\n      let leastfrequency = freqcacheiterator.next().value || null\n\n      // select the non-empty frequency set\n      while (this.#frequencymap.get(leastfrequency)?.size === 0) {\n        leastfrequency = freqcacheiterator.next().value\n      }\n\n      return leastfrequency\n    }\n\n    #removecachenode () {\n      const leastfreqset = this.#frequencymap.get(this.leastfrequency)\n      // select the least recently used node from the least frequency set\n      const lfunode = leastfreqset.values().next().value\n\n      leastfreqset.delete(lfunode)\n      this.cache.delete(lfunode.key)\n    }\n\n    /**\n   * if key exist then return true otherwise false\n   * @param {any} key\n   * @returns {boolean}\n   */\n    has (key) {\n      key = string(key) // converted to string\n\n      return this.cache.has(key)\n    }\n\n    /**\n     * @method get\n     * @description - this method return the value of key & refresh the frequencymap by the oldnode\n     * @param {string} key\n     * @returns {any}\n     */\n    get (key) {\n      key = string(key) // converted to string\n\n      if (this.cache.has(key)) {\n        const oldnode = this.cache.get(key)\n        this.#frequencymap.refresh(oldnode)\n\n        this.hits++\n\n        return oldnode.value\n      }\n\n      this.misses++\n      return null\n    }\n\n    /**\n     * @method set\n     * @description - this method stored the value by key & add frequency if it doesn't exist\n     * @param {string} key\n     * @param {any} value\n     * @param {number} frequency\n     * @returns {lfucache}\n     */\n    set (key, value, frequency = 1) {\n      key = string(key) // converted to string\n\n      if (this.#capacity === 0) {\n        throw new rangeerror('lfucache error: the capacity is 0')\n      }\n\n      if (this.cache.has(key)) {\n        const node = this.cache.get(key)\n        node.value = value\n\n        this.#frequencymap.refresh(node)\n\n        return this\n      }\n\n      // if the cache size is full, then it's delete the least frequency used node\n      if (this.#capacity === this.cache.size) {\n        this.#removecachenode()\n      }\n\n      const newnode = new cachenode(key, value, frequency)\n\n      this.cache.set(key, newnode)\n      this.#frequencymap.insert(newnode)\n\n      return this\n    }\n\n    /**\n     * @method parse\n     * @description - this method receive a valid lfucache json & run json.prase() method and merge with existing lfucache\n     * @param {json} json\n     * @returns {lfucache} - merged\n     */\n    parse (json) {\n      const { misses, hits, cache } = json.parse(json)\n\n      this.misses += misses ?? 0\n      this.hits += hits ?? 0\n\n      for (const key in cache) {\n        const { value, frequency } = cache[key]\n        this.set(key, value, frequency)\n      }\n\n      return this\n    }\n\n    /**\n     * @method clear\n     * @description - this method cleared the whole lfucache\n     * @returns {lfucache}\n     */\n    clear () {\n      this.cache.clear()\n      this.#frequencymap.clear()\n\n      return this\n    }\n\n    /**\n     * @method tostring\n     * @description - this method generate a json format of lfucache & return it.\n     * @param {number} indent\n     * @returns {string} - json\n     */\n    tostring (indent) {\n      const replacer = (_, value) => {\n        if (value instanceof set) {\n          return [...value]\n        }\n\n        if (value instanceof map) {\n          return object.fromentries(value)\n        }\n\n        return value\n      }\n\n      return json.stringify(this, replacer, indent)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n\n\n\n# 扩展\n\n操作系统 - 页面置换算法：\n\n参考：\n\n操作系统原理之内存管理\n\n\n# 参考\n\n * lru & lfu 缓存机制的原理及实现 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"LRUCache [最近最久未使用缓存]",frontmatter:{title:"LRUCache [最近最久未使用缓存]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cache/LRUCache/",categories:["算法","Cache 缓存"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/120.Cache%20%E7%BC%93%E5%AD%98/20.LRUCache.html",relativePath:"20.算法/120.Cache 缓存/20.LRUCache.md",key:"v-65099590",path:"/algorithm/cache/LRUCache/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:319},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1238},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4460}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\nLRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如 Redis, Memcached）中都有广泛使用。LRU 算法的思想是：如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。\n\nLRU 算法的描述： 设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：\n\n * set (key,value)：将记录 (key,value) 插入该结构。当缓存满时，将最久未使用的数据置换掉。\n * get (key)：返回 key 对应的 value 值。\n\n实现：最朴素的思想就是用数组 + 时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（LinkedList）+ 哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），在 Java 里有对应的数据结构 LinkedHashMap。\n\n利用 Java 的 LinkedHashMap 用非常简单的代码来实现基于 LRU 算法的 Cache 功能。\n\nclass LRUCache extends LinkedHashMap<Integer,Integer>{\n    private int capacity;\n    public LRUCache(int capacity) {\n        //调用父类中的构造方法创建一个LinkedHashMap，设置其容量为capacity，loadFactor为0.75，并开启accessOrder为true\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        //若key存在,返回对应value值;若key不存在,返回-1\n        return super.getOrDefault(key,-1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key,value);\n    }\n    protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest){\n        //若返回的结果为true，则执行removeEntryForKey方法删除eldest entry\n        return size() > capacity;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 实现\n\n\n# JavaScript\n\nclass LRUCache {\n  // LRU Cache to store a given capacity of data\n  #capacity\n\n  /**\n   * @param {number} capacity - the capacity of LRUCache\n   * @returns {LRUCache} - sealed\n   */\n  constructor (capacity) {\n    if (!Number.isInteger(capacity) || capacity < 0) {\n      throw new TypeError('Invalid capacity')\n    }\n\n    this.#capacity = ~~capacity\n    this.misses = 0\n    this.hits = 0\n    this.cache = new Map()\n\n    return Object.seal(this)\n  }\n\n  get info () {\n    return Object.freeze({\n      misses: this.misses,\n      hits: this.hits,\n      capacity: this.capacity,\n      size: this.size\n    })\n  }\n\n  get size () {\n    return this.cache.size\n  }\n\n  get capacity () {\n    return this.#capacity\n  }\n\n  set capacity (newCapacity) {\n    if (newCapacity < 0) {\n      throw new RangeError('Capacity should be greater than 0')\n    }\n\n    if (newCapacity < this.capacity) {\n      let diff = this.capacity - newCapacity\n\n      while (diff--) {\n        this.#removeLeastRecentlyUsed()\n      }\n    }\n\n    this.#capacity = newCapacity\n  }\n\n  /**\n * delete oldest key existing in map by the help of iterator\n */\n  #removeLeastRecentlyUsed () {\n    this.cache.delete(this.cache.keys().next().value)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {*}\n   */\n  has (key) {\n    key = String(key)\n\n    return this.cache.has(key)\n  }\n\n  /**\n   * @param {string} key\n   * @param {*} value\n   */\n  set (key, value) {\n    key = String(key)\n    // Sets the value for the input key and if the key exists it updates the existing key\n    if (this.size === this.capacity) {\n      this.#removeLeastRecentlyUsed()\n    }\n\n    this.cache.set(key, value)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {*}\n   */\n  get (key) {\n    key = String(key)\n    // Returns the value for the input key. Returns null if key is not present in cache\n    if (this.cache.has(key)) {\n      const value = this.cache.get(key)\n\n      // refresh the cache to update the order of key\n      this.cache.delete(key)\n      this.cache.set(key, value)\n\n      this.hits++\n      return value\n    }\n\n    this.misses++\n    return null\n  }\n\n  /**\n   * @param {JSON} json\n   * @returns {LRUCache}\n   */\n  parse (json) {\n    const { misses, hits, cache } = JSON.parse(json)\n\n    this.misses += misses ?? 0\n    this.hits += hits ?? 0\n\n    for (const key in cache) {\n      this.set(key, cache[key])\n    }\n\n    return this\n  }\n\n  /**\n   * @param {number} indent\n   * @returns {JSON} - string\n   */\n  toString (indent) {\n    const replacer = (_, value) => {\n      if (value instanceof Set) {\n        return [...value]\n      }\n\n      if (value instanceof Map) {\n        return Object.fromEntries(value)\n      }\n\n      return value\n    }\n\n    return JSON.stringify(this, replacer, indent)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n\n# 参考\n\n * LRU & LFU 缓存机制的原理及实现 - 知乎",normalizedContent:"# 介绍\n\nlru（the least recently used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如 redis, memcached）中都有广泛使用。lru 算法的思想是：如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。\n\nlru 算法的描述： 设计一种缓存结构，该结构在构造时确定大小，假设大小为 k，并有两个功能：\n\n * set (key,value)：将记录 (key,value) 插入该结构。当缓存满时，将最久未使用的数据置换掉。\n * get (key)：返回 key 对应的 value 值。\n\n实现：最朴素的思想就是用数组 + 时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（linkedlist）+ 哈希表（hashmap）实现（链表用来表示位置，哈希表用来存储和查找），在 java 里有对应的数据结构 linkedhashmap。\n\n利用 java 的 linkedhashmap 用非常简单的代码来实现基于 lru 算法的 cache 功能。\n\nclass lrucache extends linkedhashmap<integer,integer>{\n    private int capacity;\n    public lrucache(int capacity) {\n        //调用父类中的构造方法创建一个linkedhashmap，设置其容量为capacity，loadfactor为0.75，并开启accessorder为true\n        super(capacity, 0.75f, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        //若key存在,返回对应value值;若key不存在,返回-1\n        return super.getordefault(key,-1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key,value);\n    }\n    protected boolean removeeldestentry(map.entry<integer,integer> eldest){\n        //若返回的结果为true，则执行removeentryforkey方法删除eldest entry\n        return size() > capacity;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 实现\n\n\n# javascript\n\nclass lrucache {\n  // lru cache to store a given capacity of data\n  #capacity\n\n  /**\n   * @param {number} capacity - the capacity of lrucache\n   * @returns {lrucache} - sealed\n   */\n  constructor (capacity) {\n    if (!number.isinteger(capacity) || capacity < 0) {\n      throw new typeerror('invalid capacity')\n    }\n\n    this.#capacity = ~~capacity\n    this.misses = 0\n    this.hits = 0\n    this.cache = new map()\n\n    return object.seal(this)\n  }\n\n  get info () {\n    return object.freeze({\n      misses: this.misses,\n      hits: this.hits,\n      capacity: this.capacity,\n      size: this.size\n    })\n  }\n\n  get size () {\n    return this.cache.size\n  }\n\n  get capacity () {\n    return this.#capacity\n  }\n\n  set capacity (newcapacity) {\n    if (newcapacity < 0) {\n      throw new rangeerror('capacity should be greater than 0')\n    }\n\n    if (newcapacity < this.capacity) {\n      let diff = this.capacity - newcapacity\n\n      while (diff--) {\n        this.#removeleastrecentlyused()\n      }\n    }\n\n    this.#capacity = newcapacity\n  }\n\n  /**\n * delete oldest key existing in map by the help of iterator\n */\n  #removeleastrecentlyused () {\n    this.cache.delete(this.cache.keys().next().value)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {*}\n   */\n  has (key) {\n    key = string(key)\n\n    return this.cache.has(key)\n  }\n\n  /**\n   * @param {string} key\n   * @param {*} value\n   */\n  set (key, value) {\n    key = string(key)\n    // sets the value for the input key and if the key exists it updates the existing key\n    if (this.size === this.capacity) {\n      this.#removeleastrecentlyused()\n    }\n\n    this.cache.set(key, value)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {*}\n   */\n  get (key) {\n    key = string(key)\n    // returns the value for the input key. returns null if key is not present in cache\n    if (this.cache.has(key)) {\n      const value = this.cache.get(key)\n\n      // refresh the cache to update the order of key\n      this.cache.delete(key)\n      this.cache.set(key, value)\n\n      this.hits++\n      return value\n    }\n\n    this.misses++\n    return null\n  }\n\n  /**\n   * @param {json} json\n   * @returns {lrucache}\n   */\n  parse (json) {\n    const { misses, hits, cache } = json.parse(json)\n\n    this.misses += misses ?? 0\n    this.hits += hits ?? 0\n\n    for (const key in cache) {\n      this.set(key, cache[key])\n    }\n\n    return this\n  }\n\n  /**\n   * @param {number} indent\n   * @returns {json} - string\n   */\n  tostring (indent) {\n    const replacer = (_, value) => {\n      if (value instanceof set) {\n        return [...value]\n      }\n\n      if (value instanceof map) {\n        return object.fromentries(value)\n      }\n\n      return value\n    }\n\n    return json.stringify(this, replacer, indent)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n\n# 参考\n\n * lru & lfu 缓存机制的原理及实现 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"Memoize [缓存函数]",frontmatter:{title:"Memoize [缓存函数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cache/memoize/",categories:["算法","Cache 缓存"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/120.Cache%20%E7%BC%93%E5%AD%98/30.Memoize.html",relativePath:"20.算法/120.Cache 缓存/30.Memoize.md",key:"v-2f5c6694",path:"/algorithm/cache/memoize/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"高阶函数",slug:"高阶函数",normalizedTitle:"高阶函数",charIndex:142},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:146},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:577},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:3235},{level:3,title:"高阶组件",slug:"高阶组件",normalizedTitle:"高阶组件",charIndex:3242},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:534}],headersStr:"介绍 高阶函数 实现 JavaScript 扩展 高阶组件 参考",content:"# 介绍\n\n记忆化（英语：memoization，缓存化）是一种提高计算机程序执行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。\n\n记忆化是一种典型的在计算时间与电脑记忆体空间之中取得平衡的方案。\n\n缓存函数可以通过高阶函数实现。\n\n\n# 高阶函数\n\n在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：\n\n * 接受一个或多个函数作为输入\n * 输出一个函数\n\n在数学中它们也叫做算子（运算符）或泛函。微积分中的导数就是常见的例子，因为它映射一个函数到另一个函数。在函数式编程中，返回另一个函数的高阶函数被称为 Curry 化的函数。如排序函数，接受一个比较函数作为参数、filter 函数、fold 函数、apply（英语：apply）函数、函数复合（英语：Function composition (computer science)）、积分、回调函数等。\n\n对其他函数进行操作的函数，无论是把它们作为参数还是返回值，都被称为高阶函数（higher-order functions）。高阶函数允许我们对动作进行抽象，而不仅仅是数值。它们有几种形式。例如，我们可以有创建新函数的函数。\n\n参考：\n\n * Higher-Order Functions :: Eloquent JavaScript\n * 高阶函数 - Wikiwand\n * Higher Order Functions and Currying - GeeksforGeeks\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function memoize\n * @description ->\n * From [Wikipedia](https://en.wikipedia.org/wiki/Memoization),\n * memoization is an optimization technique used primarily to speed up computer programs,\n * by storing the results of expensive function calls and returning the cached result when the same inputs occur again\n * This function is a first class objects, which lets us use it as [Higher-Order Function](https://eloquentjavascript.net/05_higher_order.html) and return another function\n * @param {Function} func Original function\n * @param {Map} cache - it's receive any cache DS which have get, set & has method\n * @returns {Function} Memoized function\n */\nconst memoize = (func, cache = new Map()) => {\n  const jsonReplacer = (_, value) => {\n    // if the value is Set it's converted to Array cause JSON.stringify can't convert Set\n    if (value instanceof Set) return [...value]\n    // if the value is Map it's converted to Object cause JSON.stringify can't convert Map\n    if (value instanceof Map) return Object.fromEntries(value)\n    return value\n  }\n\n  return (...args) => {\n    /**\n     * Arguments converted to JSON string for use as a key of Map - it's easy to detect collections like -> Object and Array\n     * If the args input is -> [new Set([1, 2, 3, 4]), {name: 'myName', age: 23}]\n     * Then the agrsKey generate to -> '[[1,2,3,4],{\"name\":\"myName\",\"age\":23}]' which is JSON mean string\n     * Now it's ready to be a perfect key for Map\n     */\n    const argsKey = JSON.stringify(args, jsonReplacer)\n\n    /** Checks if the argument is already present in the cache, then return the associated value / result */\n    if (cache.has(argsKey)) return cache.get(argsKey)\n\n    /** If the argument is not yet present in the cache, execute original function and save its value / result in cache, finally return it */\n    const result = func(...args) // spread all args\n    cache.set(argsKey, result)\n\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。参见：JSON.stringify() | MDN\n   * JSON.stringify(value[, replacer [, space]]) 。\n   * replacer：如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。\n   * space：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。\n\n\n# 扩展\n\n\n# 高阶组件\n\n高阶组件（HOC，higher-order component）是 React 中重用组件逻辑的一种高级技术。HOC 本身不是 React API 的一部分。它们是一种从 React 的组合（compositional）性质中出现的模式。参见：Higher-Order Components – React。\n\n\n# 参考\n\n * Memoization - Wikiwand\n * 记忆化 - Wikiwand",normalizedContent:"# 介绍\n\n记忆化（英语：memoization，缓存化）是一种提高计算机程序执行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。\n\n记忆化是一种典型的在计算时间与电脑记忆体空间之中取得平衡的方案。\n\n缓存函数可以通过高阶函数实现。\n\n\n# 高阶函数\n\n在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：\n\n * 接受一个或多个函数作为输入\n * 输出一个函数\n\n在数学中它们也叫做算子（运算符）或泛函。微积分中的导数就是常见的例子，因为它映射一个函数到另一个函数。在函数式编程中，返回另一个函数的高阶函数被称为 curry 化的函数。如排序函数，接受一个比较函数作为参数、filter 函数、fold 函数、apply（英语：apply）函数、函数复合（英语：function composition (computer science)）、积分、回调函数等。\n\n对其他函数进行操作的函数，无论是把它们作为参数还是返回值，都被称为高阶函数（higher-order functions）。高阶函数允许我们对动作进行抽象，而不仅仅是数值。它们有几种形式。例如，我们可以有创建新函数的函数。\n\n参考：\n\n * higher-order functions :: eloquent javascript\n * 高阶函数 - wikiwand\n * higher order functions and currying - geeksforgeeks\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function memoize\n * @description ->\n * from [wikipedia](https://en.wikipedia.org/wiki/memoization),\n * memoization is an optimization technique used primarily to speed up computer programs,\n * by storing the results of expensive function calls and returning the cached result when the same inputs occur again\n * this function is a first class objects, which lets us use it as [higher-order function](https://eloquentjavascript.net/05_higher_order.html) and return another function\n * @param {function} func original function\n * @param {map} cache - it's receive any cache ds which have get, set & has method\n * @returns {function} memoized function\n */\nconst memoize = (func, cache = new map()) => {\n  const jsonreplacer = (_, value) => {\n    // if the value is set it's converted to array cause json.stringify can't convert set\n    if (value instanceof set) return [...value]\n    // if the value is map it's converted to object cause json.stringify can't convert map\n    if (value instanceof map) return object.fromentries(value)\n    return value\n  }\n\n  return (...args) => {\n    /**\n     * arguments converted to json string for use as a key of map - it's easy to detect collections like -> object and array\n     * if the args input is -> [new set([1, 2, 3, 4]), {name: 'myname', age: 23}]\n     * then the agrskey generate to -> '[[1,2,3,4],{\"name\":\"myname\",\"age\":23}]' which is json mean string\n     * now it's ready to be a perfect key for map\n     */\n    const argskey = json.stringify(args, jsonreplacer)\n\n    /** checks if the argument is already present in the cache, then return the associated value / result */\n    if (cache.has(argskey)) return cache.get(argskey)\n\n    /** if the argument is not yet present in the cache, execute original function and save its value / result in cache, finally return it */\n    const result = func(...args) // spread all args\n    cache.set(argskey, result)\n\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * json.stringify() 方法将一个 javascript 对象或值转换为 json 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。参见：json.stringify() | mdn\n   * json.stringify(value[, replacer [, space]]) 。\n   * replacer：如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 json 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。\n   * space：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。\n\n\n# 扩展\n\n\n# 高阶组件\n\n高阶组件（hoc，higher-order component）是 react 中重用组件逻辑的一种高级技术。hoc 本身不是 react api 的一部分。它们是一种从 react 的组合（compositional）性质中出现的模式。参见：higher-order components – react。\n\n\n# 参考\n\n * memoization - wikiwand\n * 记忆化 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/28, 10:40:37",lastUpdatedTimestamp:1666924837e3},{title:"LocalMaxPoint [局部最值]",frontmatter:{title:"LocalMaxPoint [局部最值]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/array/localMaxPoint/",categories:["算法","array 数组"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/130.Array%20%E6%95%B0%E7%BB%84/10.LocalMaxPoint.html",relativePath:"20.算法/130.Array 数组/10.LocalMaxPoint.md",key:"v-25b6b26f",path:"/algorithm/array/localMaxPoint/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:344},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:351},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:4184},{level:3,title:"TrappingRainWater",slug:"trappingrainwater",normalizedTitle:"trappingrainwater",charIndex:4191},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4254}],headersStr:"介绍 实现 JavaScript 扩展 TrappingRainWater 参考",content:"# 介绍\n\n给定一个整数数组 arr[] 。任务是找出给定数组中所有局部最小值（local minima）和局部最大值（local maxima）的下标。如果一个元素 arr[x] 小于它的两个邻居，我们称之为是一个局部最小值，局部最大值同理。例如：\n\nInput: arr = [100, 180, 260, 310, 40, 535, 695]\nOutput:\nPoints of local minima: 0 4 \nPoints of local maxima: 3 6\n\n\n1\n2\n3\n4\n\n\n思路：在给定的数组 arr [] 上进行迭代，并检查数组中的每个元素在其相邻元素中是否最小或最大。如果它是最小的，那么它就是局部最小值，如果它是最大的，那么它就是局部最大值。\n\n\n# 实现\n\n\n# JavaScript\n\n// Function to find all the local maxima and minima in the given array arr[]\nfunction findLocalMaximaMinima(n, arr) {\n    // Empty vector to store points of local maxima and minima\n    let mx = [], mn = [];\n \n    // Checking whether the first point is local maxima or minima or none\n    if (arr[0] > arr[1]) mx.push(0);\n    else if (arr[0] < arr[1]) mn.push(0);\n \n    // Iterating over all points to check local maxima and local minima\n    for(let i = 1; i < n - 1; i++) {\n      // Condition for local minima\n      if ((arr[i - 1] > arr[i]) && (arr[i] < arr[i + 1])) mn.push(i);\n      // Condition for local maxima\n      else if ((arr[i - 1] < arr[i]) && (arr[i] > arr[i + 1])) mx.push(i);\n    }\n \n    // Checking whether the last point is local maxima or minima or none\n    if (arr[n - 1] > arr[n - 2]) mx.push(n - 1);\n    else if (arr[n - 1] < arr[n - 2]) mn.push(n - 1);\n \n    return {mn, mx}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n分治法：寻找第一个局部最大值。\n\n/**\n * [LocalMaxima](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors\n *\n * Notes:\n * - works by using divide and conquer\n * - the function gets the array A with n Real numbers and returns the local max point index (if more than one exists return the first one)\n *\n * @complexity: O(log(n)) (on average )\n * @complexity: O(log(n)) (worst case)\n */\nconst findMaxPointIndex = (array, rangeStartIndex, rangeEndIndex, originalLength) => {\n  // find index range middle point\n  const middleIndex = rangeStartIndex + parseInt((rangeEndIndex - rangeStartIndex) / 2)\n\n  // handle array bounds\n  if ((middleIndex === 0 || array[middleIndex - 1] <= array[middleIndex]) && (middleIndex === originalLength - 1 || array[middleIndex + 1] <= array[middleIndex])) return middleIndex\n  // 首个局部最大值在左边\n  if (middleIndex > 0 && array[middleIndex - 1] > array[middleIndex]) return findMaxPointIndex(array, rangeStartIndex, (middleIndex - 1), originalLength)\n  return findMaxPointIndex(array, (middleIndex + 1), rangeEndIndex, originalLength)\n}\n\nconst LocalMaximomPoint = (A) => findMaxPointIndex(A, 0, A.length - 1, A.length)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n分治法：寻找局部最大值的数量。\n\n/**\n * [NumberOfLocalMaximumPoints](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors\n *\n * Notes:\n * - like the other similar local maxima search function find relative maxima points in array but doesn't stop at one but returns total point count\n * - runs on array A of size n and returns the local maxima count using divide and conquer methodology\n *\n * @complexity: O(n) (on average )\n * @complexity: O(n) (worst case)\n * @flow\n */\n\n// check if returned index is a local maxima\nconst IsMaximumPoint = (array, index) => {\n  // handle array bounds\n  // array start\n  if (index === 0) return array[index] > array[index + 1]\n  // array end\n  if (index === array.length - 1) return array[index] > array[index - 1]\n  // handle index inside array bounds\n  return array[index] > array[index + 1] && array[index] > array[index - 1]\n}\n\nconst CountLocalMaximumPoints = (array, startIndex, endIndex) => {\n  // stop check in divide and conquer recursion\n  if (startIndex === endIndex) return IsMaximumPoint(array, startIndex) ? 1 : 0\n  // handle the two halves\n  const middleIndex = parseInt((startIndex + endIndex) / 2)\n  return CountLocalMaximumPoints(array, startIndex, middleIndex) + CountLocalMaximumPoints(array, middleIndex + 1, endIndex)\n}\n\nconst NumberOfLocalMaximumPoints = (A) => CountLocalMaximumPoints(A, 0, A.length - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 扩展\n\n\n# TrappingRainWater\n\n参见：TrappingRainWater [接住雨水] | Fancy DSA\n\n\n# 参考\n\n * Find indices of all local maxima and local minima in an Array - GeeksforGeeks",normalizedContent:"# 介绍\n\n给定一个整数数组 arr[] 。任务是找出给定数组中所有局部最小值（local minima）和局部最大值（local maxima）的下标。如果一个元素 arr[x] 小于它的两个邻居，我们称之为是一个局部最小值，局部最大值同理。例如：\n\ninput: arr = [100, 180, 260, 310, 40, 535, 695]\noutput:\npoints of local minima: 0 4 \npoints of local maxima: 3 6\n\n\n1\n2\n3\n4\n\n\n思路：在给定的数组 arr [] 上进行迭代，并检查数组中的每个元素在其相邻元素中是否最小或最大。如果它是最小的，那么它就是局部最小值，如果它是最大的，那么它就是局部最大值。\n\n\n# 实现\n\n\n# javascript\n\n// function to find all the local maxima and minima in the given array arr[]\nfunction findlocalmaximaminima(n, arr) {\n    // empty vector to store points of local maxima and minima\n    let mx = [], mn = [];\n \n    // checking whether the first point is local maxima or minima or none\n    if (arr[0] > arr[1]) mx.push(0);\n    else if (arr[0] < arr[1]) mn.push(0);\n \n    // iterating over all points to check local maxima and local minima\n    for(let i = 1; i < n - 1; i++) {\n      // condition for local minima\n      if ((arr[i - 1] > arr[i]) && (arr[i] < arr[i + 1])) mn.push(i);\n      // condition for local maxima\n      else if ((arr[i - 1] < arr[i]) && (arr[i] > arr[i + 1])) mx.push(i);\n    }\n \n    // checking whether the last point is local maxima or minima or none\n    if (arr[n - 1] > arr[n - 2]) mx.push(n - 1);\n    else if (arr[n - 1] < arr[n - 2]) mn.push(n - 1);\n \n    return {mn, mx}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n分治法：寻找第一个局部最大值。\n\n/**\n * [localmaxima](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors\n *\n * notes:\n * - works by using divide and conquer\n * - the function gets the array a with n real numbers and returns the local max point index (if more than one exists return the first one)\n *\n * @complexity: o(log(n)) (on average )\n * @complexity: o(log(n)) (worst case)\n */\nconst findmaxpointindex = (array, rangestartindex, rangeendindex, originallength) => {\n  // find index range middle point\n  const middleindex = rangestartindex + parseint((rangeendindex - rangestartindex) / 2)\n\n  // handle array bounds\n  if ((middleindex === 0 || array[middleindex - 1] <= array[middleindex]) && (middleindex === originallength - 1 || array[middleindex + 1] <= array[middleindex])) return middleindex\n  // 首个局部最大值在左边\n  if (middleindex > 0 && array[middleindex - 1] > array[middleindex]) return findmaxpointindex(array, rangestartindex, (middleindex - 1), originallength)\n  return findmaxpointindex(array, (middleindex + 1), rangeendindex, originallength)\n}\n\nconst localmaximompoint = (a) => findmaxpointindex(a, 0, a.length - 1, a.length)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n分治法：寻找局部最大值的数量。\n\n/**\n * [numberoflocalmaximumpoints](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors\n *\n * notes:\n * - like the other similar local maxima search function find relative maxima points in array but doesn't stop at one but returns total point count\n * - runs on array a of size n and returns the local maxima count using divide and conquer methodology\n *\n * @complexity: o(n) (on average )\n * @complexity: o(n) (worst case)\n * @flow\n */\n\n// check if returned index is a local maxima\nconst ismaximumpoint = (array, index) => {\n  // handle array bounds\n  // array start\n  if (index === 0) return array[index] > array[index + 1]\n  // array end\n  if (index === array.length - 1) return array[index] > array[index - 1]\n  // handle index inside array bounds\n  return array[index] > array[index + 1] && array[index] > array[index - 1]\n}\n\nconst countlocalmaximumpoints = (array, startindex, endindex) => {\n  // stop check in divide and conquer recursion\n  if (startindex === endindex) return ismaximumpoint(array, startindex) ? 1 : 0\n  // handle the two halves\n  const middleindex = parseint((startindex + endindex) / 2)\n  return countlocalmaximumpoints(array, startindex, middleindex) + countlocalmaximumpoints(array, middleindex + 1, endindex)\n}\n\nconst numberoflocalmaximumpoints = (a) => countlocalmaximumpoints(a, 0, a.length - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 扩展\n\n\n# trappingrainwater\n\n参见：trappingrainwater [接住雨水] | fancy dsa\n\n\n# 参考\n\n * find indices of all local maxima and local minima in an array - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/28, 11:08:29",lastUpdatedTimestamp:1666926509e3},{title:"QuickSelect [快速选择]",frontmatter:{title:"QuickSelect [快速选择]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/array/quickSelect/",categories:["算法","Array 数组"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/130.Array%20%E6%95%B0%E7%BB%84/140.QuickSelect.html",relativePath:"20.算法/130.Array 数组/140.QuickSelect.md",key:"v-07b0187e",path:"/algorithm/array/quickSelect/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:624},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:631},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3941}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\nQuickselect 是一种选择算法，用于寻找无序列表中第 k 个最小的元素。它与快速排序的排序算法有关。\n\n该算法与 QuickSort 相似。不同的是，它不是对两边都进行递归（在找到支点后），而是只对包含第 k 个最小元素的部分进行递归。逻辑很简单，如果被分割的元素的索引大于 k，那么我们对左边的部分进行递归。如果索引与 k 相同，我们就找到了第 k 个最小的元素，我们就返回。如果索引小于 k，那么我们就对右边的部分进行递归。这就把预期复杂度从O(nlogn)O(nlogn)O(nlogn) 降低到O(n)O(n)O(n)，最坏的情况下是O(n2)O(n^2)O(n2)。\n\n伪代码：\n\nfunction quickSelect(list, left, right, k)\n if left = right return list[left]\n\n Select a pivotIndex between left and right\n\n pivotIndex := partition(list, left, right,  pivotIndex)\n if k = pivotIndex return list[k]\n else if k < pivotIndex right := pivotIndex - 1\n else left := pivotIndex + 1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 实现\n\n\n# JavaScript\n\n// partition function similar to quick sort\n// Considers last element as pivot and adds elements with less value to the left and high value to the right and also changes\n// the pivot position to its respective position in the final array.\nfunction _partition(arr, low, high) {\n  let pivot = arr[high], loc = low;\n  for (let i = low; i <= high; i++) {\n    // inserting elements of less value to the left of the pivot location\n    if (arr[i] < pivot) {\n      [arr[i], arr[loc]] = [arr[loc], arr[i]];\n      loc++;\n    }\n  }\n  // swapping pivot to the final pivot location\n  [arr[high], arr[loc]] = [arr[loc], arr[high]];\n  return loc;\n}\n  \n// finds the kth position (of the sorted array) in a given unsorted array i.e this function can be used to find both kth largest and kth smallest element in the array.\n// ASSUMPTION: all elements in arr[] are distinct\nfunction kthSmallest(arr, low, high, k) {\n  // find the partition\n  let partition = _partition(arr, low, high);\n\n  // if partition value is equal to the kth position, return value at k.\n  if (partition == k - 1) return arr[partition];\n  // if partition value is less than kth position, search right side of the array.\n  else if (partition < k - 1) return kthSmallest(arr, partition + 1, high, k);\n  // if partition value is more than kth position, search left side of the array.\n  return kthSmallest(arr, low, partition - 1, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n或者：\n\n/**\n * [QuickSelect](https://www.geeksforgeeks.org/quickselect-algorithm/) is an algorithm to find the kth smallest number\n *\n * Notes:\n * -QuickSelect is related to QuickSort, thus has optimal best and average\n * -case (O(n)) but unlikely poor worst case (O(n^2))\n * -This implementation uses randomly selected pivots for better performance\n *\n * @complexity: O(n) (on average )\n * @complexity: O(n^2) (worst case)\n * @flow\n */\n\nfunction QuickSelect (items, kth) { // eslint-disable-line no-unused-vars\n  if (kth < 1 || kth > items.length) {\n    throw new RangeError('Index Out of Bound')\n  }\n\n  return RandomizedSelect(items, 0, items.length - 1, kth)\n}\n\nfunction RandomizedSelect (items, left, right, i) {\n  if (left === right) return items[left]\n\n  const pivotIndex = RandomizedPartition(items, left, right)\n  const k = pivotIndex - left + 1\n\n  if (i === k) return items[pivotIndex]\n  if (i < k) return RandomizedSelect(items, left, pivotIndex - 1, i)\n\n  return RandomizedSelect(items, pivotIndex + 1, right, i - k)\n}\n\nfunction RandomizedPartition (items, left, right) {\n  const rand = getRandomInt(left, right)\n  Swap(items, rand, right)\n  return Partition(items, left, right)\n}\n\nfunction Partition (items, left, right) {\n  const x = items[right]\n  let pivotIndex = left - 1\n\n  for (let j = left; j < right; j++) {\n    if (items[j] <= x) {\n      pivotIndex++\n      Swap(items, pivotIndex, j)\n    }\n  }\n\n  Swap(items, pivotIndex + 1, right)\n\n  return pivotIndex + 1\n}\n\nfunction getRandomInt (min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\nfunction Swap (arr, x, y) {\n  [arr[x], arr[y]] = [arr[y], arr[x]]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 参考\n\n * Quickselect Algorithm - GeeksforGeeks",normalizedContent:"# 介绍\n\nquickselect 是一种选择算法，用于寻找无序列表中第 k 个最小的元素。它与快速排序的排序算法有关。\n\n该算法与 quicksort 相似。不同的是，它不是对两边都进行递归（在找到支点后），而是只对包含第 k 个最小元素的部分进行递归。逻辑很简单，如果被分割的元素的索引大于 k，那么我们对左边的部分进行递归。如果索引与 k 相同，我们就找到了第 k 个最小的元素，我们就返回。如果索引小于 k，那么我们就对右边的部分进行递归。这就把预期复杂度从o(nlogn)o(nlogn)o(nlogn) 降低到o(n)o(n)o(n)，最坏的情况下是o(n2)o(n^2)o(n2)。\n\n伪代码：\n\nfunction quickselect(list, left, right, k)\n if left = right return list[left]\n\n select a pivotindex between left and right\n\n pivotindex := partition(list, left, right,  pivotindex)\n if k = pivotindex return list[k]\n else if k < pivotindex right := pivotindex - 1\n else left := pivotindex + 1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 实现\n\n\n# javascript\n\n// partition function similar to quick sort\n// considers last element as pivot and adds elements with less value to the left and high value to the right and also changes\n// the pivot position to its respective position in the final array.\nfunction _partition(arr, low, high) {\n  let pivot = arr[high], loc = low;\n  for (let i = low; i <= high; i++) {\n    // inserting elements of less value to the left of the pivot location\n    if (arr[i] < pivot) {\n      [arr[i], arr[loc]] = [arr[loc], arr[i]];\n      loc++;\n    }\n  }\n  // swapping pivot to the final pivot location\n  [arr[high], arr[loc]] = [arr[loc], arr[high]];\n  return loc;\n}\n  \n// finds the kth position (of the sorted array) in a given unsorted array i.e this function can be used to find both kth largest and kth smallest element in the array.\n// assumption: all elements in arr[] are distinct\nfunction kthsmallest(arr, low, high, k) {\n  // find the partition\n  let partition = _partition(arr, low, high);\n\n  // if partition value is equal to the kth position, return value at k.\n  if (partition == k - 1) return arr[partition];\n  // if partition value is less than kth position, search right side of the array.\n  else if (partition < k - 1) return kthsmallest(arr, partition + 1, high, k);\n  // if partition value is more than kth position, search left side of the array.\n  return kthsmallest(arr, low, partition - 1, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n或者：\n\n/**\n * [quickselect](https://www.geeksforgeeks.org/quickselect-algorithm/) is an algorithm to find the kth smallest number\n *\n * notes:\n * -quickselect is related to quicksort, thus has optimal best and average\n * -case (o(n)) but unlikely poor worst case (o(n^2))\n * -this implementation uses randomly selected pivots for better performance\n *\n * @complexity: o(n) (on average )\n * @complexity: o(n^2) (worst case)\n * @flow\n */\n\nfunction quickselect (items, kth) { // eslint-disable-line no-unused-vars\n  if (kth < 1 || kth > items.length) {\n    throw new rangeerror('index out of bound')\n  }\n\n  return randomizedselect(items, 0, items.length - 1, kth)\n}\n\nfunction randomizedselect (items, left, right, i) {\n  if (left === right) return items[left]\n\n  const pivotindex = randomizedpartition(items, left, right)\n  const k = pivotindex - left + 1\n\n  if (i === k) return items[pivotindex]\n  if (i < k) return randomizedselect(items, left, pivotindex - 1, i)\n\n  return randomizedselect(items, pivotindex + 1, right, i - k)\n}\n\nfunction randomizedpartition (items, left, right) {\n  const rand = getrandomint(left, right)\n  swap(items, rand, right)\n  return partition(items, left, right)\n}\n\nfunction partition (items, left, right) {\n  const x = items[right]\n  let pivotindex = left - 1\n\n  for (let j = left; j < right; j++) {\n    if (items[j] <= x) {\n      pivotindex++\n      swap(items, pivotindex, j)\n    }\n  }\n\n  swap(items, pivotindex + 1, right)\n\n  return pivotindex + 1\n}\n\nfunction getrandomint (min, max) {\n  return math.floor(math.random() * (max - min + 1)) + min\n}\n\nfunction swap (arr, x, y) {\n  [arr[x], arr[y]] = [arr[y], arr[x]]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 参考\n\n * quickselect algorithm - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"Atbash",frontmatter:{title:"Atbash",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/atbash/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/10.Atbash.html",relativePath:"20.算法/140.Ciphers 密码学/10.Atbash.md",key:"v-1427bb22",path:"/algorithm/cipher/atbash/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @function Atbash - Decrypt a Atbash cipher\n * @description - The Atbash cipher is a particular type of monoalphabetic cipher formed by taking the alphabet and mapping it to its reverse, so that the first letter becomes the last letter, the second letter becomes the second to last letter, and so on.\n * @param {string} str - string to be decrypted/encrypt\n * @return {string} decrypted/encrypted string\n * @see - [wiki](https://en.wikipedia.org/wiki/Atbash)\n */\nconst Atbash = (str) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('Argument should be string')\n  }\n\n  return str.replace(/[a-z]/gi, (char) => {\n    const charCode = char.charCodeAt()\n\n    if (/[A-Z]/.test(char)) {\n      return String.fromCharCode(90 + 65 - charCode)\n    }\n\n    return String.fromCharCode(122 + 97 - charCode)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @function atbash - decrypt a atbash cipher\n * @description - the atbash cipher is a particular type of monoalphabetic cipher formed by taking the alphabet and mapping it to its reverse, so that the first letter becomes the last letter, the second letter becomes the second to last letter, and so on.\n * @param {string} str - string to be decrypted/encrypt\n * @return {string} decrypted/encrypted string\n * @see - [wiki](https://en.wikipedia.org/wiki/atbash)\n */\nconst atbash = (str) => {\n  if (typeof str !== 'string') {\n    throw new typeerror('argument should be string')\n  }\n\n  return str.replace(/[a-z]/gi, (char) => {\n    const charcode = char.charcodeat()\n\n    if (/[a-z]/.test(char)) {\n      return string.fromcharcode(90 + 65 - charcode)\n    }\n\n    return string.fromcharcode(122 + 97 - charcode)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"CaesarsCipher",frontmatter:{title:"CaesarsCipher",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/caesarsCipher/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/20.CaesarsCipher.html",relativePath:"20.算法/140.Ciphers 密码学/20.CaesarsCipher.md",key:"v-6518312d",path:"/algorithm/cipher/caesarsCipher/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @function caesarsCipher\n * @description - In cryptography, a Caesar cipher, also known as Caesar's cipher, the shift cipher, Caesar's code or Caesar shift, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence.\n * @see - [wiki](https://en.wikipedia.org/wiki/Caesar_cipher)\n * @param  {string} str - string to be encrypted\n * @param {number} rotation - the number of rotation, expect real number ( > 0)\n * @return {string} - decrypted string\n */\nconst caesarsCipher = (str, rotation) => {\n  if (typeof str !== 'string' || !Number.isInteger(rotation) || rotation < 0) {\n    throw new TypeError('Arguments are invalid')\n  }\n\n  const alphabets = new Array(26)\n    .fill()\n    .map((_, index) => String.fromCharCode(97 + index)) // generate all lower alphabets array a-z\n\n  const cipherMap = alphabets.reduce(\n    (map, char, index) => map.set(char, alphabets[(rotation + index) % 26]),\n    new Map()\n  )\n\n  return str.replace(/[a-z]/gi, (char) => {\n    if (/[A-Z]/.test(char)) {\n      return cipherMap.get(char.toLowerCase()).toUpperCase()\n    }\n\n    return cipherMap.get(char)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @function caesarscipher\n * @description - in cryptography, a caesar cipher, also known as caesar's cipher, the shift cipher, caesar's code or caesar shift, is one of the simplest and most widely known encryption techniques. it is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. for example, with a left shift of 3, d would be replaced by a, e would become b, and so on. the method is named after julius caesar, who used it in his private correspondence.\n * @see - [wiki](https://en.wikipedia.org/wiki/caesar_cipher)\n * @param  {string} str - string to be encrypted\n * @param {number} rotation - the number of rotation, expect real number ( > 0)\n * @return {string} - decrypted string\n */\nconst caesarscipher = (str, rotation) => {\n  if (typeof str !== 'string' || !number.isinteger(rotation) || rotation < 0) {\n    throw new typeerror('arguments are invalid')\n  }\n\n  const alphabets = new array(26)\n    .fill()\n    .map((_, index) => string.fromcharcode(97 + index)) // generate all lower alphabets array a-z\n\n  const ciphermap = alphabets.reduce(\n    (map, char, index) => map.set(char, alphabets[(rotation + index) % 26]),\n    new map()\n  )\n\n  return str.replace(/[a-z]/gi, (char) => {\n    if (/[a-z]/.test(char)) {\n      return ciphermap.get(char.tolowercase()).touppercase()\n    }\n\n    return ciphermap.get(char)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"KeyFinder",frontmatter:{title:"KeyFinder",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/keyFinder/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/30.KeyFinder.html",relativePath:"20.算法/140.Ciphers 密码学/30.KeyFinder.md",key:"v-07e554e7",path:"/algorithm/cipher/keyFinder/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/******************************************************\n Find and retrieve the encryption key automatically\n Note: This is a draft version, please help to modify, Thanks!\n ******************************************************/\nfunction keyFinder (str) { // str is used to get the input of encrypted string\n  const wordBank = [\n    'I ',\n    'You ',\n    'We ',\n    'They ',\n    'He ',\n    'She ',\n    'It ',\n    ' the ',\n    'The ',\n    ' of ',\n    ' is ',\n    'Is ',\n    ' am ',\n    'Am ',\n    ' are ',\n    'Are ',\n    ' have ',\n    'Have ',\n    ' has ',\n    'Has ',\n    ' may ',\n    'May ',\n    ' be ',\n    'Be ']\n  // let wordbankelementCounter = 0;\n  // let key = 0; // return zero means the key can not be found\n  const inStr = str.toString() // convert the input to String\n  let outStr = '' // store the output value\n  let outStrElement = '' // temporary store the word inside the outStr, it is used for comparison\n  for (let k = 0; k < 26; k++) { // try the number of key shifted, the sum of character from a-z or A-Z is 26\n    outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) // use the encryption engine to decrypt the input string\n\n    // loop through the whole input string\n    for (let s = 0; s < outStr.length; s++) {\n      for (let i = 0; i < wordBank.length; i++) {\n        // initialize the outStrElement which is a temp output string for comparison,\n        // use a loop to find the next digit of wordBank element and compare with outStr's digit\n        for (let w = 0; w < wordBank[i].length; w++) {\n          outStrElement += outStr[s + w]\n        }\n        // this part need to be optimize with the calculation of the number of occurrence of word's probabilities\n        // linked list will be used in the next stage of development to calculate the number of occurrence of the key\n        if (wordBank[i] === outStrElement) {\n          return k // return the key number if founded\n        }\n        outStrElement = '' // reset the temp word\n      } // end for ( let i=0; i < wordBank.length; i++)\n    }\n  }\n  return 0 // return 0 if found nothing\n}\n\n/* this sub-function is used to assist the keyFinder to find the key */\nfunction caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {\n  const shiftNum = numShifted\n  let charCode = 0\n  let outStr = ''\n  let shiftedCharCode = 0\n  let result = 0\n\n  for (let i = 0; i < inStr.length; i++) {\n    charCode = inStr[i].charCodeAt()\n    shiftedCharCode = charCode + shiftNum\n    result = charCode\n\n    if ((charCode >= 48 && charCode <= 57)) {\n      if (shiftedCharCode < 48) {\n        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10\n\n        while (diff >= 10) {\n          diff = diff % 10\n        }\n        document.getElementById('diffID').innerHTML = diff\n\n        shiftedCharCode = 57 - diff\n\n        result = shiftedCharCode\n      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {\n        result = shiftedCharCode\n      } else if (shiftedCharCode > 57) {\n        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10\n\n        while (diff >= 10) {\n          diff = diff % 10\n        }\n        document.getElementById('diffID').innerHTML = diff\n\n        shiftedCharCode = 48 + diff\n\n        result = shiftedCharCode\n      }\n    } else if ((charCode >= 65 && charCode <= 90)) {\n      if (shiftedCharCode <= 64) {\n        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 90 - diff\n        result = shiftedCharCode\n      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {\n        result = shiftedCharCode\n      } else if (shiftedCharCode > 90) {\n        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 65 + diff\n        result = shiftedCharCode\n      }\n    } else if ((charCode >= 97 && charCode <= 122)) {\n      if (shiftedCharCode <= 96) {\n        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 122 - diff\n        result = shiftedCharCode\n      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {\n        result = shiftedCharCode\n      } else if (shiftedCharCode > 122) {\n        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 97 + diff\n        result = shiftedCharCode\n      }\n    }\n    outStr = outStr + String.fromCharCode(parseInt(result))\n  }\n  return outStr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/******************************************************\n find and retrieve the encryption key automatically\n note: this is a draft version, please help to modify, thanks!\n ******************************************************/\nfunction keyfinder (str) { // str is used to get the input of encrypted string\n  const wordbank = [\n    'i ',\n    'you ',\n    'we ',\n    'they ',\n    'he ',\n    'she ',\n    'it ',\n    ' the ',\n    'the ',\n    ' of ',\n    ' is ',\n    'is ',\n    ' am ',\n    'am ',\n    ' are ',\n    'are ',\n    ' have ',\n    'have ',\n    ' has ',\n    'has ',\n    ' may ',\n    'may ',\n    ' be ',\n    'be ']\n  // let wordbankelementcounter = 0;\n  // let key = 0; // return zero means the key can not be found\n  const instr = str.tostring() // convert the input to string\n  let outstr = '' // store the output value\n  let outstrelement = '' // temporary store the word inside the outstr, it is used for comparison\n  for (let k = 0; k < 26; k++) { // try the number of key shifted, the sum of character from a-z or a-z is 26\n    outstr = caesarcipherencodeanddecodeengine(instr, k) // use the encryption engine to decrypt the input string\n\n    // loop through the whole input string\n    for (let s = 0; s < outstr.length; s++) {\n      for (let i = 0; i < wordbank.length; i++) {\n        // initialize the outstrelement which is a temp output string for comparison,\n        // use a loop to find the next digit of wordbank element and compare with outstr's digit\n        for (let w = 0; w < wordbank[i].length; w++) {\n          outstrelement += outstr[s + w]\n        }\n        // this part need to be optimize with the calculation of the number of occurrence of word's probabilities\n        // linked list will be used in the next stage of development to calculate the number of occurrence of the key\n        if (wordbank[i] === outstrelement) {\n          return k // return the key number if founded\n        }\n        outstrelement = '' // reset the temp word\n      } // end for ( let i=0; i < wordbank.length; i++)\n    }\n  }\n  return 0 // return 0 if found nothing\n}\n\n/* this sub-function is used to assist the keyfinder to find the key */\nfunction caesarcipherencodeanddecodeengine (instr, numshifted) {\n  const shiftnum = numshifted\n  let charcode = 0\n  let outstr = ''\n  let shiftedcharcode = 0\n  let result = 0\n\n  for (let i = 0; i < instr.length; i++) {\n    charcode = instr[i].charcodeat()\n    shiftedcharcode = charcode + shiftnum\n    result = charcode\n\n    if ((charcode >= 48 && charcode <= 57)) {\n      if (shiftedcharcode < 48) {\n        let diff = math.abs(48 - 1 - shiftedcharcode) % 10\n\n        while (diff >= 10) {\n          diff = diff % 10\n        }\n        document.getelementbyid('diffid').innerhtml = diff\n\n        shiftedcharcode = 57 - diff\n\n        result = shiftedcharcode\n      } else if (shiftedcharcode >= 48 && shiftedcharcode <= 57) {\n        result = shiftedcharcode\n      } else if (shiftedcharcode > 57) {\n        let diff = math.abs(57 + 1 - shiftedcharcode) % 10\n\n        while (diff >= 10) {\n          diff = diff % 10\n        }\n        document.getelementbyid('diffid').innerhtml = diff\n\n        shiftedcharcode = 48 + diff\n\n        result = shiftedcharcode\n      }\n    } else if ((charcode >= 65 && charcode <= 90)) {\n      if (shiftedcharcode <= 64) {\n        let diff = math.abs(65 - 1 - shiftedcharcode) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedcharcode = 90 - diff\n        result = shiftedcharcode\n      } else if (shiftedcharcode >= 65 && shiftedcharcode <= 90) {\n        result = shiftedcharcode\n      } else if (shiftedcharcode > 90) {\n        let diff = math.abs(shiftedcharcode - 1 - 90) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedcharcode = 65 + diff\n        result = shiftedcharcode\n      }\n    } else if ((charcode >= 97 && charcode <= 122)) {\n      if (shiftedcharcode <= 96) {\n        let diff = math.abs(97 - 1 - shiftedcharcode) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedcharcode = 122 - diff\n        result = shiftedcharcode\n      } else if (shiftedcharcode >= 97 && shiftedcharcode <= 122) {\n        result = shiftedcharcode\n      } else if (shiftedcharcode > 122) {\n        let diff = math.abs(shiftedcharcode - 1 - 122) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedcharcode = 97 + diff\n        result = shiftedcharcode\n      }\n    }\n    outstr = outstr + string.fromcharcode(parseint(result))\n  }\n  return outstr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"KeywordShiftedAlphabet",frontmatter:{title:"KeywordShiftedAlphabet",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/keywordShiftedAlphabet/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/40.KeywordShiftedAlphabet.html",relativePath:"20.算法/140.Ciphers 密码学/40.KeywordShiftedAlphabet.md",key:"v-66bee10f",path:"/algorithm/cipher/keywordShiftedAlphabet/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * Keyword shifted alphabet is a simple cipher using a translation table created with a help of a keyword.\n * Keyword must be a word where each character can occur only once.\n * To create the translation table, we write all the alphabet characters to the first.\n * Second row start with the keyword, then we continue with the rest of the characters that are missing in alphabetical order.\n *\n * |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|\n * |K|E|Y|W|O|R|D|A|B|C|F|G|H|I|J|L|M|N|P|Q|S|T|U|V|W|Z|\n *\n * Encryption is then just a matter of writing the matching (same index) letter from the second row instead of the first row:\n * 'Hello world' -> 'Aoggj ujngw'\n *\n * Decryption is then just the reverse process of writing the matching (same index) letter from the first row instead of the second row\n * 'Aogg ujngw' -> 'Hello world'\n *\n * Non alphabetical characters (space, exclamation mark, ...) are kept as they are\n */\n\nconst alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\nfunction checkKeywordValidity (keyword) {\n  keyword.split('').forEach((char, index) => {\n    const rest = keyword.slice(0, index) + keyword.slice(index + 1)\n    if (rest.indexOf(char) !== -1) {\n      return false\n    }\n  })\n  return true\n}\n\nfunction getEncryptedAlphabet (keyword) {\n  const encryptedAlphabet = keyword.split('')\n  alphabet.forEach((char) => {\n    if (encryptedAlphabet.indexOf(char) === -1) {\n      encryptedAlphabet.push(char)\n    }\n  })\n  return encryptedAlphabet\n}\n\nfunction translate (sourceAlphabet, targetAlphabet, message) {\n  return message.split('').reduce((encryptedMessage, char) => {\n    const isUpperCase = char === char.toUpperCase()\n    const encryptedCharIndex = sourceAlphabet.indexOf(char.toLowerCase())\n    const encryptedChar = encryptedCharIndex !== -1 ? targetAlphabet[encryptedCharIndex] : char\n    encryptedMessage += isUpperCase ? encryptedChar.toUpperCase() : encryptedChar\n    return encryptedMessage\n  }, '')\n}\n\nfunction checkInputs (keyword, message) {\n  if (!keyword || !message) {\n    throw new Error('Both keyword and message must be specified')\n  }\n\n  if (!checkKeywordValidity(keyword)) {\n    throw new Error('Invalid keyword!')\n  }\n}\n\nfunction encrypt (keyword, message) {\n  checkInputs(keyword, message)\n  return translate(alphabet, getEncryptedAlphabet(keyword.toLowerCase()), message)\n}\n\nfunction decrypt (keyword, message) {\n  checkInputs(keyword, message)\n  return translate(getEncryptedAlphabet(keyword.toLowerCase()), alphabet, message)\n}\n\nexport { encrypt, decrypt }\n\n// encrypt('keyword', 'Hello world!') // Prints 'Aoggj ujngw!'\n// decrypt('keyword', 'Aoggj ujngw!') // Prints 'Hello world!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * keyword shifted alphabet is a simple cipher using a translation table created with a help of a keyword.\n * keyword must be a word where each character can occur only once.\n * to create the translation table, we write all the alphabet characters to the first.\n * second row start with the keyword, then we continue with the rest of the characters that are missing in alphabetical order.\n *\n * |a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|\n * |k|e|y|w|o|r|d|a|b|c|f|g|h|i|j|l|m|n|p|q|s|t|u|v|w|z|\n *\n * encryption is then just a matter of writing the matching (same index) letter from the second row instead of the first row:\n * 'hello world' -> 'aoggj ujngw'\n *\n * decryption is then just the reverse process of writing the matching (same index) letter from the first row instead of the second row\n * 'aogg ujngw' -> 'hello world'\n *\n * non alphabetical characters (space, exclamation mark, ...) are kept as they are\n */\n\nconst alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\nfunction checkkeywordvalidity (keyword) {\n  keyword.split('').foreach((char, index) => {\n    const rest = keyword.slice(0, index) + keyword.slice(index + 1)\n    if (rest.indexof(char) !== -1) {\n      return false\n    }\n  })\n  return true\n}\n\nfunction getencryptedalphabet (keyword) {\n  const encryptedalphabet = keyword.split('')\n  alphabet.foreach((char) => {\n    if (encryptedalphabet.indexof(char) === -1) {\n      encryptedalphabet.push(char)\n    }\n  })\n  return encryptedalphabet\n}\n\nfunction translate (sourcealphabet, targetalphabet, message) {\n  return message.split('').reduce((encryptedmessage, char) => {\n    const isuppercase = char === char.touppercase()\n    const encryptedcharindex = sourcealphabet.indexof(char.tolowercase())\n    const encryptedchar = encryptedcharindex !== -1 ? targetalphabet[encryptedcharindex] : char\n    encryptedmessage += isuppercase ? encryptedchar.touppercase() : encryptedchar\n    return encryptedmessage\n  }, '')\n}\n\nfunction checkinputs (keyword, message) {\n  if (!keyword || !message) {\n    throw new error('both keyword and message must be specified')\n  }\n\n  if (!checkkeywordvalidity(keyword)) {\n    throw new error('invalid keyword!')\n  }\n}\n\nfunction encrypt (keyword, message) {\n  checkinputs(keyword, message)\n  return translate(alphabet, getencryptedalphabet(keyword.tolowercase()), message)\n}\n\nfunction decrypt (keyword, message) {\n  checkinputs(keyword, message)\n  return translate(getencryptedalphabet(keyword.tolowercase()), alphabet, message)\n}\n\nexport { encrypt, decrypt }\n\n// encrypt('keyword', 'hello world!') // prints 'aoggj ujngw!'\n// decrypt('keyword', 'aoggj ujngw!') // prints 'hello world!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"ROT13",frontmatter:{title:"ROT13",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/ROT13/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/50.ROT13.html",relativePath:"20.算法/140.Ciphers 密码学/50.ROT13.md",key:"v-9d467b7a",path:"/algorithm/cipher/ROT13/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @function ROT13\n * @description - ROT13 (\"rotate by 13 places\", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet. ROT13 is a special case of the Caesar cipher which was developed in ancient Rome. Because there are 26 letters (2×13) in the basic Latin alphabet, ROT13 is its own inverse; that is, to undo ROT13, the same algorithm is applied, so the same action can be used for encoding and decoding. The algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.\n * @see - [wiki](https://en.wikipedia.org/wiki/ROT13)\n * @param {String} str - string to be decrypted\n * @return {String} decrypted string\n */\nfunction ROT13 (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Argument should be string')\n  }\n\n  return str.replace(/[a-z]/gi, (char) => {\n    const charCode = char.charCodeAt()\n\n    if (/[n-z]/i.test(char)) {\n      return String.fromCharCode(charCode - 13)\n    }\n\n    return String.fromCharCode(charCode + 13)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @function rot13\n * @description - rot13 (\"rotate by 13 places\", sometimes hyphenated rot-13) is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet. rot13 is a special case of the caesar cipher which was developed in ancient rome. because there are 26 letters (2×13) in the basic latin alphabet, rot13 is its own inverse; that is, to undo rot13, the same algorithm is applied, so the same action can be used for encoding and decoding. the algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.\n * @see - [wiki](https://en.wikipedia.org/wiki/rot13)\n * @param {string} str - string to be decrypted\n * @return {string} decrypted string\n */\nfunction rot13 (str) {\n  if (typeof str !== 'string') {\n    throw new typeerror('argument should be string')\n  }\n\n  return str.replace(/[a-z]/gi, (char) => {\n    const charcode = char.charcodeat()\n\n    if (/[n-z]/i.test(char)) {\n      return string.fromcharcode(charcode - 13)\n    }\n\n    return string.fromcharcode(charcode + 13)\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"VigenereCipher",frontmatter:{title:"VigenereCipher",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/vigenereCipher/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/60.VigenereCipher.html",relativePath:"20.算法/140.Ciphers 密码学/60.VigenereCipher.md",key:"v-756849ef",path:"/algorithm/cipher/vigenereCipher/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * Check if the Character is letter or not\n * @param {String} str - character to check\n * @return {object} An array with the character or null if isn't a letter\n */\nfunction isLetter (str) {\n  return str.length === 1 && str.match(/[a-zA-Z]/i)\n}\n\n/**\n * Check if is Uppercase or Lowercase\n * @param {String} character - character to check\n * @return {Boolean} result of the checking\n */\nfunction isUpperCase (character) {\n  if (character === character.toUpperCase()) {\n    return true\n  }\n  if (character === character.toLowerCase()) {\n    return false\n  }\n}\n\n/**\n * Encrypt a Vigenere cipher\n * @param {String} message - string to be encrypted\n * @param {String} key - key for encrypt\n * @return {String} result - encrypted string\n */\nfunction encrypt (message, key) {\n  let result = ''\n\n  for (let i = 0, j = 0; i < message.length; i++) {\n    const c = message.charAt(i)\n    if (isLetter(c)) {\n      if (isUpperCase(c)) {\n        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65) // A: 65\n      } else {\n        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97) // a: 97\n      }\n    } else {\n      result += c\n    }\n    j = ++j % key.length\n  }\n  return result\n}\n\n/**\n * Decrypt a Vigenere cipher\n * @param {String} message - string to be decrypted\n * @param {String} key - key for decrypt\n * @return {String} result - decrypted string\n */\nfunction decrypt (message, key) {\n  let result = ''\n\n  for (let i = 0, j = 0; i < message.length; i++) {\n    const c = message.charAt(i)\n    if (isLetter(c)) {\n      if (isUpperCase(c)) {\n        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)\n      } else {\n        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)\n      }\n    } else {\n      result += c\n    }\n    j = ++j % key.length\n  }\n  return result\n}\n// > encrypt('Hello World!', 'code')\n// 'Jsopq Zstzg!'\n\n// > decrypt('Jsopq Zstzg!', 'code')\n// 'Hello World!'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * check if the character is letter or not\n * @param {string} str - character to check\n * @return {object} an array with the character or null if isn't a letter\n */\nfunction isletter (str) {\n  return str.length === 1 && str.match(/[a-za-z]/i)\n}\n\n/**\n * check if is uppercase or lowercase\n * @param {string} character - character to check\n * @return {boolean} result of the checking\n */\nfunction isuppercase (character) {\n  if (character === character.touppercase()) {\n    return true\n  }\n  if (character === character.tolowercase()) {\n    return false\n  }\n}\n\n/**\n * encrypt a vigenere cipher\n * @param {string} message - string to be encrypted\n * @param {string} key - key for encrypt\n * @return {string} result - encrypted string\n */\nfunction encrypt (message, key) {\n  let result = ''\n\n  for (let i = 0, j = 0; i < message.length; i++) {\n    const c = message.charat(i)\n    if (isletter(c)) {\n      if (isuppercase(c)) {\n        result += string.fromcharcode((c.charcodeat(0) + key.touppercase().charcodeat(j) - 2 * 65) % 26 + 65) // a: 65\n      } else {\n        result += string.fromcharcode((c.charcodeat(0) + key.tolowercase().charcodeat(j) - 2 * 97) % 26 + 97) // a: 97\n      }\n    } else {\n      result += c\n    }\n    j = ++j % key.length\n  }\n  return result\n}\n\n/**\n * decrypt a vigenere cipher\n * @param {string} message - string to be decrypted\n * @param {string} key - key for decrypt\n * @return {string} result - decrypted string\n */\nfunction decrypt (message, key) {\n  let result = ''\n\n  for (let i = 0, j = 0; i < message.length; i++) {\n    const c = message.charat(i)\n    if (isletter(c)) {\n      if (isuppercase(c)) {\n        result += string.fromcharcode(90 - (25 - (c.charcodeat(0) - key.touppercase().charcodeat(j))) % 26)\n      } else {\n        result += string.fromcharcode(122 - (25 - (c.charcodeat(0) - key.tolowercase().charcodeat(j))) % 26)\n      }\n    } else {\n      result += c\n    }\n    j = ++j % key.length\n  }\n  return result\n}\n// > encrypt('hello world!', 'code')\n// 'jsopq zstzg!'\n\n// > decrypt('jsopq zstzg!', 'code')\n// 'hello world!'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"XORCipher",frontmatter:{title:"XORCipher",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/cipher/XORCipher/",categories:["算法","Ciphers 密码学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/140.Ciphers%20%E5%AF%86%E7%A0%81%E5%AD%A6/70.XORCipher.html",relativePath:"20.算法/140.Ciphers 密码学/70.XORCipher.md",key:"v-4c429b26",path:"/algorithm/cipher/XORCipher/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @function XORCipher\n * @description - Encrypt using an XOR cipher\n * The XOR cipher is a type of additive cipher.\n * Each character is bitwise XORed with the key.\n * We loop through the input string, XORing each\n * character with the key.\n * @param {string} str - string to be encrypted\n * @param {number} key - key for encryption\n * @return {string} encrypted string\n */\nconst XORCipher = (str, key) => {\n  if (typeof str !== 'string' || !Number.isInteger(key)) {\n    throw new TypeError('Arguments type are invalid')\n  }\n\n  return str.replace(\n    /./g, (char) => String.fromCharCode(char.charCodeAt() ^ key)\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @function xorcipher\n * @description - encrypt using an xor cipher\n * the xor cipher is a type of additive cipher.\n * each character is bitwise xored with the key.\n * we loop through the input string, xoring each\n * character with the key.\n * @param {string} str - string to be encrypted\n * @param {number} key - key for encryption\n * @return {string} encrypted string\n */\nconst xorcipher = (str, key) => {\n  if (typeof str !== 'string' || !number.isinteger(key)) {\n    throw new typeerror('arguments type are invalid')\n  }\n\n  return str.replace(\n    /./g, (char) => string.fromcharcode(char.charcodeat() ^ key)\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:30:16",lastUpdatedTimestamp:1666949416e3},{title:"算法与转换：Part1",frontmatter:{title:"算法与转换：Part1",date:"2022-10-28T16:56:30.000Z",permalink:"/algorithm/conversion/p1/",categories:["算法","Conversions 转换"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/150.Conversions%20%E8%BD%AC%E6%8D%A2/10.Part1.html",relativePath:"20.算法/150.Conversions 转换/10.Part1.md",key:"v-48ac3ae5",path:"/algorithm/conversion/p1/",headers:[{level:2,title:"字符串基数转换",slug:"字符串基数转换",normalizedTitle:"字符串基数转换",charIndex:2},{level:2,title:"Buffer转Base64",slug:"buffer转base64",normalizedTitle:"buffer 转 base64",charIndex:1969},{level:2,title:"Base64转Buffer",slug:"base64转buffer",normalizedTitle:"base64 转 buffer",charIndex:3651},{level:2,title:"二进制转十进制",slug:"二进制转十进制",normalizedTitle:"二进制转十进制",charIndex:5704},{level:2,title:"十进制转二进制",slug:"十进制转二进制",normalizedTitle:"十进制转二进制",charIndex:6098},{level:2,title:"二进制转十六进制",slug:"二进制转十六进制",normalizedTitle:"二进制转十六进制",charIndex:6310},{level:2,title:"十六进制转二进制",slug:"十六进制转二进制",normalizedTitle:"十六进制转二进制",charIndex:8082},{level:2,title:"十进制转十六进制",slug:"十进制转十六进制",normalizedTitle:"十进制转十六进制",charIndex:9032},{level:2,title:"十六进制转十进制",slug:"十六进制转十进制",normalizedTitle:"十六进制转十进制",charIndex:9495},{level:2,title:"十进制转八进制",slug:"十进制转八进制",normalizedTitle:"十进制转八进制",charIndex:10154},{level:2,title:"八进制转十进制",slug:"八进制转十进制",normalizedTitle:"八进制转十进制",charIndex:10423},{level:2,title:"十进制转罗马数字",slug:"十进制转罗马数字",normalizedTitle:"十进制转罗马数字",charIndex:10664},{level:2,title:"罗马数字转十进制",slug:"罗马数字转十进制",normalizedTitle:"罗马数字转十进制",charIndex:11568},{level:2,title:"颜色：十六进制和RGB相互转化",slug:"颜色-十六进制和rgb相互转化",normalizedTitle:"颜色：十六进制和 rgb 相互转化",charIndex:12205},{level:2,title:"颜色：HSV和RGB相互转化",slug:"颜色-hsv和rgb相互转化",normalizedTitle:"颜色：hsv 和 rgb 相互转化",charIndex:12851},{level:2,title:"任意字符串转大写或者小写",slug:"任意字符串转大写或者小写",normalizedTitle:"任意字符串转大写或者小写",charIndex:17529},{level:2,title:"英尺和米的转换",slug:"英尺和米的转换",normalizedTitle:"英尺和米的转换",charIndex:20891},{level:2,title:"标准格式时间转railway格式时间",slug:"标准格式时间转railway格式时间",normalizedTitle:"标准格式时间转 railway 格式时间",charIndex:21091},{level:2,title:"温度计量相互转换",slug:"温度计量相互转换",normalizedTitle:"温度计量相互转换",charIndex:22613},{level:2,title:"字符串转Title Case",slug:"字符串转title-case",normalizedTitle:"字符串转 title case",charIndex:26328}],headersStr:"字符串基数转换 Buffer转Base64 Base64转Buffer 二进制转十进制 十进制转二进制 二进制转十六进制 十六进制转二进制 十进制转十六进制 十六进制转十进制 十进制转八进制 八进制转十进制 十进制转罗马数字 罗马数字转十进制 颜色：十六进制和RGB相互转化 颜色：HSV和RGB相互转化 任意字符串转大写或者小写 英尺和米的转换 标准格式时间转railway格式时间 温度计量相互转换 字符串转Title Case",content:"# 字符串基数转换\n\n/**\n* Converts a string from one base to other\n* @param {string} stringInBaseOne String in input base\n* @param {string} baseOneCharacters Character set for the input base\n* @param {string} baseTwoCharacters Character set for the output base\n* @returns {string}\n*/\nconst convertArbitraryBase = (stringInBaseOne, baseOneCharacters, baseTwoCharacters) => {\n  if ([stringInBaseOne, baseOneCharacters, baseTwoCharacters].map(arg => typeof arg).some(type => type !== 'string')) {\n    throw new TypeError('Only string arguments are allowed')\n  }\n  [baseOneCharacters, baseTwoCharacters].forEach(baseString => {\n    const charactersInBase = [...baseString]\n    if (charactersInBase.length !== new Set(charactersInBase).size) {\n      throw new TypeError('Duplicate characters in character set are not allowed')\n    }\n  })\n  const reversedStringOneChars = [...stringInBaseOne].reverse()\n  const stringOneBase = baseOneCharacters.length\n  let value = 0\n  let placeValue = 1\n  for (const digit of reversedStringOneChars) {\n    const digitNumber = baseOneCharacters.indexOf(digit)\n    if (digitNumber === -1) {\n      throw new TypeError(`Not a valid character: ${digit}`)\n    }\n    value += (digitNumber * placeValue)\n    placeValue *= stringOneBase\n  }\n  let stringInBaseTwo = ''\n  const stringTwoBase = baseTwoCharacters.length\n  while (value > 0) {\n    const remainder = value % stringTwoBase\n    stringInBaseTwo = baseTwoCharacters.charAt(remainder) + stringInBaseTwo\n    value /= stringTwoBase\n  }\n  const baseTwoZero = baseTwoCharacters.charAt(0)\n  return stringInBaseTwo.replace(new RegExp(`^${baseTwoZero}+`), '')\n}\n\n// > convertArbitraryBase('98', '0123456789', '01234567')\n// '142'\n\n// > convertArbitraryBase('98', '0123456789', 'abcdefgh')\n// 'bec'\n\n// > convertArbitraryBase('129', '0123456789', '01234567')\n// '201'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# Buffer 转 Base64\n\n// About base64: https://en.wikipedia.org/wiki/Base64\n\n/**\n * Converts an array of bytes to base64 encoding\n * @param {ArrayBuffer} binaryData An ArrayBuffer which represents an array of bytes\n * @returns {string} A string containing the base64 encoding of `binaryData`\n */\nfunction bufferToBase64 (binaryData) {\n  // The base64 encoding uses the following set of characters to encode any binary data as text\n  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  // Every 3 bytes translates to 4 base64 characters, if we have less than 3 bytes we must append '=' chars as padding\n  const padding = 3 - (binaryData.byteLength % 3)\n  // Create an instance of Uint8Array, to read from the binaryData array buffer\n  const byteView = new Uint8Array(binaryData)\n  let result = ''\n\n  // Loop through all bytes in the buffer, in increments of 3 bytes\n  for (let i = 0; i < byteView.byteLength; i += 3) {\n    // Get the index for the next 4 base64 chars\n    const char1 = (byteView[i] & 252) >> 2\n    const char2 = ((byteView[i] & 3) << 4) + ((byteView[i + 1] & 240) >> 4)\n    const char3 = ((byteView[i + 1] & 15) << 2) + ((byteView[i + 2] & 192) >> 6)\n    const char4 = byteView[i + 2] & 63\n\n    result +=\n        base64Table[char1] +\n        base64Table[char2] +\n        base64Table[char3] +\n        base64Table[char4]\n  }\n\n  // Add padding '=' chars if needed\n  if (padding !== 3) {\n    const paddedResult = result.slice(0, result.length - padding) + '='.repeat(padding)\n    return paddedResult\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# Base64 转 Buffer\n\n// About base64: https://en.wikipedia.org/wiki/Base64\n\n/**\n * Converts a base64 string to an array of bytes\n * @param {string} b64 A base64 string\n * @returns {ArrayBuffer} An ArrayBuffer representing the bytes encoded by the base64 string\n */\nfunction base64ToBuffer (b64) {\n  // The base64 encoding uses the following set of characters to encode any binary data as text\n  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  // Find the index of char '=' first occurrence\n  const paddingIdx = b64.indexOf('=')\n  // Remove padding chars from base64 string, if there are any\n  const b64NoPadding = paddingIdx !== -1 ? b64.slice(0, paddingIdx) : b64\n  // Calculate the length of the result buffer\n  const bufferLength = Math.floor((b64NoPadding.length * 6) / 8)\n  // Create the result buffer\n  const result = new ArrayBuffer(bufferLength)\n  // Create an instance of Uint8Array, to write to the `result` buffer\n  const byteView = new Uint8Array(result)\n\n  // Loop through all chars in the base64 string, in increments of 4 chars, and in increments of 3 bytes\n  for (let i = 0, j = 0; i < b64NoPadding.length; i += 4, j += 3) {\n    // Get the index of the next 4 base64 chars\n    const b64Char1 = base64Table.indexOf(b64NoPadding[i])\n    const b64Char2 = base64Table.indexOf(b64NoPadding[i + 1])\n    let b64Char3 = base64Table.indexOf(b64NoPadding[i + 2])\n    let b64Char4 = base64Table.indexOf(b64NoPadding[i + 3])\n\n    // If base64 chars 3 and 4 don't exit, then set them to 0\n    if (b64Char3 === -1) b64Char3 = 0\n    if (b64Char4 === -1) b64Char4 = 0\n\n    // Calculate the next 3 bytes\n    const byte1 = (b64Char1 << 2) + ((b64Char2 & 48) >> 4)\n    const byte2 = ((b64Char2 & 15) << 4) + ((b64Char3 & 60) >> 2)\n    const byte3 = ((b64Char3 & 3) << 6) + b64Char4\n\n    byteView[j] = byte1\n    byteView[j + 1] = byte2\n    byteView[j + 2] = byte3\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 二进制转十进制\n\nfunction binaryToDecimal (binaryString) {\n  let decimalNumber = 0\n  const binaryDigits = binaryString.split('').reverse() // Splits the binary number into reversed single digits\n  binaryDigits.forEach((binaryDigit, index) => {\n    decimalNumber += binaryDigit * (Math.pow(2, index)) // Summation of all the decimal converted digits\n  })\n  return decimalNumber\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 十进制转二进制\n\nfunction decimalToBinary (num) {\n  const bin = []\n  while (num > 0) {\n    bin.unshift(num % 2)\n    num >>= 1 // basically /= 2 without remainder if any\n  }\n  return bin.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二进制转十六进制\n\nconst pad = (num, padlen) => {\n  const pad = new Array(1 + padlen).join(0)\n  return (pad + num).slice(-pad.length)\n}\n\nconst hexLookup = (bin) => {\n  let binary = bin\n  if (binary.length < 4) {\n    binary = pad(binary, 4)\n  }\n  switch (binary) {\n    case '0000': return '0'\n    case '0001': return '1'\n    case '0010': return '2'\n    case '0011': return '3'\n    case '0100': return '4'\n    case '0101': return '5'\n    case '0110': return '6'\n    case '0111': return '7'\n    case '1000': return '8'\n    case '1001': return '9'\n    case '1010': return 'A'\n    case '1011': return 'B'\n    case '1100': return 'C'\n    case '1101': return 'D'\n    case '1110': return 'E'\n    case '1111': return 'F'\n  }\n}\nconst binaryToHex = (binaryString) => {\n  /*\n  Function for convertung Binary to Hex\n\n  1. The conversion will start from Least Significant Digit (LSB) to the Most Significant Bit (MSB).\n  2. We divide the bits into sections of 4-bits starting from LSB to MSB.\n  3. If the MSB get less than 4 bits, then we pad 0s to the front of it.\n\n  For Example:\n  Binary String = '1001101'\n\n  1. Divide it to 2 parts => ['100', '1101']\n  2. Pad 0s the MSB so it'll be => ['0100', '1101']\n  3. Use the lookup table and merge them, therefore the result is 4D.\n\n  */\n\n  let result = ''\n  binaryString = binaryString.split('')\n  for (let i = binaryString.length - 1; i >= 0; i = i - 4) {\n    if (i >= 3) {\n      result += hexLookup(binaryString.slice(i - 3, i + 1).join(''))\n    } else {\n      result += hexLookup(binaryString.slice(0, i + 1).join(''))\n    }\n  }\n  return result.split('').reverse().join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 十六进制转二进制\n\nconst binLookup = (key) => ({\n  0: '0000',\n  1: '0001',\n  2: '0010',\n  3: '0011',\n  4: '0100',\n  5: '0101',\n  6: '0110',\n  7: '0111',\n  8: '1000',\n  9: '1001',\n  a: '1010',\n  b: '1011',\n  c: '1100',\n  d: '1101',\n  e: '1110',\n  f: '1111'\n}[key.toLowerCase()]) // select the binary number by valid hex key with the help javascript object\n\nconst hexToBinary = (hexString) => {\n  if (typeof hexString !== 'string') {\n    throw new TypeError('Argument is not a string type')\n  }\n\n  if (/[^\\da-f]/gi.test(hexString)) {\n    throw new Error('Argument is not a valid HEX code!')\n  }\n  /*\n    Function for converting Hex to Binary\n\n    1. We convert every hexadecimal bit to 4 binary bits\n    2. Conversion goes by searching in the lookup table\n  */\n\n  return hexString.replace(\n    /[0-9a-f]/gi,\n    lexeme => binLookup(lexeme)\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 十进制转十六进制\n\nfunction intToHex (num) {\n  switch (num) {\n    case 10: return 'A'\n    case 11: return 'B'\n    case 12: return 'C'\n    case 13: return 'D'\n    case 14: return 'E'\n    case 15: return 'F'\n  }\n  return num\n}\n\nfunction decimalToHex (num) {\n  const hexOut = []\n  while (num > 15) {\n    hexOut.unshift(intToHex(num % 16))\n    num = Math.floor(num / 16)\n  }\n  return intToHex(num) + hexOut.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 十六进制转十进制\n\nfunction hexToInt (hexNum) {\n  const numArr = hexNum.split('') // converts number to array\n  return numArr.map((item, index) => {\n    switch (item) {\n      case 'A': return 10\n      case 'B': return 11\n      case 'C': return 12\n      case 'D': return 13\n      case 'E': return 14\n      case 'F': return 15\n      default: return parseInt(item)\n    }\n  })\n}\n\nfunction hexToDecimal (hexNum) {\n  const intItemsArr = hexToInt(hexNum)\n  return intItemsArr.reduce((accumulator, current, index) => {\n    return accumulator + (current * Math.pow(16, (intItemsArr.length - (1 + index))))\n  }, 0)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 十进制转八进制\n\nfunction decimalToOctal (num) {\n  let oct = 0\n  let c = 0\n  while (num > 0) {\n    const r = num % 8\n    oct = oct + (r * Math.pow(10, c++))\n    num = Math.floor(num / 8) // basically /= 8 without remainder if any\n  }\n  return oct\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 八进制转十进制\n\nfunction octalToDecimal (num) {\n  let dec = 0\n  let base = 1\n  while (num > 0) {\n    const r = num % 10\n    num = Math.floor(num / 10)\n    dec = dec + (r * base)\n    base = base * 8\n  }\n  return dec\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 十进制转罗马数字\n\n/*\n    Decimal To Roman\n\n    This algorithm take decimal number and convert to roman numeral according to standard form (https://en.wikipedia.org/wiki/Roman_numerals#Description)\n\n    Algorithm & Explanation : https://www.rapidtables.com/convert/number/how-number-to-roman-numerals.html\n*/\n\nconst values = {\n  M: 1000,\n  CM: 900,\n  D: 500,\n  CD: 400,\n  C: 100,\n  XC: 90,\n  L: 50,\n  XL: 40,\n  X: 10,\n  IX: 9,\n  V: 5,\n  IV: 4,\n  I: 1\n}\n\nconst orders = [\n  'M',\n  'CM',\n  'D',\n  'CD',\n  'C',\n  'XC',\n  'L',\n  'XL',\n  'X',\n  'IX',\n  'V',\n  'IV',\n  'I'\n]\n\nfunction decimalToRoman (num) {\n  let roman = ''\n  for (const symbol of orders) {\n    while (num >= values[symbol]) {\n      roman += symbol\n      num -= values[symbol]\n    }\n  }\n  return roman\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 罗马数字转十进制\n\nconst values = {\n  I: 1,\n  V: 5,\n  X: 10,\n  L: 50,\n  C: 100,\n  D: 500,\n  M: 1000\n}\n\nfunction romanToDecimal (romanNumber) {\n  let prev = ' '\n\n  let sum = 0\n\n  let newPrev = 0\n  for (let i = romanNumber.length - 1; i >= 0; i--) {\n    const c = romanNumber.charAt(i)\n\n    if (prev !== ' ') {\n      newPrev = values[prev] > newPrev ? values[prev] : newPrev\n    }\n\n    const currentNum = values[c]\n    if (currentNum >= newPrev) {\n      sum += currentNum\n    } else {\n      sum -= currentNum\n    }\n\n    prev = c\n  }\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 颜色：十六进制和 RGB 相互转化\n\nfunction hexStringToRGB (hexString) {\n  let r = hexString.substring(0, 2)\n  let g = hexString.substring(2, 4)\n  let b = hexString.substring(4, 6)\n\n  r = parseInt(r, 16)\n  g = parseInt(g, 16)\n  b = parseInt(b, 16)\n  const obj = { r, g, b }\n\n  return obj\n}\n\nfunction RGBToHex (r, g, b) {\n  if (\n    typeof r !== 'number' ||\n    typeof g !== 'number' ||\n    typeof b !== 'number'\n  ) {\n    throw new TypeError('argument is not a Number')\n  }\n\n  const toHex = n => (n || '0').toString(16).padStart(2, '0')\n\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 颜色：HSV 和 RGB 相互转化\n\n/*\n * The RGB color model is an additive color model in which red, green, and blue light are added\n * together in various ways to reproduce a broad array of colors. The name of the model comes from\n * the initials of the three additive primary colors, red, green, and blue. Meanwhile, the HSV\n * representation models how colors appear under light. In it, colors are represented using three\n * components: hue, saturation and (brightness-)value. This file provides functions for converting\n * colors from one representation to the other. (description adapted from\n * https://en.wikipedia.org/wiki/RGB_color_model and https://en.wikipedia.org/wiki/HSL_and_HSV).\n */\n\n/**\n * Conversion from the HSV-representation to the RGB-representation.\n *\n * @param hue Hue of the color.\n * @param saturation Saturation of the color.\n * @param value Brightness-value of the color.\n * @return The tuple of RGB-components.\n */\nfunction hsvToRgb (hue, saturation, value) {\n  if (hue < 0 || hue > 360) {\n    throw new Error('hue should be between 0 and 360')\n  }\n\n  if (saturation < 0 || saturation > 1) {\n    throw new Error('saturation should be between 0 and 1')\n  }\n\n  if (value < 0 || value > 1) {\n    throw new Error('value should be between 0 and 1')\n  }\n\n  const chroma = value * saturation\n  const hueSection = hue / 60\n  const secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1))\n  const matchValue = value - chroma\n\n  return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent)\n}\n\n/**\n * Conversion from the RGB-representation to the HSV-representation.\n *\n * @param red Red-component of the color.\n * @param green Green-component of the color.\n * @param blue Blue-component of the color.\n * @return The tuple of HSV-components.\n */\nfunction rgbToHsv (red, green, blue) {\n  if (red < 0 || red > 255) {\n    throw new Error('red should be between 0 and 255')\n  }\n\n  if (green < 0 || green > 255) {\n    throw new Error('green should be between 0 and 255')\n  }\n\n  if (blue < 0 || blue > 255) {\n    throw new Error('blue should be between 0 and 255')\n  }\n\n  const dRed = red / 255\n  const dGreen = green / 255\n  const dBlue = blue / 255\n  const value = Math.max(Math.max(dRed, dGreen), dBlue)\n  const chroma = value - Math.min(Math.min(dRed, dGreen), dBlue)\n  const saturation = value === 0 ? 0 : chroma / value\n  let hue\n\n  if (chroma === 0) {\n    hue = 0\n  } else if (value === dRed) {\n    hue = 60 * ((dGreen - dBlue) / chroma)\n  } else if (value === dGreen) {\n    hue = 60 * (2 + (dBlue - dRed) / chroma)\n  } else {\n    hue = 60 * (4 + (dRed - dGreen) / chroma)\n  }\n\n  hue = (hue + 360) % 360\n\n  return [hue, saturation, value]\n}\n\nexport function approximatelyEqualHsv (hsv1, hsv2) {\n  const bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2\n  const bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002\n  const bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002\n\n  return bHue && bSaturation && bValue\n}\n\nfunction getRgbBySection (hueSection, chroma, matchValue, secondLargestComponent) {\n  function convertToInt (input) {\n    return Math.round(255 * input)\n  }\n\n  let red\n  let green\n  let blue\n\n  if (hueSection >= 0 && hueSection <= 1) {\n    red = convertToInt(chroma + matchValue)\n    green = convertToInt(secondLargestComponent + matchValue)\n    blue = convertToInt(matchValue)\n  } else if (hueSection > 1 && hueSection <= 2) {\n    red = convertToInt(secondLargestComponent + matchValue)\n    green = convertToInt(chroma + matchValue)\n    blue = convertToInt(matchValue)\n  } else if (hueSection > 2 && hueSection <= 3) {\n    red = convertToInt(matchValue)\n    green = convertToInt(chroma + matchValue)\n    blue = convertToInt(secondLargestComponent + matchValue)\n  } else if (hueSection > 3 && hueSection <= 4) {\n    red = convertToInt(matchValue)\n    green = convertToInt(secondLargestComponent + matchValue)\n    blue = convertToInt(chroma + matchValue)\n  } else if (hueSection > 4 && hueSection <= 5) {\n    red = convertToInt(secondLargestComponent + matchValue)\n    green = convertToInt(matchValue)\n    blue = convertToInt(chroma + matchValue)\n  } else {\n    red = convertToInt(chroma + matchValue)\n    green = convertToInt(matchValue)\n    blue = convertToInt(secondLargestComponent + matchValue)\n  }\n\n  return [red, green, blue]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n\n\n# 任意字符串转大写或者小写\n\n/*\n    Explanation :- a user gives a String (it can be incomplete uppercase or\n        partial uppercase) and then the program would convert it into a\n        complete(all characters in lower case) lower case string. The\n        logic we have used in the following program is: All the upper case\n        characters (A-Z) has ASCII value ranging from 65 to 90 and their\n        corresponding lower case characters (a-z) have ASCII values 32\n        greater than them. For example ‘A‘ has an ASCII value of 65\n        and ‘a‘ has an ASCII value of 97 (65+32). The same applies to other\n        characters.\n*/\n\n/**\n * LowerCaseConversion takes any case-style string and converts it to the lower case-style string.\n * @param {String} inputString any case style string\n * @returns {String} lower case string\n */\nconst LowerCaseConversion = (inputString) => {\n  // Take a string and split it into characters.\n  const newString = inputString.split('').map(char => {\n    // Get a character code by the use charCodeAt method.\n    const presentCharCode = char.charCodeAt()\n    // If the character code lies between 65 to 90 it means they are in the upper case so convert it.\n    if (presentCharCode >= 65 && presentCharCode <= 90) {\n      // Convert the case by use of the above explanation.\n      return String.fromCharCode(presentCharCode + 32)\n    }\n    // Else return the characters without any modification.\n    return char\n  })\n  // After modification, with the help of the join method, join all the characters and return them.\n  return newString.join('')\n}\n\n/*\n    Explanation :- A user gives a string (it can be incomplete lowercase or\n        partially in lowercase) and then the program converts it into a\n        completely (all characters in uppercase) uppercase string. The\n        logic we have used in the following program is: All the lowercase\n        characters (a-z) has [ASCII](https://en.wikipedia.org/wiki/ASCII) value ranging from 97 to 122 and their\n        corresponding uppercase characters (A-Z) have ASCII values 32\n        lesser than them. For example ‘a‘ has an ASCII value of 97\n        and ‘A‘ has an ASCII value of 65 (97 - 32). The same applies to other\n        characters.\n*/\n\n/**\n * upperCaseConversion takes any case-style string and converts it to the uppercase-style string.\n * @param {string} inputString Any case style string\n * @returns {string} Uppercase string\n */\nconst upperCaseConversion = (inputString) => {\n  // Take a string and split it into characters.\n  const newString = inputString.split('').map(char => {\n    // Get a character code by the use charCodeAt method.\n    const presentCharCode = char.charCodeAt()\n    // If the character code lies between 97 to 122, it means they are in the lowercase so convert it.\n    if (presentCharCode >= 97 && presentCharCode <= 122) {\n      // Convert the case by use of the above explanation.\n      return String.fromCharCode(presentCharCode - 32)\n    }\n    // Else return the characters without any modification.\n    return char\n  })\n  // After modification, with the help of the join method, join all the characters and return them.\n  return newString.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# 英尺和米的转换\n\n// Foot: https://en.wikipedia.org/wiki/Foot_(unit)\nconst feetToMeter = (feet) => {\n  return feet * 0.3048\n}\n\nconst meterToFeet = (meter) => {\n  return meter / 0.3048\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 标准格式时间转 railway 格式时间\n\n/*\n    The time conversion of normalized time to the railway is a simple algorithm\n    because we know that if the time is in 'AM' value it means they only want\n    some changes on hours and minutes and if the time in 'PM' it means the only\n    want some changes in hour value.\n\n    Input Format -> 07:05:45PM\n    Output Format -> 19:05:45\n\n    Problem & Explanation Source : https://www.mathsisfun.com/time.html\n*/\n\n/**\n * RailwayTimeConversion method converts normalized time string to Railway time string.\n * @param {String} timeString Normalized time string.\n * @returns {String} Railway time string.\n */\nconst RailwayTimeConversion = (timeString) => {\n  // firstly, check that input is a string or not.\n  if (typeof timeString !== 'string') {\n    return new TypeError('Argument is not a string.')\n  }\n  // split the string by ':' character.\n  const [hour, minute, scondWithShift] = timeString.split(':')\n  // split second and shift value.\n  const [second, shift] = [scondWithShift.substr(0, 2), scondWithShift.substr(2)]\n  // convert shifted time to not-shift time(Railway time) by using the above explanation.\n  if (shift === 'PM') {\n    if (parseInt(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseInt(hour) + 12}:${minute}:${second}` }\n  } else {\n    if (parseInt(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 温度计量相互转换\n\n// This files has functions to convert different temperature units\n// Functions take temperature value as a argument and returns corresponding converted value\n\nconst celsiusToFahrenheit = (celsius) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n  return Math.round(((celsius) * 9 / 5) + 32)\n}\n\nconst celsiusToKelvin = (celsius) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n  return Math.round((celsius) + 273.15)\n}\n\nconst celsiusToRankine = (celsius) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n  return Math.round(((celsius) * 9 / 5) + 491.67)\n}\n\nconst fahrenheitToCelsius = (fahrenheit) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n  return Math.round(((fahrenheit) - 32) * 5 / 9)\n}\n\nconst fahrenheitToKelvin = (fahrenheit) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n  return Math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)\n}\n\nconst fahrenheitToRankine = (fahrenheit) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n  return Math.round((fahrenheit) + 459.67)\n}\n\nconst kelvinToCelsius = (kelvin) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n  return Math.round((kelvin) - 273.15)\n}\n\nconst kelvinToFahrenheit = (kelvin) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n  return Math.round((((kelvin) - 273.15) * 9 / 5) + 32)\n}\n\nconst kelvinToRankine = (kelvin) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n  return Math.round(((kelvin) * 9 / 5))\n}\n\nconst rankineToCelsius = (rankine) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n  return Math.round(((rankine) - 491.67) * 5 / 9)\n}\n\nconst rankineToFahrenheit = (rankine) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n  return Math.round((rankine) - 459.67)\n}\n\nconst rankineToKelvin = (rankine) => {\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n  return Math.round(((rankine) * 5 / 9))\n}\n\nconst reaumurToKelvin = (reaumur) => {\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\n  return Math.round(((reaumur) * 1.25 + 273.15))\n}\n\nconst reaumurToFahrenheit = (reaumur) => {\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\n  return Math.round(((reaumur) * 2.25 + 32))\n}\n\nconst reaumurToCelsius = (reaumur) => {\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\n  return Math.round(((reaumur) * 1.25))\n}\n\nconst reaumurToRankine = (reaumur) => {\n  // Reference:- http://www.csgnetwork.com/temp2conv.html\n  return Math.round(((reaumur) * 2.25 + 32 + 459.67))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n# 字符串转 Title Case\n\n/*\n    Problem statement and Explanation : https://www.codeproject.com/Tips/162540/Letter-Case-Conversion-Algorithms-Title-Case-Toggl.\n    [Title case](https://en.wikipedia.org/wiki/Title_case) is a style where all words are capitalized. Officially, title case\n    does not capitalize some words, such as very short words like \"a\" or \"is\", but for the purposes of this function, a general approach\n    is taken where all words are capitalized regardless of length.\n*/\n\n/**\n * The titleCaseConversion function converts a string into a title case string.\n * @param {string} inputString The input string which can have any types of letter casing.\n * @returns {string} A string that is in title case.\n */\nconst titleCaseConversion = (inputString) => {\n  if (inputString === '') return ''\n  // Extract all space separated string.\n  const stringCollections = inputString.split(' ').map(word => {\n    let firstChar = ''\n    // Get the [ASCII](https://en.wikipedia.org/wiki/ASCII) character code by the use charCodeAt method.\n    const firstCharCode = word[0].charCodeAt()\n    // If the ASCII character code lies between 97 to 122 it means they are in the lowercase so convert it.\n    if (firstCharCode >= 97 && firstCharCode <= 122) {\n      // Convert the case by use of the above explanation.\n      firstChar += String.fromCharCode(firstCharCode - 32)\n    } else {\n      // Else store the characters without any modification.\n      firstChar += word[0]\n    }\n    const newWordChar = word.slice(1).split('').map(char => {\n      // Get the ASCII character code by the use charCodeAt method.\n      const presentCharCode = char.charCodeAt()\n      // If the ASCII character code lies between 65 to 90, it means they are in the uppercase so convert it.\n      if (presentCharCode >= 65 && presentCharCode <= 90) {\n        // Convert the case by use of the above explanation.\n        return String.fromCharCode(presentCharCode + 32)\n      }\n      // Else return the characters without any modification.\n      return char\n    })\n    // Return the first converted character and remaining character string.\n    return firstChar + newWordChar.join('')\n  })\n  // Convert all words in a string and return it.\n  return stringCollections.join(' ')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n",normalizedContent:"# 字符串基数转换\n\n/**\n* converts a string from one base to other\n* @param {string} stringinbaseone string in input base\n* @param {string} baseonecharacters character set for the input base\n* @param {string} basetwocharacters character set for the output base\n* @returns {string}\n*/\nconst convertarbitrarybase = (stringinbaseone, baseonecharacters, basetwocharacters) => {\n  if ([stringinbaseone, baseonecharacters, basetwocharacters].map(arg => typeof arg).some(type => type !== 'string')) {\n    throw new typeerror('only string arguments are allowed')\n  }\n  [baseonecharacters, basetwocharacters].foreach(basestring => {\n    const charactersinbase = [...basestring]\n    if (charactersinbase.length !== new set(charactersinbase).size) {\n      throw new typeerror('duplicate characters in character set are not allowed')\n    }\n  })\n  const reversedstringonechars = [...stringinbaseone].reverse()\n  const stringonebase = baseonecharacters.length\n  let value = 0\n  let placevalue = 1\n  for (const digit of reversedstringonechars) {\n    const digitnumber = baseonecharacters.indexof(digit)\n    if (digitnumber === -1) {\n      throw new typeerror(`not a valid character: ${digit}`)\n    }\n    value += (digitnumber * placevalue)\n    placevalue *= stringonebase\n  }\n  let stringinbasetwo = ''\n  const stringtwobase = basetwocharacters.length\n  while (value > 0) {\n    const remainder = value % stringtwobase\n    stringinbasetwo = basetwocharacters.charat(remainder) + stringinbasetwo\n    value /= stringtwobase\n  }\n  const basetwozero = basetwocharacters.charat(0)\n  return stringinbasetwo.replace(new regexp(`^${basetwozero}+`), '')\n}\n\n// > convertarbitrarybase('98', '0123456789', '01234567')\n// '142'\n\n// > convertarbitrarybase('98', '0123456789', 'abcdefgh')\n// 'bec'\n\n// > convertarbitrarybase('129', '0123456789', '01234567')\n// '201'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# buffer 转 base64\n\n// about base64: https://en.wikipedia.org/wiki/base64\n\n/**\n * converts an array of bytes to base64 encoding\n * @param {arraybuffer} binarydata an arraybuffer which represents an array of bytes\n * @returns {string} a string containing the base64 encoding of `binarydata`\n */\nfunction buffertobase64 (binarydata) {\n  // the base64 encoding uses the following set of characters to encode any binary data as text\n  const base64table = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789+/'\n  // every 3 bytes translates to 4 base64 characters, if we have less than 3 bytes we must append '=' chars as padding\n  const padding = 3 - (binarydata.bytelength % 3)\n  // create an instance of uint8array, to read from the binarydata array buffer\n  const byteview = new uint8array(binarydata)\n  let result = ''\n\n  // loop through all bytes in the buffer, in increments of 3 bytes\n  for (let i = 0; i < byteview.bytelength; i += 3) {\n    // get the index for the next 4 base64 chars\n    const char1 = (byteview[i] & 252) >> 2\n    const char2 = ((byteview[i] & 3) << 4) + ((byteview[i + 1] & 240) >> 4)\n    const char3 = ((byteview[i + 1] & 15) << 2) + ((byteview[i + 2] & 192) >> 6)\n    const char4 = byteview[i + 2] & 63\n\n    result +=\n        base64table[char1] +\n        base64table[char2] +\n        base64table[char3] +\n        base64table[char4]\n  }\n\n  // add padding '=' chars if needed\n  if (padding !== 3) {\n    const paddedresult = result.slice(0, result.length - padding) + '='.repeat(padding)\n    return paddedresult\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# base64 转 buffer\n\n// about base64: https://en.wikipedia.org/wiki/base64\n\n/**\n * converts a base64 string to an array of bytes\n * @param {string} b64 a base64 string\n * @returns {arraybuffer} an arraybuffer representing the bytes encoded by the base64 string\n */\nfunction base64tobuffer (b64) {\n  // the base64 encoding uses the following set of characters to encode any binary data as text\n  const base64table = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789+/'\n  // find the index of char '=' first occurrence\n  const paddingidx = b64.indexof('=')\n  // remove padding chars from base64 string, if there are any\n  const b64nopadding = paddingidx !== -1 ? b64.slice(0, paddingidx) : b64\n  // calculate the length of the result buffer\n  const bufferlength = math.floor((b64nopadding.length * 6) / 8)\n  // create the result buffer\n  const result = new arraybuffer(bufferlength)\n  // create an instance of uint8array, to write to the `result` buffer\n  const byteview = new uint8array(result)\n\n  // loop through all chars in the base64 string, in increments of 4 chars, and in increments of 3 bytes\n  for (let i = 0, j = 0; i < b64nopadding.length; i += 4, j += 3) {\n    // get the index of the next 4 base64 chars\n    const b64char1 = base64table.indexof(b64nopadding[i])\n    const b64char2 = base64table.indexof(b64nopadding[i + 1])\n    let b64char3 = base64table.indexof(b64nopadding[i + 2])\n    let b64char4 = base64table.indexof(b64nopadding[i + 3])\n\n    // if base64 chars 3 and 4 don't exit, then set them to 0\n    if (b64char3 === -1) b64char3 = 0\n    if (b64char4 === -1) b64char4 = 0\n\n    // calculate the next 3 bytes\n    const byte1 = (b64char1 << 2) + ((b64char2 & 48) >> 4)\n    const byte2 = ((b64char2 & 15) << 4) + ((b64char3 & 60) >> 2)\n    const byte3 = ((b64char3 & 3) << 6) + b64char4\n\n    byteview[j] = byte1\n    byteview[j + 1] = byte2\n    byteview[j + 2] = byte3\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 二进制转十进制\n\nfunction binarytodecimal (binarystring) {\n  let decimalnumber = 0\n  const binarydigits = binarystring.split('').reverse() // splits the binary number into reversed single digits\n  binarydigits.foreach((binarydigit, index) => {\n    decimalnumber += binarydigit * (math.pow(2, index)) // summation of all the decimal converted digits\n  })\n  return decimalnumber\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 十进制转二进制\n\nfunction decimaltobinary (num) {\n  const bin = []\n  while (num > 0) {\n    bin.unshift(num % 2)\n    num >>= 1 // basically /= 2 without remainder if any\n  }\n  return bin.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二进制转十六进制\n\nconst pad = (num, padlen) => {\n  const pad = new array(1 + padlen).join(0)\n  return (pad + num).slice(-pad.length)\n}\n\nconst hexlookup = (bin) => {\n  let binary = bin\n  if (binary.length < 4) {\n    binary = pad(binary, 4)\n  }\n  switch (binary) {\n    case '0000': return '0'\n    case '0001': return '1'\n    case '0010': return '2'\n    case '0011': return '3'\n    case '0100': return '4'\n    case '0101': return '5'\n    case '0110': return '6'\n    case '0111': return '7'\n    case '1000': return '8'\n    case '1001': return '9'\n    case '1010': return 'a'\n    case '1011': return 'b'\n    case '1100': return 'c'\n    case '1101': return 'd'\n    case '1110': return 'e'\n    case '1111': return 'f'\n  }\n}\nconst binarytohex = (binarystring) => {\n  /*\n  function for convertung binary to hex\n\n  1. the conversion will start from least significant digit (lsb) to the most significant bit (msb).\n  2. we divide the bits into sections of 4-bits starting from lsb to msb.\n  3. if the msb get less than 4 bits, then we pad 0s to the front of it.\n\n  for example:\n  binary string = '1001101'\n\n  1. divide it to 2 parts => ['100', '1101']\n  2. pad 0s the msb so it'll be => ['0100', '1101']\n  3. use the lookup table and merge them, therefore the result is 4d.\n\n  */\n\n  let result = ''\n  binarystring = binarystring.split('')\n  for (let i = binarystring.length - 1; i >= 0; i = i - 4) {\n    if (i >= 3) {\n      result += hexlookup(binarystring.slice(i - 3, i + 1).join(''))\n    } else {\n      result += hexlookup(binarystring.slice(0, i + 1).join(''))\n    }\n  }\n  return result.split('').reverse().join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 十六进制转二进制\n\nconst binlookup = (key) => ({\n  0: '0000',\n  1: '0001',\n  2: '0010',\n  3: '0011',\n  4: '0100',\n  5: '0101',\n  6: '0110',\n  7: '0111',\n  8: '1000',\n  9: '1001',\n  a: '1010',\n  b: '1011',\n  c: '1100',\n  d: '1101',\n  e: '1110',\n  f: '1111'\n}[key.tolowercase()]) // select the binary number by valid hex key with the help javascript object\n\nconst hextobinary = (hexstring) => {\n  if (typeof hexstring !== 'string') {\n    throw new typeerror('argument is not a string type')\n  }\n\n  if (/[^\\da-f]/gi.test(hexstring)) {\n    throw new error('argument is not a valid hex code!')\n  }\n  /*\n    function for converting hex to binary\n\n    1. we convert every hexadecimal bit to 4 binary bits\n    2. conversion goes by searching in the lookup table\n  */\n\n  return hexstring.replace(\n    /[0-9a-f]/gi,\n    lexeme => binlookup(lexeme)\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 十进制转十六进制\n\nfunction inttohex (num) {\n  switch (num) {\n    case 10: return 'a'\n    case 11: return 'b'\n    case 12: return 'c'\n    case 13: return 'd'\n    case 14: return 'e'\n    case 15: return 'f'\n  }\n  return num\n}\n\nfunction decimaltohex (num) {\n  const hexout = []\n  while (num > 15) {\n    hexout.unshift(inttohex(num % 16))\n    num = math.floor(num / 16)\n  }\n  return inttohex(num) + hexout.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 十六进制转十进制\n\nfunction hextoint (hexnum) {\n  const numarr = hexnum.split('') // converts number to array\n  return numarr.map((item, index) => {\n    switch (item) {\n      case 'a': return 10\n      case 'b': return 11\n      case 'c': return 12\n      case 'd': return 13\n      case 'e': return 14\n      case 'f': return 15\n      default: return parseint(item)\n    }\n  })\n}\n\nfunction hextodecimal (hexnum) {\n  const intitemsarr = hextoint(hexnum)\n  return intitemsarr.reduce((accumulator, current, index) => {\n    return accumulator + (current * math.pow(16, (intitemsarr.length - (1 + index))))\n  }, 0)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 十进制转八进制\n\nfunction decimaltooctal (num) {\n  let oct = 0\n  let c = 0\n  while (num > 0) {\n    const r = num % 8\n    oct = oct + (r * math.pow(10, c++))\n    num = math.floor(num / 8) // basically /= 8 without remainder if any\n  }\n  return oct\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 八进制转十进制\n\nfunction octaltodecimal (num) {\n  let dec = 0\n  let base = 1\n  while (num > 0) {\n    const r = num % 10\n    num = math.floor(num / 10)\n    dec = dec + (r * base)\n    base = base * 8\n  }\n  return dec\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 十进制转罗马数字\n\n/*\n    decimal to roman\n\n    this algorithm take decimal number and convert to roman numeral according to standard form (https://en.wikipedia.org/wiki/roman_numerals#description)\n\n    algorithm & explanation : https://www.rapidtables.com/convert/number/how-number-to-roman-numerals.html\n*/\n\nconst values = {\n  m: 1000,\n  cm: 900,\n  d: 500,\n  cd: 400,\n  c: 100,\n  xc: 90,\n  l: 50,\n  xl: 40,\n  x: 10,\n  ix: 9,\n  v: 5,\n  iv: 4,\n  i: 1\n}\n\nconst orders = [\n  'm',\n  'cm',\n  'd',\n  'cd',\n  'c',\n  'xc',\n  'l',\n  'xl',\n  'x',\n  'ix',\n  'v',\n  'iv',\n  'i'\n]\n\nfunction decimaltoroman (num) {\n  let roman = ''\n  for (const symbol of orders) {\n    while (num >= values[symbol]) {\n      roman += symbol\n      num -= values[symbol]\n    }\n  }\n  return roman\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 罗马数字转十进制\n\nconst values = {\n  i: 1,\n  v: 5,\n  x: 10,\n  l: 50,\n  c: 100,\n  d: 500,\n  m: 1000\n}\n\nfunction romantodecimal (romannumber) {\n  let prev = ' '\n\n  let sum = 0\n\n  let newprev = 0\n  for (let i = romannumber.length - 1; i >= 0; i--) {\n    const c = romannumber.charat(i)\n\n    if (prev !== ' ') {\n      newprev = values[prev] > newprev ? values[prev] : newprev\n    }\n\n    const currentnum = values[c]\n    if (currentnum >= newprev) {\n      sum += currentnum\n    } else {\n      sum -= currentnum\n    }\n\n    prev = c\n  }\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 颜色：十六进制和 rgb 相互转化\n\nfunction hexstringtorgb (hexstring) {\n  let r = hexstring.substring(0, 2)\n  let g = hexstring.substring(2, 4)\n  let b = hexstring.substring(4, 6)\n\n  r = parseint(r, 16)\n  g = parseint(g, 16)\n  b = parseint(b, 16)\n  const obj = { r, g, b }\n\n  return obj\n}\n\nfunction rgbtohex (r, g, b) {\n  if (\n    typeof r !== 'number' ||\n    typeof g !== 'number' ||\n    typeof b !== 'number'\n  ) {\n    throw new typeerror('argument is not a number')\n  }\n\n  const tohex = n => (n || '0').tostring(16).padstart(2, '0')\n\n  return `#${tohex(r)}${tohex(g)}${tohex(b)}`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 颜色：hsv 和 rgb 相互转化\n\n/*\n * the rgb color model is an additive color model in which red, green, and blue light are added\n * together in various ways to reproduce a broad array of colors. the name of the model comes from\n * the initials of the three additive primary colors, red, green, and blue. meanwhile, the hsv\n * representation models how colors appear under light. in it, colors are represented using three\n * components: hue, saturation and (brightness-)value. this file provides functions for converting\n * colors from one representation to the other. (description adapted from\n * https://en.wikipedia.org/wiki/rgb_color_model and https://en.wikipedia.org/wiki/hsl_and_hsv).\n */\n\n/**\n * conversion from the hsv-representation to the rgb-representation.\n *\n * @param hue hue of the color.\n * @param saturation saturation of the color.\n * @param value brightness-value of the color.\n * @return the tuple of rgb-components.\n */\nfunction hsvtorgb (hue, saturation, value) {\n  if (hue < 0 || hue > 360) {\n    throw new error('hue should be between 0 and 360')\n  }\n\n  if (saturation < 0 || saturation > 1) {\n    throw new error('saturation should be between 0 and 1')\n  }\n\n  if (value < 0 || value > 1) {\n    throw new error('value should be between 0 and 1')\n  }\n\n  const chroma = value * saturation\n  const huesection = hue / 60\n  const secondlargestcomponent = chroma * (1 - math.abs(huesection % 2 - 1))\n  const matchvalue = value - chroma\n\n  return getrgbbysection(huesection, chroma, matchvalue, secondlargestcomponent)\n}\n\n/**\n * conversion from the rgb-representation to the hsv-representation.\n *\n * @param red red-component of the color.\n * @param green green-component of the color.\n * @param blue blue-component of the color.\n * @return the tuple of hsv-components.\n */\nfunction rgbtohsv (red, green, blue) {\n  if (red < 0 || red > 255) {\n    throw new error('red should be between 0 and 255')\n  }\n\n  if (green < 0 || green > 255) {\n    throw new error('green should be between 0 and 255')\n  }\n\n  if (blue < 0 || blue > 255) {\n    throw new error('blue should be between 0 and 255')\n  }\n\n  const dred = red / 255\n  const dgreen = green / 255\n  const dblue = blue / 255\n  const value = math.max(math.max(dred, dgreen), dblue)\n  const chroma = value - math.min(math.min(dred, dgreen), dblue)\n  const saturation = value === 0 ? 0 : chroma / value\n  let hue\n\n  if (chroma === 0) {\n    hue = 0\n  } else if (value === dred) {\n    hue = 60 * ((dgreen - dblue) / chroma)\n  } else if (value === dgreen) {\n    hue = 60 * (2 + (dblue - dred) / chroma)\n  } else {\n    hue = 60 * (4 + (dred - dgreen) / chroma)\n  }\n\n  hue = (hue + 360) % 360\n\n  return [hue, saturation, value]\n}\n\nexport function approximatelyequalhsv (hsv1, hsv2) {\n  const bhue = math.abs(hsv1[0] - hsv2[0]) < 0.2\n  const bsaturation = math.abs(hsv1[1] - hsv2[1]) < 0.002\n  const bvalue = math.abs(hsv1[2] - hsv2[2]) < 0.002\n\n  return bhue && bsaturation && bvalue\n}\n\nfunction getrgbbysection (huesection, chroma, matchvalue, secondlargestcomponent) {\n  function converttoint (input) {\n    return math.round(255 * input)\n  }\n\n  let red\n  let green\n  let blue\n\n  if (huesection >= 0 && huesection <= 1) {\n    red = converttoint(chroma + matchvalue)\n    green = converttoint(secondlargestcomponent + matchvalue)\n    blue = converttoint(matchvalue)\n  } else if (huesection > 1 && huesection <= 2) {\n    red = converttoint(secondlargestcomponent + matchvalue)\n    green = converttoint(chroma + matchvalue)\n    blue = converttoint(matchvalue)\n  } else if (huesection > 2 && huesection <= 3) {\n    red = converttoint(matchvalue)\n    green = converttoint(chroma + matchvalue)\n    blue = converttoint(secondlargestcomponent + matchvalue)\n  } else if (huesection > 3 && huesection <= 4) {\n    red = converttoint(matchvalue)\n    green = converttoint(secondlargestcomponent + matchvalue)\n    blue = converttoint(chroma + matchvalue)\n  } else if (huesection > 4 && huesection <= 5) {\n    red = converttoint(secondlargestcomponent + matchvalue)\n    green = converttoint(matchvalue)\n    blue = converttoint(chroma + matchvalue)\n  } else {\n    red = converttoint(chroma + matchvalue)\n    green = converttoint(matchvalue)\n    blue = converttoint(secondlargestcomponent + matchvalue)\n  }\n\n  return [red, green, blue]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n\n\n# 任意字符串转大写或者小写\n\n/*\n    explanation :- a user gives a string (it can be incomplete uppercase or\n        partial uppercase) and then the program would convert it into a\n        complete(all characters in lower case) lower case string. the\n        logic we have used in the following program is: all the upper case\n        characters (a-z) has ascii value ranging from 65 to 90 and their\n        corresponding lower case characters (a-z) have ascii values 32\n        greater than them. for example ‘a‘ has an ascii value of 65\n        and ‘a‘ has an ascii value of 97 (65+32). the same applies to other\n        characters.\n*/\n\n/**\n * lowercaseconversion takes any case-style string and converts it to the lower case-style string.\n * @param {string} inputstring any case style string\n * @returns {string} lower case string\n */\nconst lowercaseconversion = (inputstring) => {\n  // take a string and split it into characters.\n  const newstring = inputstring.split('').map(char => {\n    // get a character code by the use charcodeat method.\n    const presentcharcode = char.charcodeat()\n    // if the character code lies between 65 to 90 it means they are in the upper case so convert it.\n    if (presentcharcode >= 65 && presentcharcode <= 90) {\n      // convert the case by use of the above explanation.\n      return string.fromcharcode(presentcharcode + 32)\n    }\n    // else return the characters without any modification.\n    return char\n  })\n  // after modification, with the help of the join method, join all the characters and return them.\n  return newstring.join('')\n}\n\n/*\n    explanation :- a user gives a string (it can be incomplete lowercase or\n        partially in lowercase) and then the program converts it into a\n        completely (all characters in uppercase) uppercase string. the\n        logic we have used in the following program is: all the lowercase\n        characters (a-z) has [ascii](https://en.wikipedia.org/wiki/ascii) value ranging from 97 to 122 and their\n        corresponding uppercase characters (a-z) have ascii values 32\n        lesser than them. for example ‘a‘ has an ascii value of 97\n        and ‘a‘ has an ascii value of 65 (97 - 32). the same applies to other\n        characters.\n*/\n\n/**\n * uppercaseconversion takes any case-style string and converts it to the uppercase-style string.\n * @param {string} inputstring any case style string\n * @returns {string} uppercase string\n */\nconst uppercaseconversion = (inputstring) => {\n  // take a string and split it into characters.\n  const newstring = inputstring.split('').map(char => {\n    // get a character code by the use charcodeat method.\n    const presentcharcode = char.charcodeat()\n    // if the character code lies between 97 to 122, it means they are in the lowercase so convert it.\n    if (presentcharcode >= 97 && presentcharcode <= 122) {\n      // convert the case by use of the above explanation.\n      return string.fromcharcode(presentcharcode - 32)\n    }\n    // else return the characters without any modification.\n    return char\n  })\n  // after modification, with the help of the join method, join all the characters and return them.\n  return newstring.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# 英尺和米的转换\n\n// foot: https://en.wikipedia.org/wiki/foot_(unit)\nconst feettometer = (feet) => {\n  return feet * 0.3048\n}\n\nconst metertofeet = (meter) => {\n  return meter / 0.3048\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 标准格式时间转 railway 格式时间\n\n/*\n    the time conversion of normalized time to the railway is a simple algorithm\n    because we know that if the time is in 'am' value it means they only want\n    some changes on hours and minutes and if the time in 'pm' it means the only\n    want some changes in hour value.\n\n    input format -> 07:05:45pm\n    output format -> 19:05:45\n\n    problem & explanation source : https://www.mathsisfun.com/time.html\n*/\n\n/**\n * railwaytimeconversion method converts normalized time string to railway time string.\n * @param {string} timestring normalized time string.\n * @returns {string} railway time string.\n */\nconst railwaytimeconversion = (timestring) => {\n  // firstly, check that input is a string or not.\n  if (typeof timestring !== 'string') {\n    return new typeerror('argument is not a string.')\n  }\n  // split the string by ':' character.\n  const [hour, minute, scondwithshift] = timestring.split(':')\n  // split second and shift value.\n  const [second, shift] = [scondwithshift.substr(0, 2), scondwithshift.substr(2)]\n  // convert shifted time to not-shift time(railway time) by using the above explanation.\n  if (shift === 'pm') {\n    if (parseint(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseint(hour) + 12}:${minute}:${second}` }\n  } else {\n    if (parseint(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 温度计量相互转换\n\n// this files has functions to convert different temperature units\n// functions take temperature value as a argument and returns corresponding converted value\n\nconst celsiustofahrenheit = (celsius) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/celsius\n  // wikipedia reference: https://en.wikipedia.org/wiki/fahrenheit\n  return math.round(((celsius) * 9 / 5) + 32)\n}\n\nconst celsiustokelvin = (celsius) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/celsius\n  // wikipedia reference: https://en.wikipedia.org/wiki/kelvin\n  return math.round((celsius) + 273.15)\n}\n\nconst celsiustorankine = (celsius) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/celsius\n  // wikipedia reference: https://en.wikipedia.org/wiki/rankine_scale\n  return math.round(((celsius) * 9 / 5) + 491.67)\n}\n\nconst fahrenheittocelsius = (fahrenheit) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/fahrenheit\n  // wikipedia reference: https://en.wikipedia.org/wiki/celsius\n  return math.round(((fahrenheit) - 32) * 5 / 9)\n}\n\nconst fahrenheittokelvin = (fahrenheit) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/fahrenheit\n  // wikipedia reference: https://en.wikipedia.org/wiki/kelvin\n  return math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)\n}\n\nconst fahrenheittorankine = (fahrenheit) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/fahrenheit\n  // wikipedia reference: https://en.wikipedia.org/wiki/rankine_scale\n  return math.round((fahrenheit) + 459.67)\n}\n\nconst kelvintocelsius = (kelvin) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/kelvin\n  // wikipedia reference: https://en.wikipedia.org/wiki/celsius\n  return math.round((kelvin) - 273.15)\n}\n\nconst kelvintofahrenheit = (kelvin) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/kelvin\n  // wikipedia reference: https://en.wikipedia.org/wiki/fahrenheit\n  return math.round((((kelvin) - 273.15) * 9 / 5) + 32)\n}\n\nconst kelvintorankine = (kelvin) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/kelvin\n  // wikipedia reference: https://en.wikipedia.org/wiki/rankine_scale\n  return math.round(((kelvin) * 9 / 5))\n}\n\nconst rankinetocelsius = (rankine) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/rankine_scale\n  // wikipedia reference: https://en.wikipedia.org/wiki/celsius\n  return math.round(((rankine) - 491.67) * 5 / 9)\n}\n\nconst rankinetofahrenheit = (rankine) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/rankine_scale\n  // wikipedia reference: https://en.wikipedia.org/wiki/fahrenheit\n  return math.round((rankine) - 459.67)\n}\n\nconst rankinetokelvin = (rankine) => {\n  // wikipedia reference: https://en.wikipedia.org/wiki/rankine_scale\n  // wikipedia reference: https://en.wikipedia.org/wiki/kelvin\n  return math.round(((rankine) * 5 / 9))\n}\n\nconst reaumurtokelvin = (reaumur) => {\n  // reference:- http://www.csgnetwork.com/temp2conv.html\n  return math.round(((reaumur) * 1.25 + 273.15))\n}\n\nconst reaumurtofahrenheit = (reaumur) => {\n  // reference:- http://www.csgnetwork.com/temp2conv.html\n  return math.round(((reaumur) * 2.25 + 32))\n}\n\nconst reaumurtocelsius = (reaumur) => {\n  // reference:- http://www.csgnetwork.com/temp2conv.html\n  return math.round(((reaumur) * 1.25))\n}\n\nconst reaumurtorankine = (reaumur) => {\n  // reference:- http://www.csgnetwork.com/temp2conv.html\n  return math.round(((reaumur) * 2.25 + 32 + 459.67))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n# 字符串转 title case\n\n/*\n    problem statement and explanation : https://www.codeproject.com/tips/162540/letter-case-conversion-algorithms-title-case-toggl.\n    [title case](https://en.wikipedia.org/wiki/title_case) is a style where all words are capitalized. officially, title case\n    does not capitalize some words, such as very short words like \"a\" or \"is\", but for the purposes of this function, a general approach\n    is taken where all words are capitalized regardless of length.\n*/\n\n/**\n * the titlecaseconversion function converts a string into a title case string.\n * @param {string} inputstring the input string which can have any types of letter casing.\n * @returns {string} a string that is in title case.\n */\nconst titlecaseconversion = (inputstring) => {\n  if (inputstring === '') return ''\n  // extract all space separated string.\n  const stringcollections = inputstring.split(' ').map(word => {\n    let firstchar = ''\n    // get the [ascii](https://en.wikipedia.org/wiki/ascii) character code by the use charcodeat method.\n    const firstcharcode = word[0].charcodeat()\n    // if the ascii character code lies between 97 to 122 it means they are in the lowercase so convert it.\n    if (firstcharcode >= 97 && firstcharcode <= 122) {\n      // convert the case by use of the above explanation.\n      firstchar += string.fromcharcode(firstcharcode - 32)\n    } else {\n      // else store the characters without any modification.\n      firstchar += word[0]\n    }\n    const newwordchar = word.slice(1).split('').map(char => {\n      // get the ascii character code by the use charcodeat method.\n      const presentcharcode = char.charcodeat()\n      // if the ascii character code lies between 65 to 90, it means they are in the uppercase so convert it.\n      if (presentcharcode >= 65 && presentcharcode <= 90) {\n        // convert the case by use of the above explanation.\n        return string.fromcharcode(presentcharcode + 32)\n      }\n      // else return the characters without any modification.\n      return char\n    })\n    // return the first converted character and remaining character string.\n    return firstchar + newwordchar.join('')\n  })\n  // convert all words in a string and return it.\n  return stringcollections.join(' ')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"欧拉计划",frontmatter:{title:"欧拉计划",date:"2022-10-28T16:30:11.000Z",permalink:"/algorithm/euler/index/",categories:["算法","ProjectEuler 欧拉计划"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/160.ProjectEuler%20%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/0.index.html",relativePath:"20.算法/160.ProjectEuler 欧拉计划/0.index.md",key:"v-d30cf890",path:"/algorithm/euler/index/",headers:[{level:2,title:"欧拉计划",slug:"欧拉计划",normalizedTitle:"欧拉计划",charIndex:2},{level:2,title:"什么是欧拉项目？",slug:"什么是欧拉项目",normalizedTitle:"什么是欧拉项目？",charIndex:265},{level:2,title:"这些问题的对象是谁？",slug:"这些问题的对象是谁",normalizedTitle:"这些问题的对象是谁？",charIndex:425},{level:2,title:"任何人都能解决这些问题吗？",slug:"任何人都能解决这些问题吗",normalizedTitle:"任何人都能解决这些问题吗？",charIndex:515},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:637}],headersStr:"欧拉计划 什么是欧拉项目？ 这些问题的对象是谁？ 任何人都能解决这些问题吗？ 参考",content:'# 欧拉计划\n\n欧拉计划（Project Euler）是一个解题网站，站内提供了一系列数学题供用户解答，解题的用户主要是对数学和计算机编程感兴趣的成年人及学生。其主旨为鼓励、挑战和培养爱好数学的人的技能和乐趣。每一题都可以通过计算机程序在 1 分钟内求出结果。该网站自 2001 年起定期增加新的题目，每题都有对应的讨论区，只有注册用户在正确提交了这题的答案后才能进入。网站设立了 6 个排行榜，其中的欧拉人（Eulerians）排行榜的分数需要最新题目的前 50 位解答者才能获得。欧拉计划不希望在站外分享题目的答案。\n\n\n# 什么是欧拉项目？\n\n欧拉项目是一系列具有挑战性的数学 / 计算机编程问题，需要的不仅仅是数学上的洞察力。尽管数学将帮助你找到优雅和有效的方法，但要解决大多数问题，还需要使用计算机和编程技巧。\n\n启动 "欧拉项目" 及其延续的动机是为探究者提供一个平台，让他们深入到不熟悉的领域，在有趣和娱乐的背景下学习新概念。\n\n\n# 这些问题的对象是谁？\n\n目标受众包括那些基础课程无法满足其学习欲望的学生，那些背景主要不是数学但对数学事物有兴趣的成年人，以及那些希望保持其问题解决和数学前沿的专业人士。\n\n\n# 任何人都能解决这些问题吗？\n\n这些问题的难度各不相同，对许多人来说，经验是归纳性的连续学习。也就是说，通过解决一个问题，你会接触到一个新的概念，使你能够思考一个以前未曾接触到的问题。因此，有决心的参与者会慢慢地但肯定地通过每一个问题。\n\n\n# 参考\n\n * Archived Problems - Project Euler\n * 欧拉计划 - Wikiwand',normalizedContent:'# 欧拉计划\n\n欧拉计划（project euler）是一个解题网站，站内提供了一系列数学题供用户解答，解题的用户主要是对数学和计算机编程感兴趣的成年人及学生。其主旨为鼓励、挑战和培养爱好数学的人的技能和乐趣。每一题都可以通过计算机程序在 1 分钟内求出结果。该网站自 2001 年起定期增加新的题目，每题都有对应的讨论区，只有注册用户在正确提交了这题的答案后才能进入。网站设立了 6 个排行榜，其中的欧拉人（eulerians）排行榜的分数需要最新题目的前 50 位解答者才能获得。欧拉计划不希望在站外分享题目的答案。\n\n\n# 什么是欧拉项目？\n\n欧拉项目是一系列具有挑战性的数学 / 计算机编程问题，需要的不仅仅是数学上的洞察力。尽管数学将帮助你找到优雅和有效的方法，但要解决大多数问题，还需要使用计算机和编程技巧。\n\n启动 "欧拉项目" 及其延续的动机是为探究者提供一个平台，让他们深入到不熟悉的领域，在有趣和娱乐的背景下学习新概念。\n\n\n# 这些问题的对象是谁？\n\n目标受众包括那些基础课程无法满足其学习欲望的学生，那些背景主要不是数学但对数学事物有兴趣的成年人，以及那些希望保持其问题解决和数学前沿的专业人士。\n\n\n# 任何人都能解决这些问题吗？\n\n这些问题的难度各不相同，对许多人来说，经验是归纳性的连续学习。也就是说，通过解决一个问题，你会接触到一个新的概念，使你能够思考一个以前未曾接触到的问题。因此，有决心的参与者会慢慢地但肯定地通过每一个问题。\n\n\n# 参考\n\n * archived problems - project euler\n * 欧拉计划 - wikiwand',charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"BinarySearch [二分搜索]",frontmatter:{title:"BinarySearch [二分搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/binarySearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/10.BinarySearch.html",relativePath:"20.算法/20.Search 搜索/10.BinarySearch.md",key:"v-59830d4b",path:"/algorithm/search/binarySearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:502},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:642},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:880},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:887},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:894},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2746}],headersStr:"介绍 原理 复杂度 动画 实现 JavaScript 参考",content:"# 介绍\n\n在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管一些特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。\n\n二分查找算法有许多种变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索的速度。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分查找算法拓宽到无边界的列表。二叉搜索树和 B 树数据结构就是基于二分查找算法的。\n\n\n# 原理\n\n二分搜索只对有序数组有效。二分搜索先比较数组中比特素和目标值。如果目标值与中比特素相等，则返回其在数组中的位置；如果目标值小于中比特素，则搜索继续在前半部分的数组中进行。如果目标值大于中比特素，则搜索继续在数组上部分进行。由此，算法每次排除掉至少一半的待查数组。\n\n\n# 复杂度\n\n * 平均时间复杂度：O(log⁡n){\\displaystyle O(\\log n)}O(logn)\n * 最坏时间复杂度：O(log⁡n){\\displaystyle O(\\log n)}O(logn)\n * 最优时间复杂度：O(1){\\displaystyle O(1)}O(1)\n * 空间复杂度：迭代：O(1){\\displaystyle O(1)}O(1)；递归：O(log⁡n){\\displaystyle O(\\log n)}O(logn)\n\n\n# 动画\n\n\n# 实现\n\n\n# JavaScript\n\n/* Binary Search: https://en.wikipedia.org/wiki/Binary_search_algorithm\n *\n * Search a sorted array by repeatedly dividing the search interval\n * in half. Begin with an interval covering the whole array. If the value of the\n * search key is less than the item in the middle of the interval, narrow the interval\n * to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the\n * value is found or the interval is empty.\n */\n\nfunction binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {\n  const mid = Math.floor(low + (high - low) / 2)\n\n  if (high >= low) {\n    if (arr[mid] === x) {\n      // item found => return its index\n      return mid\n    }\n\n    if (x < arr[mid]) {\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\n      return binarySearchRecursive(arr, x, low, mid - 1)\n    } else {\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\n      return binarySearchRecursive(arr, x, mid + 1, high)\n    }\n  } else {\n    // if low > high => we have searched the whole array without finding the item\n    return -1\n  }\n}\nfunction binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {\n  while (high >= low) {\n    const mid = Math.floor(low + (high - low) / 2)\n\n    if (arr[mid] === x) {\n      // item found => return its index\n      return mid\n    }\n\n    if (x < arr[mid]) {\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\n      high = mid - 1\n    } else {\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\n      low = mid + 1\n    }\n  }\n  // if low > high => we have searched the whole array without finding the item\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 参考\n\n * 二分查找算法 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n\n除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管一些特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。\n\n二分查找算法有许多种变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索的速度。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分查找算法拓宽到无边界的列表。二叉搜索树和 b 树数据结构就是基于二分查找算法的。\n\n\n# 原理\n\n二分搜索只对有序数组有效。二分搜索先比较数组中比特素和目标值。如果目标值与中比特素相等，则返回其在数组中的位置；如果目标值小于中比特素，则搜索继续在前半部分的数组中进行。如果目标值大于中比特素，则搜索继续在数组上部分进行。由此，算法每次排除掉至少一半的待查数组。\n\n\n# 复杂度\n\n * 平均时间复杂度：o(log⁡n){\\displaystyle o(\\log n)}o(logn)\n * 最坏时间复杂度：o(log⁡n){\\displaystyle o(\\log n)}o(logn)\n * 最优时间复杂度：o(1){\\displaystyle o(1)}o(1)\n * 空间复杂度：迭代：o(1){\\displaystyle o(1)}o(1)；递归：o(log⁡n){\\displaystyle o(\\log n)}o(logn)\n\n\n# 动画\n\n\n# 实现\n\n\n# javascript\n\n/* binary search: https://en.wikipedia.org/wiki/binary_search_algorithm\n *\n * search a sorted array by repeatedly dividing the search interval\n * in half. begin with an interval covering the whole array. if the value of the\n * search key is less than the item in the middle of the interval, narrow the interval\n * to the lower half. otherwise narrow it to the upper half. repeatedly check until the\n * value is found or the interval is empty.\n */\n\nfunction binarysearchrecursive (arr, x, low = 0, high = arr.length - 1) {\n  const mid = math.floor(low + (high - low) / 2)\n\n  if (high >= low) {\n    if (arr[mid] === x) {\n      // item found => return its index\n      return mid\n    }\n\n    if (x < arr[mid]) {\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\n      return binarysearchrecursive(arr, x, low, mid - 1)\n    } else {\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\n      return binarysearchrecursive(arr, x, mid + 1, high)\n    }\n  } else {\n    // if low > high => we have searched the whole array without finding the item\n    return -1\n  }\n}\nfunction binarysearchiterative (arr, x, low = 0, high = arr.length - 1) {\n  while (high >= low) {\n    const mid = math.floor(low + (high - low) / 2)\n\n    if (arr[mid] === x) {\n      // item found => return its index\n      return mid\n    }\n\n    if (x < arr[mid]) {\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\n      high = mid - 1\n    } else {\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\n      low = mid + 1\n    }\n  }\n  // if low > high => we have searched the whole array without finding the item\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 参考\n\n * 二分查找算法 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/10, 21:03:42",lastUpdatedTimestamp:1665407022e3},{title:"TernarySearch [三元搜索]",frontmatter:{title:"TernarySearch [三元搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/ternarySearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/100.TernarySearch.html",relativePath:"20.算法/20.Search 搜索/100.TernarySearch.md",key:"v-5dd047ef",path:"/algorithm/search/ternarySearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:136},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:374},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:381},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3501}],headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\n三元搜索算法是计算机科学中用于查找 单峰函数 的最小值或最大值的一种技术。三元搜索确定最小值或最大值不能在域的前三分之一或不能在域的后三分之一，然后在剩余的三分之二上重复。三元搜索是分治算法的一个示例。\n\n注意：数组需要进行排序才能对其进行三元搜索。\n\n\n# 原理\n\n执行三元搜索的步骤：\n\n\n\n * 首先，我们将 key 与 mid1 的元素进行比较。如果发现相等，我们返回 mid1。\n * 如果不是，那么我们将 key 与 mid2 的元素进行比较。如果发现相等，我们返回 mid2。\n * 如果不是，那么我们检查 key 是否小于 mid1 的元素。如果是，则重复第一部分。\n * 如果不是，那么我们检查 key 是否大于 mid2 处的元素。如果是，则重复到第三部分。\n * 如果不是，那么我们回到第二（中间）部分。\n\n\n# 实现\n\n\n# JavaScript\n\n/* Ternary search is similar to binary search but it divide the sorted array\n * into three parts and determine which part the key lies in. The array will\n * be divided into three intervals by using two middle points, mid1 and mid2.\n * The value of the key will first compared with the two mid points, the value\n * will be returned if there is a match. Then, if the value of the key is less\n * than mid1, narrow the interval to the first part. Else, if the value of the\n * key is greater than mid2, narrow the interval to the third part. Otherwise,\n * narrow the interval to the middle part. Repeat the steps until the value is\n * found or the interval is empty(value not found after checking all elements).\n *\n * Reference: https://www.geeksforgeeks.org/ternary-search/\n */\n\nfunction ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {\n  if (high >= low) {\n    // find thmid1e mid1 and mid2\n    const  = Math.floor(low + (high - low) / 3)\n    const mid2 = Math.floor(high - (high - low) / 3)\n\n    // check if key is found at any mid\n    if (arr[mid1] === key) {\n      // return index of key if found\n      return mid1\n    }\n    if (arr[mid2] === key) {\n      // return index of key if found\n      return mid2\n    }\n\n    // since the key is not found at mid,\n    // check in which region it is present\n    // and repeat the Search operation\n    // in that region\n    if (key < arr[mid1]) {\n      // the key lies in between low and mid1\n      return ternarySearchRecursive(arr, key, low, mid1 - 1)\n    } else if (key > arr[mid2]) {\n      // the key lies in between mid2 and high\n      return ternarySearchRecursive(arr, key, mid2 + 1, high)\n    } else {\n      // the key lies in between mid1 and mid2\n      return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)\n    }\n  } else {\n    // if low > high => we have searched the whole array without finding the item\n    return -1\n  }\n}\n\nfunction ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {\n  while (high >= low) {\n    // find the mid1 and mid2\n    const mid1 = Math.floor(low + (high - low) / 3)\n    const mid2 = Math.floor(high - (high - low) / 3)\n\n    // check if key is found at any mid\n    if (arr[mid1] === key) {\n      // return index of key if found\n      return mid1\n    }\n    if (arr[mid2] === key) {\n      // return index of key if found\n      return mid2\n    }\n\n    // since the key is not found at mid,\n    // check in which region it is present\n    // and repeat the Search operation\n    // in that region\n    if (key < arr[mid1]) {\n      // the key lies in between low and mid1\n      high = mid1 - 1\n    } else if (key > arr[mid2]) {\n      // the key lies in between mid2 and high\n      low = mid2 + 1\n    } else {\n      // the key lies in between mid1 and mid2\n      low = mid1 + 1\n      high = mid2 - 1\n    }\n  }\n  // the key was not found\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# 参考\n\n * Ternary search - Wikipedia\n * Ternary Search - GeeksforGeeks",normalizedContent:"# 介绍\n\n三元搜索算法是计算机科学中用于查找 单峰函数 的最小值或最大值的一种技术。三元搜索确定最小值或最大值不能在域的前三分之一或不能在域的后三分之一，然后在剩余的三分之二上重复。三元搜索是分治算法的一个示例。\n\n注意：数组需要进行排序才能对其进行三元搜索。\n\n\n# 原理\n\n执行三元搜索的步骤：\n\n\n\n * 首先，我们将 key 与 mid1 的元素进行比较。如果发现相等，我们返回 mid1。\n * 如果不是，那么我们将 key 与 mid2 的元素进行比较。如果发现相等，我们返回 mid2。\n * 如果不是，那么我们检查 key 是否小于 mid1 的元素。如果是，则重复第一部分。\n * 如果不是，那么我们检查 key 是否大于 mid2 处的元素。如果是，则重复到第三部分。\n * 如果不是，那么我们回到第二（中间）部分。\n\n\n# 实现\n\n\n# javascript\n\n/* ternary search is similar to binary search but it divide the sorted array\n * into three parts and determine which part the key lies in. the array will\n * be divided into three intervals by using two middle points, mid1 and mid2.\n * the value of the key will first compared with the two mid points, the value\n * will be returned if there is a match. then, if the value of the key is less\n * than mid1, narrow the interval to the first part. else, if the value of the\n * key is greater than mid2, narrow the interval to the third part. otherwise,\n * narrow the interval to the middle part. repeat the steps until the value is\n * found or the interval is empty(value not found after checking all elements).\n *\n * reference: https://www.geeksforgeeks.org/ternary-search/\n */\n\nfunction ternarysearchrecursive (arr, key, low = 0, high = arr.length - 1) {\n  if (high >= low) {\n    // find thmid1e mid1 and mid2\n    const  = math.floor(low + (high - low) / 3)\n    const mid2 = math.floor(high - (high - low) / 3)\n\n    // check if key is found at any mid\n    if (arr[mid1] === key) {\n      // return index of key if found\n      return mid1\n    }\n    if (arr[mid2] === key) {\n      // return index of key if found\n      return mid2\n    }\n\n    // since the key is not found at mid,\n    // check in which region it is present\n    // and repeat the search operation\n    // in that region\n    if (key < arr[mid1]) {\n      // the key lies in between low and mid1\n      return ternarysearchrecursive(arr, key, low, mid1 - 1)\n    } else if (key > arr[mid2]) {\n      // the key lies in between mid2 and high\n      return ternarysearchrecursive(arr, key, mid2 + 1, high)\n    } else {\n      // the key lies in between mid1 and mid2\n      return ternarysearchrecursive(arr, key, mid1 + 1, mid2 - 1)\n    }\n  } else {\n    // if low > high => we have searched the whole array without finding the item\n    return -1\n  }\n}\n\nfunction ternarysearchiterative (arr, key, low = 0, high = arr.length - 1) {\n  while (high >= low) {\n    // find the mid1 and mid2\n    const mid1 = math.floor(low + (high - low) / 3)\n    const mid2 = math.floor(high - (high - low) / 3)\n\n    // check if key is found at any mid\n    if (arr[mid1] === key) {\n      // return index of key if found\n      return mid1\n    }\n    if (arr[mid2] === key) {\n      // return index of key if found\n      return mid2\n    }\n\n    // since the key is not found at mid,\n    // check in which region it is present\n    // and repeat the search operation\n    // in that region\n    if (key < arr[mid1]) {\n      // the key lies in between low and mid1\n      high = mid1 - 1\n    } else if (key > arr[mid2]) {\n      // the key lies in between mid2 and high\n      low = mid2 + 1\n    } else {\n      // the key lies in between mid1 and mid2\n      low = mid1 + 1\n      high = mid2 - 1\n    }\n  }\n  // the key was not found\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# 参考\n\n * ternary search - wikipedia\n * ternary search - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"UnionSearch [合并搜索]",frontmatter:{title:"UnionSearch [合并搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/unionSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/110.UnionSearch.html",relativePath:"20.算法/20.Search 搜索/110.UnionSearch.md",key:"v-1bef17ee",path:"/algorithm/search/unionSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"并查集",slug:"并查集",normalizedTitle:"并查集",charIndex:9},{level:3,title:"Union Find",slug:"union-find",normalizedTitle:"union find",charIndex:349},{level:4,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:626},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:995},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1002},{level:3,title:"Python",slug:"python",normalizedTitle:"python",charIndex:4337},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5128}],headersStr:"介绍 并查集 Union Find 伪代码 实现 JavaScript Python 参考",content:"# 介绍\n\n\n# 并查集\n\n在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：\n\n查询：查询某个元素属于哪个集合，通常是返回集合内的一个 “代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。 合并：将两个集合合并为一个。 添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。 由于支持查询和合并这两种操作，并查集在英文中也被称为联合 - 查找数据结构（Union-find data structure）或者合并 - 查找集合（Merge-find set）。\n\n\n# Union Find\n\nUnion Find 算法用于处理 集合的合并和查询 问题，其定义了两个用于并查集的操作：\n\n * Find : 确定元素属于哪一个子集，判断两个元素是否属于同一子集（即，查找元素的 root，当两元素 root 相同时判定他们属于同一个子集）。\n * Union : 将两个子集合并为一个子集（即通过修改元素的 root 或 parent 来合并子集）。\n\n并查集是一种树形的数据结构，其可用数组或 unordered_map 表示，下面这个图很清晰的展示了并、查、集。摘自 UnionFind Algorithm。\n\n\n\n# 伪代码\n\n构造函数必须传入参数 n，即，已知 set 里面最多会有 n 个元素。\n\n每个元素（节点）都有一个 parent，假设最开始每个节点的 parent 都是其自身（1~n），也就是一个个独立的 cluster。相应的，rank 全部初始化为 0。\n\n我们定义两个 function：Find 和 Union。Find 作用是返回节点 x 的根节点，根节点就是从 x 往上沿着 parent 的路径一直找，直到某个节点它的 parent 就是自身，那么这个节点就是根节点。在 Find 的过程中顺便做了 path compression，也就是递归调用 Find 函数，对于沿途每个 parent 节点都执行 Find 来寻找它们的根节点，最终根节点逐级向下传递到，这些之前的所有 parent 节点也都会指向根节点。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * union find data structure for javascript\n *\n * In computer science, a disjoint-set【并查集】 data structure, also called a union–find data structure or merge–find set,\n * is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition\n * of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),\n * and finding a representative member of a set.\n * The last operation allows to find out efficiently if any two elements are in the same or different sets.\n *\n * Disjoint-set data structures play a key role in Kruskal's algorithm for finding the minimum spanning tree of a graph.\n * The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.\n * In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,\n * especially for register allocation problems.\n *\n * you can learn more on disjoint-set / union–find data structure at https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n */\nfunction UnionSearch (n, key) {\n  if (!(this instanceof UnionSearch)) return new UnionSearch(n)\n  if (key && typeof key !== 'function') {\n    throw new Error('key has to be a function or else left undefined')\n  }\n  let cnt, length\n  // init Union Find with number of distinct groups. Each group will be referred to as index of the array of size 'size' starting at 0.\n  // Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.\n  key = key || function (a) { return a }\n  cnt = length = n\n  const id = new Array(n)\n  const sz = new Array(n)\n  for (let i = 0; i < n; i++) {\n    id[i] = i\n    sz[i] = 1\n  }\n  // Returns the number of elements of uf object.\n  this.size = function () {\n    return length\n  }\n  // Returns the number of distinct groups left inside the object.\n  this.count = function () {\n    return cnt\n  }\n  // Return the root (value) of the group in which p is.\n  this.find = function (p) {\n    p = key(p)\n    while (p !== id[p]) {\n      id[p] = id[id[p]]\n      p = id[p]\n    }\n    return p\n  }\n  // Returns true if p and p are both in same group, false otherwise.\n  this.connected = function (p, q) {\n    p = key(p)\n    q = key(q)\n    ensureIndexWithinBounds(p, q)\n    return this.find(p) === this.find(q)\n  }\n  // Combine elements in groups p and q into a single group. In other words connect the two groups.\n  this.union = function (p, q) {\n    p = key(p)\n    q = key(q)\n    ensureIndexWithinBounds(p, q)\n    const i = this.find(p)\n    const j = this.find(q)\n    if (i === j) return\n    if (sz[i] < sz[j]) {\n      id[i] = j; sz[j] += sz[i]\n    } else {\n      id[j] = i; sz[i] += sz[j]\n    }\n    cnt--\n  }\n  function ensureIndexWithinBounds (args) {\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      const p = arguments[i]\n      if (p >= length) throw new Error('Index out of bounds. The maximum index can be length-1')\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# Python\n\nclass UnionFindSet:\n    def __init__(self, n):\n        self._parents = [i for i in range(n + 1)]\n        self._ranks = [1 for i in range(n + 1)]\n    \n    def find(self, u):\n        while u != self._parents[u]:\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n    \n    def union(self, u, v):\n        pu, pv = self.find(u), self.find(v)\n        if pu == pv: return False\n        \n        if self._ranks[pu] < self._ranks[pv]:\n            self._parents[pu] = pv\n        elif self._ranks[pu] > self._ranks[pv]:\n            self._parents[pv] = pu\n        else:        \n            self._parents[pv] = pu\n            self._ranks[pu] += 1\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考\n\n * 并查集 - 维基百科，自由的百科全书\n * [算法] 合并查找 (Union Find)",normalizedContent:"# 介绍\n\n\n# 并查集\n\n在计算机科学中，并查集（英文：disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：\n\n查询：查询某个元素属于哪个集合，通常是返回集合内的一个 “代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。 合并：将两个集合合并为一个。 添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。 由于支持查询和合并这两种操作，并查集在英文中也被称为联合 - 查找数据结构（union-find data structure）或者合并 - 查找集合（merge-find set）。\n\n\n# union find\n\nunion find 算法用于处理 集合的合并和查询 问题，其定义了两个用于并查集的操作：\n\n * find : 确定元素属于哪一个子集，判断两个元素是否属于同一子集（即，查找元素的 root，当两元素 root 相同时判定他们属于同一个子集）。\n * union : 将两个子集合并为一个子集（即通过修改元素的 root 或 parent 来合并子集）。\n\n并查集是一种树形的数据结构，其可用数组或 unordered_map 表示，下面这个图很清晰的展示了并、查、集。摘自 unionfind algorithm。\n\n\n\n# 伪代码\n\n构造函数必须传入参数 n，即，已知 set 里面最多会有 n 个元素。\n\n每个元素（节点）都有一个 parent，假设最开始每个节点的 parent 都是其自身（1~n），也就是一个个独立的 cluster。相应的，rank 全部初始化为 0。\n\n我们定义两个 function：find 和 union。find 作用是返回节点 x 的根节点，根节点就是从 x 往上沿着 parent 的路径一直找，直到某个节点它的 parent 就是自身，那么这个节点就是根节点。在 find 的过程中顺便做了 path compression，也就是递归调用 find 函数，对于沿途每个 parent 节点都执行 find 来寻找它们的根节点，最终根节点逐级向下传递到，这些之前的所有 parent 节点也都会指向根节点。\n\n\n\n\n# 实现\n\n\n# javascript\n\n/**\n * union find data structure for javascript\n *\n * in computer science, a disjoint-set【并查集】 data structure, also called a union–find data structure or merge–find set,\n * is a data structure that stores a collection of disjoint (non-overlapping) sets. equivalently, it stores a partition\n * of a set into disjoint subsets. it provides operations for adding new sets, merging sets (replacing them by their union),\n * and finding a representative member of a set.\n * the last operation allows to find out efficiently if any two elements are in the same or different sets.\n *\n * disjoint-set data structures play a key role in kruskal's algorithm for finding the minimum spanning tree of a graph.\n * the importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.\n * in addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,\n * especially for register allocation problems.\n *\n * you can learn more on disjoint-set / union–find data structure at https://en.wikipedia.org/wiki/disjoint-set_data_structure\n */\nfunction unionsearch (n, key) {\n  if (!(this instanceof unionsearch)) return new unionsearch(n)\n  if (key && typeof key !== 'function') {\n    throw new error('key has to be a function or else left undefined')\n  }\n  let cnt, length\n  // init union find with number of distinct groups. each group will be referred to as index of the array of size 'size' starting at 0.\n  // provide an optional key function that maps these indices. i.e. for the groups starting with 1 provide function(a){return a-1;}. the default value is function(a){return a;}.\n  key = key || function (a) { return a }\n  cnt = length = n\n  const id = new array(n)\n  const sz = new array(n)\n  for (let i = 0; i < n; i++) {\n    id[i] = i\n    sz[i] = 1\n  }\n  // returns the number of elements of uf object.\n  this.size = function () {\n    return length\n  }\n  // returns the number of distinct groups left inside the object.\n  this.count = function () {\n    return cnt\n  }\n  // return the root (value) of the group in which p is.\n  this.find = function (p) {\n    p = key(p)\n    while (p !== id[p]) {\n      id[p] = id[id[p]]\n      p = id[p]\n    }\n    return p\n  }\n  // returns true if p and p are both in same group, false otherwise.\n  this.connected = function (p, q) {\n    p = key(p)\n    q = key(q)\n    ensureindexwithinbounds(p, q)\n    return this.find(p) === this.find(q)\n  }\n  // combine elements in groups p and q into a single group. in other words connect the two groups.\n  this.union = function (p, q) {\n    p = key(p)\n    q = key(q)\n    ensureindexwithinbounds(p, q)\n    const i = this.find(p)\n    const j = this.find(q)\n    if (i === j) return\n    if (sz[i] < sz[j]) {\n      id[i] = j; sz[j] += sz[i]\n    } else {\n      id[j] = i; sz[i] += sz[j]\n    }\n    cnt--\n  }\n  function ensureindexwithinbounds (args) {\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      const p = arguments[i]\n      if (p >= length) throw new error('index out of bounds. the maximum index can be length-1')\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# python\n\nclass unionfindset:\n    def __init__(self, n):\n        self._parents = [i for i in range(n + 1)]\n        self._ranks = [1 for i in range(n + 1)]\n    \n    def find(self, u):\n        while u != self._parents[u]:\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n    \n    def union(self, u, v):\n        pu, pv = self.find(u), self.find(v)\n        if pu == pv: return false\n        \n        if self._ranks[pu] < self._ranks[pv]:\n            self._parents[pu] = pv\n        elif self._ranks[pu] > self._ranks[pv]:\n            self._parents[pv] = pu\n        else:        \n            self._parents[pv] = pu\n            self._ranks[pu] += 1\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考\n\n * 并查集 - 维基百科，自由的百科全书\n * [算法] 合并查找 (union find)",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"ExponentialSearch [指数搜索]",frontmatter:{title:"ExponentialSearch [指数搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/exponentialSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/20.ExponentialSearch.html",relativePath:"20.算法/20.Search 搜索/20.ExponentialSearch.md",key:"v-e75db5c2",path:"/algorithm/search/exponentialSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:84},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:242},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:436},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:443},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1809}],headersStr:"介绍 原理 复杂度 实现 JavaScript 参考",content:"# 介绍\n\n指数搜索用于通过跳跃指数位置（即 2 的幂）来搜索元素。试图找到一个相对较小的范围，在该范围内可使用其他有界搜索算法（例如二进制搜索）来搜索元素。\n\n\n# 原理\n\n试图找到一个比搜索的元素更大的元素，目的是为了最大程度地减少所需元素的范围。通过将其乘以 2 来增加范围，然后再次检查是否到达的元素大于要搜索的元素或数组的末尾。一旦达到这两个目的，便会跳出循环。然后，使用 startIndex range/2 和 lastIndex 执行二进制搜索 range。\n\n\n# 复杂度\n\n * 平均时间复杂度：O(log⁡i){\\displaystyle O(\\log i)}O(logi)\n * 最坏时间复杂度：O(log⁡i){\\displaystyle O(\\log i)}O(logi)\n * 最优时间复杂度：O(1){\\displaystyle O(1)}O(1)\n * 空间复杂度：迭代：O(1){\\displaystyle O(1)}O(1)\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Exponential Search\n *\n * The algorithm consists of two stages. The first stage determines a\n * range in which the search key would reside if it were in the list.\n * In the second stage, a binary search is performed on this range.\n */\n\nfunction binarySearch (arr, value, floor, ceiling) {\n  // Middle index\n  const mid = Math.floor((floor + ceiling) / 2)\n\n  // If value is at the mid position return this position\n  if (arr[mid] === value) {\n    return mid\n  }\n\n  if (floor > ceiling) return -1\n\n  // If the middle element is great than the value\n  // search the left part of the array\n  if (arr[mid] > value) {\n    return binarySearch(arr, value, floor, mid - 1)\n    // If the middle element is lower than the value\n    // search the right part of the array\n  } else {\n    return binarySearch(arr, value, mid + 1, ceiling)\n  }\n}\n\nfunction exponentialSearch (arr, length, value) {\n  // If value is the first element of the array return this position\n  if (arr[0] === value) {\n    return 0\n  }\n\n  // Find range for binary search\n  let i = 1\n  while (i < length && arr[i] <= value) {\n    i = i * 2\n  }\n\n  // Call binary search for the range found above\n  return binarySearch(arr, value, i / 2, Math.min(i, length))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 参考\n\n * Exponential search - Wikipedia",normalizedContent:"# 介绍\n\n指数搜索用于通过跳跃指数位置（即 2 的幂）来搜索元素。试图找到一个相对较小的范围，在该范围内可使用其他有界搜索算法（例如二进制搜索）来搜索元素。\n\n\n# 原理\n\n试图找到一个比搜索的元素更大的元素，目的是为了最大程度地减少所需元素的范围。通过将其乘以 2 来增加范围，然后再次检查是否到达的元素大于要搜索的元素或数组的末尾。一旦达到这两个目的，便会跳出循环。然后，使用 startindex range/2 和 lastindex 执行二进制搜索 range。\n\n\n# 复杂度\n\n * 平均时间复杂度：o(log⁡i){\\displaystyle o(\\log i)}o(logi)\n * 最坏时间复杂度：o(log⁡i){\\displaystyle o(\\log i)}o(logi)\n * 最优时间复杂度：o(1){\\displaystyle o(1)}o(1)\n * 空间复杂度：迭代：o(1){\\displaystyle o(1)}o(1)\n\n\n# 实现\n\n\n# javascript\n\n/**\n * exponential search\n *\n * the algorithm consists of two stages. the first stage determines a\n * range in which the search key would reside if it were in the list.\n * in the second stage, a binary search is performed on this range.\n */\n\nfunction binarysearch (arr, value, floor, ceiling) {\n  // middle index\n  const mid = math.floor((floor + ceiling) / 2)\n\n  // if value is at the mid position return this position\n  if (arr[mid] === value) {\n    return mid\n  }\n\n  if (floor > ceiling) return -1\n\n  // if the middle element is great than the value\n  // search the left part of the array\n  if (arr[mid] > value) {\n    return binarysearch(arr, value, floor, mid - 1)\n    // if the middle element is lower than the value\n    // search the right part of the array\n  } else {\n    return binarysearch(arr, value, mid + 1, ceiling)\n  }\n}\n\nfunction exponentialsearch (arr, length, value) {\n  // if value is the first element of the array return this position\n  if (arr[0] === value) {\n    return 0\n  }\n\n  // find range for binary search\n  let i = 1\n  while (i < length && arr[i] <= value) {\n    i = i * 2\n  }\n\n  // call binary search for the range found above\n  return binarysearch(arr, value, i / 2, math.min(i, length))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 参考\n\n * exponential search - wikipedia",charsets:{cjk:!0},lastUpdated:"2022/05/10, 23:46:22",lastUpdatedTimestamp:1652197582e3},{title:"FibonacciSearch [斐波那契搜索]",frontmatter:{title:"FibonacciSearch [斐波那契搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/fibonacciSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/30.FibonacciSearch.html",relativePath:"20.算法/20.Search 搜索/30.FibonacciSearch.md",key:"v-19abda42",path:"/algorithm/search/fibonacciSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:61},{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:269},{level:2,title:"斐波那契数列",slug:"斐波那契数列",normalizedTitle:"斐波那契数列",charIndex:84},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2460},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2467},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4582}],headersStr:"介绍 原理 描述 斐波那契数列 实现 JavaScript 参考",content:"# 介绍\n\n斐波那契搜索 (Fibonacci search) ，又称斐波那契查找，是区间中单峰函数的搜索技术。\n\n\n# 原理\n\n斐波那契搜索就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数 F [n]，将原查找表扩展为长度为 F[n] (如果要补充元素，则补充重复最后一个元素，直到满足 F [n] 个元素)，完成后进行斐波那契分割，即 F [n] 个元素分割为前半部分 F [n-1] 个元素，后半部分 F [n-2] 个元素，找出要查找的元素在那一部分并递归，直到找到。\n\n\n# 描述\n\n斐波那契查找是依据斐波那契序列的特点对表进行分割的。假设开始时表中记录的个数 (不妨设为 n) 比某个斐波那契数 (Fu) 小 1，即 n = Fu - 1（这也是一个前提条件），然后将给定值 key 和 a [Fu-1] 进行比较。\n\n * 若相等，则查找成功。\n * 若 key <a [Fu-1] ，则继续在 a [1] 至 a [Fu-1 - 1] 的子表中进行查找。\n * 若 key > a [Fu-1] ，则继续在 a [Fu-1 + 1] 至 a [Fu - 1] 的子表中进行查找。该子表的长度为 Fu-2 - 1。\n\n\n\n步骤如下：\n\n * 首先我们生成一个斐波那契数列： F1 = 1, F2 = 1， F3 = 2， F4 = 3， F5 = 5， F6 = 8， F7 = 13；\n * 然后我们设，有序表 a, 从 a [1]~a [12] 的值为 1 ~ 12。（为了方便理解，储存该表的数组的 a [0] 为空）\n * 我们假定，需要查找的数为 key = 4。\n * 因为 n = Fu - 1 ，可以知道此时，u = 7。将 key 和 a [F7-1] （即 a [8]）进行比较，我们发现 key<a[8] 。\n * 然后在 a [1]~a [7] 中进行查找，此时 u = 6。将 key 和 a [F6-1]（即 a [5]）进行比较，我们发现 key<a[5] 。\n * 然后再 a [1]~a [4] 中进行查找，此时 u = 5。将 key 和 a [F5-1]（即 a [3]）进行比较，我们发现 key>a[3] 。\n * 此时只剩 a [4]，查找完毕。\n\n\n# 斐波那契数列\n\n// 递归法\nconst Fn = (n) => {\n\n    // 容错：字符串可转为数字类型\n    if(typeof n === 'string' && n !== '') { console.info(`n: ${n} 是字符串，将会自动转化为数字类型: ${+n}`); n = +n; }\n\n    // 类型判断\n    if (typeof n !== 'number') { return console.error(`n: ${n} 必须为数字类型`); }\n\n    // 容错：浮点数能转成整数进行计算\n    if (!isNaN(n) && n !== parseInt(n)) { console.info(`n: ${n} 不是整数，将会自动转化为整数: ${parseInt(n)}`); n = parseInt(n); }\n\n    // 范围判断\n    if (n < 0 || isNaN(n)) { return console.error(`n: ${n} 必须大于0，并且不能为NaN`); }\n\n    if(n === 0) { return 0; }\n\n    if(n === 1) { return 1; }\n\n    return Fn(n - 1) + Fn(n - 2);\n}\n\n// 迭代法\nconst Fn = (n) => {\n\n    // 容错：字符串可转为数字类型\n    if(typeof n === 'string' && n !== '') { console.info(`n: ${n} 是字符串，将会自动转化为数字类型: ${+n}`); n = +n; }\n\n    // 类型判断\n    if (typeof n !== 'number') { return console.error(`n: ${n} 必须为数字类型`); }\n\n    // 容错：浮点数能转成整数进行计算\n    if (!isNaN(n) && n !== parseInt(n)) { console.info(`n: ${n} 不是整数，将会自动转化为整数: ${parseInt(n)}`); n = parseInt(n); }\n\n    // 范围判断\n    if (n < 0 || isNaN(n)) { return console.error(`n: ${n} 必须大于0，并且不能为NaN`); }\n\n    let pre = 0,\n        next = 1,\n        result;\n\n    if (n === 0) { result = pre; }\n\n    if (n === 1) { result = next; }\n\n    while (n >= 2) {\n        n--;\n        result = pre + next;\n        pre = next;\n        next = result;\n    }\n\n    return result;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 实现\n\n\n# JavaScript\n\n/****************************************************************************\n * This implementation is based on Generalizing the Fibonacci search we\n * define the Fibonacci search of degree K. Like the Fibonacci search,\n * which it reduces to for K = 2, the Fibonacci search of degree K\n * involves only addition and subtraction.\n *\n * We define a function fibonacciSearch() that takes an array of numbers,\n * the item (number) to be searched for and the length of the items in the array\n ****************************************************************************/\n\nconst fibonacciSearch = (arr, x, n) => {\n  let fib2 = 0 // (K-2)'th Fibonacci Number\n  let fib1 = 1 // (K-1)'th Fibonacci Number.\n  let fibK = fib2 + fib1 // Kth Fibonacci\n\n  /* We want to store the smallest fibonacci number smaller such that\n    number is greater than or equal to n, we use fibK for this */\n  while (fibK < n) {\n    fib2 = fib1\n    fib1 = fibK\n    fibK = fib2 + fib1\n  }\n  //  This marks the eliminated range from front\n  let offset = -1\n\n  /* while there are elements to be checked. We compare arr[fib2] with x.\n    When fibM becomes 1, fib2 becomes 0 */\n\n  while (fibK > 1) {\n    // Check if fibK is a valid location\n    const i = Math.min(offset + fib2, n - 1)\n\n    /*  If x is greater than the value at\n      index fib2, Partition the subarray array\n      from offset to i */\n    if (arr[i] < x) {\n      fibK = fib1\n      fib1 = fib2\n      fib2 = fibK - fib1\n      offset = i\n      /* If x is greater than the value at\n            index fib2, cut the subarray array\n            from offset to i */\n    } else if (arr[i] > x) {\n      fibK = fib2\n      fib1 = fib1 - fib2\n      fib2 = fibK - fib1\n    } else {\n    //  return index for found element\n      return i\n    }\n  }\n\n  //    comparing the last element with x */\n  if (fib1 && arr[offset + 1] === x) {\n    return offset + 1\n  }\n  //    element not found. return -1\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 参考\n\n * Fibonacci search technique - Wikipedia\n * 斐波那契搜索_百度百科",normalizedContent:"# 介绍\n\n斐波那契搜索 (fibonacci search) ，又称斐波那契查找，是区间中单峰函数的搜索技术。\n\n\n# 原理\n\n斐波那契搜索就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数 f [n]，将原查找表扩展为长度为 f[n] (如果要补充元素，则补充重复最后一个元素，直到满足 f [n] 个元素)，完成后进行斐波那契分割，即 f [n] 个元素分割为前半部分 f [n-1] 个元素，后半部分 f [n-2] 个元素，找出要查找的元素在那一部分并递归，直到找到。\n\n\n# 描述\n\n斐波那契查找是依据斐波那契序列的特点对表进行分割的。假设开始时表中记录的个数 (不妨设为 n) 比某个斐波那契数 (fu) 小 1，即 n = fu - 1（这也是一个前提条件），然后将给定值 key 和 a [fu-1] 进行比较。\n\n * 若相等，则查找成功。\n * 若 key <a [fu-1] ，则继续在 a [1] 至 a [fu-1 - 1] 的子表中进行查找。\n * 若 key > a [fu-1] ，则继续在 a [fu-1 + 1] 至 a [fu - 1] 的子表中进行查找。该子表的长度为 fu-2 - 1。\n\n\n\n步骤如下：\n\n * 首先我们生成一个斐波那契数列： f1 = 1, f2 = 1， f3 = 2， f4 = 3， f5 = 5， f6 = 8， f7 = 13；\n * 然后我们设，有序表 a, 从 a [1]~a [12] 的值为 1 ~ 12。（为了方便理解，储存该表的数组的 a [0] 为空）\n * 我们假定，需要查找的数为 key = 4。\n * 因为 n = fu - 1 ，可以知道此时，u = 7。将 key 和 a [f7-1] （即 a [8]）进行比较，我们发现 key<a[8] 。\n * 然后在 a [1]~a [7] 中进行查找，此时 u = 6。将 key 和 a [f6-1]（即 a [5]）进行比较，我们发现 key<a[5] 。\n * 然后再 a [1]~a [4] 中进行查找，此时 u = 5。将 key 和 a [f5-1]（即 a [3]）进行比较，我们发现 key>a[3] 。\n * 此时只剩 a [4]，查找完毕。\n\n\n# 斐波那契数列\n\n// 递归法\nconst fn = (n) => {\n\n    // 容错：字符串可转为数字类型\n    if(typeof n === 'string' && n !== '') { console.info(`n: ${n} 是字符串，将会自动转化为数字类型: ${+n}`); n = +n; }\n\n    // 类型判断\n    if (typeof n !== 'number') { return console.error(`n: ${n} 必须为数字类型`); }\n\n    // 容错：浮点数能转成整数进行计算\n    if (!isnan(n) && n !== parseint(n)) { console.info(`n: ${n} 不是整数，将会自动转化为整数: ${parseint(n)}`); n = parseint(n); }\n\n    // 范围判断\n    if (n < 0 || isnan(n)) { return console.error(`n: ${n} 必须大于0，并且不能为nan`); }\n\n    if(n === 0) { return 0; }\n\n    if(n === 1) { return 1; }\n\n    return fn(n - 1) + fn(n - 2);\n}\n\n// 迭代法\nconst fn = (n) => {\n\n    // 容错：字符串可转为数字类型\n    if(typeof n === 'string' && n !== '') { console.info(`n: ${n} 是字符串，将会自动转化为数字类型: ${+n}`); n = +n; }\n\n    // 类型判断\n    if (typeof n !== 'number') { return console.error(`n: ${n} 必须为数字类型`); }\n\n    // 容错：浮点数能转成整数进行计算\n    if (!isnan(n) && n !== parseint(n)) { console.info(`n: ${n} 不是整数，将会自动转化为整数: ${parseint(n)}`); n = parseint(n); }\n\n    // 范围判断\n    if (n < 0 || isnan(n)) { return console.error(`n: ${n} 必须大于0，并且不能为nan`); }\n\n    let pre = 0,\n        next = 1,\n        result;\n\n    if (n === 0) { result = pre; }\n\n    if (n === 1) { result = next; }\n\n    while (n >= 2) {\n        n--;\n        result = pre + next;\n        pre = next;\n        next = result;\n    }\n\n    return result;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 实现\n\n\n# javascript\n\n/****************************************************************************\n * this implementation is based on generalizing the fibonacci search we\n * define the fibonacci search of degree k. like the fibonacci search,\n * which it reduces to for k = 2, the fibonacci search of degree k\n * involves only addition and subtraction.\n *\n * we define a function fibonaccisearch() that takes an array of numbers,\n * the item (number) to be searched for and the length of the items in the array\n ****************************************************************************/\n\nconst fibonaccisearch = (arr, x, n) => {\n  let fib2 = 0 // (k-2)'th fibonacci number\n  let fib1 = 1 // (k-1)'th fibonacci number.\n  let fibk = fib2 + fib1 // kth fibonacci\n\n  /* we want to store the smallest fibonacci number smaller such that\n    number is greater than or equal to n, we use fibk for this */\n  while (fibk < n) {\n    fib2 = fib1\n    fib1 = fibk\n    fibk = fib2 + fib1\n  }\n  //  this marks the eliminated range from front\n  let offset = -1\n\n  /* while there are elements to be checked. we compare arr[fib2] with x.\n    when fibm becomes 1, fib2 becomes 0 */\n\n  while (fibk > 1) {\n    // check if fibk is a valid location\n    const i = math.min(offset + fib2, n - 1)\n\n    /*  if x is greater than the value at\n      index fib2, partition the subarray array\n      from offset to i */\n    if (arr[i] < x) {\n      fibk = fib1\n      fib1 = fib2\n      fib2 = fibk - fib1\n      offset = i\n      /* if x is greater than the value at\n            index fib2, cut the subarray array\n            from offset to i */\n    } else if (arr[i] > x) {\n      fibk = fib2\n      fib1 = fib1 - fib2\n      fib2 = fibk - fib1\n    } else {\n    //  return index for found element\n      return i\n    }\n  }\n\n  //    comparing the last element with x */\n  if (fib1 && arr[offset + 1] === x) {\n    return offset + 1\n  }\n  //    element not found. return -1\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 参考\n\n * fibonacci search technique - wikipedia\n * 斐波那契搜索_百度百科",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"InterpolationSearch [插值搜索]",frontmatter:{title:"InterpolationSearch [插值搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/interpolationSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/40.InterpolationSearch.html",relativePath:"20.算法/20.Search 搜索/40.InterpolationSearch.md",key:"v-76aa68ff",path:"/algorithm/search/interpolationSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:771},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:778}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n插值查找，它是二分查找的变种，它只适用于有序递增系列。其时间复杂度 O (log2n) 。\n\n插值查找算法只适用于有序序列，换句话说，它只能在升序序列或者降序序列中查找目标元素。作为 “改进版” 的二分查找算法，当有序序列中的元素呈现均匀分布时，插值查找算法的查找效率要优于二分查找算法；反之，如果有序序列不满足均匀分布的特征，插值查找算法的查找效率不如二分查找算法。\n\n所谓均匀分布，是指序列中各个相邻元素的差值近似相等。例如，{10, 20, 30, 40, 50} 就是一个均匀分布的升序序列，各个相邻元素的差值为 10。再比如 {100, 500, 2000, 5000} 是一个升序序列，但各相邻元素之间的差值相差巨大，不具备均匀分布的特征。\n\n插值查找改变了二分查找中原有的中值 mid 的求解方式，其 mid 不再代表中值，而是使用了一个插值公式：\n\nmid=left+(x−Val[left])×( right −left)Val[right]−Val[left] mid=l e f t+\\frac{(x-V a l[l e f t]) \\times(\\text { right }-l e f t)}{V a l[r i g h t]-V a l[l e f t]} mid=left+Val[right]−Val[left](x−Val[left])×( right −left)\n\n式子中，各部分的含义分别是：\n\n * midmidmid：计算得出的元素的位置；\n * rightrightright：搜索区域内最后一个元素所在的位置；\n * leftleftleft：搜索区域内第一个元素所在的位置；\n * xxx：要查找的目标元素；\n * Val[]Val[]Val[]：表示整个待搜索序列。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Interpolation Search\n *\n * Time Complexity:\n * -Best case: O(1)\n * -Worst case: O(n)\n * -O((log(log(n))) If the data are uniformly distributed\n */\n\nfunction interpolationSearch (arr, key) {\n  const length = arr.length - 1\n  let low = 0\n  let high = length\n  let position = -1\n  let delta = -1\n\n  // Because the array is sorted the key must be between low and high\n  while (low <= high && key >= arr[low] && key <= arr[high]) {\n    delta = (key - arr[low]) / (arr[high] - arr[low])\n    position = low + Math.floor((high - low) * delta)\n\n    // Target found return its position\n    if (arr[position] === key) {\n      return position\n    }\n\n    // If the key is larger then it is in the upper part of the array\n    if (arr[position] < key) {\n      low = position + 1\n      // If the key is smaller then it is in the lower part of the array\n    } else {\n      high = position - 1\n    }\n  }\n\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n",normalizedContent:"# 介绍\n\n插值查找，它是二分查找的变种，它只适用于有序递增系列。其时间复杂度 o (log2n) 。\n\n插值查找算法只适用于有序序列，换句话说，它只能在升序序列或者降序序列中查找目标元素。作为 “改进版” 的二分查找算法，当有序序列中的元素呈现均匀分布时，插值查找算法的查找效率要优于二分查找算法；反之，如果有序序列不满足均匀分布的特征，插值查找算法的查找效率不如二分查找算法。\n\n所谓均匀分布，是指序列中各个相邻元素的差值近似相等。例如，{10, 20, 30, 40, 50} 就是一个均匀分布的升序序列，各个相邻元素的差值为 10。再比如 {100, 500, 2000, 5000} 是一个升序序列，但各相邻元素之间的差值相差巨大，不具备均匀分布的特征。\n\n插值查找改变了二分查找中原有的中值 mid 的求解方式，其 mid 不再代表中值，而是使用了一个插值公式：\n\nmid=left+(x−val[left])×( right −left)val[right]−val[left] mid=l e f t+\\frac{(x-v a l[l e f t]) \\times(\\text { right }-l e f t)}{v a l[r i g h t]-v a l[l e f t]} mid=left+val[right]−val[left](x−val[left])×( right −left)\n\n式子中，各部分的含义分别是：\n\n * midmidmid：计算得出的元素的位置；\n * rightrightright：搜索区域内最后一个元素所在的位置；\n * leftleftleft：搜索区域内第一个元素所在的位置；\n * xxx：要查找的目标元素；\n * val[]val[]val[]：表示整个待搜索序列。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * interpolation search\n *\n * time complexity:\n * -best case: o(1)\n * -worst case: o(n)\n * -o((log(log(n))) if the data are uniformly distributed\n */\n\nfunction interpolationsearch (arr, key) {\n  const length = arr.length - 1\n  let low = 0\n  let high = length\n  let position = -1\n  let delta = -1\n\n  // because the array is sorted the key must be between low and high\n  while (low <= high && key >= arr[low] && key <= arr[high]) {\n    delta = (key - arr[low]) / (arr[high] - arr[low])\n    position = low + math.floor((high - low) * delta)\n\n    // target found return its position\n    if (arr[position] === key) {\n      return position\n    }\n\n    // if the key is larger then it is in the upper part of the array\n    if (arr[position] < key) {\n      low = position + 1\n      // if the key is smaller then it is in the lower part of the array\n    } else {\n      high = position - 1\n    }\n  }\n\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"JumpSearch [跳跃搜索]",frontmatter:{title:"JumpSearch [跳跃搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/jumpSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/50.JumpSearch.html",relativePath:"20.算法/20.Search 搜索/50.JumpSearch.md",key:"v-423e3e69",path:"/algorithm/search/jumpSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:176},{level:2,title:"块的大小",slug:"块的大小",normalizedTitle:"块的大小",charIndex:602},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:753},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:761},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1051},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1102},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1109},{level:3,title:"CPP",slug:"cpp",normalizedTitle:"cpp",charIndex:2164},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2921}],headersStr:"介绍 描述 块的大小 复杂度 时间复杂度 空间复杂度 实现 JavaScript CPP 参考",content:'# 介绍\n\n跳跃搜索是一种区间搜索算法。它是一种相对较新的算法，只适用于排序数组。它试图比线性搜索减少所需的比较次数，不像线性搜索那样扫描每一个元素。在跳跃搜索中，数组被分成 m 块。它搜索一个块中的元素，如果该元素不存在，则移动到下一个块。当算法找到包含元素的块时，它使用线性搜索算法来寻找精确的索引。这种算法比线性搜索快，但比二叉搜索慢。\n\n\n# 描述\n\n假设我们有一个未排序的数组 A []，包含 n 个元素，我们想找到一个元素 X。\n\n 1. 从第一个元素开始设置 i 为 0，块大小 m 为 √n 。\n 2. 当 A[min(m,n)-1]<X 且 i<n 时。\n\n * 将 i 设为 m，并以√n 递增 m。\n\n 3. If i >= n return -1。\n 4. 当 A[i]< X 时，执行以下操作。\n\n * 递增 i\n * 如果 i 等于 min (m,n) 返回 -1。\n\n 5. 如果 A[i] == X ，返回 i。\n 6. 否则，返回 -1。\n\n假设我们有一个数组 arr []，其大小为 n, block (向前跳过的固定长度) 的大小为 m。然后我们搜索索引 arr[0] ， arr[m] ， arr[2m]…Arr [km] 等。一旦我们找到区间 ( arr[km] < x < arr[(k+1)m] )，我们就从索引 km 执行线性搜索操作来找到元素。\n\n\n# 块的大小\n\n在最坏的情况下，如果最后检查的值大于要查找的元素，必须跳 n/m 次，然后再执行线性查找 m-1 次。因此最坏情况下的比较总数为 ((n/m) + m-1) 。\n\n当 m =√n 时，函数 ((n/m) + m-1) 的值最小。因此，最佳步长为 m =√n 即数组长度的平方根 。\n\n\n# 复杂度\n\n\n# 时间复杂度\n\n * 平均情况 跳跃排序算法运行 n/m 次，其中 n 是元素数量，m 是块大小。线性搜索需要 m-1 次比较，使得总时间表达式为 n/m+m-1。使时间表达式最小化的 m 的最优值为√n，使得时间复杂度为 n/√n+√n，即√n。跳跃搜索算法的时间复杂度为 O (√n)。\n\n * 最佳情况 最佳情况下的时间复杂度是 O (1)。当要搜索的元素是数组中的第一个元素时，就会出现这种情况。\n\n * 最坏情况 最坏的情况发生在我们做 n/m 跳跃的时候，我们最后检查的值大于我们要搜索的元素，m-1 比较进行线性搜索。最坏情况下的时间复杂度为 O (√n)。\n\n\n# 空间复杂度\n\n这种算法的空间复杂度是 O (1)，因为除了临时变量外，它不需要任何数据结构。\n\n\n# 实现\n\n\n# JavaScript\n\n/* The Jump Search algorithm allows to combine a linear search with a speed optimization.\n  * This means that instead of going 1 by 1, we will increase the step of √n and increase that\n  * step of √n which make the step getting bigger and bigger.\n  * The asymptotic analysis of Jump Search is o(√n). Like the binary search, it needs to be sorted.\n  * The advantage against binary search is that Jump Search traversed back only once.\n */\n\nconst jumpSearch = (arr, value) => {\n  const length = arr.length\n  let step = Math.floor(Math.sqrt(length))\n  let lowerBound = 0\n  while (arr[Math.min(step, length) - 1] < value) {\n    lowerBound = step\n    step += step\n    if (lowerBound >= length) {\n      return -1\n    }\n  }\n\n  const upperBound = Math.min(step, length)\n  while (arr[lowerBound] < value) {\n    lowerBound++\n    if (lowerBound === upperBound) {\n      return -1\n    }\n  }\n  if (arr[lowerBound] === value) {\n    return lowerBound\n  }\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# CPP\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint jumpSearch(int arr[], int x, int n)\n{\n\n    int m = sqrt(n);\n    int i = 0;\n    while (arr[min(m, n) - 1] < x)\n    {\n        i = m;\n        m += sqrt(n);\n        if (i >= n)\n            return -1;\n    }\n    while (arr[i] < x)\n    {\n        i++;\n        if (i == min(m, n))\n            return -1;\n    }\n    if (arr[i] == x)\n        return i;\n\n    return -1;\n}\n\nint main() {\n    int n = 10;\n    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = 7;\n    int result = jumpSearch(arr, x, n);\n    if (result == -1) cout << "Element not found";\n    else cout << "Element found at index " << result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 参考\n\n * Jump search - Wikipedia',normalizedContent:'# 介绍\n\n跳跃搜索是一种区间搜索算法。它是一种相对较新的算法，只适用于排序数组。它试图比线性搜索减少所需的比较次数，不像线性搜索那样扫描每一个元素。在跳跃搜索中，数组被分成 m 块。它搜索一个块中的元素，如果该元素不存在，则移动到下一个块。当算法找到包含元素的块时，它使用线性搜索算法来寻找精确的索引。这种算法比线性搜索快，但比二叉搜索慢。\n\n\n# 描述\n\n假设我们有一个未排序的数组 a []，包含 n 个元素，我们想找到一个元素 x。\n\n 1. 从第一个元素开始设置 i 为 0，块大小 m 为 √n 。\n 2. 当 a[min(m,n)-1]<x 且 i<n 时。\n\n * 将 i 设为 m，并以√n 递增 m。\n\n 3. if i >= n return -1。\n 4. 当 a[i]< x 时，执行以下操作。\n\n * 递增 i\n * 如果 i 等于 min (m,n) 返回 -1。\n\n 5. 如果 a[i] == x ，返回 i。\n 6. 否则，返回 -1。\n\n假设我们有一个数组 arr []，其大小为 n, block (向前跳过的固定长度) 的大小为 m。然后我们搜索索引 arr[0] ， arr[m] ， arr[2m]…arr [km] 等。一旦我们找到区间 ( arr[km] < x < arr[(k+1)m] )，我们就从索引 km 执行线性搜索操作来找到元素。\n\n\n# 块的大小\n\n在最坏的情况下，如果最后检查的值大于要查找的元素，必须跳 n/m 次，然后再执行线性查找 m-1 次。因此最坏情况下的比较总数为 ((n/m) + m-1) 。\n\n当 m =√n 时，函数 ((n/m) + m-1) 的值最小。因此，最佳步长为 m =√n 即数组长度的平方根 。\n\n\n# 复杂度\n\n\n# 时间复杂度\n\n * 平均情况 跳跃排序算法运行 n/m 次，其中 n 是元素数量，m 是块大小。线性搜索需要 m-1 次比较，使得总时间表达式为 n/m+m-1。使时间表达式最小化的 m 的最优值为√n，使得时间复杂度为 n/√n+√n，即√n。跳跃搜索算法的时间复杂度为 o (√n)。\n\n * 最佳情况 最佳情况下的时间复杂度是 o (1)。当要搜索的元素是数组中的第一个元素时，就会出现这种情况。\n\n * 最坏情况 最坏的情况发生在我们做 n/m 跳跃的时候，我们最后检查的值大于我们要搜索的元素，m-1 比较进行线性搜索。最坏情况下的时间复杂度为 o (√n)。\n\n\n# 空间复杂度\n\n这种算法的空间复杂度是 o (1)，因为除了临时变量外，它不需要任何数据结构。\n\n\n# 实现\n\n\n# javascript\n\n/* the jump search algorithm allows to combine a linear search with a speed optimization.\n  * this means that instead of going 1 by 1, we will increase the step of √n and increase that\n  * step of √n which make the step getting bigger and bigger.\n  * the asymptotic analysis of jump search is o(√n). like the binary search, it needs to be sorted.\n  * the advantage against binary search is that jump search traversed back only once.\n */\n\nconst jumpsearch = (arr, value) => {\n  const length = arr.length\n  let step = math.floor(math.sqrt(length))\n  let lowerbound = 0\n  while (arr[math.min(step, length) - 1] < value) {\n    lowerbound = step\n    step += step\n    if (lowerbound >= length) {\n      return -1\n    }\n  }\n\n  const upperbound = math.min(step, length)\n  while (arr[lowerbound] < value) {\n    lowerbound++\n    if (lowerbound === upperbound) {\n      return -1\n    }\n  }\n  if (arr[lowerbound] === value) {\n    return lowerbound\n  }\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint jumpsearch(int arr[], int x, int n)\n{\n\n    int m = sqrt(n);\n    int i = 0;\n    while (arr[min(m, n) - 1] < x)\n    {\n        i = m;\n        m += sqrt(n);\n        if (i >= n)\n            return -1;\n    }\n    while (arr[i] < x)\n    {\n        i++;\n        if (i == min(m, n))\n            return -1;\n    }\n    if (arr[i] == x)\n        return i;\n\n    return -1;\n}\n\nint main() {\n    int n = 10;\n    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = 7;\n    int result = jumpsearch(arr, x, n);\n    if (result == -1) cout << "element not found";\n    else cout << "element found at index " << result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 参考\n\n * jump search - wikipedia',charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"LinearSearch [线性搜索]",frontmatter:{title:"LinearSearch [线性搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/linearSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/60.LinearSearch.html",relativePath:"20.算法/20.Search 搜索/60.LinearSearch.md",key:"v-7f1bcab9",path:"/algorithm/search/linearSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:89},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:176},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:183},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:942}],headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\n在计算机科学中，线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。\n\n\n# 原理\n\n在计算机科学中，线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Linear search or sequential search is a method for finding a target\n * value within a list. It sequentially checks each element of the list\n * for the target value until a match is found or until all the elements\n * have been searched.\n */\nfunction SearchArray (searchNum, ar, output = v => console.log(v)) {\n  const position = Search(ar, searchNum)\n  if (position !== -1) {\n    output('The element was found at ' + (position + 1))\n  } else {\n    output('The element not found')\n  }\n}\n\n// Search “theArray” for the specified “key” value\nfunction Search (theArray, key) {\n  for (let n = 0; n < theArray.length; n++) {\n    if (theArray[n] === key) { return n }\n  }\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 参考\n\n * 线性搜索 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n在计算机科学中，线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。\n\n\n# 原理\n\n在计算机科学中，线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * linear search or sequential search is a method for finding a target\n * value within a list. it sequentially checks each element of the list\n * for the target value until a match is found or until all the elements\n * have been searched.\n */\nfunction searcharray (searchnum, ar, output = v => console.log(v)) {\n  const position = search(ar, searchnum)\n  if (position !== -1) {\n    output('the element was found at ' + (position + 1))\n  } else {\n    output('the element not found')\n  }\n}\n\n// search “thearray” for the specified “key” value\nfunction search (thearray, key) {\n  for (let n = 0; n < thearray.length; n++) {\n    if (thearray[n] === key) { return n }\n  }\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 参考\n\n * 线性搜索 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"QuickSelectSearch [快速选择搜索]",frontmatter:{title:"QuickSelectSearch [快速选择搜索]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/quickSelectSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/70.QuickSelectSearch.html",relativePath:"20.算法/20.Search 搜索/70.QuickSelectSearch.md",key:"v-46c7f282",path:"/algorithm/search/quickSelectSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:51},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:123},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:350},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:400},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1708}],headersStr:"介绍 原理 复杂度 实现 JavaScript 参考",content:"# 介绍\n\n快速选择（英语：QuickSelect）是一种从无序列表找到第 k 小元素的选择算法。它从原理上来说与快速排序有关。与快速排序一样都由托尼・霍尔提出的，因而也被称为霍尔选择算法。同样地，它在实际应用是一种高效的算法，具有很好的平均时间复杂度，然而最坏时间复杂度则不理想。快速选择及其变种是实际应用中最常使用的高效选择算法。\n\n\n# 原理\n\n快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 O (n log n) 至 O (n)，不过最坏情况仍然是 O (n2)。\n\n与快速排序一样，快速选择一般是以原地算法的方式实现，除了选出第 k 小的元素，数据也得到了部分地排序。\n\n\n# 复杂度\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Places the `k` smallest elements in `array` in the first `k` indices: `[0..k-1]`\n * Modifies the passed in array *in place*\n * Returns a slice of the wanted elements for convenience\n * Efficient mainly because it never performs a full sort.\n *\n * The only guarantees are that:\n *\n * - The `k`th element is in its final sort index (if the array were to be sorted)\n * - All elements before index `k` are smaller than the `k`th element\n *\n * [Reference](http://en.wikipedia.org/wiki/Quickselect)\n */\nfunction quickSelectSearch (array, k) {\n  if (!array || array.length <= k) {\n    throw new Error('Invalid arguments')\n  }\n\n  let from = 0\n  let to = array.length - 1\n  while (from < to) {\n    let left = from\n    let right = to\n    const pivot = array[Math.ceil((left + right) * 0.5)]\n\n    while (left < right) {\n      if (array[left] >= pivot) {\n        const tmp = array[left]\n        array[left] = array[right]\n        array[right] = tmp\n        --right\n      } else {\n        ++left\n      }\n    }\n\n    if (array[left] > pivot) {\n      --left\n    }\n\n    if (k <= left) {\n      to = left\n    } else {\n      from = left + 1\n    }\n  }\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 参考\n\n * 快速选择 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n快速选择（英语：quickselect）是一种从无序列表找到第 k 小元素的选择算法。它从原理上来说与快速排序有关。与快速排序一样都由托尼・霍尔提出的，因而也被称为霍尔选择算法。同样地，它在实际应用是一种高效的算法，具有很好的平均时间复杂度，然而最坏时间复杂度则不理想。快速选择及其变种是实际应用中最常使用的高效选择算法。\n\n\n# 原理\n\n快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 o (n log n) 至 o (n)，不过最坏情况仍然是 o (n2)。\n\n与快速排序一样，快速选择一般是以原地算法的方式实现，除了选出第 k 小的元素，数据也得到了部分地排序。\n\n\n# 复杂度\n\n\n\n\n# 实现\n\n\n# javascript\n\n/*\n * places the `k` smallest elements in `array` in the first `k` indices: `[0..k-1]`\n * modifies the passed in array *in place*\n * returns a slice of the wanted elements for convenience\n * efficient mainly because it never performs a full sort.\n *\n * the only guarantees are that:\n *\n * - the `k`th element is in its final sort index (if the array were to be sorted)\n * - all elements before index `k` are smaller than the `k`th element\n *\n * [reference](http://en.wikipedia.org/wiki/quickselect)\n */\nfunction quickselectsearch (array, k) {\n  if (!array || array.length <= k) {\n    throw new error('invalid arguments')\n  }\n\n  let from = 0\n  let to = array.length - 1\n  while (from < to) {\n    let left = from\n    let right = to\n    const pivot = array[math.ceil((left + right) * 0.5)]\n\n    while (left < right) {\n      if (array[left] >= pivot) {\n        const tmp = array[left]\n        array[left] = array[right]\n        array[right] = tmp\n        --right\n      } else {\n        ++left\n      }\n    }\n\n    if (array[left] > pivot) {\n      --left\n    }\n\n    if (k <= left) {\n      to = left\n    } else {\n      from = left + 1\n    }\n  }\n  return array\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 参考\n\n * 快速选择 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"ConwaysGameOfLife [康威生命游戏]",frontmatter:{title:"ConwaysGameOfLife [康威生命游戏]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/more/conwaysGameOfLife/",categories:["算法","其他"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/200.%E5%85%B6%E4%BB%96/10.ConwaysGameOfLife.html",relativePath:"20.算法/200.其他/10.ConwaysGameOfLife.md",key:"v-23204e4c",path:"/algorithm/more/conwaysGameOfLife/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:819},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1319},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:301}],headersStr:"介绍 概述 实现 参考",content:"# 介绍\n\n康威生命游戏（英语：Conway's Game of Life），又称康威生命棋，是英国数学家约翰・何顿・康威在 1970 年发明的细胞自动机。\n\n细胞自动机\n\n细胞自动机（英语：Cellular automaton），又称格状自动机、元胞自动机，是一种离散模型，在可计算性理论、数学及理论生物学都有相关研究。它是由无限个有规律、坚硬的方格组成，每格均处于一种有限状态。整个格网可以是任何有限维的。同时也是离散的。每格于 t 时的态由 t-1 时的一集有限格（这集叫那格的邻域）的态决定。每一格的 “邻居” 都是已被固定的。（一格可以是自己的邻居。）每次演进时，每格均遵从同一规矩一齐演进。参考：细胞自动机 - Wikiwand\n\n就形式而言，细胞自动机有三个特征：\n\n * 平行计算（parallel computation）：每一个细胞个体都同时同步的改变\n * 局部的（local）：细胞的状态变化只受周遭细胞的影响。\n * 一致性的（homogeneous）：所有细胞均受同样的规则所支配\n\n生命游戏中，对于任意细胞，规则如下：\n\n * 每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）\n * 当前细胞为存活状态时，当周围的存活细胞低于 2 个时（不包含 2 个），该细胞变成死亡状态。（模拟生命数量稀少）\n * 当前细胞为存活状态时，当周围有 2 个或 3 个存活细胞时，该细胞保持原样。\n * 当前细胞为存活状态时，当周围有超过 3 个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）\n * 当前细胞为死亡状态时，当周围有 3 个存活细胞时，该细胞变成存活状态。（模拟繁殖）\n\n可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。\n\n\n# 概述\n\n生命游戏是一个零玩家游戏。它包括一个二维矩形世界，这个世界中的每个方格居住着一个活着的或死了的细胞。一个细胞在下一个时刻生死取决于相邻八个方格中活着的或死了的细胞的数量。如果相邻方格活着的细胞数量过多，这个细胞会因为资源匮乏而在下一个时刻死去；相反，如果周围活细胞过少，这个细胞会因太孤单而死去。实际中，玩家可以设定周围活细胞的数目怎样时才适宜该细胞的生存。如果这个数目设定过高，世界中的大部分细胞会因为找不到太多的活的邻居而死去，直到整个世界都没有生命；如果这个数目设定过低，世界中又会被生命充满而没有什么变化。\n\n实际中，这个数目一般选取 2 或者 3；这样整个生命世界才不至于太过荒凉或拥挤，而是一种动态的平衡。这样的话，游戏的规则就是：当一个方格周围有 2 或 3 个活细胞时，方格中的活细胞在下一个时刻继续存活；即使这个时刻方格中没有活细胞，在下一个时刻也会 “诞生” 活细胞。\n\n在这个游戏中，还可以设定一些更加复杂的规则，例如当前方格的状况不仅由父一代决定，而且还考虑祖父一代的情况。玩家还可以作为这个世界的 “上帝”，随意设定某个方格细胞的死活，以观察对世界的影响。\n\n\n# 实现\n\n/*\nConway's Game of Life\nThe Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, \neach of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively).\nEvery cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. \nAt each step in time, the following transitions occur:\n  1. Any live cell with two or three live neighbours survives.\n  2. Any dead cell with three live neighbours becomes a live cell.\n  3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.\n(description adapted from https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life )\n(example adapted from https://github.com/TheAlgorithms/Python/blob/master/cellular_automata/conways_game_of_life.py )\n*/\n\n/*** Generates the next generation for a given state of Conway's Game of Life. */\nfunction newGeneration(cells) {\n const nextGeneration = [];\n for (let i = 0; i < cells.length; i++) {\n  const nextGenerationRow = [];\n  for (let j = 0; j < cells[i].length; j++) {\n   // Get the number of living neighbors\n   let neighborCount = 0;\n   if (i > 0 && j > 0) neighborCount += cells[i - 1][j - 1];\n   if (i > 0) neighborCount += cells[i - 1][j];\n   if (i > 0 && j < cells[i].length - 1) neighborCount += cells[i - 1][j + 1];\n   if (j > 0) neighborCount += cells[i][j - 1];\n   if (j < cells[i].length - 1) neighborCount += cells[i][j + 1];\n   if (i < cells.length - 1 && j > 0) neighborCount += cells[i + 1][j - 1];\n   if (i < cells.length - 1) neighborCount += cells[i + 1][j];\n   if (i < cells.length - 1 && j < cells[i].length - 1) neighborCount += cells[i + 1][j + 1];\n\n   // Decide whether the cell is alive or dead\n   const alive = cells[i][j] === 1;\n   if ((alive && neighborCount >= 2 && neighborCount <= 3) || (!alive && neighborCount === 3)) nextGenerationRow.push(1);\n   else nextGenerationRow.push(0);\n  }\n  nextGeneration.push(nextGenerationRow);\n }\n return nextGeneration;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 参考\n\n * Conway's Game of Life - Wikiwand\n * 康威生命游戏 - Wikiwand\n * 康威生命游戏 —— 孤独会致命，拥挤也一样 - 知乎",normalizedContent:"# 介绍\n\n康威生命游戏（英语：conway's game of life），又称康威生命棋，是英国数学家约翰・何顿・康威在 1970 年发明的细胞自动机。\n\n细胞自动机\n\n细胞自动机（英语：cellular automaton），又称格状自动机、元胞自动机，是一种离散模型，在可计算性理论、数学及理论生物学都有相关研究。它是由无限个有规律、坚硬的方格组成，每格均处于一种有限状态。整个格网可以是任何有限维的。同时也是离散的。每格于 t 时的态由 t-1 时的一集有限格（这集叫那格的邻域）的态决定。每一格的 “邻居” 都是已被固定的。（一格可以是自己的邻居。）每次演进时，每格均遵从同一规矩一齐演进。参考：细胞自动机 - wikiwand\n\n就形式而言，细胞自动机有三个特征：\n\n * 平行计算（parallel computation）：每一个细胞个体都同时同步的改变\n * 局部的（local）：细胞的状态变化只受周遭细胞的影响。\n * 一致性的（homogeneous）：所有细胞均受同样的规则所支配\n\n生命游戏中，对于任意细胞，规则如下：\n\n * 每个细胞有两种状态 - 存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动（如图，黑色为存活，白色为死亡）\n * 当前细胞为存活状态时，当周围的存活细胞低于 2 个时（不包含 2 个），该细胞变成死亡状态。（模拟生命数量稀少）\n * 当前细胞为存活状态时，当周围有 2 个或 3 个存活细胞时，该细胞保持原样。\n * 当前细胞为存活状态时，当周围有超过 3 个存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）\n * 当前细胞为死亡状态时，当周围有 3 个存活细胞时，该细胞变成存活状态。（模拟繁殖）\n\n可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。\n\n\n# 概述\n\n生命游戏是一个零玩家游戏。它包括一个二维矩形世界，这个世界中的每个方格居住着一个活着的或死了的细胞。一个细胞在下一个时刻生死取决于相邻八个方格中活着的或死了的细胞的数量。如果相邻方格活着的细胞数量过多，这个细胞会因为资源匮乏而在下一个时刻死去；相反，如果周围活细胞过少，这个细胞会因太孤单而死去。实际中，玩家可以设定周围活细胞的数目怎样时才适宜该细胞的生存。如果这个数目设定过高，世界中的大部分细胞会因为找不到太多的活的邻居而死去，直到整个世界都没有生命；如果这个数目设定过低，世界中又会被生命充满而没有什么变化。\n\n实际中，这个数目一般选取 2 或者 3；这样整个生命世界才不至于太过荒凉或拥挤，而是一种动态的平衡。这样的话，游戏的规则就是：当一个方格周围有 2 或 3 个活细胞时，方格中的活细胞在下一个时刻继续存活；即使这个时刻方格中没有活细胞，在下一个时刻也会 “诞生” 活细胞。\n\n在这个游戏中，还可以设定一些更加复杂的规则，例如当前方格的状况不仅由父一代决定，而且还考虑祖父一代的情况。玩家还可以作为这个世界的 “上帝”，随意设定某个方格细胞的死活，以观察对世界的影响。\n\n\n# 实现\n\n/*\nconway's game of life\nthe game of life is a cellular automaton devised by the british mathematician john horton conway in 1970. the universe of the game of life is an infinite, two-dimensional orthogonal grid of square cells, \neach of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively).\nevery cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. \nat each step in time, the following transitions occur:\n  1. any live cell with two or three live neighbours survives.\n  2. any dead cell with three live neighbours becomes a live cell.\n  3. all other live cells die in the next generation. similarly, all other dead cells stay dead.\n(description adapted from https://en.wikipedia.org/wiki/conway%27s_game_of_life )\n(example adapted from https://github.com/thealgorithms/python/blob/master/cellular_automata/conways_game_of_life.py )\n*/\n\n/*** generates the next generation for a given state of conway's game of life. */\nfunction newgeneration(cells) {\n const nextgeneration = [];\n for (let i = 0; i < cells.length; i++) {\n  const nextgenerationrow = [];\n  for (let j = 0; j < cells[i].length; j++) {\n   // get the number of living neighbors\n   let neighborcount = 0;\n   if (i > 0 && j > 0) neighborcount += cells[i - 1][j - 1];\n   if (i > 0) neighborcount += cells[i - 1][j];\n   if (i > 0 && j < cells[i].length - 1) neighborcount += cells[i - 1][j + 1];\n   if (j > 0) neighborcount += cells[i][j - 1];\n   if (j < cells[i].length - 1) neighborcount += cells[i][j + 1];\n   if (i < cells.length - 1 && j > 0) neighborcount += cells[i + 1][j - 1];\n   if (i < cells.length - 1) neighborcount += cells[i + 1][j];\n   if (i < cells.length - 1 && j < cells[i].length - 1) neighborcount += cells[i + 1][j + 1];\n\n   // decide whether the cell is alive or dead\n   const alive = cells[i][j] === 1;\n   if ((alive && neighborcount >= 2 && neighborcount <= 3) || (!alive && neighborcount === 3)) nextgenerationrow.push(1);\n   else nextgenerationrow.push(0);\n  }\n  nextgeneration.push(nextgenerationrow);\n }\n return nextgeneration;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 参考\n\n * conway's game of life - wikiwand\n * 康威生命游戏 - wikiwand\n * 康威生命游戏 —— 孤独会致命，拥挤也一样 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"Roadmap 路线",frontmatter:{title:"Roadmap 路线",date:"2022-04-16T16:44:46.000Z",permalink:"/algorithm/roadmap/",categories:["算法"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/3.roadmap.html",relativePath:"20.算法/3.roadmap.md",key:"v-48c1e216",path:"/algorithm/roadmap/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],headersStr:"参考",content:"# 参考\n\n * Roadmap/v1.0.png at master · OI-wiki/Roadmap",normalizedContent:"# 参考\n\n * roadmap/v1.0.png at master · oi-wiki/roadmap",charsets:{cjk:!0},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"BinaryEquivalent [二进制转化]",frontmatter:{title:"BinaryEquivalent [二进制转化]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/binaryEquivalent/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/10.BinaryEquivalent.html",relativePath:"20.算法/30.Recursive 递归/10.BinaryEquivalent.md",key:"v-16a18680",path:"/algorithm/recursive/binaryEquivalent/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:43},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:50}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n利用递归将十进制数字转化为二进制。可以推广到任意进制的互相转换。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Problem Statement: Given a positive number `num`, find it's binary equivalent using recursion\n *\n * What is Binary Equivalent?\n * - In binary number system, a number is represented in terms of 0s and 1s,\n *   for example:\n *    - Binary Of 2 = 10\n *    - Binary of 3 = 11\n *    - Binary of 4 = 100\n *\n * Reference on how to find Binary Equivalent\n * - https://byjus.com/maths/decimal-to-binary/\n *\n */\n\nexport const binaryEquivalent = (num) => {\n  if (num === 0 || num === 1) {\n    return String(num)\n  }\n  return binaryEquivalent(Math.floor(num / 2)) + String(num % 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# 介绍\n\n利用递归将十进制数字转化为二进制。可以推广到任意进制的互相转换。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * problem statement: given a positive number `num`, find it's binary equivalent using recursion\n *\n * what is binary equivalent?\n * - in binary number system, a number is represented in terms of 0s and 1s,\n *   for example:\n *    - binary of 2 = 10\n *    - binary of 3 = 11\n *    - binary of 4 = 100\n *\n * reference on how to find binary equivalent\n * - https://byjus.com/maths/decimal-to-binary/\n *\n */\n\nexport const binaryequivalent = (num) => {\n  if (num === 0 || num === 1) {\n    return string(num)\n  }\n  return binaryequivalent(math.floor(num / 2)) + string(num % 2)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"TowerOfHanoi [汉诺塔]",frontmatter:{title:"TowerOfHanoi [汉诺塔]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/towerOfHanoi/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/110.TowerOfHanoi.html",relativePath:"20.算法/30.Recursive 递归/110.TowerOfHanoi.md",key:"v-fb132384",path:"/algorithm/recursive/towerOfHanoi/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:221},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:228},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:835}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n汉诺塔（港台：河内塔）（Tower of Hanoi）是根据一个传说形成的数学问题：\n\n有三根杆子 A，B，C。A 杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：\n\n * 每次只能移动一个圆盘；\n * 大盘不能叠在小盘上面。\n\n提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。\n\n问：如何移？最少要移动多少次？\n\n\n# 实现\n\n\n# JavaScript\n\n// wiki - https://en.wikipedia.org/wiki/Tower_of_Hanoi\n// Recursive Javascript function to solve tower of hanoi\n\nexport function TowerOfHanoi (n, from, to, aux, output = []) {\n  if (n === 1) {\n    output.push(`Move disk 1 from rod ${from} to rod ${to}`)\n    return output\n  }\n  TowerOfHanoi(n - 1, from, aux, to, output)\n  output.push(`Move disk ${n} from rod ${from} to rod ${to}`)\n  TowerOfHanoi(n - 1, aux, to, from, output)\n  return output\n}\n\n// Driver code (A, C, B are the name of rods)\n\n// const n = 4\n// TowerOfHanoi(n, 'A', 'C', 'B')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参考\n\n * 汉诺塔 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n汉诺塔（港台：河内塔）（tower of hanoi）是根据一个传说形成的数学问题：\n\n有三根杆子 a，b，c。a 杆上有 n 个 (n>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 c 杆：\n\n * 每次只能移动一个圆盘；\n * 大盘不能叠在小盘上面。\n\n提示：可将圆盘临时置于 b 杆，也可将从 a 杆移出的圆盘重新移回 a 杆，但都必须遵循上述两条规则。\n\n问：如何移？最少要移动多少次？\n\n\n# 实现\n\n\n# javascript\n\n// wiki - https://en.wikipedia.org/wiki/tower_of_hanoi\n// recursive javascript function to solve tower of hanoi\n\nexport function towerofhanoi (n, from, to, aux, output = []) {\n  if (n === 1) {\n    output.push(`move disk 1 from rod ${from} to rod ${to}`)\n    return output\n  }\n  towerofhanoi(n - 1, from, aux, to, output)\n  output.push(`move disk ${n} from rod ${from} to rod ${to}`)\n  towerofhanoi(n - 1, aux, to, from, output)\n  return output\n}\n\n// driver code (a, c, b are the name of rods)\n\n// const n = 4\n// towerofhanoi(n, 'a', 'c', 'b')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参考\n\n * 汉诺塔 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"BinarySearch [二分搜索]",frontmatter:{title:"BinarySearch [二分搜索]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/binarySearch/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/20.BinarySearch.html",relativePath:"20.算法/30.Recursive 递归/20.BinarySearch.md",key:"v-58bc8820",path:"/algorithm/recursive/binarySearch/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9},{level:2,title:"参见",slug:"参见",normalizedTitle:"参见",charIndex:1216}],headersStr:"实现 JavaScript 参见",content:"# 实现\n\n\n# JavaScript\n\n\n/**\n * @function BinarySearch\n * @description Search the integer inside the sorted integers array using Binary Search Algorithm.\n * @param {Integer[]} arr - sorted array of integers\n * @param {Integer} low - The input integer\n * @param {Integer} high - The input integer\n * @param {Integer} searchValue - The input integer\n * @return {Integer} - return index of searchValue if found else return -1.\n * @see [BinarySearch](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n */\n\nconst binarySearch = (arr, searchValue, low = 0, high = arr.length - 1) => {\n  // base case\n  if (high < low || arr.length === 0) return -1\n\n  const mid = low + Math.floor((high - low) / 2)\n\n  // If the element is present at the middle\n  if (arr[mid] === searchValue) {\n    return mid\n  }\n\n  // If element is smaller than mid, then\n  // it can only be present in left subarray\n  if (arr[mid] > searchValue) {\n    return binarySearch(arr, searchValue, low, mid - 1)\n  }\n\n  // Else the element can only be present in right subarray\n  return binarySearch(arr, searchValue, mid + 1, high)\n}\n\nexport { binarySearch }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参见\n\n * BinarySearch [二分搜索]",normalizedContent:"# 实现\n\n\n# javascript\n\n\n/**\n * @function binarysearch\n * @description search the integer inside the sorted integers array using binary search algorithm.\n * @param {integer[]} arr - sorted array of integers\n * @param {integer} low - the input integer\n * @param {integer} high - the input integer\n * @param {integer} searchvalue - the input integer\n * @return {integer} - return index of searchvalue if found else return -1.\n * @see [binarysearch](https://en.wikipedia.org/wiki/binary_search_algorithm)\n */\n\nconst binarysearch = (arr, searchvalue, low = 0, high = arr.length - 1) => {\n  // base case\n  if (high < low || arr.length === 0) return -1\n\n  const mid = low + math.floor((high - low) / 2)\n\n  // if the element is present at the middle\n  if (arr[mid] === searchvalue) {\n    return mid\n  }\n\n  // if element is smaller than mid, then\n  // it can only be present in left subarray\n  if (arr[mid] > searchvalue) {\n    return binarysearch(arr, searchvalue, low, mid - 1)\n  }\n\n  // else the element can only be present in right subarray\n  return binarysearch(arr, searchvalue, mid + 1, high)\n}\n\nexport { binarysearch }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参见\n\n * binarysearch [二分搜索]",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"EuclideanGCD [辗转相除法]",frontmatter:{title:"EuclideanGCD [辗转相除法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/euclideanGCD/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/30.EucledianGCD.html",relativePath:"20.算法/30.Recursive 递归/30.EucledianGCD.md",key:"v-4b1c1560",path:"/algorithm/recursive/euclideanGCD/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:66},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:315},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:322},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1057}],headersStr:"介绍 原理 实现 JavaScript 参考",content:"# 介绍\n\n在数学中，辗转相除法，又称欧几里得算法（英语：Euclidean algorithm），是求最大公约数的算法。\n\n\n# 原理\n\n两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 21 = 5 × 105 + (−2) × 252 。这个重要的结论叫做裴蜀定理。两个数的最大公约数通常写成 GCD (a, b)。\n\n在现代密码学方面，它是 RSA 算法（一种在电子商务中广泛使用的公钥加密算法）的重要部分。辗转相除法是现代数论中的基本工具。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nCalculates GCD of two numbers using Euclidean Recursive Algorithm\n:param first: First number\n:param second: Second number\n:return: GCD of the numbers\n*/\nfunction euclideanGCDRecursive (first, second) {\n  if (second === 0) {\n    return first\n  } else {\n    return euclideanGCDRecursive(second, (first % second))\n  }\n}\n\n/*\nCalculates GCD of two numbers using Euclidean Iterative Algorithm\n:param first: First number\n:param second: Second number\n:return: GCD of the numbers\n*/\nfunction euclideanGCDIterative (first, second) {\n  while (second !== 0) {\n    const temp = second\n    second = first % second\n    first = temp\n  }\n  return first\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 参考\n\n * 辗转相除法 - 维基百科，自由的百科全书\n * 深究递归和迭代的区别、联系、优缺点及实例对比",normalizedContent:"# 介绍\n\n在数学中，辗转相除法，又称欧几里得算法（英语：euclidean algorithm），是求最大公约数的算法。\n\n\n# 原理\n\n两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 21 = 5 × 105 + (−2) × 252 。这个重要的结论叫做裴蜀定理。两个数的最大公约数通常写成 gcd (a, b)。\n\n在现代密码学方面，它是 rsa 算法（一种在电子商务中广泛使用的公钥加密算法）的重要部分。辗转相除法是现代数论中的基本工具。\n\n\n\n\n# 实现\n\n\n# javascript\n\n/*\ncalculates gcd of two numbers using euclidean recursive algorithm\n:param first: first number\n:param second: second number\n:return: gcd of the numbers\n*/\nfunction euclideangcdrecursive (first, second) {\n  if (second === 0) {\n    return first\n  } else {\n    return euclideangcdrecursive(second, (first % second))\n  }\n}\n\n/*\ncalculates gcd of two numbers using euclidean iterative algorithm\n:param first: first number\n:param second: second number\n:return: gcd of the numbers\n*/\nfunction euclideangcditerative (first, second) {\n  while (second !== 0) {\n    const temp = second\n    second = first % second\n    first = temp\n  }\n  return first\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 参考\n\n * 辗转相除法 - 维基百科，自由的百科全书\n * 深究递归和迭代的区别、联系、优缺点及实例对比",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"Factorial [阶乘]",frontmatter:{title:"Factorial [阶乘]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/factorial/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/40.Factorial.html",relativePath:"20.算法/30.Recursive 递归/40.Factorial.md",key:"v-42ab0b9c",path:"/algorithm/recursive/factorial/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:480}],headersStr:"实现 JavaScript 参考",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @function Factorial\n * @description function to find factorial using recursion.\n * @param {Integer} n - The input integer\n * @return {Integer} - Factorial of n.\n * @see [Factorial](https://en.wikipedia.org/wiki/Factorial)\n * @example 5! = 1*2*3*4*5 = 120\n * @example 2! = 1*2 = 2\n */\n\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial(n - 1)\n}\n\nexport { factorial }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参考\n\n * 阶乘 - 维基百科，自由的百科全书",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @function factorial\n * @description function to find factorial using recursion.\n * @param {integer} n - the input integer\n * @return {integer} - factorial of n.\n * @see [factorial](https://en.wikipedia.org/wiki/factorial)\n * @example 5! = 1*2*3*4*5 = 120\n * @example 2! = 1*2 = 2\n */\n\nconst factorial = (n) => {\n  if (n === 0) {\n    return 1\n  }\n  return n * factorial(n - 1)\n}\n\nexport { factorial }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参考\n\n * 阶乘 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"FibonacciNumberRecursive [斐波那契数]",frontmatter:{title:"FibonacciNumberRecursive [斐波那契数]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/fibonacci/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/50.FibonacciNumberRecursive.html",relativePath:"20.算法/30.Recursive 递归/50.FibonacciNumberRecursive.md",key:"v-9165af80",path:"/algorithm/recursive/fibonacci/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:277},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:284},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:730}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在数学上，斐波那契数是以递归的方法来定义：\n\n * F0=0F_{0}=0F0 =0\n * F1=1F_{1}=1F1 =1\n * Fn=Fn−1+Fn−2F_{n}=F_{{n-1}}+F_{n-2}Fn =Fn−1 +Fn−2 （n≧2）\n\n用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。首几个斐波那契数是：\n\n1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……\n\n特别指出：0 不是第一项，而是第零项。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function Fibonacci\n * @description Function to return the N-th Fibonacci number.\n * @param {Integer} n - The input integer\n * @return {Integer} - Return the N-th Fibonacci number\n * @see [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_number)\n */\n\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n\n  }\n  return fibonacci(n - 2) + fibonacci(n - 1)\n}\n\nexport { fibonacci }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 参考\n\n * 斐波那契数 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n在数学上，斐波那契数是以递归的方法来定义：\n\n * f0=0f_{0}=0f0 =0\n * f1=1f_{1}=1f1 =1\n * fn=fn−1+fn−2f_{n}=f_{{n-1}}+f_{n-2}fn =fn−1 +fn−2 （n≧2）\n\n用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。首几个斐波那契数是：\n\n1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……\n\n特别指出：0 不是第一项，而是第零项。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function fibonacci\n * @description function to return the n-th fibonacci number.\n * @param {integer} n - the input integer\n * @return {integer} - return the n-th fibonacci number\n * @see [fibonacci](https://en.wikipedia.org/wiki/fibonacci_number)\n */\n\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n\n  }\n  return fibonacci(n - 2) + fibonacci(n - 1)\n}\n\nexport { fibonacci }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 参考\n\n * 斐波那契数 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"FloodFill [Flood Fill算法]",frontmatter:{title:"FloodFill [Flood Fill算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/floodFill/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/60.FloodFill.html",relativePath:"20.算法/30.Recursive 递归/60.FloodFill.md",key:"v-0a82273e",path:"/algorithm/recursive/floodFill/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:96},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:316},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:323},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:330},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4403}],headersStr:"介绍 原理 视频 实现 JavaScript 参考",content:"# 介绍\n\nFlood fill 算法是从一个区域中提取若干个连通的点与其他相邻区域区分开（或分别染成不同颜色）的经典算法。因为其思路类似洪水从一个区域扩散到所有能到达的区域而得名。\n\n\n# 原理\n\nFlood fill 算法接受三个参数：起始节点，目标颜色和替换颜色。算法遍历所有的节点以寻找和起始节点相连的节点（通过一条目标颜色的路径相连），然后 改变他们的颜色为替换颜色。目前有许多 flood-fill 算法的构建方式，但是他们都显示或隐式的使用队列或者栈。根据我们是否考虑当前节点对角线方向的节点，算法分为四路算法（不考虑对角线方向的节点）和八路算法（考虑对角线方向的节点）。\n\n四路算法：\n\n\n\n八路算法：\n\n\n\n\n# 视频\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Flood fill.\n *\n * Flood fill, also called seed fill, is an algorithm that determines and alters the area connected to a given node in a\n * multi-dimensional array with some matching attribute. It is used in the \"bucket\" fill tool of paint programs to fill\n * connected, similarly-colored areas with a different color.\n *\n * (description adapted from https://en.wikipedia.org/wiki/Flood_fill)\n * @see https://www.techiedelight.com/flood-fill-algorithm/\n */\n\nconst neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n\n/**\n * Implements the flood fill algorithm through a breadth-first approach using a queue.\n *\n * @param rgbData The image to which the algorithm is applied.\n * @param location The start location on the image.\n * @param targetColor The old color to be replaced.\n * @param replacementColor The new color to replace the old one.\n */\nexport function breadthFirstSearch (rgbData, location, targetColor, replacementColor) {\n  if (location[0] < 0 ||\n    location[0] >= rgbData.length ||\n    location[1] < 0 ||\n    location[1] >= rgbData[0].length) {\n    throw new Error('location should point to a pixel within the rgbData')\n  }\n\n  const queue = []\n  queue.push(location)\n\n  while (queue.length > 0) {\n    breadthFirstFill(rgbData, location, targetColor, replacementColor, queue)\n  }\n}\n\n/**\n * Implements the flood fill algorithm through a depth-first approach using recursion.\n *\n * @param rgbData The image to which the algorithm is applied.\n * @param location The start location on the image.\n * @param targetColor The old color to be replaced.\n * @param replacementColor The new color to replace the old one.\n */\nexport function depthFirstSearch (rgbData, location, targetColor, replacementColor) {\n  if (location[0] < 0 ||\n    location[0] >= rgbData.length ||\n    location[1] < 0 ||\n    location[1] >= rgbData[0].length) {\n    throw new Error('location should point to a pixel within the rgbData')\n  }\n\n  depthFirstFill(rgbData, location, targetColor, replacementColor)\n}\n\n/**\n * Utility-function to implement the breadth-first loop.\n *\n * @param rgbData The image to which the algorithm is applied.\n * @param location The start location on the image.\n * @param targetColor The old color to be replaced.\n * @param replacementColor The new color to replace the old one.\n * @param queue The locations that still need to be visited.\n */\nfunction breadthFirstFill (rgbData, location, targetColor, replacementColor, queue) {\n  const currentLocation = queue[0]\n  queue.shift()\n\n  if (rgbData[currentLocation[0]][currentLocation[1]] === targetColor) {\n    rgbData[currentLocation[0]][currentLocation[1]] = replacementColor\n\n    for (let i = 0; i < neighbors.length; i++) {\n      const x = currentLocation[0] + neighbors[i][0]\n      const y = currentLocation[1] + neighbors[i][1]\n      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {\n        queue.push([x, y])\n      }\n    }\n  }\n}\n\n/**\n * Utility-function to implement the depth-first loop.\n *\n * @param rgbData The image to which the algorithm is applied.\n * @param location The start location on the image.\n * @param targetColor The old color to be replaced.\n * @param replacementColor The new color to replace the old one.\n */\nfunction depthFirstFill (rgbData, location, targetColor, replacementColor) {\n  if (rgbData[location[0]][location[1]] === targetColor) {\n    rgbData[location[0]][location[1]] = replacementColor\n\n    for (let i = 0; i < neighbors.length; i++) {\n      const x = location[0] + neighbors[i][0]\n      const y = location[1] + neighbors[i][1]\n      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {\n        depthFirstFill(rgbData, [x, y], targetColor, replacementColor)\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n\n\n\n# 参考\n\n * Flood fill - 维基百科，自由的百科全书\n * Flood fill - Wikipedia",normalizedContent:"# 介绍\n\nflood fill 算法是从一个区域中提取若干个连通的点与其他相邻区域区分开（或分别染成不同颜色）的经典算法。因为其思路类似洪水从一个区域扩散到所有能到达的区域而得名。\n\n\n# 原理\n\nflood fill 算法接受三个参数：起始节点，目标颜色和替换颜色。算法遍历所有的节点以寻找和起始节点相连的节点（通过一条目标颜色的路径相连），然后 改变他们的颜色为替换颜色。目前有许多 flood-fill 算法的构建方式，但是他们都显示或隐式的使用队列或者栈。根据我们是否考虑当前节点对角线方向的节点，算法分为四路算法（不考虑对角线方向的节点）和八路算法（考虑对角线方向的节点）。\n\n四路算法：\n\n\n\n八路算法：\n\n\n\n\n# 视频\n\n\n# 实现\n\n\n# javascript\n\n/**\n * flood fill.\n *\n * flood fill, also called seed fill, is an algorithm that determines and alters the area connected to a given node in a\n * multi-dimensional array with some matching attribute. it is used in the \"bucket\" fill tool of paint programs to fill\n * connected, similarly-colored areas with a different color.\n *\n * (description adapted from https://en.wikipedia.org/wiki/flood_fill)\n * @see https://www.techiedelight.com/flood-fill-algorithm/\n */\n\nconst neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n\n/**\n * implements the flood fill algorithm through a breadth-first approach using a queue.\n *\n * @param rgbdata the image to which the algorithm is applied.\n * @param location the start location on the image.\n * @param targetcolor the old color to be replaced.\n * @param replacementcolor the new color to replace the old one.\n */\nexport function breadthfirstsearch (rgbdata, location, targetcolor, replacementcolor) {\n  if (location[0] < 0 ||\n    location[0] >= rgbdata.length ||\n    location[1] < 0 ||\n    location[1] >= rgbdata[0].length) {\n    throw new error('location should point to a pixel within the rgbdata')\n  }\n\n  const queue = []\n  queue.push(location)\n\n  while (queue.length > 0) {\n    breadthfirstfill(rgbdata, location, targetcolor, replacementcolor, queue)\n  }\n}\n\n/**\n * implements the flood fill algorithm through a depth-first approach using recursion.\n *\n * @param rgbdata the image to which the algorithm is applied.\n * @param location the start location on the image.\n * @param targetcolor the old color to be replaced.\n * @param replacementcolor the new color to replace the old one.\n */\nexport function depthfirstsearch (rgbdata, location, targetcolor, replacementcolor) {\n  if (location[0] < 0 ||\n    location[0] >= rgbdata.length ||\n    location[1] < 0 ||\n    location[1] >= rgbdata[0].length) {\n    throw new error('location should point to a pixel within the rgbdata')\n  }\n\n  depthfirstfill(rgbdata, location, targetcolor, replacementcolor)\n}\n\n/**\n * utility-function to implement the breadth-first loop.\n *\n * @param rgbdata the image to which the algorithm is applied.\n * @param location the start location on the image.\n * @param targetcolor the old color to be replaced.\n * @param replacementcolor the new color to replace the old one.\n * @param queue the locations that still need to be visited.\n */\nfunction breadthfirstfill (rgbdata, location, targetcolor, replacementcolor, queue) {\n  const currentlocation = queue[0]\n  queue.shift()\n\n  if (rgbdata[currentlocation[0]][currentlocation[1]] === targetcolor) {\n    rgbdata[currentlocation[0]][currentlocation[1]] = replacementcolor\n\n    for (let i = 0; i < neighbors.length; i++) {\n      const x = currentlocation[0] + neighbors[i][0]\n      const y = currentlocation[1] + neighbors[i][1]\n      if (x >= 0 && x < rgbdata.length && y >= 0 && y < rgbdata[0].length) {\n        queue.push([x, y])\n      }\n    }\n  }\n}\n\n/**\n * utility-function to implement the depth-first loop.\n *\n * @param rgbdata the image to which the algorithm is applied.\n * @param location the start location on the image.\n * @param targetcolor the old color to be replaced.\n * @param replacementcolor the new color to replace the old one.\n */\nfunction depthfirstfill (rgbdata, location, targetcolor, replacementcolor) {\n  if (rgbdata[location[0]][location[1]] === targetcolor) {\n    rgbdata[location[0]][location[1]] = replacementcolor\n\n    for (let i = 0; i < neighbors.length; i++) {\n      const x = location[0] + neighbors[i][0]\n      const y = location[1] + neighbors[i][1]\n      if (x >= 0 && x < rgbdata.length && y >= 0 && y < rgbdata[0].length) {\n        depthfirstfill(rgbdata, [x, y], targetcolor, replacementcolor)\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n\n\n\n# 参考\n\n * flood fill - 维基百科，自由的百科全书\n * flood fill - wikipedia",charsets:{cjk:!0},lastUpdated:"2022/10/17, 12:47:34",lastUpdatedTimestamp:1665982054e3},{title:"KochSnowflake [科赫雪花算法]",frontmatter:{title:"KochSnowflake [科赫雪花算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/kochSnowflake/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/80.KochSnowflake.html",relativePath:"20.算法/30.Recursive 递归/80.KochSnowflake.md",key:"v-61e6541c",path:"/algorithm/recursive/kochSnowflake/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:363},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:370},{level:2,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:4591},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:6603},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6643}],headersStr:"介绍 实现 JavaScript 测试 扩展 参考",content:"# 介绍\n\n科赫曲线（英语：Koch curve）是一种分形。其形态似雪花，又称科赫雪花（Koch snowflake）、科赫星（Koch star）、科赫岛（Koch island）或雪花曲线（Snowflake curve）。\n\n给定线段 AB，科赫曲线可以由以下步骤生成：\n\n * 将线段分成三等份（AC,CD,DB）。\n * 以 CD 为底，向外（内外随意）画一个等边三角形 DMC。\n * 将线段 CD 移去。\n * 分别对 AC,CM,MD,DB 重复 1~3。\n\n科赫雪花是以等边三角形三边生成的科赫曲线组成的。科赫雪花的面积是 23(s2)5\\frac{2\\sqrt{3}(s^2)}{5}523 (s2) ，其中sss 是原来三角形的边长。每条科赫曲线的长度是无限大，它是连续而无处可微的曲线。\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * The Koch snowflake is a fractal curve and one of the earliest fractals to have been described.\n *\n * The Koch snowflake can be built up iteratively, in a sequence of stages. The first stage is an equilateral triangle,\n * and each successive stage is formed by adding outward bends to each side of the previous stage, making smaller\n * equilateral triangles. This can be achieved through the following steps for each line:\n * 1. divide the line segment into three segments of equal length.\n * 2. draw an equilateral triangle that has the middle segment from step 1 as its base and points outward.\n * 3. remove the line segment that is the base of the triangle from step 2.\n *\n * (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake)\n * (for a more detailed explanation and an implementation in the Processing language, see\n * https://natureofcode.com/book/chapter-8-fractals/ #84-the-koch-curve-and-the-arraylist-technique).\n */\n\n/** Class to handle the vector calculations. */\nexport class Vector2 {\n  constructor (x, y) {\n    this.x = x\n    this.y = y\n  }\n\n  /**\n   * Vector addition\n   *\n   * @param vector The vector to be added.\n   * @returns The sum-vector.\n   */\n  add (vector) {\n    const x = this.x + vector.x\n    const y = this.y + vector.y\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Vector subtraction\n   *\n   * @param vector The vector to be subtracted.\n   * @returns The difference-vector.\n   */\n  subtract (vector) {\n    const x = this.x - vector.x\n    const y = this.y - vector.y\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Vector scalar multiplication\n   *\n   * @param scalar The factor by which to multiply the vector.\n   * @returns The scaled vector.\n   */\n  multiply (scalar) {\n    const x = this.x * scalar\n    const y = this.y * scalar\n    return new Vector2(x, y)\n  }\n\n  /**\n   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)\n   *\n   * @param angleInDegrees The angle by which to rotate the vector.\n   * @returns The rotated vector.\n   */\n  rotate (angleInDegrees) {\n    const radians = angleInDegrees * Math.PI / 180\n    const ca = Math.cos(radians)\n    const sa = Math.sin(radians)\n    const x = ca * this.x - sa * this.y\n    const y = sa * this.x + ca * this.y\n    return new Vector2(x, y)\n  }\n}\n\n/**\n * Go through the number of iterations determined by the argument \"steps\".\n *\n * Be careful with high values (above 5) since the time to calculate increases exponentially.\n *\n * @param initialVectors The vectors composing the shape to which the algorithm is applied.\n * @param steps The number of iterations.\n * @returns The transformed vectors after the iteration-steps.\n */\nexport function iterate (initialVectors, steps) {\n  let vectors = initialVectors\n  for (let i = 0; i < steps; i++) {\n    vectors = iterationStep(vectors)\n  }\n\n  return vectors\n}\n\n/**\n * Loops through each pair of adjacent vectors.\n *\n * Each line between two adjacent vectors is divided into 4 segments by adding 3 additional vectors in-between the\n * original two vectors. The vector in the middle is constructed through a 60 degree rotation so it is bent outwards.\n *\n * @param vectors The vectors composing the shape to which the algorithm is applied.\n * @returns The transformed vectors after the iteration-step.\n */\nfunction iterationStep (vectors) {\n  const newVectors = []\n  for (let i = 0; i < vectors.length - 1; i++) {\n    const startVector = vectors[i]\n    const endVector = vectors[i + 1]\n    newVectors.push(startVector)\n    const differenceVector = endVector.subtract(startVector).multiply(1 / 3)\n    newVectors.push(startVector.add(differenceVector))\n    newVectors.push(startVector.add(differenceVector).add(differenceVector.rotate(60)))\n    newVectors.push(startVector.add(differenceVector.multiply(2)))\n  }\n\n  newVectors.push(vectors[vectors.length - 1])\n  return newVectors\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n\n# 测试\n\nimport { Vector2, iterate } from './KochSnowflake'\n\n/**\n * Method to render the Koch snowflake to a canvas.\n *\n * @param canvasWidth The width of the canvas.\n * @param steps The number of iterations.\n * @returns The canvas of the rendered Koch snowflake.\n */\nfunction getKochSnowflake (canvasWidth = 600, steps = 5) {\n  if (canvasWidth <= 0) {\n    throw new Error('canvasWidth should be greater than zero')\n  }\n\n  const offsetX = canvasWidth / 10.0\n  const offsetY = canvasWidth / 3.7\n  const vector1 = new Vector2(offsetX, offsetY)\n  const vector2 = new Vector2(canvasWidth / 2, Math.sin(Math.PI / 3) * canvasWidth * 0.8 + offsetY)\n  const vector3 = new Vector2(canvasWidth - offsetX, offsetY)\n  const initialVectors = []\n  initialVectors.push(vector1)\n  initialVectors.push(vector2)\n  initialVectors.push(vector3)\n  initialVectors.push(vector1)\n  const vectors = iterate(initialVectors, steps)\n  return drawToCanvas(vectors, canvasWidth, canvasWidth)\n}\n\n/**\n * Utility-method to render the Koch snowflake to a canvas.\n *\n * @param vectors The vectors defining the edges to be rendered.\n * @param canvasWidth The width of the canvas.\n * @param canvasHeight The height of the canvas.\n * @returns The canvas of the rendered edges.\n */\nfunction drawToCanvas (vectors, canvasWidth, canvasHeight) {\n  const canvas = document.createElement('canvas')\n  canvas.width = canvasWidth\n  canvas.height = canvasHeight\n\n  // Draw the edges\n  const ctx = canvas.getContext('2d')\n  ctx.beginPath()\n  ctx.moveTo(vectors[0].x, vectors[0].y)\n  for (let i = 1; i < vectors.length; i++) {\n    ctx.lineTo(vectors[i].x, vectors[i].y)\n  }\n  ctx.stroke()\n\n  return canvas\n}\n\n// plot the results if the script is executed in a browser with a window-object\nif (typeof window !== 'undefined') {\n  const canvas = getKochSnowflake()\n  document.body.append(canvas)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 扩展\n\n * “科赫雪花” 是什么？为什么它的面积有限，周长却无限大？\n\n\n# 参考\n\n * Koch snowflake - Wikipedia\n * 科赫曲线 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n科赫曲线（英语：koch curve）是一种分形。其形态似雪花，又称科赫雪花（koch snowflake）、科赫星（koch star）、科赫岛（koch island）或雪花曲线（snowflake curve）。\n\n给定线段 ab，科赫曲线可以由以下步骤生成：\n\n * 将线段分成三等份（ac,cd,db）。\n * 以 cd 为底，向外（内外随意）画一个等边三角形 dmc。\n * 将线段 cd 移去。\n * 分别对 ac,cm,md,db 重复 1~3。\n\n科赫雪花是以等边三角形三边生成的科赫曲线组成的。科赫雪花的面积是 23(s2)5\\frac{2\\sqrt{3}(s^2)}{5}523 (s2) ，其中sss 是原来三角形的边长。每条科赫曲线的长度是无限大，它是连续而无处可微的曲线。\n\n\n\n\n# 实现\n\n\n# javascript\n\n/**\n * the koch snowflake is a fractal curve and one of the earliest fractals to have been described.\n *\n * the koch snowflake can be built up iteratively, in a sequence of stages. the first stage is an equilateral triangle,\n * and each successive stage is formed by adding outward bends to each side of the previous stage, making smaller\n * equilateral triangles. this can be achieved through the following steps for each line:\n * 1. divide the line segment into three segments of equal length.\n * 2. draw an equilateral triangle that has the middle segment from step 1 as its base and points outward.\n * 3. remove the line segment that is the base of the triangle from step 2.\n *\n * (description adapted from https://en.wikipedia.org/wiki/koch_snowflake)\n * (for a more detailed explanation and an implementation in the processing language, see\n * https://natureofcode.com/book/chapter-8-fractals/ #84-the-koch-curve-and-the-arraylist-technique).\n */\n\n/** class to handle the vector calculations. */\nexport class vector2 {\n  constructor (x, y) {\n    this.x = x\n    this.y = y\n  }\n\n  /**\n   * vector addition\n   *\n   * @param vector the vector to be added.\n   * @returns the sum-vector.\n   */\n  add (vector) {\n    const x = this.x + vector.x\n    const y = this.y + vector.y\n    return new vector2(x, y)\n  }\n\n  /**\n   * vector subtraction\n   *\n   * @param vector the vector to be subtracted.\n   * @returns the difference-vector.\n   */\n  subtract (vector) {\n    const x = this.x - vector.x\n    const y = this.y - vector.y\n    return new vector2(x, y)\n  }\n\n  /**\n   * vector scalar multiplication\n   *\n   * @param scalar the factor by which to multiply the vector.\n   * @returns the scaled vector.\n   */\n  multiply (scalar) {\n    const x = this.x * scalar\n    const y = this.y * scalar\n    return new vector2(x, y)\n  }\n\n  /**\n   * vector rotation (see https://en.wikipedia.org/wiki/rotation_matrix)\n   *\n   * @param angleindegrees the angle by which to rotate the vector.\n   * @returns the rotated vector.\n   */\n  rotate (angleindegrees) {\n    const radians = angleindegrees * math.pi / 180\n    const ca = math.cos(radians)\n    const sa = math.sin(radians)\n    const x = ca * this.x - sa * this.y\n    const y = sa * this.x + ca * this.y\n    return new vector2(x, y)\n  }\n}\n\n/**\n * go through the number of iterations determined by the argument \"steps\".\n *\n * be careful with high values (above 5) since the time to calculate increases exponentially.\n *\n * @param initialvectors the vectors composing the shape to which the algorithm is applied.\n * @param steps the number of iterations.\n * @returns the transformed vectors after the iteration-steps.\n */\nexport function iterate (initialvectors, steps) {\n  let vectors = initialvectors\n  for (let i = 0; i < steps; i++) {\n    vectors = iterationstep(vectors)\n  }\n\n  return vectors\n}\n\n/**\n * loops through each pair of adjacent vectors.\n *\n * each line between two adjacent vectors is divided into 4 segments by adding 3 additional vectors in-between the\n * original two vectors. the vector in the middle is constructed through a 60 degree rotation so it is bent outwards.\n *\n * @param vectors the vectors composing the shape to which the algorithm is applied.\n * @returns the transformed vectors after the iteration-step.\n */\nfunction iterationstep (vectors) {\n  const newvectors = []\n  for (let i = 0; i < vectors.length - 1; i++) {\n    const startvector = vectors[i]\n    const endvector = vectors[i + 1]\n    newvectors.push(startvector)\n    const differencevector = endvector.subtract(startvector).multiply(1 / 3)\n    newvectors.push(startvector.add(differencevector))\n    newvectors.push(startvector.add(differencevector).add(differencevector.rotate(60)))\n    newvectors.push(startvector.add(differencevector.multiply(2)))\n  }\n\n  newvectors.push(vectors[vectors.length - 1])\n  return newvectors\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n\n# 测试\n\nimport { vector2, iterate } from './kochsnowflake'\n\n/**\n * method to render the koch snowflake to a canvas.\n *\n * @param canvaswidth the width of the canvas.\n * @param steps the number of iterations.\n * @returns the canvas of the rendered koch snowflake.\n */\nfunction getkochsnowflake (canvaswidth = 600, steps = 5) {\n  if (canvaswidth <= 0) {\n    throw new error('canvaswidth should be greater than zero')\n  }\n\n  const offsetx = canvaswidth / 10.0\n  const offsety = canvaswidth / 3.7\n  const vector1 = new vector2(offsetx, offsety)\n  const vector2 = new vector2(canvaswidth / 2, math.sin(math.pi / 3) * canvaswidth * 0.8 + offsety)\n  const vector3 = new vector2(canvaswidth - offsetx, offsety)\n  const initialvectors = []\n  initialvectors.push(vector1)\n  initialvectors.push(vector2)\n  initialvectors.push(vector3)\n  initialvectors.push(vector1)\n  const vectors = iterate(initialvectors, steps)\n  return drawtocanvas(vectors, canvaswidth, canvaswidth)\n}\n\n/**\n * utility-method to render the koch snowflake to a canvas.\n *\n * @param vectors the vectors defining the edges to be rendered.\n * @param canvaswidth the width of the canvas.\n * @param canvasheight the height of the canvas.\n * @returns the canvas of the rendered edges.\n */\nfunction drawtocanvas (vectors, canvaswidth, canvasheight) {\n  const canvas = document.createelement('canvas')\n  canvas.width = canvaswidth\n  canvas.height = canvasheight\n\n  // draw the edges\n  const ctx = canvas.getcontext('2d')\n  ctx.beginpath()\n  ctx.moveto(vectors[0].x, vectors[0].y)\n  for (let i = 1; i < vectors.length; i++) {\n    ctx.lineto(vectors[i].x, vectors[i].y)\n  }\n  ctx.stroke()\n\n  return canvas\n}\n\n// plot the results if the script is executed in a browser with a window-object\nif (typeof window !== 'undefined') {\n  const canvas = getkochsnowflake()\n  document.body.append(canvas)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 扩展\n\n * “科赫雪花” 是什么？为什么它的面积有限，周长却无限大？\n\n\n# 参考\n\n * koch snowflake - wikipedia\n * 科赫曲线 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/10/17, 12:47:34",lastUpdatedTimestamp:1665982054e3},{title:"Palindrome [回文]",frontmatter:{title:"Palindrome [回文]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/recursive/palindrome/",categories:["算法","Recursive 递归"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/30.Recursive%20%E9%80%92%E5%BD%92/90.Palindrome.html",relativePath:"20.算法/30.Recursive 递归/90.Palindrome.md",key:"v-b378a200",path:"/algorithm/recursive/palindrome/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:86},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:93},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:711}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n回文，亦称回环，是正读反读都能读通的句子，亦有将文字排列成圆圈者，是一种修辞方式和文字游戏。回环运用得当，可以表现两种事物或现象相互依靠或排斥的关系。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function Palindrome\n * @description Check whether the given string is Palindrome or not.\n * @param {String} str - The input string\n * @return {Boolean}.\n * @see [Palindrome](https://en.wikipedia.org/wiki/Palindrome)\n */\n\nconst palindrome = (str) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('Invalid Input')\n  }\n\n  if (str.length <= 1) {\n    return true\n  }\n\n  if (str[0] !== str[str.length - 1]) {\n    return false\n  } else {\n    return palindrome(str.slice(1, str.length - 1))\n  }\n}\n\nexport { palindrome }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 参考\n\n * 回文 - 维基百科，自由的百科全书",normalizedContent:"# 介绍\n\n回文，亦称回环，是正读反读都能读通的句子，亦有将文字排列成圆圈者，是一种修辞方式和文字游戏。回环运用得当，可以表现两种事物或现象相互依靠或排斥的关系。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function palindrome\n * @description check whether the given string is palindrome or not.\n * @param {string} str - the input string\n * @return {boolean}.\n * @see [palindrome](https://en.wikipedia.org/wiki/palindrome)\n */\n\nconst palindrome = (str) => {\n  if (typeof str !== 'string') {\n    throw new typeerror('invalid input')\n  }\n\n  if (str.length <= 1) {\n    return true\n  }\n\n  if (str[0] !== str[str.length - 1]) {\n    return false\n  } else {\n    return palindrome(str.slice(1, str.length - 1))\n  }\n}\n\nexport { palindrome }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 参考\n\n * 回文 - 维基百科，自由的百科全书",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"算法简介",frontmatter:{title:"算法简介",date:"2022-10-17T17:31:41.000Z",permalink:"/algorithm/introduction/",categories:["算法"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/4.intro.html",relativePath:"20.算法/4.intro.md",key:"v-6e5ede56",path:"/algorithm/introduction/",headers:[{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2},{level:2,title:"特征",slug:"特征",normalizedTitle:"特征",charIndex:168},{level:2,title:"基本要素",slug:"基本要素",normalizedTitle:"基本要素",charIndex:475},{level:3,title:"常用设计模式",slug:"常用设计模式",normalizedTitle:"常用设计模式",charIndex:538},{level:3,title:"常用实现方法",slug:"常用实现方法",normalizedTitle:"常用实现方法",charIndex:984},{level:2,title:"复杂度",slug:"复杂度",normalizedTitle:"复杂度",charIndex:1090},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1098},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1700},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1789}],headersStr:"算法 特征 基本要素 常用设计模式 常用实现方法 复杂度 时间复杂度 空间复杂度 参考",content:"# 算法\n\n算法（英语：algorithm），在数学（算学）和电脑科学之中，指一个被定义好的、计算机可施行其指示的有限步骤或次序，常用于计算、数据处理（英语：Data processing）和自动推理。算法是有效方法（英语：Effective method），包含一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。\n\n\n# 特征\n\n以下是高德纳在他的著作《计算机程序设计艺术》里对演算法的特征归纳：\n\n * 输入：一个算法必须有零个或以上输入量。\n * 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。\n * 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际执行结果是确定的。\n * 有限性：依据图灵的定义，一个演算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定演算法必须在有限个步骤内完成任务。\n * 有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。\n\n\n# 基本要素\n\n算法的核心是建立问题抽象的模型和明确求解目标，之后可以根据具体的问题选择不同的模式和方法完成算法的设计。\n\n\n# 常用设计模式\n\n * 完全遍历法和不完全遍历法：在问题的解是有限离散解空间，且可以验证正确性和最优性时，最简单的算法就是把解空间的所有元素完全遍历一遍，逐个检测元素是否是我们要的解。这是最直接的算法，实现往往最简单。但是当解空间特别庞大时，这种算法很可能导致工程上无法承受的计算量。这时候可以利用不完全遍历方法 —— 例如各种搜索法和规划法 —— 来减少计算量。\n\n * 分治法：把一个问题分割成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。\n\n * 动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。\n\n * 贪婪算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。\n\n * 线性规划法：指目标函数和约束条件皆为线性的最佳化问题。。\n\n * 简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。\n\n\n# 常用实现方法\n\n * 递归方法与迭代方法\n\n * 顺序计算、并行计算和分布式计算：顺序计算就是把形式化算法用编程语言进行单线程序列化后执行。\n\n * 确定性算法和非确定性算法\n\n * 精确求解和近似求解\n\n\n# 复杂度\n\n\n# 时间复杂度\n\n算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模 n 的函数f(n){\\displaystyle f(n)}f(n)，算法的时间复杂度也因此记做T(n)=O(f(n))T(n)=\\mathcal{O}(f(n))T(n)=O(f(n))。\n\n算法执行时间的增长率与f(n){\\displaystyle f(n)}f(n) 的增长率正相关，称作渐近时间复杂度（英语：Asymptotic computational complexity），简称时间复杂度。\n\n常见的时间复杂度有：常数阶O(1){\\displaystyle O(1)}O(1)，对数阶O(log⁡n){\\displaystyle O(\\log n)}O(logn)，线性阶O(n){\\displaystyle O(n)}O(n)，线性对数阶O(nlog⁡n){\\displaystyle O(n\\log n)}O(nlogn)，平方阶O(n2)O(n^{2})O(n2)，立方阶O(n3){\\displaystyle O(n^{3})}O(n3)，...， k 次方阶O(nk){\\displaystyle O(n^{k})}O(nk), 指数阶O(2n){\\displaystyle O(2^{n})}O(2n)。随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n\n\n# 空间复杂度\n\n算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。\n\n\n# 参考\n\n * 算法 - Wikiwand",normalizedContent:"# 算法\n\n算法（英语：algorithm），在数学（算学）和电脑科学之中，指一个被定义好的、计算机可施行其指示的有限步骤或次序，常用于计算、数据处理（英语：data processing）和自动推理。算法是有效方法（英语：effective method），包含一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。\n\n\n# 特征\n\n以下是高德纳在他的著作《计算机程序设计艺术》里对演算法的特征归纳：\n\n * 输入：一个算法必须有零个或以上输入量。\n * 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。\n * 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际执行结果是确定的。\n * 有限性：依据图灵的定义，一个演算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定演算法必须在有限个步骤内完成任务。\n * 有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。\n\n\n# 基本要素\n\n算法的核心是建立问题抽象的模型和明确求解目标，之后可以根据具体的问题选择不同的模式和方法完成算法的设计。\n\n\n# 常用设计模式\n\n * 完全遍历法和不完全遍历法：在问题的解是有限离散解空间，且可以验证正确性和最优性时，最简单的算法就是把解空间的所有元素完全遍历一遍，逐个检测元素是否是我们要的解。这是最直接的算法，实现往往最简单。但是当解空间特别庞大时，这种算法很可能导致工程上无法承受的计算量。这时候可以利用不完全遍历方法 —— 例如各种搜索法和规划法 —— 来减少计算量。\n\n * 分治法：把一个问题分割成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。\n\n * 动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。\n\n * 贪婪算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。\n\n * 线性规划法：指目标函数和约束条件皆为线性的最佳化问题。。\n\n * 简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。\n\n\n# 常用实现方法\n\n * 递归方法与迭代方法\n\n * 顺序计算、并行计算和分布式计算：顺序计算就是把形式化算法用编程语言进行单线程序列化后执行。\n\n * 确定性算法和非确定性算法\n\n * 精确求解和近似求解\n\n\n# 复杂度\n\n\n# 时间复杂度\n\n算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模 n 的函数f(n){\\displaystyle f(n)}f(n)，算法的时间复杂度也因此记做t(n)=o(f(n))t(n)=\\mathcal{o}(f(n))t(n)=o(f(n))。\n\n算法执行时间的增长率与f(n){\\displaystyle f(n)}f(n) 的增长率正相关，称作渐近时间复杂度（英语：asymptotic computational complexity），简称时间复杂度。\n\n常见的时间复杂度有：常数阶o(1){\\displaystyle o(1)}o(1)，对数阶o(log⁡n){\\displaystyle o(\\log n)}o(logn)，线性阶o(n){\\displaystyle o(n)}o(n)，线性对数阶o(nlog⁡n){\\displaystyle o(n\\log n)}o(nlogn)，平方阶o(n2)o(n^{2})o(n2)，立方阶o(n3){\\displaystyle o(n^{3})}o(n3)，...， k 次方阶o(nk){\\displaystyle o(n^{k})}o(nk), 指数阶o(2n){\\displaystyle o(2^{n})}o(2n)。随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n\n\n# 空间复杂度\n\n算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。\n\n\n# 参考\n\n * 算法 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 09:41:50",lastUpdatedTimestamp:166605731e4},{title:"BellmanFord [贝尔曼-福特算法]",frontmatter:{title:"BellmanFord [贝尔曼-福特算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/bellmanFord/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/10.BellmanFord.html",relativePath:"20.算法/40.Graph 图/10.BellmanFord.md",key:"v-f5d9ba7a",path:"/algorithm/graph/bellmanFord/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:62},{level:2,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:198},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:1581},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:142},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1652},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1585}],headersStr:"介绍 原理 优化 演示 实现 JavaScript 参考",content:"# 介绍\n\n贝尔曼 - 福特算法（英语：Bellman–Ford algorithm），求解单源最短路径问题的一种算法。它的原理是对图进行∣V∣−1{\\displaystyle |V|-1}∣V∣−1 次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达O(∣V∣∣E∣)O(|V||E|)O(∣V∣∣E∣)。但算法可以进行若干种优化，提高了效率。\n\nBellman-Ford 算法是一种用于计算带权有向图中单源最短路径（SSSP：Single-Source Shortest Path）的算法。该算法由 Richard Bellman 和 Lester Ford 分别发表于 1958 年和 1956 年，而实际上 Edward F. Moore 也在 1957 年发布了相同的算法，因此，此算法也常被称为 Bellman-Ford-Moore 算法。\n\nBellman-Ford 算法和 Dijkstra 算法同为解决单源最短路径的算法。对于带权有向图 G = (V, E)，Dijkstra 算法要求图 G 中边的权值均为非负，而 Bellman-Ford 算法能适应一般的情况（即存在负权边的情况）。一个实现的很好的 Dijkstra 算法比 Bellman-Ford 算法的运行时间要低。\n\nBellman-Ford 算法采用动态规划（Dynamic Programming）进行设计，实现的时间复杂度为 O (V*E)，其中 V 为顶点数量，E 为边的数量。Dijkstra 算法采用贪心算法（Greedy Algorithm）范式进行设计，普通实现的时间复杂度为 O (V2)，若基于 Fibonacci heap 的最小优先队列实现版本则时间复杂度为 O (E + VlogV)。\n\nBellman-Ford 算法描述：\n\n * 创建源顶点 v 到图中所有顶点的距离的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；\n * 计算最短路径，执行 V - 1 次遍历；\n * 对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；\n * 检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；\n\n\n# 原理\n\n * 松弛：每次松弛操作实际上是对相邻节点的访问，第 n 次松弛操作保证了所有深度为 n 的路径最短。由于图的最短路径最长不会经过超过∣V∣−1{\\displaystyle |V|-1}∣V∣−1 条边，所以可知贝尔曼 - 福特算法所得为最短路径。\n * 负边权操作：与迪科斯彻算法不同的是，迪科斯彻算法的基本操作 “拓展” 是在深度上寻路，而 “松弛” 操作则是在广度上寻路，这就确定了贝尔曼 - 福特算法可以对负边进行操作而不会影响结果。\n * 负权环判定：因为负权环可以无限制的降低总花费，所以如果发现第 n 次操作仍可降低花销，就一定存在负权环。\n\n\n# 优化\n\n * 循环的提前跳出：在实际操作中，贝尔曼 - 福特算法经常会在未达到 V - 1 次前就出解，其实 V - 1 是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。\n * 队列优化：西南交通大学的段凡丁于 1994 年提出了用队列来优化的算法。松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。原文中提出该算法的复杂度为 O (k|E|)，是个比较小的系数，但该结论未得到广泛认可。参见：最短路径快速算法_百度百科\n\n\n# 演示\n\n参考：\n\n * The Bellman-Ford Algorithm\n * BELLMAN-FORD DEMO\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nThe Bellman–Ford algorithm is an algorithm that computes shortest paths\nfrom a single source vertex to all of the other vertices in a weighted digraph.\nIt also detects negative weight cycle.\n\nComplexity:\n    Worst-case performance O(VE)\n    Best-case performance O(E)\n    Worst-case space complexity O(V)\n\nReference:\n    https://en.wikipedia.org/wiki/Bellman–Ford_algorithm\n    https://cp-algorithms.com/graph/bellman_ford.html\n\n*/\n\n/**\n *\n * @param graph Graph in the format (u, v, w) where\n *  the edge is from vertex u to v. And weight\n *  of the edge is w.\n * @param V Number of vertices in graph\n * @param E Number of edges in graph\n * @param src Starting node\n * @param dest Destination node\n * @returns Shortest distance from source to destination\n */\nfunction BellmanFord (graph, V, E, src, dest) {\n  // Initialize distance of all vertices as infinite.\n  const dis = Array(V).fill(Infinity)\n  // initialize distance of source as 0\n  dis[src] = 0\n\n  // Relax all edges |V| - 1 times. A simple\n  // shortest path from src to any other\n  // vertex can have at-most |V| - 1 edges\n  for (let i = 0; i < V - 1; i++) {\n    for (let j = 0; j < E; j++) {\n      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { \n        dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] \n      }\n    }\n  }\n  // check for negative-weight cycles.\n  for (let i = 0; i < E; i++) {\n    const x = graph[i][0]\n    const y = graph[i][1]\n    const weight = graph[i][2]\n    if ((dis[x] !== Infinity) && (dis[x] + weight < dis[y])) {\n      return null\n    }\n  }\n  for (let i = 0; i < V; i++) {\n    if (i === dest) return dis[i]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 参考\n\n * 贝尔曼 - 福特算法 - 维基百科，自由的百科全书\n * Bellman-ford 算法 - 知乎\n * 贝尔曼 - 福特算法_百度百科\n * 算法系列 —— 贝尔曼福特算法（Bellman-Ford）",normalizedContent:"# 介绍\n\n贝尔曼 - 福特算法（英语：bellman–ford algorithm），求解单源最短路径问题的一种算法。它的原理是对图进行∣v∣−1{\\displaystyle |v|-1}∣v∣−1 次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达o(∣v∣∣e∣)o(|v||e|)o(∣v∣∣e∣)。但算法可以进行若干种优化，提高了效率。\n\nbellman-ford 算法是一种用于计算带权有向图中单源最短路径（sssp：single-source shortest path）的算法。该算法由 richard bellman 和 lester ford 分别发表于 1958 年和 1956 年，而实际上 edward f. moore 也在 1957 年发布了相同的算法，因此，此算法也常被称为 bellman-ford-moore 算法。\n\nbellman-ford 算法和 dijkstra 算法同为解决单源最短路径的算法。对于带权有向图 g = (v, e)，dijkstra 算法要求图 g 中边的权值均为非负，而 bellman-ford 算法能适应一般的情况（即存在负权边的情况）。一个实现的很好的 dijkstra 算法比 bellman-ford 算法的运行时间要低。\n\nbellman-ford 算法采用动态规划（dynamic programming）进行设计，实现的时间复杂度为 o (v*e)，其中 v 为顶点数量，e 为边的数量。dijkstra 算法采用贪心算法（greedy algorithm）范式进行设计，普通实现的时间复杂度为 o (v2)，若基于 fibonacci heap 的最小优先队列实现版本则时间复杂度为 o (e + vlogv)。\n\nbellman-ford 算法描述：\n\n * 创建源顶点 v 到图中所有顶点的距离的集合 distset，为图中的所有顶点指定一个距离值，初始均为 infinite，源顶点距离为 0；\n * 计算最短路径，执行 v - 1 次遍历；\n * 对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；\n * 检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；\n\n\n# 原理\n\n * 松弛：每次松弛操作实际上是对相邻节点的访问，第 n 次松弛操作保证了所有深度为 n 的路径最短。由于图的最短路径最长不会经过超过∣v∣−1{\\displaystyle |v|-1}∣v∣−1 条边，所以可知贝尔曼 - 福特算法所得为最短路径。\n * 负边权操作：与迪科斯彻算法不同的是，迪科斯彻算法的基本操作 “拓展” 是在深度上寻路，而 “松弛” 操作则是在广度上寻路，这就确定了贝尔曼 - 福特算法可以对负边进行操作而不会影响结果。\n * 负权环判定：因为负权环可以无限制的降低总花费，所以如果发现第 n 次操作仍可降低花销，就一定存在负权环。\n\n\n# 优化\n\n * 循环的提前跳出：在实际操作中，贝尔曼 - 福特算法经常会在未达到 v - 1 次前就出解，其实 v - 1 是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。\n * 队列优化：西南交通大学的段凡丁于 1994 年提出了用队列来优化的算法。松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。原文中提出该算法的复杂度为 o (k|e|)，是个比较小的系数，但该结论未得到广泛认可。参见：最短路径快速算法_百度百科\n\n\n# 演示\n\n参考：\n\n * the bellman-ford algorithm\n * bellman-ford demo\n\n\n# 实现\n\n\n# javascript\n\n/*\nthe bellman–ford algorithm is an algorithm that computes shortest paths\nfrom a single source vertex to all of the other vertices in a weighted digraph.\nit also detects negative weight cycle.\n\ncomplexity:\n    worst-case performance o(ve)\n    best-case performance o(e)\n    worst-case space complexity o(v)\n\nreference:\n    https://en.wikipedia.org/wiki/bellman–ford_algorithm\n    https://cp-algorithms.com/graph/bellman_ford.html\n\n*/\n\n/**\n *\n * @param graph graph in the format (u, v, w) where\n *  the edge is from vertex u to v. and weight\n *  of the edge is w.\n * @param v number of vertices in graph\n * @param e number of edges in graph\n * @param src starting node\n * @param dest destination node\n * @returns shortest distance from source to destination\n */\nfunction bellmanford (graph, v, e, src, dest) {\n  // initialize distance of all vertices as infinite.\n  const dis = array(v).fill(infinity)\n  // initialize distance of source as 0\n  dis[src] = 0\n\n  // relax all edges |v| - 1 times. a simple\n  // shortest path from src to any other\n  // vertex can have at-most |v| - 1 edges\n  for (let i = 0; i < v - 1; i++) {\n    for (let j = 0; j < e; j++) {\n      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { \n        dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] \n      }\n    }\n  }\n  // check for negative-weight cycles.\n  for (let i = 0; i < e; i++) {\n    const x = graph[i][0]\n    const y = graph[i][1]\n    const weight = graph[i][2]\n    if ((dis[x] !== infinity) && (dis[x] + weight < dis[y])) {\n      return null\n    }\n  }\n  for (let i = 0; i < v; i++) {\n    if (i === dest) return dis[i]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 参考\n\n * 贝尔曼 - 福特算法 - 维基百科，自由的百科全书\n * bellman-ford 算法 - 知乎\n * 贝尔曼 - 福特算法_百度百科\n * 算法系列 —— 贝尔曼福特算法（bellman-ford）",charsets:{cjk:!0},lastUpdated:"2022/10/17, 12:47:34",lastUpdatedTimestamp:1665982054e3},{title:"FloydWarshall [弗洛伊德算法]",frontmatter:{title:"FloydWarshall [弗洛伊德算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/floydWarshall/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/100.FloydWarshall.html",relativePath:"20.算法/40.Graph 图/100.FloydWarshall.md",key:"v-552817ee",path:"/algorithm/graph/floydWarshall/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:213},{level:2,title:"算法描述",slug:"算法描述",normalizedTitle:"算法描述",charIndex:882},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:1377},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1384},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1391},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2862}],headersStr:"介绍 原理 算法描述 演示 实现 JavaScript 参考",content:"# 介绍\n\nFloyd-Warshall 算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法或佛洛依德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。\n\nFloyd-Warshall 算法的时间复杂度为O(N3)O(N^{3})O(N3)，空间复杂度为O(N2)O(N^{2})O(N2)。\n\n\n# 原理\n\nFloyd-Warshall 算法的原理是动态规划。设 Di,j,kD_{i, j, k}Di,j,k 为从 iii 到 jjj 的只以 (1..k)(1 . . k)(1..k) 集合中的节点为中间节点的最短路径的长度。\n\n * 若最短路径经过点 k\\mathrm{k}k, 则 Di,j,k=Di,k,k−1+Dk,j,k−1D_{i, j, k}=D_{i, k, k-1}+D_{k, j, k-1}Di,j,k =Di,k,k−1 +Dk,j,k−1 ;\n * 若最短路径不经过点 k, 则 Di,j,k=Di,j,k−1D_{i, j, k}=D_{i, j, k-1}Di,j,k =Di,j,k−1 。\n\n因此，Di,j,k=min⁡(Di,j,k−1,Di,k,k−1+Dk,j,k−1)D_{i, j, k}=\\min \\left(D_{i, j, k-1}, D_{i, k, k-1}+D_{k, j, k-1}\\right)Di,j,k =min(Di,j,k−1 ,Di,k,k−1 +Dk,j,k−1 ) 。在实际算法中，为了节约空间，可以直接在原来空间上进行迭代，这样空间可降至二维。\n\n动态规划\n\n动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。\n\n\n# 算法描述\n\nFloyd-Warshall 算法的伪代码描述如下：\n\n// let dist be a |V| × |V| array of minimum distances initialized to ∞ (infinity)\nfor each vertex v\n   dist[v][v] ← 0\nfor each edge (u,v)\n   dist[u][v] ← w(u,v)  // the weight of the edge (u,v)\nfor k from 1 to |V|\n   for i from 1 to |V|\n      for j from 1 to |V|\n         if dist[i][j] > dist[i][k] + dist[k][j] \n             dist[i][j] ← dist[i][k] + dist[k][j]\n         end if\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n其中 dist[i][j] 表示由点 i 到点 j 的代价，当其为 ∞ 表示两点之间没有任何连接。\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  Source:\n    https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n\n  Complexity:\n    O(|V|^3) where V is the set of vertices\n*/\n\nconst FloydWarshall = (dist) => {\n  // Input:- dist: 2D Array where dist[i][j] = edge weight b/w i and j\n  // Output:- dist: 2D Array where dist[i][j] = shortest dist b/w i and j\n  const n = dist.length\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          // dist from i to j via k is lesser than the current distance\n          dist[i][j] = dist[i][k] + dist[k][j]\n        }\n      }\n    }\n  }\n  return dist\n}\n\n// For the following graph (edge weights are shown in brackets)\n//  4       1       dist[1][2] = dist[2][1] = 1\n//   \\  (2)/ \\      dist[1][3] = dist[3][1] = 2\n//    \\   /   \\(1)  dist[1][4] = dist[4][1] = Infinity\n//  (1)\\ /     \\    dist[3][4] = dist[4][3] = 1\n//      3       2   dist[2][4] = dist[4][2] = Infinity\n//                  dist[2][3] = dist[3][2] = Infinity\n// Output should be:\n// [ [0, 1, 2, 3],\n//   [1, 0, 3, 4],\n//   [2, 3, 0, 1],\n//   [3, 4, 1, 0] ]\n\n// FloydWarshall(\n//     [[0, 1, 2, Infinity],\n//       [1, 0, Infinity, Infinity],\n//       [2, Infinity, 0, 1],\n//       [Infinity, Infinity, 1, 0]\n//     ]\n//   )\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n注意：\n\n * 不需要 startNode。\n\n\n# 参考\n\n * Floyd–Warshall algorithm - Wikiwand\n * Floyd-Warshall 算法 - Wikiwand",normalizedContent:"# 介绍\n\nfloyd-warshall 算法（英语：floyd-warshall algorithm），中文亦称弗洛伊德算法或佛洛依德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。\n\nfloyd-warshall 算法的时间复杂度为o(n3)o(n^{3})o(n3)，空间复杂度为o(n2)o(n^{2})o(n2)。\n\n\n# 原理\n\nfloyd-warshall 算法的原理是动态规划。设 di,j,kd_{i, j, k}di,j,k 为从 iii 到 jjj 的只以 (1..k)(1 . . k)(1..k) 集合中的节点为中间节点的最短路径的长度。\n\n * 若最短路径经过点 k\\mathrm{k}k, 则 di,j,k=di,k,k−1+dk,j,k−1d_{i, j, k}=d_{i, k, k-1}+d_{k, j, k-1}di,j,k =di,k,k−1 +dk,j,k−1 ;\n * 若最短路径不经过点 k, 则 di,j,k=di,j,k−1d_{i, j, k}=d_{i, j, k-1}di,j,k =di,j,k−1 。\n\n因此，di,j,k=min⁡(di,j,k−1,di,k,k−1+dk,j,k−1)d_{i, j, k}=\\min \\left(d_{i, j, k-1}, d_{i, k, k-1}+d_{k, j, k-1}\\right)di,j,k =min(di,j,k−1 ,di,k,k−1 +dk,j,k−1 ) 。在实际算法中，为了节约空间，可以直接在原来空间上进行迭代，这样空间可降至二维。\n\n动态规划\n\n动态规划（英语：dynamic programming，简称 dp）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。\n\n\n# 算法描述\n\nfloyd-warshall 算法的伪代码描述如下：\n\n// let dist be a |v| × |v| array of minimum distances initialized to ∞ (infinity)\nfor each vertex v\n   dist[v][v] ← 0\nfor each edge (u,v)\n   dist[u][v] ← w(u,v)  // the weight of the edge (u,v)\nfor k from 1 to |v|\n   for i from 1 to |v|\n      for j from 1 to |v|\n         if dist[i][j] > dist[i][k] + dist[k][j] \n             dist[i][j] ← dist[i][k] + dist[k][j]\n         end if\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n其中 dist[i][j] 表示由点 i 到点 j 的代价，当其为 ∞ 表示两点之间没有任何连接。\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\n/*\n  source:\n    https://en.wikipedia.org/wiki/floyd%e2%80%93warshall_algorithm\n\n  complexity:\n    o(|v|^3) where v is the set of vertices\n*/\n\nconst floydwarshall = (dist) => {\n  // input:- dist: 2d array where dist[i][j] = edge weight b/w i and j\n  // output:- dist: 2d array where dist[i][j] = shortest dist b/w i and j\n  const n = dist.length\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          // dist from i to j via k is lesser than the current distance\n          dist[i][j] = dist[i][k] + dist[k][j]\n        }\n      }\n    }\n  }\n  return dist\n}\n\n// for the following graph (edge weights are shown in brackets)\n//  4       1       dist[1][2] = dist[2][1] = 1\n//   \\  (2)/ \\      dist[1][3] = dist[3][1] = 2\n//    \\   /   \\(1)  dist[1][4] = dist[4][1] = infinity\n//  (1)\\ /     \\    dist[3][4] = dist[4][3] = 1\n//      3       2   dist[2][4] = dist[4][2] = infinity\n//                  dist[2][3] = dist[3][2] = infinity\n// output should be:\n// [ [0, 1, 2, 3],\n//   [1, 0, 3, 4],\n//   [2, 3, 0, 1],\n//   [3, 4, 1, 0] ]\n\n// floydwarshall(\n//     [[0, 1, 2, infinity],\n//       [1, 0, infinity, infinity],\n//       [2, infinity, 0, 1],\n//       [infinity, infinity, 1, 0]\n//     ]\n//   )\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n注意：\n\n * 不需要 startnode。\n\n\n# 参考\n\n * floyd–warshall algorithm - wikiwand\n * floyd-warshall 算法 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 19:00:15",lastUpdatedTimestamp:1666090815e3},{title:"KruskalMST [克鲁斯克尔算法]",frontmatter:{title:"KruskalMST [克鲁斯克尔算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/kruskalMST/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/110.KruskalMST.html",relativePath:"20.算法/40.Graph 图/110.KruskalMST.md",key:"v-ad60b07a",path:"/algorithm/graph/kruskalMST/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:491},{level:2,title:"并查集",slug:"并查集",normalizedTitle:"并查集",charIndex:634},{level:2,title:"不交集森林",slug:"不交集森林",normalizedTitle:"不交集森林",charIndex:1353},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:2706},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1350},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:2720},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:61}],headersStr:"介绍 步骤 并查集 不交集森林 演示 实现 JavaScript 参考",content:"# 介绍\n\nKruskal 演算法是一种用来寻找最小生成树的演算法。最小生成树是一副连通加权无向图中一棵权值最小的生成树，参考最小生成树。用来解决同样问题的还有 Prim 演算法和 Boruvka 演算法（英语：Borůvka's algorithm）等。三种演算法都是贪心算法的应用。和 Boruvka 演算法不同的地方是，Kruskal 演算法在图中存在相同权值的边时也有效。\n\n\n\n平均时间复杂度为O(∣E∣log⁡∣V∣){\\displaystyle \\mathrm {O} (|E|\\log |V|)}O(∣E∣log∣V∣)，其中 E 和 V 分别是图的边集和点集。\n\n贪心算法\n\n贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。\n\n贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。\n\n参考：贪心算法 - Wikiwand\n\n\n# 步骤\n\n * 新建图 G，G 中拥有原图中相同的节点，但没有边\n * 将原图中所有的边按权值从小到大排序\n * 从权值最小的边开始，如果这条边连接的两个节点于图 G 中不在同一个连通分量中，则添加这条边到图 G 中\n * 重复 3，直至图 G 中所有的节点都在同一个连通分量中\n\n\n# 并查集\n\n数学中的并查集：\n\n并查集（Disjoint Set）是指集合彼此相交的的子集结果是一个空集。在集合理论中，有时我们会注意到两个集合中没有共同的元素，这两个集合的交集是一个空集。这种类型的集合被称为并查集。例如，如果我们有 X={a，b，c} 和 Y={d，e，f}，那么我们可以说给定的两个集合是不相交的，因为在这两个集合 X 和 Y 中没有共同的元素。更多关于什么是不相交集，并查集联合（disjoint set union），维恩图，互为并查集（pairwise disjoint set）详细的例子，参见：Disjoint Set - Definition & Examples | Pairwise Disjoint Set。\n\n在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：\n\n * 查询：查询某个元素属于哪个集合，通常是返回集合内的一个 “代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。\n * 合并：将两个集合合并为一个。\n * 添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。\n\n由于支持查询和合并这两种操作，并查集在英文中也被称为联合 - 查找数据结构（Union-find data structure）或者合并 - 查找集合（Merge-find set）。\n\n“并查集” 可以用来指代任何支持上述操作的数据结构，但是一般来说，“并查集” 特指其中最常见的一种实现：不交集森林（Disjoint-set forest）。经过优化的不交集森林有线性的空间复杂度（O (n)，n 为元素数目，下同），以及接近常数的单次操作平均时间复杂度（O(α(n)){\\displaystyle \\mathrm {O} \\left(\\alpha \\left(n\\right)\\right)}O(α(n))，α\\alphaα 为反阿克曼函数），是效率最高的常见数据结构之一。\n\n并查集是用于计算最小生成树的克鲁斯克尔算法中的关键。由于最小生成树在网络路由等场景下十分重要，并查集也得到了广泛的引用。此外，并查集在符号计算，寄存器分配等方面也有应用。\n\n\n# 不交集森林\n\n * 表示：不交集森林把每一个集合以一棵树表示，每一个节点即是一个元素。节点保存着到它的父节点的引用，树的根节点则保存一个空引用或者到自身的引用或者其他无效值，以表示自身为根节点。\n\n * 添加：添加操作 MakeSet (x) 添加一个元素 x，这个元素单独属于一个仅有它自己的集合。在不交集森林中，添加操作仅需将元素标记为根节点。在经过优化的不交集森林中，添加操作还会初始化一些有关节点的信息，例如集合的大小或者秩。\n\n * 查询：在不交集森林中，每个集合的代表即是集合的根节点。查询操作 Find (x) 从 x 开始，根据节点到父节点的引用向根行进，直到找到根节点。\n\n * 路径压缩优化：在集合很大或者树很不平衡时，上述代码的效率很差，最坏情况下（树退化成一条链时），单次查询的时间复杂度高达O(n){\\displaystyle \\mathrm {O} \\left(n\\right)}O(n)。一个常见的优化是路径压缩：在查询时，把被查询的节点到根节点的路径上的所有节点的父节点设置为根结点，从而减小树的高度。也就是说，在向上查询的同时，把在路径上的每个节点都直接连接到根上，以后查询时就能直接查询到根节点。\n\n * 合并：合并操作 Union (x, y) 把元素 x 所在的集合与元素 y 所在的集合合并为一个。合并操作首先找出节点 x 与节点 y 对应的两个根节点，如果两个根节点其实是同一个，则说明元素 x 与元素 y 已经位于同一个集合中，否则，则使其中一个根节点成为另一个的父节点。\n\n * 按秩合并优化：上述代码的问题在于，可能会使得树不平衡，增大树的深度，从而增加查询的耗时。一个控制树的深度的办法是，在合并时，比较两棵树的大小，较大的一棵树的根节点成为合并后的树的根节点，较小的一棵树的根节点则成为前者的子节点。判断树的大小有两种常用的方法，一个是以树中元素的数量作为树的大小，这被称为按大小合并。另一种做法则是使用 “秩” 来比较树的大小。” 秩 “的定义如下：\n   \n   * 只有根节点的树（即只有一个元素的集合），秩为 0；\n   * 当两棵秩不同的树合并后，新的树的秩为原来两棵树的秩的较大者；\n   * 当两棵秩相同的树合并后，新的树的秩为原来的树的秩加一。\n\n图论并查集详解：\n\n参见：\n\n * 并查集 - Wikiwand\n * Disjoint–Set Data Structure (Union–Find Algorithm) | Techie Delight\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\nclass DisjointSetTreeNode {\n  // Disjoint Set Node to store the parent and rank\n  constructor (key) {\n    this.key = key\n    this.parent = this\n    this.rank = 0\n  }\n}\n\nclass DisjointSetTree {\n  // Disjoint Set DataStructure\n  constructor () {\n    // map to from node name to the node object\n    this.map = {}\n  }\n\n  makeSet (x) {\n    // Function to create a new set with x as its member\n    this.map[x] = new DisjointSetTreeNode(x)\n  }\n\n  findSet (x) {\n    // Function to find the set x belongs to (with path-compression)\n    if (this.map[x] !== this.map[x].parent) {\n      this.map[x].parent = this.findSet(this.map[x].parent.key)\n    }\n    return this.map[x].parent\n  }\n\n  union (x, y) {\n    // Function to merge 2 disjoint sets\n    this.link(this.findSet(x), this.findSet(y))\n  }\n\n  link (x, y) {\n    // Helper function for union operation\n    if (x.rank > y.rank) {\n      y.parent = x\n    } else {\n      x.parent = y\n      if (x.rank === y.rank) {\n        y.rank += 1\n      }\n    }\n  }\n}\n\nclass GraphWeightedUndirectedAdjacencyList {\n  // Weighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n    this.nodes = 0\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = {}\n    this.nodes += 1\n  }\n\n  addEdge (node1, node2, weight) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1][node2] = weight\n    this.connections[node2][node1] = weight\n  }\n\n  KruskalMST () {\n    // Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\n    // Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n    // getting the edges in ascending order of weights\n    const edges = []\n    const seen = new Set()\n    for (const start of Object.keys(this.connections)) {\n      for (const end of Object.keys(this.connections[start])) {\n        if (!seen.has(`${start} ${end}`)) {\n          seen.add(`${end} ${start}`)\n          edges.push([start, end, this.connections[start][end]])\n        }\n      }\n    }\n    edges.sort((a, b) => a[2] - b[2])\n    // creating the disjoint set\n    const disjointSet = new DisjointSetTree()\n    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))\n    // MST generation\n    const graph = new GraphWeightedUndirectedAdjacencyList()\n    let numEdges = 0\n    let index = 0\n    while (numEdges < this.nodes - 1) {\n      const [u, v, w] = edges[index]\n      index += 1\n      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {\n        numEdges += 1\n        graph.addEdge(u, v, w)\n        disjointSet.union(u, v)\n      }\n    }\n    return graph\n  }\n}\n// const graph = new GraphWeightedUndirectedAdjacencyList()\n// graph.addEdge(1, 2, 1)\n// graph.addEdge(2, 3, 2)\n// graph.addEdge(3, 4, 1)\n// graph.addEdge(3, 5, 100) // Removed in MST\n// graph.addEdge(4, 5, 5)\n// graph.KruskalMST()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n\n\n\n# 参考\n\n * Kruskal's algorithm - Wikiwand\n * 克鲁斯克尔演算法 - Wikiwand",normalizedContent:"# 介绍\n\nkruskal 演算法是一种用来寻找最小生成树的演算法。最小生成树是一副连通加权无向图中一棵权值最小的生成树，参考最小生成树。用来解决同样问题的还有 prim 演算法和 boruvka 演算法（英语：boruvka's algorithm）等。三种演算法都是贪心算法的应用。和 boruvka 演算法不同的地方是，kruskal 演算法在图中存在相同权值的边时也有效。\n\n\n\n平均时间复杂度为o(∣e∣log⁡∣v∣){\\displaystyle \\mathrm {o} (|e|\\log |v|)}o(∣e∣log∣v∣)，其中 e 和 v 分别是图的边集和点集。\n\n贪心算法\n\n贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。\n\n贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。\n\n参考：贪心算法 - wikiwand\n\n\n# 步骤\n\n * 新建图 g，g 中拥有原图中相同的节点，但没有边\n * 将原图中所有的边按权值从小到大排序\n * 从权值最小的边开始，如果这条边连接的两个节点于图 g 中不在同一个连通分量中，则添加这条边到图 g 中\n * 重复 3，直至图 g 中所有的节点都在同一个连通分量中\n\n\n# 并查集\n\n数学中的并查集：\n\n并查集（disjoint set）是指集合彼此相交的的子集结果是一个空集。在集合理论中，有时我们会注意到两个集合中没有共同的元素，这两个集合的交集是一个空集。这种类型的集合被称为并查集。例如，如果我们有 x={a，b，c} 和 y={d，e，f}，那么我们可以说给定的两个集合是不相交的，因为在这两个集合 x 和 y 中没有共同的元素。更多关于什么是不相交集，并查集联合（disjoint set union），维恩图，互为并查集（pairwise disjoint set）详细的例子，参见：disjoint set - definition & examples | pairwise disjoint set。\n\n在计算机科学中，并查集（英文：disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：\n\n * 查询：查询某个元素属于哪个集合，通常是返回集合内的一个 “代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。\n * 合并：将两个集合合并为一个。\n * 添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。\n\n由于支持查询和合并这两种操作，并查集在英文中也被称为联合 - 查找数据结构（union-find data structure）或者合并 - 查找集合（merge-find set）。\n\n“并查集” 可以用来指代任何支持上述操作的数据结构，但是一般来说，“并查集” 特指其中最常见的一种实现：不交集森林（disjoint-set forest）。经过优化的不交集森林有线性的空间复杂度（o (n)，n 为元素数目，下同），以及接近常数的单次操作平均时间复杂度（o(α(n)){\\displaystyle \\mathrm {o} \\left(\\alpha \\left(n\\right)\\right)}o(α(n))，α\\alphaα 为反阿克曼函数），是效率最高的常见数据结构之一。\n\n并查集是用于计算最小生成树的克鲁斯克尔算法中的关键。由于最小生成树在网络路由等场景下十分重要，并查集也得到了广泛的引用。此外，并查集在符号计算，寄存器分配等方面也有应用。\n\n\n# 不交集森林\n\n * 表示：不交集森林把每一个集合以一棵树表示，每一个节点即是一个元素。节点保存着到它的父节点的引用，树的根节点则保存一个空引用或者到自身的引用或者其他无效值，以表示自身为根节点。\n\n * 添加：添加操作 makeset (x) 添加一个元素 x，这个元素单独属于一个仅有它自己的集合。在不交集森林中，添加操作仅需将元素标记为根节点。在经过优化的不交集森林中，添加操作还会初始化一些有关节点的信息，例如集合的大小或者秩。\n\n * 查询：在不交集森林中，每个集合的代表即是集合的根节点。查询操作 find (x) 从 x 开始，根据节点到父节点的引用向根行进，直到找到根节点。\n\n * 路径压缩优化：在集合很大或者树很不平衡时，上述代码的效率很差，最坏情况下（树退化成一条链时），单次查询的时间复杂度高达o(n){\\displaystyle \\mathrm {o} \\left(n\\right)}o(n)。一个常见的优化是路径压缩：在查询时，把被查询的节点到根节点的路径上的所有节点的父节点设置为根结点，从而减小树的高度。也就是说，在向上查询的同时，把在路径上的每个节点都直接连接到根上，以后查询时就能直接查询到根节点。\n\n * 合并：合并操作 union (x, y) 把元素 x 所在的集合与元素 y 所在的集合合并为一个。合并操作首先找出节点 x 与节点 y 对应的两个根节点，如果两个根节点其实是同一个，则说明元素 x 与元素 y 已经位于同一个集合中，否则，则使其中一个根节点成为另一个的父节点。\n\n * 按秩合并优化：上述代码的问题在于，可能会使得树不平衡，增大树的深度，从而增加查询的耗时。一个控制树的深度的办法是，在合并时，比较两棵树的大小，较大的一棵树的根节点成为合并后的树的根节点，较小的一棵树的根节点则成为前者的子节点。判断树的大小有两种常用的方法，一个是以树中元素的数量作为树的大小，这被称为按大小合并。另一种做法则是使用 “秩” 来比较树的大小。” 秩 “的定义如下：\n   \n   * 只有根节点的树（即只有一个元素的集合），秩为 0；\n   * 当两棵秩不同的树合并后，新的树的秩为原来两棵树的秩的较大者；\n   * 当两棵秩相同的树合并后，新的树的秩为原来的树的秩加一。\n\n图论并查集详解：\n\n参见：\n\n * 并查集 - wikiwand\n * disjoint–set data structure (union–find algorithm) | techie delight\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\nclass disjointsettreenode {\n  // disjoint set node to store the parent and rank\n  constructor (key) {\n    this.key = key\n    this.parent = this\n    this.rank = 0\n  }\n}\n\nclass disjointsettree {\n  // disjoint set datastructure\n  constructor () {\n    // map to from node name to the node object\n    this.map = {}\n  }\n\n  makeset (x) {\n    // function to create a new set with x as its member\n    this.map[x] = new disjointsettreenode(x)\n  }\n\n  findset (x) {\n    // function to find the set x belongs to (with path-compression)\n    if (this.map[x] !== this.map[x].parent) {\n      this.map[x].parent = this.findset(this.map[x].parent.key)\n    }\n    return this.map[x].parent\n  }\n\n  union (x, y) {\n    // function to merge 2 disjoint sets\n    this.link(this.findset(x), this.findset(y))\n  }\n\n  link (x, y) {\n    // helper function for union operation\n    if (x.rank > y.rank) {\n      y.parent = x\n    } else {\n      x.parent = y\n      if (x.rank === y.rank) {\n        y.rank += 1\n      }\n    }\n  }\n}\n\nclass graphweightedundirectedadjacencylist {\n  // weighted undirected graph class\n  constructor () {\n    this.connections = {}\n    this.nodes = 0\n  }\n\n  addnode (node) {\n    // function to add a node to the graph (connection represented by set)\n    this.connections[node] = {}\n    this.nodes += 1\n  }\n\n  addedge (node1, node2, weight) {\n    // function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addnode(node1) }\n    if (!(node2 in this.connections)) { this.addnode(node2) }\n    this.connections[node1][node2] = weight\n    this.connections[node2][node1] = weight\n  }\n\n  kruskalmst () {\n    // kruskal's algorithm to generate a minimum spanning tree (mst) of a graph\n    // details: https://en.wikipedia.org/wiki/kruskal%27s_algorithm\n    // getting the edges in ascending order of weights\n    const edges = []\n    const seen = new set()\n    for (const start of object.keys(this.connections)) {\n      for (const end of object.keys(this.connections[start])) {\n        if (!seen.has(`${start} ${end}`)) {\n          seen.add(`${end} ${start}`)\n          edges.push([start, end, this.connections[start][end]])\n        }\n      }\n    }\n    edges.sort((a, b) => a[2] - b[2])\n    // creating the disjoint set\n    const disjointset = new disjointsettree()\n    object.keys(this.connections).foreach(node => disjointset.makeset(node))\n    // mst generation\n    const graph = new graphweightedundirectedadjacencylist()\n    let numedges = 0\n    let index = 0\n    while (numedges < this.nodes - 1) {\n      const [u, v, w] = edges[index]\n      index += 1\n      if (disjointset.findset(u) !== disjointset.findset(v)) {\n        numedges += 1\n        graph.addedge(u, v, w)\n        disjointset.union(u, v)\n      }\n    }\n    return graph\n  }\n}\n// const graph = new graphweightedundirectedadjacencylist()\n// graph.addedge(1, 2, 1)\n// graph.addedge(2, 3, 2)\n// graph.addedge(3, 4, 1)\n// graph.addedge(3, 5, 100) // removed in mst\n// graph.addedge(4, 5, 5)\n// graph.kruskalmst()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n\n\n\n# 参考\n\n * kruskal's algorithm - wikiwand\n * 克鲁斯克尔演算法 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 19:00:15",lastUpdatedTimestamp:1666090815e3},{title:"NodeNeighbors [节点邻域]",frontmatter:{title:"NodeNeighbors [节点邻域]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/nodeNeighbors/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/120.NodeNeighbors.html",relativePath:"20.算法/40.Graph 图/120.NodeNeighbors.md",key:"v-272cc03f",path:"/algorithm/graph/nodeNeighbors/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:118},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:125},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1223}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在图论中，图中一个顶点 v 的相邻顶点是指通过一条边与 v 相连的顶点。图 G 中一个顶点 v 的邻域是由与 v 相邻的所有顶点所引起的 G 的子图，即由与 v 相邻的顶点和连接与 v 相邻的顶点的所有边组成的图。\n\n\n# 实现\n\n\n# JavaScript\n\n// https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)\n\nclass Graph {\n  // Generic graph: the algorithm works regardless of direction or weight\n  constructor () {\n    this.edges = []\n  }\n\n  addEdge (node1, node2) {\n    // Adding edges to the graph\n    this.edges.push({\n      node1,\n      node2\n    })\n  }\n\n  nodeNeighbors (node) {\n    // Returns an array with all of the node neighbors\n    const neighbors = new Set()\n    for (const edge of this.edges) {\n      // Checks if they have an edge between them and if the neighbor is not\n      // already in the neighbors array\n      if (edge.node1 === node && !(neighbors.has(edge.node2))) {\n        neighbors.add(edge.node2)\n      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {\n        neighbors.add(edge.node1)\n      }\n    }\n    return neighbors\n  }\n}\n\n// const graph = new Graph()\n// graph.addEdge(1, 2)\n// graph.addEdge(2, 3)\n// graph.addEdge(3, 5)\n// graph.addEdge(1, 5)\n// graph.nodeNeighbors(1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 参考\n\n * Neighbourhood (graph theory) - Wikiwand",normalizedContent:"# 介绍\n\n在图论中，图中一个顶点 v 的相邻顶点是指通过一条边与 v 相连的顶点。图 g 中一个顶点 v 的邻域是由与 v 相邻的所有顶点所引起的 g 的子图，即由与 v 相邻的顶点和连接与 v 相邻的顶点的所有边组成的图。\n\n\n# 实现\n\n\n# javascript\n\n// https://en.wikipedia.org/wiki/neighbourhood_(graph_theory)\n\nclass graph {\n  // generic graph: the algorithm works regardless of direction or weight\n  constructor () {\n    this.edges = []\n  }\n\n  addedge (node1, node2) {\n    // adding edges to the graph\n    this.edges.push({\n      node1,\n      node2\n    })\n  }\n\n  nodeneighbors (node) {\n    // returns an array with all of the node neighbors\n    const neighbors = new set()\n    for (const edge of this.edges) {\n      // checks if they have an edge between them and if the neighbor is not\n      // already in the neighbors array\n      if (edge.node1 === node && !(neighbors.has(edge.node2))) {\n        neighbors.add(edge.node2)\n      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {\n        neighbors.add(edge.node1)\n      }\n    }\n    return neighbors\n  }\n}\n\n// const graph = new graph()\n// graph.addedge(1, 2)\n// graph.addedge(2, 3)\n// graph.addedge(3, 5)\n// graph.addedge(1, 5)\n// graph.nodeneighbors(1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 参考\n\n * neighbourhood (graph theory) - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 19:00:15",lastUpdatedTimestamp:1666090815e3},{title:"NumberOfIslands [岛屿数量]",frontmatter:{title:"NumberOfIslands [岛屿数量]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/numberOfIslands/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/130.NumberOfIslands.html",relativePath:"20.算法/40.Graph 图/130.NumberOfIslands.md",key:"v-40614603",path:"/algorithm/graph/numberOfIslands/",headers:[{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:417},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1047},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1054},{level:3,title:"Python",slug:"python",normalizedTitle:"python",charIndex:3318},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4508}],headersStr:"问题 伪代码 实现 JavaScript Python 参考",content:"# 问题\n\n给定一个由 0 和 1 组成的 2 维数组矩阵，计算 1 的岛屿的数量。一个岛被一组相邻的单元格所包围，这些单元格都是 1。一个单元格只能在水平和垂直方向上相邻。\n\ninput:  binaryMatrix = [ [0,    1,    0,    1,    0],\n                         [0,    0,    1,    1,    1],\n                         [1,    0,    0,    1,    0],\n                         [0,    1,    1,    0,    0],\n                         [1,    0,    1,    0,    1] ]\n\noutput: 6  # there are six islands\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 伪代码\n\ndef main():\n    visited [] # array to keep track of visited cell\n    num_islands = 0 # start with zero\n    for each row, col in matrix\n          num_island += get_number_of_islands(matrix, row, col) #return 1 if it is an island\nreturn num_island\ndef get_number_of_islands(matrix, row, col, visited):\n    check if row and col is out of bound of the matrix\n    check if we already visited the cell with row, col\n    check if the cell is 0\n    => return 0\n\n    mark the cell as visited in the visited array\n    recursive call get_number_of_islands() on each adjacent cell\n    return 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 实现\n\n\n# JavaScript\n\n/* Number of Islands\nhttps://dev.to/rattanakchea/amazons-interview-question-count-island-21h6\nGiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\na two dimensional grid map\neach element is going to represent a piece of land\n1 is land,\n0 is water\noutput a number which is the number of islands\n\nExample 1:\n  Input:\n  11110\n  11010\n  11000\n  00000\n\n  Output: 1\n\nExample 2:\n  Input:\n  11000\n  11000\n  00100\n  00011\n\n  Output: 3\n\nI: two dimensional array\nO: a single integer; total number of islands\n\nPseudocode:\n  OUTER FUNCTION\n    set count to 0\n\n    INNER FUNCTION - flood (col, row)\n      if the tile is water\n        return\n      make tile water(flood tile)\n      invoke flood on the neighbor coordinates\n\n    iterate over the matrix (col, row)\n      if the current element is a 1\n        increment count\n        invoke flood (coordinates for col and row)\n\n    Return the count\n*/\n\nconst islands = (matrixGrid) => {\n  const matrix = matrixGrid\n  let counter = 0\n\n  const flood = (row, col) => {\n    if (row < 0 || col < 0) return // Off the map above or left\n    if (row >= matrix.length || col >= matrix[row].length) return // Off the map below or right\n\n    const tile = matrix[row][col]\n    if (tile !== '1') return\n\n    matrix[row][col] = '0'\n\n    flood(row + 1, col) // Down\n    flood(row - 1, col) // Up\n    flood(row, col + 1) // Right\n    flood(row, col - 1) // Left\n  }\n\n  for (let row = 0; row < matrix.length; row += 1) {\n    for (let col = 0; col < matrix[row].length; col += 1) {\n      const current = matrix[row][col]\n      if (current === '1') {\n        flood(row, col)\n        counter += 1\n      }\n    }\n  }\n  return counter\n}\n\n// islands(\n//   ['1', '1', '0', '0', '0'],\n//   ['1', '1', '0', '0', '0'],\n//   ['0', '0', '1', '0', '0'],\n//   ['0', '0', '0', '1', '1']\n// )\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# Python\n\ndef get_number_of_islands(binaryMatrix):\n    rows = len(binaryMatrix)\n    cols = len(binaryMatrix[0])\n    # you can use Set if you like\n    # or change the content of binaryMatrix as it is visited\n    visited = [[0 for col in range(cols)] for r in range(rows)]\n    number_of_island = 0\n    for row in range(rows):\n        for col in range(cols):\n            number_of_island += get_island(binaryMatrix, row, col, visited)\n    return number_of_island\n\n\n# get a continuous island\ndef get_island(binaryMatrix, row, col, visited):\n    if not is_valid(binaryMatrix, row, col)\n        or visited[row][col] == 1 or binaryMatrix[row][col] == 0:\n        return 0\n\n    # mark as visited\n    visited[row][col] = 1\n    get_island(binaryMatrix, row, col + 1, visited)\n    get_island(binaryMatrix, row, col - 1, visited)\n    get_island(binaryMatrix, row + 1, col, visited)\n    get_island(binaryMatrix, row - 1, col, visited)\n    return 1\n\n\ndef is_valid(binaryMatrix, row, col):\n    rows = len(binaryMatrix)\n    cols = len(binaryMatrix[0])\n    return row >= 0 and row < rows and col >= 0 and col < cols\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * Amazon's Interview Question: Count Island - DEV Community 👩‍💻👨‍💻\n * FloodFill [Flood Fill 算法] | Fancy DSA",normalizedContent:"# 问题\n\n给定一个由 0 和 1 组成的 2 维数组矩阵，计算 1 的岛屿的数量。一个岛被一组相邻的单元格所包围，这些单元格都是 1。一个单元格只能在水平和垂直方向上相邻。\n\ninput:  binarymatrix = [ [0,    1,    0,    1,    0],\n                         [0,    0,    1,    1,    1],\n                         [1,    0,    0,    1,    0],\n                         [0,    1,    1,    0,    0],\n                         [1,    0,    1,    0,    1] ]\n\noutput: 6  # there are six islands\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 伪代码\n\ndef main():\n    visited [] # array to keep track of visited cell\n    num_islands = 0 # start with zero\n    for each row, col in matrix\n          num_island += get_number_of_islands(matrix, row, col) #return 1 if it is an island\nreturn num_island\ndef get_number_of_islands(matrix, row, col, visited):\n    check if row and col is out of bound of the matrix\n    check if we already visited the cell with row, col\n    check if the cell is 0\n    => return 0\n\n    mark the cell as visited in the visited array\n    recursive call get_number_of_islands() on each adjacent cell\n    return 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 实现\n\n\n# javascript\n\n/* number of islands\nhttps://dev.to/rattanakchea/amazons-interview-question-count-island-21h6\ngiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. an island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. you may assume all four edges of the grid are all surrounded by water.\n\na two dimensional grid map\neach element is going to represent a piece of land\n1 is land,\n0 is water\noutput a number which is the number of islands\n\nexample 1:\n  input:\n  11110\n  11010\n  11000\n  00000\n\n  output: 1\n\nexample 2:\n  input:\n  11000\n  11000\n  00100\n  00011\n\n  output: 3\n\ni: two dimensional array\no: a single integer; total number of islands\n\npseudocode:\n  outer function\n    set count to 0\n\n    inner function - flood (col, row)\n      if the tile is water\n        return\n      make tile water(flood tile)\n      invoke flood on the neighbor coordinates\n\n    iterate over the matrix (col, row)\n      if the current element is a 1\n        increment count\n        invoke flood (coordinates for col and row)\n\n    return the count\n*/\n\nconst islands = (matrixgrid) => {\n  const matrix = matrixgrid\n  let counter = 0\n\n  const flood = (row, col) => {\n    if (row < 0 || col < 0) return // off the map above or left\n    if (row >= matrix.length || col >= matrix[row].length) return // off the map below or right\n\n    const tile = matrix[row][col]\n    if (tile !== '1') return\n\n    matrix[row][col] = '0'\n\n    flood(row + 1, col) // down\n    flood(row - 1, col) // up\n    flood(row, col + 1) // right\n    flood(row, col - 1) // left\n  }\n\n  for (let row = 0; row < matrix.length; row += 1) {\n    for (let col = 0; col < matrix[row].length; col += 1) {\n      const current = matrix[row][col]\n      if (current === '1') {\n        flood(row, col)\n        counter += 1\n      }\n    }\n  }\n  return counter\n}\n\n// islands(\n//   ['1', '1', '0', '0', '0'],\n//   ['1', '1', '0', '0', '0'],\n//   ['0', '0', '1', '0', '0'],\n//   ['0', '0', '0', '1', '1']\n// )\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\n\n# python\n\ndef get_number_of_islands(binarymatrix):\n    rows = len(binarymatrix)\n    cols = len(binarymatrix[0])\n    # you can use set if you like\n    # or change the content of binarymatrix as it is visited\n    visited = [[0 for col in range(cols)] for r in range(rows)]\n    number_of_island = 0\n    for row in range(rows):\n        for col in range(cols):\n            number_of_island += get_island(binarymatrix, row, col, visited)\n    return number_of_island\n\n\n# get a continuous island\ndef get_island(binarymatrix, row, col, visited):\n    if not is_valid(binarymatrix, row, col)\n        or visited[row][col] == 1 or binarymatrix[row][col] == 0:\n        return 0\n\n    # mark as visited\n    visited[row][col] = 1\n    get_island(binarymatrix, row, col + 1, visited)\n    get_island(binarymatrix, row, col - 1, visited)\n    get_island(binarymatrix, row + 1, col, visited)\n    get_island(binarymatrix, row - 1, col, visited)\n    return 1\n\n\ndef is_valid(binarymatrix, row, col):\n    rows = len(binarymatrix)\n    cols = len(binarymatrix[0])\n    return row >= 0 and row < rows and col >= 0 and col < cols\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * amazon's interview question: count island - dev community 👩‍💻👨‍💻\n * floodfill [flood fill 算法] | fancy dsa",charsets:{cjk:!0},lastUpdated:"2022/10/18, 19:00:15",lastUpdatedTimestamp:1666090815e3},{title:"PrimMST [普林姆算法]",frontmatter:{title:"PrimMST [普林姆算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/primMST/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/140.PrimMST.html",relativePath:"20.算法/40.Graph 图/140.PrimMST.md",key:"v-f2614c1e",path:"/algorithm/graph/primMST/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:156},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:768},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:775},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:782},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:8139}],headersStr:"介绍 描述 演示 实现 JavaScript 参考",content:"# 介绍\n\n普里姆算法（Prim's algorithm）是图论中的一种贪心算法，可在一个加权连通图中找到其最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。在某些场合，普里姆算法又被称为 DJP 算法、亚尔尼克算法或普里姆－亚尔尼克算法。\n\n\n# 描述\n\n从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。\n\n * 输入：一个加权连通图，其中顶点集合为 VVV, 边集合为 EEE;\n * 初始化: Vnew ={x}V_{\\text {new }}=\\{x\\}Vnew  ={x}, 其中 xxx 为集合 VVV 中的任一节点（起始点）, Enew ={}E_{\\text {new }}=\\{\\}Enew  ={}\n * 重复下列操作，直到 Vnew =VV_{\\text {new }}=VVnew  =V :\n   * 在集合 EEE 中选取权值最小的边 (u,v)(u, v)(u,v), 其中 uuu 为集合 Vnew V_{\\text {new }}Vnew  中的元素，而 vvv 则 是 VVV 中没有加入 Vnew V_{\\text {new }}Vnew  的顶点 (如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）;\n   * 将 vvv 加入集合 Vnew V_{\\text {new }}Vnew  中，将 (u,v)(u, v)(u,v) 加入集合 Enew E_{\\text {new }}Enew  中；\n * 输出：使用集合 Vnew V_{\\text {new }}Vnew  和 Enew E_{\\text {new }}Enew  来描述所得到的最小生成树。\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\n// Priority Queue Helper functions\nfunction getParentPosition (position) {\n  // Get the parent node of the current node\n  return Math.floor((position - 1) / 2)\n}\nfunction getChildrenPosition (position) {\n  // Get the children nodes of the current node\n  return [2 * position + 1, 2 * position + 2]\n}\n\nclass PriorityQueue {\n  // Priority Queue class using Minimum Binary Heap\n  constructor () {\n    this._heap = []\n    this.keys = {}\n  }\n\n  isEmpty () {\n    // Checking if the heap is empty\n    return this._heap.length === 0\n  }\n\n  push (key, priority) {\n    // Adding element to the queue (equivalent to add)\n    this._heap.push([key, priority])\n    this.keys[key] = this._heap.length - 1\n    this._shiftUp(this.keys[key])\n  }\n\n  pop () {\n    // Removing the element with least priority (equivalent to extractMin)\n    this._swap(0, this._heap.length - 1)\n    const [key] = this._heap.pop()\n    delete this.keys[key]\n    this._shiftDown(0)\n    return key\n  }\n\n  contains (key) {\n    // Check if a given key is present in the queue\n    return (key in this.keys)\n  }\n\n  update (key, priority) {\n    // Update the priority of the given element (equivalent to decreaseKey)\n    const currPos = this.keys[key]\n    this._heap[currPos][1] = priority\n    const parentPos = getParentPosition(currPos)\n    const currPriority = this._heap[currPos][1]\n    let parentPriority = Infinity\n    if (parentPos >= 0) {\n      parentPriority = this._heap[parentPos][1]\n    }\n    const [child1Pos, child2Pos] = getChildrenPosition(currPos)\n    let [child1Priority, child2Priority] = [Infinity, Infinity]\n    if (child1Pos < this._heap.length) {\n      child1Priority = this._heap[child1Pos][1]\n    }\n    if (child2Pos < this._heap.length) {\n      child2Priority = this._heap[child2Pos][1]\n    }\n\n    if (parentPos >= 0 && parentPriority > currPriority) {\n      this._shiftUp(currPos)\n    } else if (child2Pos < this._heap.length &&\n      (child1Priority < currPriority || child2Priority < currPriority)) {\n      this._shiftDown(currPos)\n    }\n  }\n\n  _shiftUp (position) {\n    // Helper function to shift up a node to proper position (equivalent to bubbleUp)\n    let currPos = position\n    let parentPos = getParentPosition(currPos)\n    let currPriority = this._heap[currPos][1]\n    let parentPriority = Infinity\n    if (parentPos >= 0) {\n      parentPriority = this._heap[parentPos][1]\n    }\n\n    while (parentPos >= 0 && parentPriority > currPriority) {\n      this._swap(currPos, parentPos)\n      currPos = parentPos\n      parentPos = getParentPosition(currPos)\n      currPriority = this._heap[currPos][1]\n      try {\n        parentPriority = this._heap[parentPos][1]\n      } catch (error) {\n        parentPriority = Infinity\n      }\n    }\n    this.keys[this._heap[currPos][0]] = currPos\n  }\n\n  _shiftDown (position) {\n    // Helper function to shift down a node to proper position (equivalent to bubbleDown)\n    let currPos = position\n    let [child1Pos, child2Pos] = getChildrenPosition(currPos)\n    let [child1Priority, child2Priority] = [Infinity, Infinity]\n    if (child1Pos < this._heap.length) {\n      child1Priority = this._heap[child1Pos][1]\n    }\n    if (child2Pos < this._heap.length) {\n      child2Priority = this._heap[child2Pos][1]\n    }\n    let currPriority\n    try {\n      currPriority = this._heap[currPos][1]\n    } catch {\n      return\n    }\n\n    while (child2Pos < this._heap.length &&\n      (child1Priority < currPriority || child2Priority < currPriority)) {\n      if (child1Priority < currPriority && child1Priority < child2Priority) {\n        this._swap(child1Pos, currPos)\n        currPos = child1Pos\n      } else {\n        this._swap(child2Pos, currPos)\n        currPos = child2Pos\n      }\n      [child1Pos, child2Pos] = getChildrenPosition(currPos)\n      try {\n        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]\n      } catch (error) {\n        [child1Priority, child2Priority] = [Infinity, Infinity]\n      }\n\n      currPriority = this._heap[currPos][1]\n    }\n    this.keys[this._heap[currPos][0]] = currPos\n    if (child1Pos < this._heap.length && child1Priority < currPriority) {\n      this._swap(child1Pos, currPos)\n      this.keys[this._heap[child1Pos][0]] = child1Pos\n    }\n  }\n\n  _swap (position1, position2) {\n    // Helper function to swap 2 nodes\n    [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]\n    this.keys[this._heap[position1][0]] = position1\n    this.keys[this._heap[position2][0]] = position2\n  }\n}\n\nclass GraphWeightedUndirectedAdjacencyList {\n  // Weighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = {}\n  }\n\n  addEdge (node1, node2, weight) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1][node2] = weight\n    this.connections[node2][node1] = weight\n  }\n\n  PrimMST (start) {\n    // Prim's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\n    // Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    const distance = {}\n    const parent = {}\n    const priorityQueue = new PriorityQueue()\n    // Initialization\n    for (const node in this.connections) {\n      distance[node] = (node === start.toString() ? 0 : Infinity)\n      parent[node] = null\n      priorityQueue.push(node, distance[node])\n    }\n    // Updating 'distance' object\n    while (!priorityQueue.isEmpty()) {\n      const node = priorityQueue.pop()\n      Object.keys(this.connections[node]).forEach(neighbour => {\n        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {\n          distance[neighbour] = distance[node] + this.connections[node][neighbour]\n          parent[neighbour] = node\n          priorityQueue.update(neighbour, distance[neighbour])\n        }\n      })\n    }\n\n    // MST Generation from the 'parent' object\n    const graph = new GraphWeightedUndirectedAdjacencyList()\n    Object.keys(parent).forEach(node => {\n      if (node && parent[node]) {\n        graph.addEdge(node, parent[node], this.connections[node][parent[node]])\n      }\n    })\n    return graph\n  }\n}\n\n// const graph = new GraphWeightedUndirectedAdjacencyList()\n// graph.addEdge(1, 2, 1)\n// graph.addEdge(2, 3, 2)\n// graph.addEdge(3, 4, 1)\n// graph.addEdge(3, 5, 100) // Removed in MST\n// graph.addEdge(4, 5, 5)\n// graph.PrimMST(1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n\n\n\n# 参考\n\n * Prim's algorithm - Wikiwand\n * 普里姆算法 - Wikiwand\n * Prim MST Visualzation",normalizedContent:"# 介绍\n\n普里姆算法（prim's algorithm）是图论中的一种贪心算法，可在一个加权连通图中找到其最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。在某些场合，普里姆算法又被称为 djp 算法、亚尔尼克算法或普里姆－亚尔尼克算法。\n\n\n# 描述\n\n从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。\n\n * 输入：一个加权连通图，其中顶点集合为 vvv, 边集合为 eee;\n * 初始化: vnew ={x}v_{\\text {new }}=\\{x\\}vnew  ={x}, 其中 xxx 为集合 vvv 中的任一节点（起始点）, enew ={}e_{\\text {new }}=\\{\\}enew  ={}\n * 重复下列操作，直到 vnew =vv_{\\text {new }}=vvnew  =v :\n   * 在集合 eee 中选取权值最小的边 (u,v)(u, v)(u,v), 其中 uuu 为集合 vnew v_{\\text {new }}vnew  中的元素，而 vvv 则 是 vvv 中没有加入 vnew v_{\\text {new }}vnew  的顶点 (如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）;\n   * 将 vvv 加入集合 vnew v_{\\text {new }}vnew  中，将 (u,v)(u, v)(u,v) 加入集合 enew e_{\\text {new }}enew  中；\n * 输出：使用集合 vnew v_{\\text {new }}vnew  和 enew e_{\\text {new }}enew  来描述所得到的最小生成树。\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\n// priority queue helper functions\nfunction getparentposition (position) {\n  // get the parent node of the current node\n  return math.floor((position - 1) / 2)\n}\nfunction getchildrenposition (position) {\n  // get the children nodes of the current node\n  return [2 * position + 1, 2 * position + 2]\n}\n\nclass priorityqueue {\n  // priority queue class using minimum binary heap\n  constructor () {\n    this._heap = []\n    this.keys = {}\n  }\n\n  isempty () {\n    // checking if the heap is empty\n    return this._heap.length === 0\n  }\n\n  push (key, priority) {\n    // adding element to the queue (equivalent to add)\n    this._heap.push([key, priority])\n    this.keys[key] = this._heap.length - 1\n    this._shiftup(this.keys[key])\n  }\n\n  pop () {\n    // removing the element with least priority (equivalent to extractmin)\n    this._swap(0, this._heap.length - 1)\n    const [key] = this._heap.pop()\n    delete this.keys[key]\n    this._shiftdown(0)\n    return key\n  }\n\n  contains (key) {\n    // check if a given key is present in the queue\n    return (key in this.keys)\n  }\n\n  update (key, priority) {\n    // update the priority of the given element (equivalent to decreasekey)\n    const currpos = this.keys[key]\n    this._heap[currpos][1] = priority\n    const parentpos = getparentposition(currpos)\n    const currpriority = this._heap[currpos][1]\n    let parentpriority = infinity\n    if (parentpos >= 0) {\n      parentpriority = this._heap[parentpos][1]\n    }\n    const [child1pos, child2pos] = getchildrenposition(currpos)\n    let [child1priority, child2priority] = [infinity, infinity]\n    if (child1pos < this._heap.length) {\n      child1priority = this._heap[child1pos][1]\n    }\n    if (child2pos < this._heap.length) {\n      child2priority = this._heap[child2pos][1]\n    }\n\n    if (parentpos >= 0 && parentpriority > currpriority) {\n      this._shiftup(currpos)\n    } else if (child2pos < this._heap.length &&\n      (child1priority < currpriority || child2priority < currpriority)) {\n      this._shiftdown(currpos)\n    }\n  }\n\n  _shiftup (position) {\n    // helper function to shift up a node to proper position (equivalent to bubbleup)\n    let currpos = position\n    let parentpos = getparentposition(currpos)\n    let currpriority = this._heap[currpos][1]\n    let parentpriority = infinity\n    if (parentpos >= 0) {\n      parentpriority = this._heap[parentpos][1]\n    }\n\n    while (parentpos >= 0 && parentpriority > currpriority) {\n      this._swap(currpos, parentpos)\n      currpos = parentpos\n      parentpos = getparentposition(currpos)\n      currpriority = this._heap[currpos][1]\n      try {\n        parentpriority = this._heap[parentpos][1]\n      } catch (error) {\n        parentpriority = infinity\n      }\n    }\n    this.keys[this._heap[currpos][0]] = currpos\n  }\n\n  _shiftdown (position) {\n    // helper function to shift down a node to proper position (equivalent to bubbledown)\n    let currpos = position\n    let [child1pos, child2pos] = getchildrenposition(currpos)\n    let [child1priority, child2priority] = [infinity, infinity]\n    if (child1pos < this._heap.length) {\n      child1priority = this._heap[child1pos][1]\n    }\n    if (child2pos < this._heap.length) {\n      child2priority = this._heap[child2pos][1]\n    }\n    let currpriority\n    try {\n      currpriority = this._heap[currpos][1]\n    } catch {\n      return\n    }\n\n    while (child2pos < this._heap.length &&\n      (child1priority < currpriority || child2priority < currpriority)) {\n      if (child1priority < currpriority && child1priority < child2priority) {\n        this._swap(child1pos, currpos)\n        currpos = child1pos\n      } else {\n        this._swap(child2pos, currpos)\n        currpos = child2pos\n      }\n      [child1pos, child2pos] = getchildrenposition(currpos)\n      try {\n        [child1priority, child2priority] = [this._heap[child1pos][1], this._heap[child2pos][1]]\n      } catch (error) {\n        [child1priority, child2priority] = [infinity, infinity]\n      }\n\n      currpriority = this._heap[currpos][1]\n    }\n    this.keys[this._heap[currpos][0]] = currpos\n    if (child1pos < this._heap.length && child1priority < currpriority) {\n      this._swap(child1pos, currpos)\n      this.keys[this._heap[child1pos][0]] = child1pos\n    }\n  }\n\n  _swap (position1, position2) {\n    // helper function to swap 2 nodes\n    [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]\n    this.keys[this._heap[position1][0]] = position1\n    this.keys[this._heap[position2][0]] = position2\n  }\n}\n\nclass graphweightedundirectedadjacencylist {\n  // weighted undirected graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addnode (node) {\n    // function to add a node to the graph (connection represented by set)\n    this.connections[node] = {}\n  }\n\n  addedge (node1, node2, weight) {\n    // function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addnode(node1) }\n    if (!(node2 in this.connections)) { this.addnode(node2) }\n    this.connections[node1][node2] = weight\n    this.connections[node2][node1] = weight\n  }\n\n  primmst (start) {\n    // prim's algorithm to generate a minimum spanning tree (mst) of a graph\n    // details: https://en.wikipedia.org/wiki/prim%27s_algorithm\n    const distance = {}\n    const parent = {}\n    const priorityqueue = new priorityqueue()\n    // initialization\n    for (const node in this.connections) {\n      distance[node] = (node === start.tostring() ? 0 : infinity)\n      parent[node] = null\n      priorityqueue.push(node, distance[node])\n    }\n    // updating 'distance' object\n    while (!priorityqueue.isempty()) {\n      const node = priorityqueue.pop()\n      object.keys(this.connections[node]).foreach(neighbour => {\n        if (priorityqueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {\n          distance[neighbour] = distance[node] + this.connections[node][neighbour]\n          parent[neighbour] = node\n          priorityqueue.update(neighbour, distance[neighbour])\n        }\n      })\n    }\n\n    // mst generation from the 'parent' object\n    const graph = new graphweightedundirectedadjacencylist()\n    object.keys(parent).foreach(node => {\n      if (node && parent[node]) {\n        graph.addedge(node, parent[node], this.connections[node][parent[node]])\n      }\n    })\n    return graph\n  }\n}\n\n// const graph = new graphweightedundirectedadjacencylist()\n// graph.addedge(1, 2, 1)\n// graph.addedge(2, 3, 2)\n// graph.addedge(3, 4, 1)\n// graph.addedge(3, 5, 100) // removed in mst\n// graph.addedge(4, 5, 5)\n// graph.primmst(1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n\n\n\n# 参考\n\n * prim's algorithm - wikiwand\n * 普里姆算法 - wikiwand\n * prim mst visualzation",charsets:{cjk:!0},lastUpdated:"2022/10/18, 20:15:06",lastUpdatedTimestamp:1666095306e3},{title:"BreadthFirstSearch [广度优先搜索/BFS]",frontmatter:{title:"BreadthFirstSearch [广度优先搜索/BFS]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/breadthFirstSearch/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/20.BreadthFirstSearch.html",relativePath:"20.算法/40.Graph 图/20.BreadthFirstSearch.md",key:"v-5adb5772",path:"/algorithm/graph/breadthFirstSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:157},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:131},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:231},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1406}],headersStr:"介绍 演示 实现 JavaScript 参考",content:"# 介绍\n\n广度优先搜索算法（英语：Breadth-First Search，缩写为 BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索演算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用 open-closed 表。\n\n\n# 演示\n\n * Breadth-First Search【双语 cc 字幕】\n\n * 图的遍历 (广度优先搜索、深度优先搜索）\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Breadth-first search is an algorithm for traversing a graph.\n *\n * It discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present\n * depth prior to moving on to the nodes at the next depth level.\n *\n * (description adapted from https://en.wikipedia.org/wiki/Breadth-first_search)\n * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\n */\nexport function breadthFirstSearch (graph, startingNode) {\n  // visited keeps track of all nodes visited\n  const visited = new Set()\n\n  // queue contains the nodes to be explored in the future\n  const queue = [startingNode]\n\n  while (queue.length > 0) {\n    // start with the queue's first node\n    const node = queue.shift()\n\n    if (!visited.has(node)) {\n      // mark the node as visited\n      visited.add(node)\n      const neighbors = graph[node]\n\n      // put all its neighbors into the queue\n      for (let i = 0; i < neighbors.length; i++) {\n        queue.push(neighbors[i])\n      }\n    }\n  }\n\n  return visited\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参考\n\n * Breadth-first search - Wikiwand\n * 广度优先搜索 - Wikiwand",normalizedContent:"# 介绍\n\n广度优先搜索算法（英语：breadth-first search，缩写为 bfs），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索演算法。简单的说，bfs 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用 open-closed 表。\n\n\n# 演示\n\n * breadth-first search【双语 cc 字幕】\n\n * 图的遍历 (广度优先搜索、深度优先搜索）\n\n\n# 实现\n\n\n# javascript\n\n/**\n * breadth-first search is an algorithm for traversing a graph.\n *\n * it discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present\n * depth prior to moving on to the nodes at the next depth level.\n *\n * (description adapted from https://en.wikipedia.org/wiki/breadth-first_search)\n * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\n */\nexport function breadthfirstsearch (graph, startingnode) {\n  // visited keeps track of all nodes visited\n  const visited = new set()\n\n  // queue contains the nodes to be explored in the future\n  const queue = [startingnode]\n\n  while (queue.length > 0) {\n    // start with the queue's first node\n    const node = queue.shift()\n\n    if (!visited.has(node)) {\n      // mark the node as visited\n      visited.add(node)\n      const neighbors = graph[node]\n\n      // put all its neighbors into the queue\n      for (let i = 0; i < neighbors.length; i++) {\n        queue.push(neighbors[i])\n      }\n    }\n  }\n\n  return visited\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参考\n\n * breadth-first search - wikiwand\n * 广度优先搜索 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/17, 12:47:34",lastUpdatedTimestamp:1665982054e3},{title:"BreadthFirstShortestPath [广度优先寻最短路径]",frontmatter:{title:"BreadthFirstShortestPath [广度优先寻最短路径]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/breadthFirstShortestPath/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/30.BreadthFirstShortestPath.html",relativePath:"20.算法/40.Graph 图/30.BreadthFirstShortestPath.md",key:"v-69d870f7",path:"/algorithm/graph/breadthFirstShortestPath/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:540},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:590},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:597},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2370},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2409}],headersStr:"介绍 演示 实现 JavaScript 扩展 参考",content:"# 介绍\n\nBFS 能用于寻找图中的最短路径，除非：\n\n * 不存在循环\n * 所有的边都有相同的权重或没有权重。\n\n为了找到最短的路径，你所要做的就是从源头开始，进行广度优先的搜索，当你找到目标节点时就停止。你唯一需要做的是有一个数组 previous [n]，它将存储每个被访问节点的前一个节点。源的前一个节点可以是空的。要打印路径，只需从源点开始循环浏览 previous [] 数组，直到到达目标节点。在类似条件下，DFS 也可以用来寻找图中的最短路径。\n\n但是，如果图形更复杂，包含加权边和循环，那么我们就需要一个更复杂的 BFS 版本，即 Dijkstra 的算法。\n\n如果我们想在一个无向的、无权重的图中找到最短路径（undirected, unweighted graph），那么 BFS 就是要使用的算法。BFS 的主张是，在遍历过程中第一次发现一个节点时，该节点与源头的距离即为最短路径。在普遍的图中，广度优先搜索没有办法知道某一个节点的发现是否会给我们带来通往该节点的最短路径。于是，BFS（或 DFS）在加权图中找到最短路径的唯一可能方式是搜索整个图并不断记录从源点到目的顶点的最小距离。这种解决方案在复杂的场景下不可行的，除非给定一些限制条件。\n\n\n# 演示\n\n视频讲述广度优先搜索相关知识，还涉及最短路径、floodFill 等实际应用问题。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Breadth-first approach can be applied to determine the shortest path between two nodes in an equi-weighted graph.\n *\n * It searches the target node among all neighbors of the starting node, then the process is repeated on the level of\n * the neighbors of the neighbors and so on.\n *\n * @see https://en.wikipedia.org/wiki/Breadth-first_search\n * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\n */\nexport function breadthFirstShortestPath (graph, startNode, targetNode) {\n  // check if startNode & targetNode are identical\n  if (startNode === targetNode) {\n    return [startNode]\n  }\n\n  // visited keeps track of all nodes visited\n  const visited = new Set()\n\n  // queue contains the paths to be explored in the future\n  const initialPath = [startNode]\n  const queue = [initialPath]\n\n  while (queue.length > 0) {\n    // start with the queue's first path\n    const path = queue.shift()\n    const node = path[path.length - 1]\n\n    // explore this node if it hasn't been visited yet\n    if (!visited.has(node)) {\n      // mark the node as visited\n      visited.add(node)\n\n      const neighbors = graph[node]\n\n      // create a new path in the queue for each neighbor\n      for (let i = 0; i < neighbors.length; i++) {\n        const newPath = path.concat([neighbors[i]])\n\n        // the first path to contain the target node is the shortest path\n        if (neighbors[i] === targetNode) {\n          return newPath\n        }\n\n        // queue the new path\n        queue.push(newPath)\n      }\n    }\n  }\n\n  // the target node was not reachable\n  return []\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 扩展\n\n * 广度优先搜索算法在 Unity 网格地图中寻找最短路径\n\n\n# 参考\n\n * java - How does a Breadth-First Search work when looking for Shortest Path? - Stack Overflow\n * Finding Shortest Paths using Breadth First Search",normalizedContent:"# 介绍\n\nbfs 能用于寻找图中的最短路径，除非：\n\n * 不存在循环\n * 所有的边都有相同的权重或没有权重。\n\n为了找到最短的路径，你所要做的就是从源头开始，进行广度优先的搜索，当你找到目标节点时就停止。你唯一需要做的是有一个数组 previous [n]，它将存储每个被访问节点的前一个节点。源的前一个节点可以是空的。要打印路径，只需从源点开始循环浏览 previous [] 数组，直到到达目标节点。在类似条件下，dfs 也可以用来寻找图中的最短路径。\n\n但是，如果图形更复杂，包含加权边和循环，那么我们就需要一个更复杂的 bfs 版本，即 dijkstra 的算法。\n\n如果我们想在一个无向的、无权重的图中找到最短路径（undirected, unweighted graph），那么 bfs 就是要使用的算法。bfs 的主张是，在遍历过程中第一次发现一个节点时，该节点与源头的距离即为最短路径。在普遍的图中，广度优先搜索没有办法知道某一个节点的发现是否会给我们带来通往该节点的最短路径。于是，bfs（或 dfs）在加权图中找到最短路径的唯一可能方式是搜索整个图并不断记录从源点到目的顶点的最小距离。这种解决方案在复杂的场景下不可行的，除非给定一些限制条件。\n\n\n# 演示\n\n视频讲述广度优先搜索相关知识，还涉及最短路径、floodfill 等实际应用问题。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * breadth-first approach can be applied to determine the shortest path between two nodes in an equi-weighted graph.\n *\n * it searches the target node among all neighbors of the starting node, then the process is repeated on the level of\n * the neighbors of the neighbors and so on.\n *\n * @see https://en.wikipedia.org/wiki/breadth-first_search\n * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\n */\nexport function breadthfirstshortestpath (graph, startnode, targetnode) {\n  // check if startnode & targetnode are identical\n  if (startnode === targetnode) {\n    return [startnode]\n  }\n\n  // visited keeps track of all nodes visited\n  const visited = new set()\n\n  // queue contains the paths to be explored in the future\n  const initialpath = [startnode]\n  const queue = [initialpath]\n\n  while (queue.length > 0) {\n    // start with the queue's first path\n    const path = queue.shift()\n    const node = path[path.length - 1]\n\n    // explore this node if it hasn't been visited yet\n    if (!visited.has(node)) {\n      // mark the node as visited\n      visited.add(node)\n\n      const neighbors = graph[node]\n\n      // create a new path in the queue for each neighbor\n      for (let i = 0; i < neighbors.length; i++) {\n        const newpath = path.concat([neighbors[i]])\n\n        // the first path to contain the target node is the shortest path\n        if (neighbors[i] === targetnode) {\n          return newpath\n        }\n\n        // queue the new path\n        queue.push(newpath)\n      }\n    }\n  }\n\n  // the target node was not reachable\n  return []\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 扩展\n\n * 广度优先搜索算法在 unity 网格地图中寻找最短路径\n\n\n# 参考\n\n * java - how does a breadth-first search work when looking for shortest path? - stack overflow\n * finding shortest paths using breadth first search",charsets:{cjk:!0},lastUpdated:"2022/10/17, 12:47:34",lastUpdatedTimestamp:1665982054e3},{title:"ConnectedComponents [连通元件]",frontmatter:{title:"ConnectedComponents [连通元件]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/connectedComponents/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/40.ConnectedComponents.html",relativePath:"20.算法/40.Graph 图/40.ConnectedComponents.md",key:"v-9e12a0fa",path:"/algorithm/graph/connectedComponents/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"连通元件",slug:"连通元件",normalizedTitle:"连通元件",charIndex:9},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:254},{level:3,title:"使用DFS的无向图的连接元件",slug:"使用dfs的无向图的连接元件",normalizedTitle:"使用 dfs 的无向图的连接元件",charIndex:261},{level:3,title:"使用Disjoint Set Union解决无向图的连接元件",slug:"使用disjoint-set-union解决无向图的连接元件",normalizedTitle:"使用 disjoint set union 解决无向图的连接元件",charIndex:499},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:361},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:929},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:3821},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:886}],headersStr:"介绍 连通元件 原理 使用DFS的无向图的连接元件 使用Disjoint Set Union解决无向图的连接元件 实现 JavaScript 扩展 参考",content:'# 介绍\n\n\n# 连通元件\n\n在图论中，元件又称为连通元件、元件、或分支，是一个无向子图，在元件中的任何两个顶点都可以经由该图上的边抵达另一个顶点，且没有任何一边可以连到其他子图的顶点。例如右图中的无向图可以分成 3 个无向子图，也就是 3 个元件。没有与任何其他顶点相连的单一顶点也可以算是一个元件。\n\n如果图是一个有向图，而每 2 个顶点都存在可以来回该顶点的路径则称为强连通元件；而若图上任两个点之间皆有不止一条路径连通，则称为双连通元件（英语：Biconnected component）。\n\n\n# 原理\n\n\n# 使用 DFS 的无向图的连接元件\n\n为无向图寻找连接原件是一项比较容易的任务。我们的想法是：从每个未访问的顶点开始做 BFS 或 DFS，我们得到所有强连接的组件。\n\n按照下面提到的步骤，用 DFS 实现这个想法：\n\n * 将所有顶点初始化为未访问的顶点。\n * 对每个顶点做如下处理：\n   * 如果 v 以前没有被访问过，则调用 DFS 进行访问\n   * 将 v 标记为已访问。\n   * 对于 v 的每一个相邻的 u，如果 u 未被访问，则递归调用 DFS。\n\n\n# 使用 Disjoint Set Union 解决无向图的连接元件\n\n使用 DSU (Disjoint Set Union) 来解决问题的想法是：最初将所有的节点声明为单独的子集（subsets），然后访问它们。当遇到一个新的未访问的节点时，将其与下面的节点联合（unite）起来。通过这种方式，在每次遍历中都会访问一个元件（component）。\n\n按照下面的步骤来实现这个想法：\n\n * 声明一个大小为 V 的数组 arr []，其中 V 是节点的总数。\n * 对于数组 arr [] 的每个索引 i，其值表示第 i 个顶点的父节点是谁。\n * 将每个节点初始化为自己的父节点，然后在将它们加在一起时，相应地改变它们的父节点。\n * 遍历从 0 到 V 的节点：\n   * 对于每个是自己的父节点，启动 DSU。\n   * 打印该不相交集的节点，因为它们属于一个组件。\n\n参考：\n\n * 并查集 - Wikiwand\n\n\n# 实现\n\n使用 DFS:\n\n\n# JavaScript\n\nclass GraphUnweightedUndirectedAdjacencyList {\n  // Unweighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = new Set()\n  }\n\n  addEdge (node1, node2) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  DFSComponent (components, node, visited) {\n    // Helper function to populate the visited set with the nodes in each component\n\n    // adding the first visited node in the component to the array\n    components.push(node)\n    const stack = [node]\n    // populating the visited set using DFS (Iterative)\n    while (stack.length > 0) {\n      const curr = stack.pop()\n      visited.add(curr.toString())\n      for (const neighbour of this.connections[curr].keys()) {\n        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }\n      }\n    }\n  }\n\n  connectedComponents () {\n    // Function to generate the Connected Components\n    // Result is an array containing 1 node from each component\n    const visited = new Set()\n    const components = []\n    for (const node of Object.keys(this.connections)) {\n      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }\n    }\n    return components\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n使用 DSU:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint merge(int* parent, int x)\n{\n if (parent[x] == x)\n  return x;\n return merge(parent, parent[x]);\n}\n\nint connectedcomponents(int n, vector<vector<int> >& edges)\n{\n int parent[n];\n for (int i = 0; i < n; i++) {\n  parent[i] = i;\n }\n for (auto x : edges) {\n  parent[merge(parent, x[0])] = merge(parent, x[1]);\n }\n int ans = 0;\n for (int i = 0; i < n; i++) {\n  ans += (parent[i] == i);\n }\n for (int i = 0; i < n; i++) {\n  parent[i] = merge(parent, parent[i]);\n }\n map<int, list<int> > m;\n for (int i = 0; i < n; i++) {\n  m[parent[i]].push_back(i);\n }\n for (auto it = m.begin(); it != m.end(); it++) {\n  list<int> l = it->second;\n  for (auto x : l) {\n   cout << x << " ";\n  }\n  cout << endl;\n }\n return ans;\n}\n\nint main()\n{\n int n = 5;\n vector<int> e1 = { 0, 1 };\n vector<int> e2 = { 2, 1 };\n vector<int> e3 = { 3, 4 };\n vector<vector<int> > e;\n e.push_back(e1);\n e.push_back(e2);\n e.push_back(e3);\n\n cout << "Following are connected components:\\n";\n int a = connectedcomponents(n, e);\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 扩展\n\n * OpenCV Connected Component Labeling and Analysis - PyImageSearch\n\n\n# 参考\n\n * Component (graph theory) - Wikiwand\n * 元件 (圖論) - Wikiwand\n * Connected Components in an Undirected Graph - GeeksforGeeks\n * Connected Component Visualization',normalizedContent:'# 介绍\n\n\n# 连通元件\n\n在图论中，元件又称为连通元件、元件、或分支，是一个无向子图，在元件中的任何两个顶点都可以经由该图上的边抵达另一个顶点，且没有任何一边可以连到其他子图的顶点。例如右图中的无向图可以分成 3 个无向子图，也就是 3 个元件。没有与任何其他顶点相连的单一顶点也可以算是一个元件。\n\n如果图是一个有向图，而每 2 个顶点都存在可以来回该顶点的路径则称为强连通元件；而若图上任两个点之间皆有不止一条路径连通，则称为双连通元件（英语：biconnected component）。\n\n\n# 原理\n\n\n# 使用 dfs 的无向图的连接元件\n\n为无向图寻找连接原件是一项比较容易的任务。我们的想法是：从每个未访问的顶点开始做 bfs 或 dfs，我们得到所有强连接的组件。\n\n按照下面提到的步骤，用 dfs 实现这个想法：\n\n * 将所有顶点初始化为未访问的顶点。\n * 对每个顶点做如下处理：\n   * 如果 v 以前没有被访问过，则调用 dfs 进行访问\n   * 将 v 标记为已访问。\n   * 对于 v 的每一个相邻的 u，如果 u 未被访问，则递归调用 dfs。\n\n\n# 使用 disjoint set union 解决无向图的连接元件\n\n使用 dsu (disjoint set union) 来解决问题的想法是：最初将所有的节点声明为单独的子集（subsets），然后访问它们。当遇到一个新的未访问的节点时，将其与下面的节点联合（unite）起来。通过这种方式，在每次遍历中都会访问一个元件（component）。\n\n按照下面的步骤来实现这个想法：\n\n * 声明一个大小为 v 的数组 arr []，其中 v 是节点的总数。\n * 对于数组 arr [] 的每个索引 i，其值表示第 i 个顶点的父节点是谁。\n * 将每个节点初始化为自己的父节点，然后在将它们加在一起时，相应地改变它们的父节点。\n * 遍历从 0 到 v 的节点：\n   * 对于每个是自己的父节点，启动 dsu。\n   * 打印该不相交集的节点，因为它们属于一个组件。\n\n参考：\n\n * 并查集 - wikiwand\n\n\n# 实现\n\n使用 dfs:\n\n\n# javascript\n\nclass graphunweightedundirectedadjacencylist {\n  // unweighted undirected graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addnode (node) {\n    // function to add a node to the graph (connection represented by set)\n    this.connections[node] = new set()\n  }\n\n  addedge (node1, node2) {\n    // function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addnode(node1) }\n    if (!(node2 in this.connections)) { this.addnode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  dfscomponent (components, node, visited) {\n    // helper function to populate the visited set with the nodes in each component\n\n    // adding the first visited node in the component to the array\n    components.push(node)\n    const stack = [node]\n    // populating the visited set using dfs (iterative)\n    while (stack.length > 0) {\n      const curr = stack.pop()\n      visited.add(curr.tostring())\n      for (const neighbour of this.connections[curr].keys()) {\n        if (!visited.has(neighbour.tostring())) { stack.push(neighbour) }\n      }\n    }\n  }\n\n  connectedcomponents () {\n    // function to generate the connected components\n    // result is an array containing 1 node from each component\n    const visited = new set()\n    const components = []\n    for (const node of object.keys(this.connections)) {\n      if (!visited.has(node.tostring())) { this.dfscomponent(components, node, visited) }\n    }\n    return components\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n使用 dsu:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint merge(int* parent, int x)\n{\n if (parent[x] == x)\n  return x;\n return merge(parent, parent[x]);\n}\n\nint connectedcomponents(int n, vector<vector<int> >& edges)\n{\n int parent[n];\n for (int i = 0; i < n; i++) {\n  parent[i] = i;\n }\n for (auto x : edges) {\n  parent[merge(parent, x[0])] = merge(parent, x[1]);\n }\n int ans = 0;\n for (int i = 0; i < n; i++) {\n  ans += (parent[i] == i);\n }\n for (int i = 0; i < n; i++) {\n  parent[i] = merge(parent, parent[i]);\n }\n map<int, list<int> > m;\n for (int i = 0; i < n; i++) {\n  m[parent[i]].push_back(i);\n }\n for (auto it = m.begin(); it != m.end(); it++) {\n  list<int> l = it->second;\n  for (auto x : l) {\n   cout << x << " ";\n  }\n  cout << endl;\n }\n return ans;\n}\n\nint main()\n{\n int n = 5;\n vector<int> e1 = { 0, 1 };\n vector<int> e2 = { 2, 1 };\n vector<int> e3 = { 3, 4 };\n vector<vector<int> > e;\n e.push_back(e1);\n e.push_back(e2);\n e.push_back(e3);\n\n cout << "following are connected components:\\n";\n int a = connectedcomponents(n, e);\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 扩展\n\n * opencv connected component labeling and analysis - pyimagesearch\n\n\n# 参考\n\n * component (graph theory) - wikiwand\n * 元件 (圖論) - wikiwand\n * connected components in an undirected graph - geeksforgeeks\n * connected component visualization',charsets:{cjk:!0},lastUpdated:"2022/10/18, 09:41:50",lastUpdatedTimestamp:166605731e4},{title:"Density [图的密度]",frontmatter:{title:"Density [图的密度]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/density/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/50.Density.html",relativePath:"20.算法/40.Graph 图/50.Density.md",key:"v-428975fa",path:"/algorithm/graph/density/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:3,title:"图的密度",slug:"图的密度",normalizedTitle:"图的密度",charIndex:9},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:540},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:547},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1032}],headersStr:"介绍 图的密度 实现 JavaScript 参考",content:"# 介绍\n\n\n# 图的密度\n\n图的密度表示图中存在的边与图可包含的最大边数之间的比率。从概念上讲，它提供了一个关于一个图在边的连接（edge connectivity）方面的密度的概念。当我们有一个庞大的网络并想在网络中添加新的边时，它特别有用。此外，图的密度让我们了解到我们还能在网络中增加多少条边。\n\n现在，在推导图密度的公式之前，让我们谈谈如何计算一个简单的有向图和无向图中的最大边数。让我们看一下一个简单的无向图 G1:\n\n\n\n现在，我们要推导出一个标准的公式来计算一个简单的无向图中的最大边数:\n\n\n\n同样地，我们可以用有向图中的两条双向边来代替每条无向边。因此，最大的边数可以用类似的公式来计算：\n\n\n\n我们现在可以定义图形密度公式。图中存在的边除以该图可包含的最大边数。让我们看看一个简单无向图的公式:\n\n\n\n同样地，我们可以为有向图重写前面的密度公式:\n\n\n\n对于一个完全有向或无向图，密度总是 1。在一个完全有向图或无向图的情况下，它已经有最大数量的边，我们不能再增加任何边。此外，它还表明该图是完全密集的（fully dense）。\n\n一个具有所有孤立顶点的图的密度为 0。 此外，它表示图中没有边，可以添加到图中的边的数量等于最大可添加的边的数量。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nThe density of a network is a measure of how many edges exist proportional to\nhow many edges would exist in a complete network (where all possible edges).\nhttps://networkx.org/documentation/networkx-1.9/reference/generated/networkx.classes.function.density.html\n*/\nfunction density (numberOfNodes, numberOfEdges, isDirected = false) {\n  const multi = isDirected ? 1 : 2\n  return (multi * numberOfEdges) / (numberOfNodes * (numberOfNodes - 1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参考\n\n * Graph Density | Baeldung on Computer Science",normalizedContent:"# 介绍\n\n\n# 图的密度\n\n图的密度表示图中存在的边与图可包含的最大边数之间的比率。从概念上讲，它提供了一个关于一个图在边的连接（edge connectivity）方面的密度的概念。当我们有一个庞大的网络并想在网络中添加新的边时，它特别有用。此外，图的密度让我们了解到我们还能在网络中增加多少条边。\n\n现在，在推导图密度的公式之前，让我们谈谈如何计算一个简单的有向图和无向图中的最大边数。让我们看一下一个简单的无向图 g1:\n\n\n\n现在，我们要推导出一个标准的公式来计算一个简单的无向图中的最大边数:\n\n\n\n同样地，我们可以用有向图中的两条双向边来代替每条无向边。因此，最大的边数可以用类似的公式来计算：\n\n\n\n我们现在可以定义图形密度公式。图中存在的边除以该图可包含的最大边数。让我们看看一个简单无向图的公式:\n\n\n\n同样地，我们可以为有向图重写前面的密度公式:\n\n\n\n对于一个完全有向或无向图，密度总是 1。在一个完全有向图或无向图的情况下，它已经有最大数量的边，我们不能再增加任何边。此外，它还表明该图是完全密集的（fully dense）。\n\n一个具有所有孤立顶点的图的密度为 0。 此外，它表示图中没有边，可以添加到图中的边的数量等于最大可添加的边的数量。\n\n\n# 实现\n\n\n# javascript\n\n/*\nthe density of a network is a measure of how many edges exist proportional to\nhow many edges would exist in a complete network (where all possible edges).\nhttps://networkx.org/documentation/networkx-1.9/reference/generated/networkx.classes.function.density.html\n*/\nfunction density (numberofnodes, numberofedges, isdirected = false) {\n  const multi = isdirected ? 1 : 2\n  return (multi * numberofedges) / (numberofnodes * (numberofnodes - 1))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参考\n\n * graph density | baeldung on computer science",charsets:{cjk:!0},lastUpdated:"2022/10/18, 09:41:50",lastUpdatedTimestamp:166605731e4},{title:"DepthFirstSearch [深度优先搜索]",frontmatter:{title:"DepthFirstSearch [深度优先搜索]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/depthFirstSearch/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/60.DepthFirstSearch.html",relativePath:"20.算法/40.Graph 图/60.DepthFirstSearch.md",key:"v-65f4a9ad",path:"/algorithm/graph/depthFirstSearch/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:222},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:229},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:236},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2879}],headersStr:"介绍 演示 实现 JavaScript 参考",content:"# 介绍\n\n深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。这种算法不会根据图的结构等信息调整执行策略。\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\n迭代法：\n\nclass GraphUnweightedUndirected {\n  // Unweighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = new Set()\n  }\n\n  addEdge (node1, node2) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  DFSIterative (node, value) {\n    // DFS Function to search if a node with the given value is present in the graph\n    const stack = [node]\n    const visited = new Set()\n    while (stack.length > 0) {\n      const currNode = stack.pop()\n      // if the current node contains the value being searched for, true is returned\n      if (currNode === value) { return true }\n      // adding the current node to the visited set\n      visited.add(currNode)\n      // adding neighbours in the stack\n      for (const neighbour of this.connections[currNode]) {\n        if (!visited.has(neighbour)) {\n          stack.push(neighbour)\n        }\n      }\n    }\n    return false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n递归法：\n\nclass GraphUnweightedUndirected {\n  // Unweighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = new Set()\n  }\n\n  addEdge (node1, node2) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  DFSRecursive (node, value, visited = new Set()) {\n    // DFS Function to search if a node with the given value is present in the graph\n    // checking if the searching node has been found\n    if (node === value) { return true }\n    // adding the current node to the visited set\n    visited.add(node)\n    // calling the helper function recursively for all unvisited nodes\n    for (const neighbour of this.connections[node]) {\n      if (!visited.has(neighbour)) {\n        if (this.DFSRecursive(neighbour, value, visited)) { return true }\n      }\n    }\n    return false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参考\n\n * Depth-first search - Wikiwand\n * 深度优先搜索 - Wikiwand",normalizedContent:"# 介绍\n\n深度优先搜索算法（英语：depth-first-search，dfs）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。这种算法不会根据图的结构等信息调整执行策略。\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\n迭代法：\n\nclass graphunweightedundirected {\n  // unweighted undirected graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addnode (node) {\n    // function to add a node to the graph (connection represented by set)\n    this.connections[node] = new set()\n  }\n\n  addedge (node1, node2) {\n    // function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addnode(node1) }\n    if (!(node2 in this.connections)) { this.addnode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  dfsiterative (node, value) {\n    // dfs function to search if a node with the given value is present in the graph\n    const stack = [node]\n    const visited = new set()\n    while (stack.length > 0) {\n      const currnode = stack.pop()\n      // if the current node contains the value being searched for, true is returned\n      if (currnode === value) { return true }\n      // adding the current node to the visited set\n      visited.add(currnode)\n      // adding neighbours in the stack\n      for (const neighbour of this.connections[currnode]) {\n        if (!visited.has(neighbour)) {\n          stack.push(neighbour)\n        }\n      }\n    }\n    return false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n递归法：\n\nclass graphunweightedundirected {\n  // unweighted undirected graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addnode (node) {\n    // function to add a node to the graph (connection represented by set)\n    this.connections[node] = new set()\n  }\n\n  addedge (node1, node2) {\n    // function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addnode(node1) }\n    if (!(node2 in this.connections)) { this.addnode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  dfsrecursive (node, value, visited = new set()) {\n    // dfs function to search if a node with the given value is present in the graph\n    // checking if the searching node has been found\n    if (node === value) { return true }\n    // adding the current node to the visited set\n    visited.add(node)\n    // calling the helper function recursively for all unvisited nodes\n    for (const neighbour of this.connections[node]) {\n      if (!visited.has(neighbour)) {\n        if (this.dfsrecursive(neighbour, value, visited)) { return true }\n      }\n    }\n    return false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 参考\n\n * depth-first search - wikiwand\n * 深度优先搜索 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 09:41:50",lastUpdatedTimestamp:166605731e4},{title:"Dijkstra [迪杰斯特拉算法]",frontmatter:{title:"Dijkstra [迪杰斯特拉算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/graph/dijkstra/",categories:["算法","Graph 图"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/40.Graph%20%E5%9B%BE/80.Dijkstra.html",relativePath:"20.算法/40.Graph 图/80.Dijkstra.md",key:"v-55d448e7",path:"/algorithm/graph/dijkstra/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:514},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:752},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:759},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5048}],headersStr:"介绍 演示 实现 JavaScript 参考",content:"# 介绍\n\n戴克斯特拉算法（英语：Dijkstra's algorithm），又译迪杰斯特拉算法，亦可不音译而称为 Dijkstra 算法。戴克斯特拉算法使用类似广度优先搜索的方法解决赋权图的单源最短路径问题。\n\n该算法存在很多变体：戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。\n\n该算法解决了图 G=⟨V,E⟩{\\displaystyle G=\\langle V,E\\rangle }G=⟨V,E⟩ 上带权的单源最短路径问题。具体来说，戴克斯特拉算法设置了一顶点集合 S，在集合 S 中所有的顶点与源点 s 之间的最终最短路径权值均已确定。算法反复选择最短路径估计最小的点u∈V−Su \\in V-Su∈V−S 并将 u 加入 S 中。该算法常用于路由算法或者作为其他图算法的一个子模块。\n\n应当注意，绝大多数的戴克斯特拉算法不能有效处理带有负权边的图。\n\n戴克斯特拉算法在计算机科学的人工智能等领域也被称为均一开销搜索，并被认为是最良优先搜索（英语：best-first search）的一个特例。\n\n\n# 演示\n\n戴克斯特拉算法运行演示（找到 A，B 之间的最短路），本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。在演示过程中访问过的结点会被标为红色。\n\n\n\n动画：\n\n * Single-Source Shortest Paths (Dijkstra/+ve Weighted, BFS/Unweighted, Bellman-Ford, DFS/Tree, Dynamic Programming/DAG) - VisuAlgo\n\n戴克斯特拉算法:\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Author: Samarth Jain\n * Dijkstra's Algorithm implementation in JavaScript\n * Dijkstra's Algorithm calculates the minimum distance between two nodes.\n * It is used to find the shortest path.\n * It uses graph data structure.\n */\n\nfunction createGraph (V, E) {\n  // V - Number of vertices in graph\n  // E - Number of edges in graph (u,v,w)\n  const adjList = [] // Adjacency list\n  for (let i = 0; i < V; i++) {\n    adjList.push([])\n  }\n  for (let i = 0; i < E.length; i++) {\n    adjList[E[i][0]].push([E[i][1], E[i][2]])\n    adjList[E[i][1]].push([E[i][0], E[i][2]])\n  }\n  return adjList\n}\n\nfunction dijkstra (graph, V, src) {\n  const vis = Array(V).fill(0)\n  /**\n   * The first value in the array determines the minimum distance and the\n   * second value represents the parent node from which the minimum distance has been calculated\n   */\n  const dist = []\n  for (let i = 0; i < V; i++) dist.push([10000, -1])\n  dist[src][0] = 0\n\n  for (let i = 0; i < V - 1; i++) {\n    let mn = -1\n    for (let j = 0; j < V; j++) {\n      if (vis[j] === 0) {\n        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j\n      }\n    }\n\n    vis[mn] = 1\n    for (let j = 0; j < graph[mn].length; j++) {\n      const edge = graph[mn][j]\n      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {\n        dist[edge[0]][0] = dist[mn][0] + edge[1]\n        dist[edge[0]][1] = mn\n      }\n    }\n  }\n\n  return dist\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n迪杰斯特拉算法寻最短路径:\n\n// starting at s\nfunction solve (graph, s) {\n  const solutions = {}\n  solutions[s] = []\n  solutions[s].dist = 0\n\n  while (true) {\n    let p = null\n    let neighbor = null\n    let dist = Infinity\n\n    for (const n in solutions) {\n      if (!solutions[n]) { continue }\n      const ndist = solutions[n].dist\n      const adj = graph[n]\n\n      for (const a in adj) {\n        if (solutions[a]) { continue }\n\n        const d = adj[a] + ndist\n        if (d < dist) {\n          p = solutions[n]\n          neighbor = a\n          dist = d\n        }\n      }\n    }\n\n    // no more solutions\n    if (dist === Infinity) {\n      break\n    }\n\n    // extend parent's solution path\n    solutions[neighbor] = p.concat(neighbor)\n    // extend parent's cost\n    solutions[neighbor].dist = dist\n  }\n\n  return solutions\n}\n\n// // create graph\n// const graph = {}\n\n// const layout = {\n//   R: ['2'],\n//   2: ['3', '4'],\n//   3: ['4', '6', '13'],\n//   4: ['5', '8'],\n//   5: ['7', '11'],\n//   6: ['13', '15'],\n//   7: ['10'],\n//   8: ['11', '13'],\n//   9: ['14'],\n//   10: [],\n//   11: ['12'],\n//   12: [],\n//   13: ['14'],\n//   14: [],\n//   15: []\n// }\n\n// // convert uni-directional to bi-directional graph\n// let  graph = {\n//     a: {e:1, b:1, g:3},\n//     b: {a:1, c:1},\n//     c: {b:1, d:1},\n//     d: {c:1, e:1},\n//     e: {d:1, a:1},\n//     f: {g:1, h:1},\n//     g: {a:3, f:1},\n//     h: {f:1}\n// };\n\n// for (const id in layout) {\n//   if (!graph[id]) { graph[id] = {} }\n//   layout[id].forEach(function (aid) {\n//     graph[id][aid] = 1\n//     if (!graph[aid]) { graph[aid] = {} }\n//     graph[aid][id] = 1\n//   })\n// }\n\n// // choose start node\n// const start = '10'\n// // get all solutions\n// const solutions = solve(graph, start)\n\n// // for s in solutions..\n// ' -> ' + s + ': [' + solutions[s].join(', ') + ']   (dist:' + solutions[s].dist + ')'\n\n// From '10' to\n//  -> 2: [7, 5, 4, 2]   (dist:4)\n//  -> 3: [7, 5, 4, 3]   (dist:4)\n//  -> 4: [7, 5, 4]   (dist:3)\n//  -> 5: [7, 5]   (dist:2)\n//  -> 6: [7, 5, 4, 3, 6]   (dist:5)\n//  -> 7: [7]   (dist:1)\n//  -> 8: [7, 5, 4, 8]   (dist:4)\n//  -> 9: [7, 5, 4, 3, 13, 14, 9]   (dist:7)\n//  -> 10: []   (dist:0)\n//  -> 11: [7, 5, 11]   (dist:3)\n//  -> 12: [7, 5, 11, 12]   (dist:4)\n//  -> 13: [7, 5, 4, 3, 13]   (dist:5)\n//  -> 14: [7, 5, 4, 3, 13, 14]   (dist:6)\n//  -> 15: [7, 5, 4, 3, 6, 15]   (dist:6)\n//  -> R: [7, 5, 4, 2, R]   (dist:5)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 参考\n\n * Dijkstra's algorithm - Wikiwand\n * 戴克斯特拉算法 - Wikiwand\n * Dijkstra's Shortest Path Algorithm - A Detailed and Visual Introduction\n * Dijkstra's Shortest Path Algorithm | Brilliant Math & Science Wiki",normalizedContent:"# 介绍\n\n戴克斯特拉算法（英语：dijkstra's algorithm），又译迪杰斯特拉算法，亦可不音译而称为 dijkstra 算法。戴克斯特拉算法使用类似广度优先搜索的方法解决赋权图的单源最短路径问题。\n\n该算法存在很多变体：戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。\n\n该算法解决了图 g=⟨v,e⟩{\\displaystyle g=\\langle v,e\\rangle }g=⟨v,e⟩ 上带权的单源最短路径问题。具体来说，戴克斯特拉算法设置了一顶点集合 s，在集合 s 中所有的顶点与源点 s 之间的最终最短路径权值均已确定。算法反复选择最短路径估计最小的点u∈v−su \\in v-su∈v−s 并将 u 加入 s 中。该算法常用于路由算法或者作为其他图算法的一个子模块。\n\n应当注意，绝大多数的戴克斯特拉算法不能有效处理带有负权边的图。\n\n戴克斯特拉算法在计算机科学的人工智能等领域也被称为均一开销搜索，并被认为是最良优先搜索（英语：best-first search）的一个特例。\n\n\n# 演示\n\n戴克斯特拉算法运行演示（找到 a，b 之间的最短路），本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。在演示过程中访问过的结点会被标为红色。\n\n\n\n动画：\n\n * single-source shortest paths (dijkstra/+ve weighted, bfs/unweighted, bellman-ford, dfs/tree, dynamic programming/dag) - visualgo\n\n戴克斯特拉算法:\n\n\n# 实现\n\n\n# javascript\n\n/**\n * author: samarth jain\n * dijkstra's algorithm implementation in javascript\n * dijkstra's algorithm calculates the minimum distance between two nodes.\n * it is used to find the shortest path.\n * it uses graph data structure.\n */\n\nfunction creategraph (v, e) {\n  // v - number of vertices in graph\n  // e - number of edges in graph (u,v,w)\n  const adjlist = [] // adjacency list\n  for (let i = 0; i < v; i++) {\n    adjlist.push([])\n  }\n  for (let i = 0; i < e.length; i++) {\n    adjlist[e[i][0]].push([e[i][1], e[i][2]])\n    adjlist[e[i][1]].push([e[i][0], e[i][2]])\n  }\n  return adjlist\n}\n\nfunction dijkstra (graph, v, src) {\n  const vis = array(v).fill(0)\n  /**\n   * the first value in the array determines the minimum distance and the\n   * second value represents the parent node from which the minimum distance has been calculated\n   */\n  const dist = []\n  for (let i = 0; i < v; i++) dist.push([10000, -1])\n  dist[src][0] = 0\n\n  for (let i = 0; i < v - 1; i++) {\n    let mn = -1\n    for (let j = 0; j < v; j++) {\n      if (vis[j] === 0) {\n        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j\n      }\n    }\n\n    vis[mn] = 1\n    for (let j = 0; j < graph[mn].length; j++) {\n      const edge = graph[mn][j]\n      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {\n        dist[edge[0]][0] = dist[mn][0] + edge[1]\n        dist[edge[0]][1] = mn\n      }\n    }\n  }\n\n  return dist\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n迪杰斯特拉算法寻最短路径:\n\n// starting at s\nfunction solve (graph, s) {\n  const solutions = {}\n  solutions[s] = []\n  solutions[s].dist = 0\n\n  while (true) {\n    let p = null\n    let neighbor = null\n    let dist = infinity\n\n    for (const n in solutions) {\n      if (!solutions[n]) { continue }\n      const ndist = solutions[n].dist\n      const adj = graph[n]\n\n      for (const a in adj) {\n        if (solutions[a]) { continue }\n\n        const d = adj[a] + ndist\n        if (d < dist) {\n          p = solutions[n]\n          neighbor = a\n          dist = d\n        }\n      }\n    }\n\n    // no more solutions\n    if (dist === infinity) {\n      break\n    }\n\n    // extend parent's solution path\n    solutions[neighbor] = p.concat(neighbor)\n    // extend parent's cost\n    solutions[neighbor].dist = dist\n  }\n\n  return solutions\n}\n\n// // create graph\n// const graph = {}\n\n// const layout = {\n//   r: ['2'],\n//   2: ['3', '4'],\n//   3: ['4', '6', '13'],\n//   4: ['5', '8'],\n//   5: ['7', '11'],\n//   6: ['13', '15'],\n//   7: ['10'],\n//   8: ['11', '13'],\n//   9: ['14'],\n//   10: [],\n//   11: ['12'],\n//   12: [],\n//   13: ['14'],\n//   14: [],\n//   15: []\n// }\n\n// // convert uni-directional to bi-directional graph\n// let  graph = {\n//     a: {e:1, b:1, g:3},\n//     b: {a:1, c:1},\n//     c: {b:1, d:1},\n//     d: {c:1, e:1},\n//     e: {d:1, a:1},\n//     f: {g:1, h:1},\n//     g: {a:3, f:1},\n//     h: {f:1}\n// };\n\n// for (const id in layout) {\n//   if (!graph[id]) { graph[id] = {} }\n//   layout[id].foreach(function (aid) {\n//     graph[id][aid] = 1\n//     if (!graph[aid]) { graph[aid] = {} }\n//     graph[aid][id] = 1\n//   })\n// }\n\n// // choose start node\n// const start = '10'\n// // get all solutions\n// const solutions = solve(graph, start)\n\n// // for s in solutions..\n// ' -> ' + s + ': [' + solutions[s].join(', ') + ']   (dist:' + solutions[s].dist + ')'\n\n// from '10' to\n//  -> 2: [7, 5, 4, 2]   (dist:4)\n//  -> 3: [7, 5, 4, 3]   (dist:4)\n//  -> 4: [7, 5, 4]   (dist:3)\n//  -> 5: [7, 5]   (dist:2)\n//  -> 6: [7, 5, 4, 3, 6]   (dist:5)\n//  -> 7: [7]   (dist:1)\n//  -> 8: [7, 5, 4, 8]   (dist:4)\n//  -> 9: [7, 5, 4, 3, 13, 14, 9]   (dist:7)\n//  -> 10: []   (dist:0)\n//  -> 11: [7, 5, 11]   (dist:3)\n//  -> 12: [7, 5, 11, 12]   (dist:4)\n//  -> 13: [7, 5, 4, 3, 13]   (dist:5)\n//  -> 14: [7, 5, 4, 3, 13, 14]   (dist:6)\n//  -> 15: [7, 5, 4, 3, 6, 15]   (dist:6)\n//  -> r: [7, 5, 4, 2, r]   (dist:5)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 参考\n\n * dijkstra's algorithm - wikiwand\n * 戴克斯特拉算法 - wikiwand\n * dijkstra's shortest path algorithm - a detailed and visual introduction\n * dijkstra's shortest path algorithm | brilliant math & science wiki",charsets:{cjk:!0},lastUpdated:"2022/10/18, 09:41:50",lastUpdatedTimestamp:166605731e4},{title:"BreadthFirstTreeTraversal [二叉树的广度优先遍历、层序遍历]",frontmatter:{title:"BreadthFirstTreeTraversal [二叉树的广度优先遍历、层序遍历]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/tree/breadthFirstTreeTraversal/",categories:["算法","Tree 树"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/50.Tree%20%E6%A0%91/10.BreadthFirstTreeTraversal.html",relativePath:"20.算法/50.Tree 树/10.BreadthFirstTreeTraversal.md",key:"v-38f0ff9a",path:"/algorithm/tree/breadthFirstTreeTraversal/",headers:[{level:2,title:"层序遍历（level order traversal）",slug:"层序遍历-level-order-traversal",normalizedTitle:"层序遍历（level order traversal）",charIndex:2},{level:2,title:"BFS遍历的递归方法",slug:"bfs遍历的递归方法",normalizedTitle:"bfs 遍历的递归方法",charIndex:245},{level:2,title:"使用队列的BFS遍历",slug:"使用队列的bfs遍历",normalizedTitle:"使用队列的 bfs 遍历",charIndex:2251},{level:2,title:"二叉树的BFS遍历 vs DFS遍历",slug:"二叉树的bfs遍历-vs-dfs遍历",normalizedTitle:"二叉树的 bfs 遍历 vs dfs 遍历",charIndex:4173},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:396},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:4764},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5956}],headersStr:"层序遍历（level order traversal） BFS遍历的递归方法 使用队列的BFS遍历 二叉树的BFS遍历 vs DFS遍历 实现 JavaScript 参考",content:"# 层序遍历（level order traversal）\n\n在二叉树的 DFS 遍历中，我们以三种不同的顺序访问节点：前序、后序和中序。现在有另一种遍历方法，可以按层级顺序访问节点。这就是所谓的层序遍历或广度优先搜索遍历。简而言之，我们也叫它 BFS 遍历。\n\n二叉树被组织成不同的层次，根节点位于最顶层（第 0 层）。所以层级遍历的想法是：我们从处理根节点开始，然后处理第一层、第二层的所有节点，以此类推。换句话说，我们先探索当前级别的所有节点，然后再进入下一级别的节点。\n\n\n\n\n# BFS 遍历的递归方法\n\n这是一个蛮力的想法，我们使用一个循环从顶层移动到最底层，并使用递归处理每一层的节点。这个想法看起来很简单，但实施起来就有点麻烦了。讨论这种方法的目的是与解决问题有关的。在一些树形问题的递归解决中，有时我们会传递额外的参数或使用辅助函数来生成正确的输出。\n\n递归 BFS 遍历的实现：\n\n * 层次的数量等于树的高度。所以我们首先用函数 height (root) 计算树的高度 h。\n * 我们运行一个从 l=0 到 h-1 的循环，并访问树中的每一层。在这个循环中，我们使用函数 processCurrentLevel (root, l) 来访问和处理当前级别 l 的节点。\n\n我们如何实现函数 processCurrentLevel (root, l)？让我们思考一下！我们可以把这个问题分成两部分:\n\n * 我们处理左侧子树中 l 级的所有节点。为此，我们用 root->left 和 l - 1 作为函数参数调用同一个函数。为什么？因为，如果当前级别与根的距离是 l，那么它与根 -> 左的距离将是 l - 1。\n * 我们处理右边子树中 l 级的所有节点。为此，我们用 root->right 和 l - 1 作为函数参数调用同一个函数。为什么？因为，如果当前级别与根的距离是 l，那么它与根 -> 右的距离将是 l - 1。\n * 在递归调用过程中，当 l == 0 时，我们到达一个节点，该节点与根的距离为 l。所以我们处理这个节点。通过这种方式，我们可以递归地访问 l 层的所有节点。\n\n伪代码：\n\nclass TreeNode\n{\n    int data\n    TreeNode left \n    TreeNode right\n}\n \nvoid recursiveLevelOrder(TreeNode root)\n{\n    int h = height(root)\n    for (int l = 0; l < h; l = l + 1)\n        processCurrentLevel(root, l)\n}\n\nvoid processCurrentLevel(TreeNode root, int l)\n{\n    if (root == NULL)\n        return\n    if (l == 0)\n        process(root->data)\n    else if (l > 0)\n    {\n        processCurrentLevel(root->left, l - 1)\n        processCurrentLevel(root->right, l - 1)\n    }\n}\n\nint height(TreeNode root)\n{\n    if (root == NULL)\n        return 0\n    else\n    {\n        int leftHeight = height(root->left)\n        int rightHeight = height(root->right)\n        \n        if (leftHeight > rightHeight)\n            return (rightHeight + 1)\n        else \n            return(rightHeight + 1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n时间和空间复杂性分析：\n\n对于每一次递归调用 processCurrentLevel ()，我们都要在左右子树中向下移动 l-1 级。换句话说，我们正在访问从 0 级到 l 级的每个节点，并检查 l==0 与否。所以有一个想法很清楚：操作的总数取决于树的高度。\n\n最坏的情况是倾斜的树，每层都有一个节点。在这种情况下，processCurrentLevel () 对最后一层需要 O (n) 时间，对倒数第二层需要 O (n-1) 时间，以此类推。这里 n 是树中的节点数。时间复杂性 = O(n) + O(n-1) + ... + O(1) = O(n + (n-1) + ...+ 1) = O(n^2) 。\n\n在最坏的情况下，空间复杂度 = O (n)。对于一棵倾斜的树，processCurrentLevel () 将使用 O (n) 空间作为调用栈。对于一个平衡树，调用栈使用 O (log n) 空间（这等于平衡树的高度）。\n\n\n# 使用队列的 BFS 遍历\n\n现在的关键问题是，我们能优化 BFS 遍历的时间复杂性吗？我们能以 O (n) 的时间复杂度逐级遍历树吗？让我们观察一下层级遍历中的节点顺序。\n\n * 我们首先处理第 0 层的根节点，然后处理第 1 层的左、右子节点（假设从左到右的顺序）。\n * 同样地，在第二层，我们首先处理根节点的左子节点的子节点，然后处理右子节点的子节点。这个过程对树中的所有级别都是如此。\n\n因此，有一个想法是明确的：在任何给定的级别，节点将被首先处理，该节点的子女将在下一级被首先处理。这是处理节点的先入先出顺序（FIFO 顺序）。所以我们可以使用队列数据结构来模拟 BFS 遍历。\n\n使用队列进行 BFS 遍历的实施步骤：\n\n * 我们取一个空的队列 treeQueue，并用根节点初始化它。\n * 现在我们运行一个循环，直到 treeQueue 不为空。\n * 在这个循环中，我们声明一个 currNode，以便在遍历过程中跟踪当前节点。\n * 我们开始循环，从 treeQueue 中移除前端节点，并将其分配给 currNode。我们处理 currNode，并将左右两个子节点插入到 treeQueue 中。\n\nTreeNode currNode = treeQueue.dequeue()\nprocess (currNode->data)\n\n\n1\n2\n\n * 如果 currNode 的左侧子节点不是 NULL，我们将左侧子节点插入到 treeQueue 中。\n\nif (currNode->left != NULL)\n  treeQueue.enqueue(currNode->left)\n\n\n1\n2\n\n * 如果 currNode 的右边的孩子不是 NULL，我们就把右边的孩子插入到 treeQueue 中。\n\nif (currNode->right != NULL)\n  treeQueue.enqueue(currNode->right)\n\n\n1\n2\n\n\n在处理完最后一级的最右边的节点后，队列里面就没有节点可以继续处理了。所以我们从循环中出来，我们的层序遍历在这时完成。\n\n伪代码：\n\nvoid iterativeLevelOrder(Treenode root)\n{\n    if (root == NULL)  \n        return\n    Queue<TreeNode> treeQueue\n    treeQueue.enqueue(root)\n    while (treeQueue.empty() == false)\n    {\n        TreeNode currNode = treeQueue.dequeue()\n        process(currNode->data) \n        \n        if (currNode->left != NULL)\n            treeQueue.enqueue(currNode->left)\n \n        if (currNode->right != NULL)\n            treeQueue.enqueue(currNode->right)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nBFS 遍历的时间复杂性分析：\n\n * 假设输入中有 n 个节点。\n * enqueue 和 dequeue 操作的时间复杂度 = O (1)\n * 我们在循环内为每个节点做两次队列操作。向队列中插入一次，从队列中删除一次。所以总的队列操作 = 2n。\n * 总体时间复杂度 = 总队列操作 * 每个队列操作的时间复杂度 = 2n * O (1) = O (n)\n\nBFS 遍历的空间复杂度分析：\n\n空间复杂度等于队列大小。我们逐级处理节点，所以最大队列大小取决于具有最大节点数或二叉树最大宽度的层级。如果二叉树的最大宽度是 w，那么空间复杂度 = O（w）。这个想法很简单：w 取决于给定二叉树的结构。\n\n最坏的情况：当树是平衡的，最后一层将有最大的宽度或最大的节点数，这将是 2^h（其中 h 是树的高度）。对于平衡树，h=logn，所需的队列大小 = O (2^h) = O (2 ^ (log n)) = O (n)。空间复杂度 = O (n)\n\n最好的情况：当树是倾斜的，在这种情况下，每一层最多只有一个节点，因此在任何一点，队列中最多只有一个节点。因此需要的队列大小 = O (1)。空间复杂度 = O (1)。\n\n\n# 二叉树的 BFS 遍历 vs DFS 遍历\n\n * 这两种遍历方法都需要 O (n) 时间，因为它们对每个节点都正好访问一次。\n * 深度优先遍历从根部开始，尽可能地深入，然后从那里回溯。换句话说，它从树的底部访问节点。但在广度优先搜索中，我们逐级探索节点，即按照它们与根节点的距离排序。因此，如果我们的问题是要搜索离根更近的东西，我们会选择 BFS。而如果我们需要在树的深度或靠近叶子的节点中搜索一些东西，我们会选择 DFS。\n * 在 BFS 遍历中，我们使用队列数据结构来存储不同层次的节点。但是在 DFS 遍历中，我们使用堆栈（如果是递归，系统使用调用堆栈）来存储一个节点的所有祖先。\n * BFS 和 DFS 所占用的内存都取决于树的结构。BFS 遍历所需的额外空间是 O (w)，但 DFS 遍历所需的额外空间是 O (h)。这里 w = 二叉树的最大宽度，h = 二叉树的最大高度。在最坏的情况下，两者都需要 O (n) 的额外空间，但最坏的情况发生在不同类型的树。例如，当树比较平衡时，BFS 遍历需要的空间可能会更多，而当树不太平衡时，DFS 遍历的额外空间可能会更多。\n * 有时，当解决问题时不需要节点顺序，我们可以同时使用 BFS 和 DFS 遍历。但在某些情况下，这种事情是不可能的。我们需要确定遍历的使用情况，以便有效地解决问题。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  Breadth First Tree Traversal or level order traversal implementation in javascript\n  Author: @GerardUbuntu\n*/\n\nclass Node {\n  constructor (data) {\n    this.data = data\n    this.left = null\n    this.right = null\n  }\n}\n\nclass BinaryTree {\n  constructor () {\n    this.root = null\n    this.traversal = []\n  }\n\n  breadthFirst () {\n    const h = this.getHeight(this.root)\n    for (let i = 0; i !== h; i++) {\n      this.traverseLevel(this.root, i)\n    }\n    return this.traversal\n  }\n\n  // Computing the height of the tree\n  getHeight (node) {\n    if (node === null) {\n      return 0\n    }\n    const lheight = this.getHeight(node.left)\n    const rheight = this.getHeight(node.right)\n    return lheight > rheight ? lheight + 1 : rheight + 1\n  }\n\n  traverseLevel (node, levelRemaining) {\n    if (node === null) {\n      return\n    }\n    if (levelRemaining === 0) {\n      this.traversal.push(node.data)\n    } else {\n      this.traverseLevel(node.left, levelRemaining - 1)\n      this.traverseLevel(node.right, levelRemaining - 1)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 参考\n\n * Level Order Traversal (BFS Traversal) of a Binary Tree\n * BreadthFirstSearch [广度优先搜索 / BFS] | Fancy DSA",normalizedContent:"# 层序遍历（level order traversal）\n\n在二叉树的 dfs 遍历中，我们以三种不同的顺序访问节点：前序、后序和中序。现在有另一种遍历方法，可以按层级顺序访问节点。这就是所谓的层序遍历或广度优先搜索遍历。简而言之，我们也叫它 bfs 遍历。\n\n二叉树被组织成不同的层次，根节点位于最顶层（第 0 层）。所以层级遍历的想法是：我们从处理根节点开始，然后处理第一层、第二层的所有节点，以此类推。换句话说，我们先探索当前级别的所有节点，然后再进入下一级别的节点。\n\n\n\n\n# bfs 遍历的递归方法\n\n这是一个蛮力的想法，我们使用一个循环从顶层移动到最底层，并使用递归处理每一层的节点。这个想法看起来很简单，但实施起来就有点麻烦了。讨论这种方法的目的是与解决问题有关的。在一些树形问题的递归解决中，有时我们会传递额外的参数或使用辅助函数来生成正确的输出。\n\n递归 bfs 遍历的实现：\n\n * 层次的数量等于树的高度。所以我们首先用函数 height (root) 计算树的高度 h。\n * 我们运行一个从 l=0 到 h-1 的循环，并访问树中的每一层。在这个循环中，我们使用函数 processcurrentlevel (root, l) 来访问和处理当前级别 l 的节点。\n\n我们如何实现函数 processcurrentlevel (root, l)？让我们思考一下！我们可以把这个问题分成两部分:\n\n * 我们处理左侧子树中 l 级的所有节点。为此，我们用 root->left 和 l - 1 作为函数参数调用同一个函数。为什么？因为，如果当前级别与根的距离是 l，那么它与根 -> 左的距离将是 l - 1。\n * 我们处理右边子树中 l 级的所有节点。为此，我们用 root->right 和 l - 1 作为函数参数调用同一个函数。为什么？因为，如果当前级别与根的距离是 l，那么它与根 -> 右的距离将是 l - 1。\n * 在递归调用过程中，当 l == 0 时，我们到达一个节点，该节点与根的距离为 l。所以我们处理这个节点。通过这种方式，我们可以递归地访问 l 层的所有节点。\n\n伪代码：\n\nclass treenode\n{\n    int data\n    treenode left \n    treenode right\n}\n \nvoid recursivelevelorder(treenode root)\n{\n    int h = height(root)\n    for (int l = 0; l < h; l = l + 1)\n        processcurrentlevel(root, l)\n}\n\nvoid processcurrentlevel(treenode root, int l)\n{\n    if (root == null)\n        return\n    if (l == 0)\n        process(root->data)\n    else if (l > 0)\n    {\n        processcurrentlevel(root->left, l - 1)\n        processcurrentlevel(root->right, l - 1)\n    }\n}\n\nint height(treenode root)\n{\n    if (root == null)\n        return 0\n    else\n    {\n        int leftheight = height(root->left)\n        int rightheight = height(root->right)\n        \n        if (leftheight > rightheight)\n            return (rightheight + 1)\n        else \n            return(rightheight + 1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n时间和空间复杂性分析：\n\n对于每一次递归调用 processcurrentlevel ()，我们都要在左右子树中向下移动 l-1 级。换句话说，我们正在访问从 0 级到 l 级的每个节点，并检查 l==0 与否。所以有一个想法很清楚：操作的总数取决于树的高度。\n\n最坏的情况是倾斜的树，每层都有一个节点。在这种情况下，processcurrentlevel () 对最后一层需要 o (n) 时间，对倒数第二层需要 o (n-1) 时间，以此类推。这里 n 是树中的节点数。时间复杂性 = o(n) + o(n-1) + ... + o(1) = o(n + (n-1) + ...+ 1) = o(n^2) 。\n\n在最坏的情况下，空间复杂度 = o (n)。对于一棵倾斜的树，processcurrentlevel () 将使用 o (n) 空间作为调用栈。对于一个平衡树，调用栈使用 o (log n) 空间（这等于平衡树的高度）。\n\n\n# 使用队列的 bfs 遍历\n\n现在的关键问题是，我们能优化 bfs 遍历的时间复杂性吗？我们能以 o (n) 的时间复杂度逐级遍历树吗？让我们观察一下层级遍历中的节点顺序。\n\n * 我们首先处理第 0 层的根节点，然后处理第 1 层的左、右子节点（假设从左到右的顺序）。\n * 同样地，在第二层，我们首先处理根节点的左子节点的子节点，然后处理右子节点的子节点。这个过程对树中的所有级别都是如此。\n\n因此，有一个想法是明确的：在任何给定的级别，节点将被首先处理，该节点的子女将在下一级被首先处理。这是处理节点的先入先出顺序（fifo 顺序）。所以我们可以使用队列数据结构来模拟 bfs 遍历。\n\n使用队列进行 bfs 遍历的实施步骤：\n\n * 我们取一个空的队列 treequeue，并用根节点初始化它。\n * 现在我们运行一个循环，直到 treequeue 不为空。\n * 在这个循环中，我们声明一个 currnode，以便在遍历过程中跟踪当前节点。\n * 我们开始循环，从 treequeue 中移除前端节点，并将其分配给 currnode。我们处理 currnode，并将左右两个子节点插入到 treequeue 中。\n\ntreenode currnode = treequeue.dequeue()\nprocess (currnode->data)\n\n\n1\n2\n\n * 如果 currnode 的左侧子节点不是 null，我们将左侧子节点插入到 treequeue 中。\n\nif (currnode->left != null)\n  treequeue.enqueue(currnode->left)\n\n\n1\n2\n\n * 如果 currnode 的右边的孩子不是 null，我们就把右边的孩子插入到 treequeue 中。\n\nif (currnode->right != null)\n  treequeue.enqueue(currnode->right)\n\n\n1\n2\n\n\n在处理完最后一级的最右边的节点后，队列里面就没有节点可以继续处理了。所以我们从循环中出来，我们的层序遍历在这时完成。\n\n伪代码：\n\nvoid iterativelevelorder(treenode root)\n{\n    if (root == null)  \n        return\n    queue<treenode> treequeue\n    treequeue.enqueue(root)\n    while (treequeue.empty() == false)\n    {\n        treenode currnode = treequeue.dequeue()\n        process(currnode->data) \n        \n        if (currnode->left != null)\n            treequeue.enqueue(currnode->left)\n \n        if (currnode->right != null)\n            treequeue.enqueue(currnode->right)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nbfs 遍历的时间复杂性分析：\n\n * 假设输入中有 n 个节点。\n * enqueue 和 dequeue 操作的时间复杂度 = o (1)\n * 我们在循环内为每个节点做两次队列操作。向队列中插入一次，从队列中删除一次。所以总的队列操作 = 2n。\n * 总体时间复杂度 = 总队列操作 * 每个队列操作的时间复杂度 = 2n * o (1) = o (n)\n\nbfs 遍历的空间复杂度分析：\n\n空间复杂度等于队列大小。我们逐级处理节点，所以最大队列大小取决于具有最大节点数或二叉树最大宽度的层级。如果二叉树的最大宽度是 w，那么空间复杂度 = o（w）。这个想法很简单：w 取决于给定二叉树的结构。\n\n最坏的情况：当树是平衡的，最后一层将有最大的宽度或最大的节点数，这将是 2^h（其中 h 是树的高度）。对于平衡树，h=logn，所需的队列大小 = o (2^h) = o (2 ^ (log n)) = o (n)。空间复杂度 = o (n)\n\n最好的情况：当树是倾斜的，在这种情况下，每一层最多只有一个节点，因此在任何一点，队列中最多只有一个节点。因此需要的队列大小 = o (1)。空间复杂度 = o (1)。\n\n\n# 二叉树的 bfs 遍历 vs dfs 遍历\n\n * 这两种遍历方法都需要 o (n) 时间，因为它们对每个节点都正好访问一次。\n * 深度优先遍历从根部开始，尽可能地深入，然后从那里回溯。换句话说，它从树的底部访问节点。但在广度优先搜索中，我们逐级探索节点，即按照它们与根节点的距离排序。因此，如果我们的问题是要搜索离根更近的东西，我们会选择 bfs。而如果我们需要在树的深度或靠近叶子的节点中搜索一些东西，我们会选择 dfs。\n * 在 bfs 遍历中，我们使用队列数据结构来存储不同层次的节点。但是在 dfs 遍历中，我们使用堆栈（如果是递归，系统使用调用堆栈）来存储一个节点的所有祖先。\n * bfs 和 dfs 所占用的内存都取决于树的结构。bfs 遍历所需的额外空间是 o (w)，但 dfs 遍历所需的额外空间是 o (h)。这里 w = 二叉树的最大宽度，h = 二叉树的最大高度。在最坏的情况下，两者都需要 o (n) 的额外空间，但最坏的情况发生在不同类型的树。例如，当树比较平衡时，bfs 遍历需要的空间可能会更多，而当树不太平衡时，dfs 遍历的额外空间可能会更多。\n * 有时，当解决问题时不需要节点顺序，我们可以同时使用 bfs 和 dfs 遍历。但在某些情况下，这种事情是不可能的。我们需要确定遍历的使用情况，以便有效地解决问题。\n\n\n# 实现\n\n\n# javascript\n\n/*\n  breadth first tree traversal or level order traversal implementation in javascript\n  author: @gerardubuntu\n*/\n\nclass node {\n  constructor (data) {\n    this.data = data\n    this.left = null\n    this.right = null\n  }\n}\n\nclass binarytree {\n  constructor () {\n    this.root = null\n    this.traversal = []\n  }\n\n  breadthfirst () {\n    const h = this.getheight(this.root)\n    for (let i = 0; i !== h; i++) {\n      this.traverselevel(this.root, i)\n    }\n    return this.traversal\n  }\n\n  // computing the height of the tree\n  getheight (node) {\n    if (node === null) {\n      return 0\n    }\n    const lheight = this.getheight(node.left)\n    const rheight = this.getheight(node.right)\n    return lheight > rheight ? lheight + 1 : rheight + 1\n  }\n\n  traverselevel (node, levelremaining) {\n    if (node === null) {\n      return\n    }\n    if (levelremaining === 0) {\n      this.traversal.push(node.data)\n    } else {\n      this.traverselevel(node.left, levelremaining - 1)\n      this.traverselevel(node.right, levelremaining - 1)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 参考\n\n * level order traversal (bfs traversal) of a binary tree\n * breadthfirstsearch [广度优先搜索 / bfs] | fancy dsa",charsets:{cjk:!0},lastUpdated:"2022/10/19, 17:35:33",lastUpdatedTimestamp:1666172133e3},{title:"DepthFirstSearch [二叉树的深度优先遍历]",frontmatter:{title:"DepthFirstSearch [二叉树的深度优先遍历]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/tree/depthFirstSearch/",categories:["算法","Tree 树"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/50.Tree%20%E6%A0%91/20.DepthFirstSearch.html",relativePath:"20.算法/50.Tree 树/20.DepthFirstSearch.md",key:"v-7679b8ac",path:"/algorithm/tree/depthFirstSearch/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1706}],headersStr:"实现 JavaScript 参考",content:"# 实现\n\n\n# JavaScript\n\n/*\n * Author: Surendra Kumar\n * DFS Algorithm implementation in JavaScript\n * DFS Algorithm for traversing or searching graph data structures.\n*/\n\nfunction traverseDFS (root) {\n  const stack = [root]\n  const res = []\n\n  while (stack.length) {\n    const curr = stack.pop()\n    res.push(curr.key)\n\n    if (curr.right) {\n      stack.push(curr.right)\n    }\n\n    if (curr.left) {\n      stack.push(curr.left)\n    }\n  }\n\n  return res.reverse()\n}\n\nfunction searchDFS (tree, value) {\n  const stack = []\n\n  stack.push(tree[0])\n\n  while (stack.length !== 0) {\n    for (let i = 0; i < stack.length; i++) {\n      const node = stack.pop()\n\n      if (node.value === value) {\n        return node\n      }\n      if (node.right) {\n        stack.push(tree[node.right])\n      }\n      if (node.left) {\n        stack.push(tree[node.left])\n      }\n    }\n  }\n  return null\n}\n\nconst tree = [\n  { value: 6, left: 1, right: 2 },\n  { value: 5, left: 3, right: 4 },\n  { value: 7, left: null, right: 5 },\n  { value: 3, left: 6, right: null },\n  { value: 4, left: null, right: null },\n  { value: 9, left: 7, right: 8 },\n  { value: 2, left: 9, right: null },\n  { value: 8, left: null, right: null },\n  { value: 10, left: null, right: null },\n  { value: 1, left: null, right: null }\n]\n\nsearchDFS(tree, 9)\nsearchDFS(tree, 10)\n\ntraverseDFS(6)\n\n//            6\n//           / \\\n//          5   7\n//         / \\   \\\n//        3   4   9\n//       /       / \\\n//      2       8   10\n//     /\n//    1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 参考\n\n * DepthFirstSearch [深度优先搜索] | Fancy DSA\n * DFS traversal of a tree using recursion - GeeksforGeeks\n * Demystifying Depth-First Search. Once you’ve learned enough about… | by Vaidehi Joshi | basecs | Medium",normalizedContent:"# 实现\n\n\n# javascript\n\n/*\n * author: surendra kumar\n * dfs algorithm implementation in javascript\n * dfs algorithm for traversing or searching graph data structures.\n*/\n\nfunction traversedfs (root) {\n  const stack = [root]\n  const res = []\n\n  while (stack.length) {\n    const curr = stack.pop()\n    res.push(curr.key)\n\n    if (curr.right) {\n      stack.push(curr.right)\n    }\n\n    if (curr.left) {\n      stack.push(curr.left)\n    }\n  }\n\n  return res.reverse()\n}\n\nfunction searchdfs (tree, value) {\n  const stack = []\n\n  stack.push(tree[0])\n\n  while (stack.length !== 0) {\n    for (let i = 0; i < stack.length; i++) {\n      const node = stack.pop()\n\n      if (node.value === value) {\n        return node\n      }\n      if (node.right) {\n        stack.push(tree[node.right])\n      }\n      if (node.left) {\n        stack.push(tree[node.left])\n      }\n    }\n  }\n  return null\n}\n\nconst tree = [\n  { value: 6, left: 1, right: 2 },\n  { value: 5, left: 3, right: 4 },\n  { value: 7, left: null, right: 5 },\n  { value: 3, left: 6, right: null },\n  { value: 4, left: null, right: null },\n  { value: 9, left: 7, right: 8 },\n  { value: 2, left: 9, right: null },\n  { value: 8, left: null, right: null },\n  { value: 10, left: null, right: null },\n  { value: 1, left: null, right: null }\n]\n\nsearchdfs(tree, 9)\nsearchdfs(tree, 10)\n\ntraversedfs(6)\n\n//            6\n//           / \\\n//          5   7\n//         / \\   \\\n//        3   4   9\n//       /       / \\\n//      2       8   10\n//     /\n//    1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 参考\n\n * depthfirstsearch [深度优先搜索] | fancy dsa\n * dfs traversal of a tree using recursion - geeksforgeeks\n * demystifying depth-first search. once you’ve learned enough about… | by vaidehi joshi | basecs | medium",charsets:{cjk:!0},lastUpdated:"2022/10/19, 17:35:33",lastUpdatedTimestamp:1666172133e3},{title:"FenwickTree [二叉索引树]",frontmatter:{title:"FenwickTree [二叉索引树]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/tree/fenwickTree/",categories:["算法","Tree 树"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/50.Tree%20%E6%A0%91/30.FenwickTree.html",relativePath:"20.算法/50.Tree 树/30.FenwickTree.md",key:"v-45074848",path:"/algorithm/tree/fenwickTree/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:270},{level:2,title:"Lowbit",slug:"lowbit",normalizedTitle:"lowbit",charIndex:901},{level:2,title:"建立索引",slug:"建立索引",normalizedTitle:"建立索引",charIndex:2224},{level:2,title:"Sum",slug:"sum",normalizedTitle:"sum",charIndex:3204},{level:2,title:"更新节点",slug:"更新节点",normalizedTitle:"更新节点",charIndex:4263},{level:2,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:4599},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:5081},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:892},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:5095},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5962}],headersStr:"介绍 使用场景 Lowbit 建立索引 Sum 更新节点 初始化 演示 实现 JavaScript 参考",content:'# 介绍\n\n树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为 Fenwick 树。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和，区间和。它可以在 O(logn)O(log n)O(logn) 的时间内得到数组的前缀和(A[1]+A[2]+…+A[i])(A[1] + A[2] + … + A[i])(A[1]+A[2]+…+A[i])，且在 O(logn)O(log n)O(logn) 时间内支持动态修改数组的值。\n\n\n# 使用场景\n\n首先我们考虑一个数组 AAA，想求 Ai,Ai+1,…,AjAi,Ai+1,…,AjAi,Ai+1,…,Aj 的和，如果只求一次，很自然地把这些数相加即可，时间复杂度为 O(n)O(n)O(n)。但现在如果我们经常要求 AAA 中第 iii 到第 jjj 个元素的和，则最好事先做个索引。\n\n做法也简单，我们新建一个数组 CCC，数组 CCC 中的元素 Ci=A0+A1+…+AiCi=A0+A1+…+AiCi=A0+A1+…+Ai。于是如果我们要求 AiAiAi 到 AjAjAj 的和，则有 Q(i,j)=Ai+…+Aj=Cj−Ci−1Q(i,j)=Ai+…+Aj=Cj−Ci−1Q(i,j)=Ai+…+Aj=Cj−Ci−1。即通过访问数组 CCC，我们只需要 O(1)O(1)O(1) 的时间即可。\n\n但如果 AAA 中的元素 AiAiAi 的值有变化呢？这时，我们需要更新 CiCiCi 之后的所有数据，需要 O(n)O(n)O(n) 的时间。\n\n于是索引 C 需要空间 O(n)O(n)O(n)，访问 O(1)O(1)O(1)，修改 O(n)O(n)O(n)。\n\n有时我们需要平衡索引的访问和修改时间，二叉索引数 (binary indexed tree) 可以让我们用 O (logn) O (log⁡n) 的时间复杂度进行访问，用 O(logn)O(logn)O(logn) 完成修改。虽然称为 "树"，但其实是用数组实现的。\n\n\n# Lowbit\n\n首先，我们来看一个完全二叉树：\n\n                                   lowbit\n\n                o                ├ 1000 = 8\n        ┌───────┴───────┐        │\n        o               o        ├ 100  = 4\n    ┌───┴───┐       ┌───┴───┐    │\n    o       o       o       o    ├ 10   = 2\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │\n  o   o   o   o   o   o   o   o  ├ 1    = 1\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们看到二叉树不同层数二叉结尾是有规律的。例如第一层：1, 3, 5, 7, …，这些数的二进制分别是 1, 11, 101, 111, …，最后一位都是 1。同理，第二层的数都以 10 结尾。现在我们定义一个新的函数 lowbit (n)，它的作用是在 n 的二进制上从右往左数，数到第一个 1 为止。例如数字 6 的二进制是 110，向右数到第一个 1，得到 10，得到 lowbit (6) = b10 = 2，同理 lowbit (12) = 4。\n\n那么 lowbit 有什么用呢？如果当前节点是父节点的右子树，则 n - lowbit (n) 正好是父节点。再例如 12，12 - lowbit (12) = 12 - 4 = 8 正好是 12 的父节点 8。而如果当前节点是父节点的左子树，则 n - lowbit (n) 代表了它的第一个 "左祖父节点"，例如节点 10，10 - lowbit (10) = 10 - 2 = 8，是 10 的左祖父节点。同理， n + lowbit (n) 是 “右” 祖父节点。例如 4，4 + lowbit (4) = 4 + 4 = 8 是 4 的父节点；而 6 + lowbit (6) = 6 + 2 = 8 则对应于 6 的右祖父节点。\n\n同时可以看到 n - lowbit (n) + 1 在完全二叉数上对应的节点，就是从数字 n 对应的节点开始，不断取节点的左子节点直到第一层的那个节点。例如 12 所在的结点，不断取左子节点，最终得到的是 9，而 9 = 12 - 4 + 1 = 12 - lowbit (12) + 1。\n\n有了 lowbit，我们就能在完全二叉树里快速地定位：\n\n * n - lowbit (bit) 为左祖父 / 父节点\n * n + lowbit (bit) 为右祖父 / 父节点\n * n - lowbit (bit) + 1 为左子树的底层节点\n\n从编程的角度上， lowbit 可以由位运算完成 (C++)：\n\nint lowbit(int x)\n{\n    return x&(-x);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 建立索引\n\n我们知道，索引的本质就是预先存储一些信息，现在我们来看如何从原数组 A 来构建我们的二叉索引数 BIT 。我们定义：\n\nBITi=∑j=i−lowbit(i)+1iAjB I T_i=\\sum_{j=i-l o w b i t(i)+1}^i A_j BITi =j=i−lowbit(i)+1∑i Aj\n\n看公式好像很复杂，我们拆解一下。看到下标 i - lowbit(i) + 1 ，我们知道代表了 i 所在节点左子树的底层节点。我们用图来说明如何计算 BIT [12] (图中标 x)。\n\n                o\n        ┌───────┴───────┐\n        o               x\n    ┌───┴───┐       ┌───┴───┐\n    o       o       x       o\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐\n  o   o   o   o   x   x   o   o\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\nA:                2 1 3 1\nBIT:                   (7)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到 12 - lowbit(12) + 1 = 12-4+1=9 ，因此 BIT[12] = A[9] + A[10] + A[11] + A[12] 。同理，如果要计算 BIT [8]，则需要计算 A[1] + ... + A[8] ，因为 8 - lowbit(8) + 1 = 1 。\n\n\n                x\n        ┌───────┴───────┐\n        x               o\n    ┌───┴───┐       ┌───┴───┐\n    x       x       o       o\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐\n  x   x   x   x   o   o   o   o\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n具体如何构建二叉索引树我们下面再说。\n\n\n# Sum\n\n我们定义二叉查找树的查找操作为 sum(k) = A[1] + ... + A[k] ，有了 BIT 之后，就可以这么求：\n\nint sum(int k)\n{\n    int ans = 0;\n    for (int i = k; i > 0; i = i-lowbit(i))\n        ans += BIT[i];\n    return ans;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n还记得 n - lowbit(n) 代表什么吗？代表的是 n 节点的左祖父 / 父节点。因此为了求 sum(k) 我们只需要将 k 及 k 的所有左祖父 / 父节点相加即可。因此复杂度是 O(logn)O(logn)O(logn)。\n\n                                   lowbit\n\n                o                ├ 1000 = 8\n        ┌───────┴───────┐        │\n        o               o        ├ 100  = 4\n    ┌───┴───┐       ┌───┴───┐    │\n    o       o       o       o    ├ 10   = 2\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │\n  o   o   o   o   o   o   o   o  ├ 1    = 1\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们以 6 为例，BIT [6] 相当于 A[5] + A[6] ，但我们要计算 A[1] + ... + A[6] ，因此还要计算 A[1] + ... + A[4] ，而在 BIT 中，这正好对应于 BIT [4]。再以 14 为例， BIT[14] = A[13] + a[14] ，还差 A[1] + ... + A[12] ，于是找到 14 - lowbit(14) = 14 - 2 = 12 ，而由于 BIT[12] = BIT[9] + ... + BIT[12] ，因此还差 A[1] + ... + A[8] ，正好对应于 BIT [8]，而又有 12 - lowbit(12) = 12 - 4 = 8 。\n\n所以说 sum (k) 操作就是求节点 k 及它的父节点的和。\n\n\n# 更新节点\n\n如果 A [k] 的值发生变化了怎么办？从 BIT 的定义可知，A [k] 的值会影响 k 的所有右祖父 / 父节点。而这可以通过 k + lowbit(k) 来得到。例如 A [9] 发生了变化，根据定义，我们需要更新 BIT [9], BIT [10], BIT [12]。代码如下：\n\nvoid edit(int i, int delta)\n{\n    for (int j = i; j <= MAX_N; j = j+lowbit(j))\n        BIT[j] += delta;\n}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，和 sum 类似，也是不断寻找祖父 / 父节点的过程，因此也是 O(logn)O(logn)O(logn)。\n\n\n# 初始化\n\n可以有多种方式初始化，每种的复杂度不同。\n\n先假设初始数组 A 全为 0，之后调用节点更新函数 edit 来更新数组中的每个元素，复杂度为 O(nlogn)O(nlogn)O(nlogn)。\n\nvoid build()\n{\n    for (int i=1;i<=MAX_N;i++)\n    {\n        edit(i, A[i])\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当然初始化操作是可以达到 O (n) O (n) 的。方法是像开头说的，先创建一个累加数组，于是只需要用 O (1) O (1) 时间即可求得 A[j] - A[i] 。\n\n但这么做意义不是特别大。因为当我们采用 BIT 时，其实就意味着我们想利用它更新时间为 O(logn)O(logn)O(logn) 的特性，这意味着更新操作不会少。于是可以大胆猜测会有 O (n) O (n) 个更新操作，这样整体的算法复杂度就要大于 O(nlogn)O(nlogn)O(nlogn)，那么强行用 O(n)O(n)O(n) 来初始化 BIT 也没有太大的意义。\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Author: Mohit Kumar\n * Fedwick Tree Implementation in JavaScript\n * Fedwick Tree Implementation for finding prefix sum.\n*/\n\nclass FenwickTree {\n  constructor (feneickArray, array, n) {\n    for (let i = 1; i <= n; i++) {\n      feneickArray[i] = 0\n    }\n    for (let i = 0; i < n; i++) {\n      this.update(feneickArray, n, i, array[i])\n    }\n  }\n\n  update (feneickArray, n, index, value) {\n    index = index + 1\n    while (index <= n) {\n      feneickArray[index] += value\n      index += index & (-index)\n    }\n  }\n\n  getPrefixSum (feneickArray, index) {\n    let currSum = 0\n    index = index + 1\n    while (index > 0) {\n      currSum += feneickArray[index]\n      index -= index & (-index)\n    }\n\n    return currSum\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n注意，feneickArray 是从 1 开始的。\n\n\n# 参考\n\n * 树状数组 - Wikiwand\n * Fenwick tree - Wikiwand\n * 二叉索引树 | 三点水\n * 二进制索引树 (树状数组)',normalizedContent:'# 介绍\n\n树状数组或二元索引树（英语：binary indexed tree），又以其发明者命名为 fenwick 树。其初衷是解决数据压缩里的累积频率（cumulative frequency）的计算问题，现多用于高效计算数列的前缀和，区间和。它可以在 o(logn)o(log n)o(logn) 的时间内得到数组的前缀和(a[1]+a[2]+…+a[i])(a[1] + a[2] + … + a[i])(a[1]+a[2]+…+a[i])，且在 o(logn)o(log n)o(logn) 时间内支持动态修改数组的值。\n\n\n# 使用场景\n\n首先我们考虑一个数组 aaa，想求 ai,ai+1,…,ajai,ai+1,…,ajai,ai+1,…,aj 的和，如果只求一次，很自然地把这些数相加即可，时间复杂度为 o(n)o(n)o(n)。但现在如果我们经常要求 aaa 中第 iii 到第 jjj 个元素的和，则最好事先做个索引。\n\n做法也简单，我们新建一个数组 ccc，数组 ccc 中的元素 ci=a0+a1+…+aici=a0+a1+…+aici=a0+a1+…+ai。于是如果我们要求 aiaiai 到 ajajaj 的和，则有 q(i,j)=ai+…+aj=cj−ci−1q(i,j)=ai+…+aj=cj−ci−1q(i,j)=ai+…+aj=cj−ci−1。即通过访问数组 ccc，我们只需要 o(1)o(1)o(1) 的时间即可。\n\n但如果 aaa 中的元素 aiaiai 的值有变化呢？这时，我们需要更新 cicici 之后的所有数据，需要 o(n)o(n)o(n) 的时间。\n\n于是索引 c 需要空间 o(n)o(n)o(n)，访问 o(1)o(1)o(1)，修改 o(n)o(n)o(n)。\n\n有时我们需要平衡索引的访问和修改时间，二叉索引数 (binary indexed tree) 可以让我们用 o (logn) o (log⁡n) 的时间复杂度进行访问，用 o(logn)o(logn)o(logn) 完成修改。虽然称为 "树"，但其实是用数组实现的。\n\n\n# lowbit\n\n首先，我们来看一个完全二叉树：\n\n                                   lowbit\n\n                o                ├ 1000 = 8\n        ┌───────┴───────┐        │\n        o               o        ├ 100  = 4\n    ┌───┴───┐       ┌───┴───┐    │\n    o       o       o       o    ├ 10   = 2\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │\n  o   o   o   o   o   o   o   o  ├ 1    = 1\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们看到二叉树不同层数二叉结尾是有规律的。例如第一层：1, 3, 5, 7, …，这些数的二进制分别是 1, 11, 101, 111, …，最后一位都是 1。同理，第二层的数都以 10 结尾。现在我们定义一个新的函数 lowbit (n)，它的作用是在 n 的二进制上从右往左数，数到第一个 1 为止。例如数字 6 的二进制是 110，向右数到第一个 1，得到 10，得到 lowbit (6) = b10 = 2，同理 lowbit (12) = 4。\n\n那么 lowbit 有什么用呢？如果当前节点是父节点的右子树，则 n - lowbit (n) 正好是父节点。再例如 12，12 - lowbit (12) = 12 - 4 = 8 正好是 12 的父节点 8。而如果当前节点是父节点的左子树，则 n - lowbit (n) 代表了它的第一个 "左祖父节点"，例如节点 10，10 - lowbit (10) = 10 - 2 = 8，是 10 的左祖父节点。同理， n + lowbit (n) 是 “右” 祖父节点。例如 4，4 + lowbit (4) = 4 + 4 = 8 是 4 的父节点；而 6 + lowbit (6) = 6 + 2 = 8 则对应于 6 的右祖父节点。\n\n同时可以看到 n - lowbit (n) + 1 在完全二叉数上对应的节点，就是从数字 n 对应的节点开始，不断取节点的左子节点直到第一层的那个节点。例如 12 所在的结点，不断取左子节点，最终得到的是 9，而 9 = 12 - 4 + 1 = 12 - lowbit (12) + 1。\n\n有了 lowbit，我们就能在完全二叉树里快速地定位：\n\n * n - lowbit (bit) 为左祖父 / 父节点\n * n + lowbit (bit) 为右祖父 / 父节点\n * n - lowbit (bit) + 1 为左子树的底层节点\n\n从编程的角度上， lowbit 可以由位运算完成 (c++)：\n\nint lowbit(int x)\n{\n    return x&(-x);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 建立索引\n\n我们知道，索引的本质就是预先存储一些信息，现在我们来看如何从原数组 a 来构建我们的二叉索引数 bit 。我们定义：\n\nbiti=∑j=i−lowbit(i)+1iajb i t_i=\\sum_{j=i-l o w b i t(i)+1}^i a_j biti =j=i−lowbit(i)+1∑i aj\n\n看公式好像很复杂，我们拆解一下。看到下标 i - lowbit(i) + 1 ，我们知道代表了 i 所在节点左子树的底层节点。我们用图来说明如何计算 bit [12] (图中标 x)。\n\n                o\n        ┌───────┴───────┐\n        o               x\n    ┌───┴───┐       ┌───┴───┐\n    o       o       x       o\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐\n  o   o   o   o   x   x   o   o\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\na:                2 1 3 1\nbit:                   (7)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到 12 - lowbit(12) + 1 = 12-4+1=9 ，因此 bit[12] = a[9] + a[10] + a[11] + a[12] 。同理，如果要计算 bit [8]，则需要计算 a[1] + ... + a[8] ，因为 8 - lowbit(8) + 1 = 1 。\n\n\n                x\n        ┌───────┴───────┐\n        x               o\n    ┌───┴───┐       ┌───┴───┐\n    x       x       o       o\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐\n  x   x   x   x   o   o   o   o\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n具体如何构建二叉索引树我们下面再说。\n\n\n# sum\n\n我们定义二叉查找树的查找操作为 sum(k) = a[1] + ... + a[k] ，有了 bit 之后，就可以这么求：\n\nint sum(int k)\n{\n    int ans = 0;\n    for (int i = k; i > 0; i = i-lowbit(i))\n        ans += bit[i];\n    return ans;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n还记得 n - lowbit(n) 代表什么吗？代表的是 n 节点的左祖父 / 父节点。因此为了求 sum(k) 我们只需要将 k 及 k 的所有左祖父 / 父节点相加即可。因此复杂度是 o(logn)o(logn)o(logn)。\n\n                                   lowbit\n\n                o                ├ 1000 = 8\n        ┌───────┴───────┐        │\n        o               o        ├ 100  = 4\n    ┌───┴───┐       ┌───┴───┐    │\n    o       o       o       o    ├ 10   = 2\n  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │\n  o   o   o   o   o   o   o   o  ├ 1    = 1\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们以 6 为例，bit [6] 相当于 a[5] + a[6] ，但我们要计算 a[1] + ... + a[6] ，因此还要计算 a[1] + ... + a[4] ，而在 bit 中，这正好对应于 bit [4]。再以 14 为例， bit[14] = a[13] + a[14] ，还差 a[1] + ... + a[12] ，于是找到 14 - lowbit(14) = 14 - 2 = 12 ，而由于 bit[12] = bit[9] + ... + bit[12] ，因此还差 a[1] + ... + a[8] ，正好对应于 bit [8]，而又有 12 - lowbit(12) = 12 - 4 = 8 。\n\n所以说 sum (k) 操作就是求节点 k 及它的父节点的和。\n\n\n# 更新节点\n\n如果 a [k] 的值发生变化了怎么办？从 bit 的定义可知，a [k] 的值会影响 k 的所有右祖父 / 父节点。而这可以通过 k + lowbit(k) 来得到。例如 a [9] 发生了变化，根据定义，我们需要更新 bit [9], bit [10], bit [12]。代码如下：\n\nvoid edit(int i, int delta)\n{\n    for (int j = i; j <= max_n; j = j+lowbit(j))\n        bit[j] += delta;\n}\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，和 sum 类似，也是不断寻找祖父 / 父节点的过程，因此也是 o(logn)o(logn)o(logn)。\n\n\n# 初始化\n\n可以有多种方式初始化，每种的复杂度不同。\n\n先假设初始数组 a 全为 0，之后调用节点更新函数 edit 来更新数组中的每个元素，复杂度为 o(nlogn)o(nlogn)o(nlogn)。\n\nvoid build()\n{\n    for (int i=1;i<=max_n;i++)\n    {\n        edit(i, a[i])\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当然初始化操作是可以达到 o (n) o (n) 的。方法是像开头说的，先创建一个累加数组，于是只需要用 o (1) o (1) 时间即可求得 a[j] - a[i] 。\n\n但这么做意义不是特别大。因为当我们采用 bit 时，其实就意味着我们想利用它更新时间为 o(logn)o(logn)o(logn) 的特性，这意味着更新操作不会少。于是可以大胆猜测会有 o (n) o (n) 个更新操作，这样整体的算法复杂度就要大于 o(nlogn)o(nlogn)o(nlogn)，那么强行用 o(n)o(n)o(n) 来初始化 bit 也没有太大的意义。\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\n/*\n * author: mohit kumar\n * fedwick tree implementation in javascript\n * fedwick tree implementation for finding prefix sum.\n*/\n\nclass fenwicktree {\n  constructor (feneickarray, array, n) {\n    for (let i = 1; i <= n; i++) {\n      feneickarray[i] = 0\n    }\n    for (let i = 0; i < n; i++) {\n      this.update(feneickarray, n, i, array[i])\n    }\n  }\n\n  update (feneickarray, n, index, value) {\n    index = index + 1\n    while (index <= n) {\n      feneickarray[index] += value\n      index += index & (-index)\n    }\n  }\n\n  getprefixsum (feneickarray, index) {\n    let currsum = 0\n    index = index + 1\n    while (index > 0) {\n      currsum += feneickarray[index]\n      index -= index & (-index)\n    }\n\n    return currsum\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n注意，feneickarray 是从 1 开始的。\n\n\n# 参考\n\n * 树状数组 - wikiwand\n * fenwick tree - wikiwand\n * 二叉索引树 | 三点水\n * 二进制索引树 (树状数组)',charsets:{cjk:!0},lastUpdated:"2022/10/19, 17:35:33",lastUpdatedTimestamp:1666172133e3},{title:"Abs [绝对值]",frontmatter:{title:"Abs [绝对值]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/math/abs/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/10.Abs.html",relativePath:"20.算法/60.Math 数学/10.Abs.md",key:"v-383bae3e",path:"/algorithm/math/abs/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:194},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:201},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:941}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在数学中，实数 a 的绝对值或模，记号为 | a|，是指去掉 a 的符号所得的非负值。若 a 是正数，则∣a∣=a{\\displaystyle |a|=a}∣a∣=a； 若 x 是负数（则−a-a−a 是正数），则∣a∣=−a{\\displaystyle |a|=-a}∣a∣=−a；零的绝对值为零（∣0∣=0{\\displaystyle |0|=0}∣0∣=0）。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function abs\n * @description This script will find the absolute value of a number.\n * @param {number} num - The input integer\n * @return {number} - Absolute number of num.\n * @see https://en.wikipedia.org/wiki/Absolute_value\n * @example abs(-10) = 10\n * @example abs(50) = 50\n * @example abs(0) = 0\n */\n\nconst abs = (num) => {\n  const validNumber = +num // converted to number, also can use - Number(num)\n\n  if (Number.isNaN(validNumber)) {\n    throw new TypeError('Argument is NaN - Not a Number')\n  }\n\n  return validNumber < 0 ? -validNumber : validNumber // if number is less then zero mean negative then it converted to positive. i.e -> n = -2 = -(-2) = 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * Absolute value - Wikiwand\n * 绝对值 - Wikiwand",normalizedContent:"# 介绍\n\n在数学中，实数 a 的绝对值或模，记号为 | a|，是指去掉 a 的符号所得的非负值。若 a 是正数，则∣a∣=a{\\displaystyle |a|=a}∣a∣=a； 若 x 是负数（则−a-a−a 是正数），则∣a∣=−a{\\displaystyle |a|=-a}∣a∣=−a；零的绝对值为零（∣0∣=0{\\displaystyle |0|=0}∣0∣=0）。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function abs\n * @description this script will find the absolute value of a number.\n * @param {number} num - the input integer\n * @return {number} - absolute number of num.\n * @see https://en.wikipedia.org/wiki/absolute_value\n * @example abs(-10) = 10\n * @example abs(50) = 50\n * @example abs(0) = 0\n */\n\nconst abs = (num) => {\n  const validnumber = +num // converted to number, also can use - number(num)\n\n  if (number.isnan(validnumber)) {\n    throw new typeerror('argument is nan - not a number')\n  }\n\n  return validnumber < 0 ? -validnumber : validnumber // if number is less then zero mean negative then it converted to positive. i.e -> n = -2 = -(-2) = 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * absolute value - wikiwand\n * 绝对值 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 20:15:06",lastUpdatedTimestamp:1666095306e3},{title:"BinaryConvert [二进制转换]",frontmatter:{title:"BinaryConvert [二进制转换]",date:"2022-10-17T21:21:24.000Z",permalink:"/algorithm/math/binaryConvert/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/100.BinaryConvert.html",relativePath:"20.算法/60.Math 数学/100.BinaryConvert.md",key:"v-582593b7",path:"/algorithm/math/binaryConvert/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @function BinaryConvert\n * @description Convert the decimal to binary.\n * @param {Integer} num - The input integer\n * @return {Integer} - Binary of num.\n * @see [BinaryConvert](https://www.programiz.com/javascript/examples/decimal-binary)\n * @example BinaryConvert(12) = 1100\n * @example BinaryConvert(12 + 2) = 1110\n */\n\nconst BinaryConvert = (num) => {\n  let power = 1\n  let binary = 0\n\n  while (num) {\n    const rem = num % 2\n    num = Math.floor(num / 2)\n    binary = rem * power + binary\n    power *= 10\n  }\n\n  return binary\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n或者：\n\n// convert to binary\nconst result = number.toString(2);\n\n\n1\n2\n\n\nJavaScript 内置方法 toString([radix]) 返回一个指定基数（base）的字符串值。在这里，toString (2) 将十进制数字转换为二进制数字。参见：Number.prototype.toString()",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @function binaryconvert\n * @description convert the decimal to binary.\n * @param {integer} num - the input integer\n * @return {integer} - binary of num.\n * @see [binaryconvert](https://www.programiz.com/javascript/examples/decimal-binary)\n * @example binaryconvert(12) = 1100\n * @example binaryconvert(12 + 2) = 1110\n */\n\nconst binaryconvert = (num) => {\n  let power = 1\n  let binary = 0\n\n  while (num) {\n    const rem = num % 2\n    num = math.floor(num / 2)\n    binary = rem * power + binary\n    power *= 10\n  }\n\n  return binary\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n或者：\n\n// convert to binary\nconst result = number.tostring(2);\n\n\n1\n2\n\n\njavascript 内置方法 tostring([radix]) 返回一个指定基数（base）的字符串值。在这里，tostring (2) 将十进制数字转换为二进制数字。参见：number.prototype.tostring()",charsets:{cjk:!0},lastUpdated:"2022/10/19, 17:35:33",lastUpdatedTimestamp:1666172133e3},{title:"CheckKishnamurthyNumber [克里希纳穆尔西数]",frontmatter:{title:"CheckKishnamurthyNumber [克里希纳穆尔西数]",date:"2022-10-17T21:21:31.000Z",permalink:"/algorithm/math/checkKishnamurthyNumber/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/120.CheckKishnamurthyNumber.html",relativePath:"20.算法/60.Math 数学/120.CheckKishnamurthyNumber.md",key:"v-4a4644fb",path:"/algorithm/math/checkKishnamurthyNumber/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:137},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:144},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1854}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n克里希纳穆尔西数是一个数字，其数字的阶乘之和等于该数字本身。例如，145，每个数字的阶乘之和： 1!+ 4!+ 5! = 1 + 24 + 120 = 145 。\n\n有趣的是，我们知道的克里希纳穆尔西数字正好有四个，即 1、2、145 和 40585。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n    Problem statement and Explanation : https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/\n\n    krishnamurthy number is a number the sum of the all factorial of the all dights is equal to the number itself.\n    145 => 1! + 4! + 5! = 1  + 24 + 120 = 145\n*/\n\n// factorial utility method.\nconst factorial = (n) => {\n  let fact = 1\n  while (n !== 0) {\n    fact = fact * n\n    n--\n  }\n  return fact\n}\n\n/**\n * krishnamurthy number is a number the sum of the factorial of the all dights is equal to the number itself.\n * @param {Number} number a number for checking is krishnamurthy number or not.\n * @returns return correspond boolean value, if the number is krishnamurthy number return `true` else return `false`.\n * @example 145 => 1! + 4! + 5! = 1  + 24 + 120 = 145\n */\nconst CheckKishnamurthyNumber = (number) => {\n  // firstly, check that input is a number or not.\n  if (typeof number !== 'number') {\n    return new TypeError('Argument is not a number.')\n  }\n  // create a variable to store the sum of all digits factorial.\n  let sumOfAllDigitFactorial = 0\n  // convert the number to string for convenience.\n  let newNumber = number\n  // Extract number digits using the remainder method.\n  while (newNumber > 0) {\n    const lastDigit = newNumber % 10\n    // calculate each digit factorial.\n    sumOfAllDigitFactorial += factorial(lastDigit)\n    newNumber = Math.floor(newNumber / 10)\n  }\n  // if the sumOftheFactorial is equal to the given number it means the number is a Krishnamurthy number.\n  return sumOfAllDigitFactorial === number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考\n\n * Check if a number is a Krishnamurthy Number or not - GeeksforGeeks",normalizedContent:"# 介绍\n\n克里希纳穆尔西数是一个数字，其数字的阶乘之和等于该数字本身。例如，145，每个数字的阶乘之和： 1!+ 4!+ 5! = 1 + 24 + 120 = 145 。\n\n有趣的是，我们知道的克里希纳穆尔西数字正好有四个，即 1、2、145 和 40585。\n\n\n# 实现\n\n\n# javascript\n\n/*\n    problem statement and explanation : https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/\n\n    krishnamurthy number is a number the sum of the all factorial of the all dights is equal to the number itself.\n    145 => 1! + 4! + 5! = 1  + 24 + 120 = 145\n*/\n\n// factorial utility method.\nconst factorial = (n) => {\n  let fact = 1\n  while (n !== 0) {\n    fact = fact * n\n    n--\n  }\n  return fact\n}\n\n/**\n * krishnamurthy number is a number the sum of the factorial of the all dights is equal to the number itself.\n * @param {number} number a number for checking is krishnamurthy number or not.\n * @returns return correspond boolean value, if the number is krishnamurthy number return `true` else return `false`.\n * @example 145 => 1! + 4! + 5! = 1  + 24 + 120 = 145\n */\nconst checkkishnamurthynumber = (number) => {\n  // firstly, check that input is a number or not.\n  if (typeof number !== 'number') {\n    return new typeerror('argument is not a number.')\n  }\n  // create a variable to store the sum of all digits factorial.\n  let sumofalldigitfactorial = 0\n  // convert the number to string for convenience.\n  let newnumber = number\n  // extract number digits using the remainder method.\n  while (newnumber > 0) {\n    const lastdigit = newnumber % 10\n    // calculate each digit factorial.\n    sumofalldigitfactorial += factorial(lastdigit)\n    newnumber = math.floor(newnumber / 10)\n  }\n  // if the sumofthefactorial is equal to the given number it means the number is a krishnamurthy number.\n  return sumofalldigitfactorial === number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考\n\n * check if a number is a krishnamurthy number or not - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/19, 17:35:33",lastUpdatedTimestamp:1666172133e3},{title:"Coordinate",frontmatter:{title:"Coordinate",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/coordinate/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/130.Coordinate.html",relativePath:"20.算法/60.Math 数学/130.Coordinate.md",key:"v-1cc688c1",path:"/algorithm/math/coordinate/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/*\n Calculate the mathematical properties involving coordinates\n Calculate the Distance Between 2 Points on a 2 Dimensional Plane\n Example: coorDistance(2,2,14,11) will return 15\n Wikipedia reference: https://en.wikipedia.org/wiki/Geographical_distance#Flat-surface_formulae\n*/\nconst euclideanDistance = (longitude1, latitude1, longitude2, latitude2) => {\n  const width = longitude2 - longitude1\n  const height = latitude2 - latitude1\n  return (Math.sqrt(width * width + height * height))\n}\n\nconst manhattanDistance = (longitude1, latitude1, longitude2, latitude2) => {\n  const width = Math.abs(longitude2 - longitude1)\n  const height = Math.abs(latitude2 - latitude1)\n  return width + height\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/*\n calculate the mathematical properties involving coordinates\n calculate the distance between 2 points on a 2 dimensional plane\n example: coordistance(2,2,14,11) will return 15\n wikipedia reference: https://en.wikipedia.org/wiki/geographical_distance#flat-surface_formulae\n*/\nconst euclideandistance = (longitude1, latitude1, longitude2, latitude2) => {\n  const width = longitude2 - longitude1\n  const height = latitude2 - latitude1\n  return (math.sqrt(width * width + height * height))\n}\n\nconst manhattandistance = (longitude1, latitude1, longitude2, latitude2) => {\n  const width = math.abs(longitude2 - longitude1)\n  const height = math.abs(latitude2 - latitude1)\n  return width + height\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"CoPrimeCheck",frontmatter:{title:"CoPrimeCheck",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/coPrimeCheck/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/140.CoPrimeCheck.html",relativePath:"20.算法/60.Math 数学/140.CoPrimeCheck.md",key:"v-48760081",path:"/algorithm/math/coPrimeCheck/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/*\n    Problem statement and Explanation : https://en.wikipedia.org/wiki/Coprime_integers\n\n    In number theory, two integers a and b are coprime, relatively prime or\n    mutually prime if the only positive integer that is a divisor of both\n    of them is Consequently, any prime number that divides one of a\n    or b does not divide the other. This is equivalent to their greatest\n    common divisor (gcd) being. One says also a is prime to b or a\n    is coprime with b.\n*/\n\n// Here we use a GetEuclidGCD method as a utility.\nconst GetEuclidGCD = (arg1, arg2) => {\n  let less = arg1 > arg2 ? arg2 : arg1\n  for (less; less >= 2; less--) {\n    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)\n  }\n  return (less)\n}\n\n// CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.\n/**\n * CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.\n * @param {Number} firstNumber first number for checking is prime or not.\n * @param {Number} secondNumber second number for checking is prime or not.\n * @returns return correspond boolean value, if both number are co-prime return `true`, else return `false`.\n */\nconst CoPrimeCheck = (firstNumber, secondNumber) => {\n  // firstly, check that input is a number or not.\n  if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {\n    return new TypeError('Argument is not a number.')\n  }\n  /*\n    This is the most efficient algorithm for checking co-primes\n    if the GCD of both the numbers is 1 that means they are co-primes.\n    */\n  return GetEuclidGCD(firstNumber, secondNumber) === 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/*\n    problem statement and explanation : https://en.wikipedia.org/wiki/coprime_integers\n\n    in number theory, two integers a and b are coprime, relatively prime or\n    mutually prime if the only positive integer that is a divisor of both\n    of them is consequently, any prime number that divides one of a\n    or b does not divide the other. this is equivalent to their greatest\n    common divisor (gcd) being. one says also a is prime to b or a\n    is coprime with b.\n*/\n\n// here we use a geteuclidgcd method as a utility.\nconst geteuclidgcd = (arg1, arg2) => {\n  let less = arg1 > arg2 ? arg2 : arg1\n  for (less; less >= 2; less--) {\n    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)\n  }\n  return (less)\n}\n\n// coprimecheck function return the boolean in respect of the given number is co-prime or not.\n/**\n * coprimecheck function return the boolean in respect of the given number is co-prime or not.\n * @param {number} firstnumber first number for checking is prime or not.\n * @param {number} secondnumber second number for checking is prime or not.\n * @returns return correspond boolean value, if both number are co-prime return `true`, else return `false`.\n */\nconst coprimecheck = (firstnumber, secondnumber) => {\n  // firstly, check that input is a number or not.\n  if (typeof firstnumber !== 'number' || typeof secondnumber !== 'number') {\n    return new typeerror('argument is not a number.')\n  }\n  /*\n    this is the most efficient algorithm for checking co-primes\n    if the gcd of both the numbers is 1 that means they are co-primes.\n    */\n  return geteuclidgcd(firstnumber, secondnumber) === 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"DegreeToRadian",frontmatter:{title:"DegreeToRadian",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/degreeToRadian/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/160.DegreeToRadian.html",relativePath:"20.算法/60.Math 数学/160.DegreeToRadian.md",key:"v-0577e13e",path:"/algorithm/math/degreeToRadian/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/*\n * Radian : https://en.wikipedia.org/wiki/Radian\n * Degree : https://en.wikipedia.org/wiki/Degree_(angle)\n *\n * Angle in Radian = ( Angle in Degree ) x ( pi / 180 )\n *\n * Example :\n * Question : Convert 90 degree to radian\n * So, Angle in Degree = 90\n *\n * Solution :\n * Angle in Radian = ( 90 ) x ( pi / 180 ) = pi / 2\n *\n * So, 90 degree is equal to pi / 2 radian\n */\n\n/**\n * @param {number} degree\n * @return {number}\n */\nexport const degreeToRadian = (degree) => {\n  return degree * (Math.PI / 180)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/*\n * radian : https://en.wikipedia.org/wiki/radian\n * degree : https://en.wikipedia.org/wiki/degree_(angle)\n *\n * angle in radian = ( angle in degree ) x ( pi / 180 )\n *\n * example :\n * question : convert 90 degree to radian\n * so, angle in degree = 90\n *\n * solution :\n * angle in radian = ( 90 ) x ( pi / 180 ) = pi / 2\n *\n * so, 90 degree is equal to pi / 2 radian\n */\n\n/**\n * @param {number} degree\n * @return {number}\n */\nexport const degreetoradian = (degree) => {\n  return degree * (math.pi / 180)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"DecimalIsolate",frontmatter:{title:"DecimalIsolate",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/decimalIsolate/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/150.DecimalIsolate.html",relativePath:"20.算法/60.Math 数学/150.DecimalIsolate.md",key:"v-081d8441",path:"/algorithm/math/decimalIsolate/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/*\n * function isolates the decimal part of a number.\n * Take the number and subtract it from the floored number.\n * Return the result.\n */\n\nexport const decimalIsolate = (number) => {\n  const answer = parseFloat((number + '').replace(/^[-\\d]+./, '.'))\n  return isNaN(answer) === true ? 0 : answer\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/*\n * function isolates the decimal part of a number.\n * take the number and subtract it from the floored number.\n * return the result.\n */\n\nexport const decimalisolate = (number) => {\n  const answer = parsefloat((number + '').replace(/^[-\\d]+./, '.'))\n  return isnan(answer) === true ? 0 : answer\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"DecimalExpansion",frontmatter:{title:"DecimalExpansion",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/decimalExpansion/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/170.DecimalExpansion.html",relativePath:"20.算法/60.Math 数学/170.DecimalExpansion.md",key:"v-450c7701",path:"/algorithm/math/decimalExpansion/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/**\n * @author Eric Lavault <https://github.com/lvlte>\n *\n * Represents the decimal (or binary, octal, any base from 2 to 10) expansion\n * of a/b using euclidean division.\n *\n * Because this function is recursive, it may throw an error when reaching the\n * maximum call stack size.\n *\n * Returns an array containing : [\n *  0: integer part of the division\n *  1: array of decimals (if any, or an empty array)\n *  2: indexOf 1st cycle digit in decimals array if a/b is periodic, or undef.\n * ]\n *\n * @see https://mathworld.wolfram.com/DecimalExpansion.html\n *\n * @param {number} a\n * @param {number} b\n * @param {number} [base=10]\n * @returns {array}\n */\nexport function decExp (a, b, base = 10, exp = [], d = {}, dlen = 0) {\n  if (base < 2 || base > 10) {\n    throw new RangeError('Unsupported base. Must be in range [2, 10]')\n  }\n\n  if (a === 0) {\n    return [0, [], undefined]\n  }\n\n  if (a === b && dlen === 0) {\n    return [1, [], undefined]\n  }\n\n  // d contains the dividends used so far and the corresponding index of its\n  // euclidean division by b in the expansion array.\n  d[a] = dlen++\n\n  if (a < b) {\n    exp.push(0)\n    return decExp(a * base, b, base, exp, d, dlen)\n  }\n\n  // Euclid's division lemma : a = bq + r\n  const r = a % b\n  const q = (a - r) / b\n\n  // Decimal expansion (1st element is the integer part)\n  exp.push(+q.toString(base))\n\n  if (r === 0) {\n    // got a regular number (division terminates)\n    return [exp[0], exp.slice(1), undefined]\n  }\n\n  // For the next iteration\n  a = r * base\n\n  // Check if `a` has already been used as a dividend, in which case it means\n  // the expansion is periodic.\n  if (a in d) {\n    return [exp[0], exp.slice(1), d[a] - 1]\n  }\n\n  return decExp(a, b, base, exp, d, dlen)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/**\n * @author eric lavault <https://github.com/lvlte>\n *\n * represents the decimal (or binary, octal, any base from 2 to 10) expansion\n * of a/b using euclidean division.\n *\n * because this function is recursive, it may throw an error when reaching the\n * maximum call stack size.\n *\n * returns an array containing : [\n *  0: integer part of the division\n *  1: array of decimals (if any, or an empty array)\n *  2: indexof 1st cycle digit in decimals array if a/b is periodic, or undef.\n * ]\n *\n * @see https://mathworld.wolfram.com/decimalexpansion.html\n *\n * @param {number} a\n * @param {number} b\n * @param {number} [base=10]\n * @returns {array}\n */\nexport function decexp (a, b, base = 10, exp = [], d = {}, dlen = 0) {\n  if (base < 2 || base > 10) {\n    throw new rangeerror('unsupported base. must be in range [2, 10]')\n  }\n\n  if (a === 0) {\n    return [0, [], undefined]\n  }\n\n  if (a === b && dlen === 0) {\n    return [1, [], undefined]\n  }\n\n  // d contains the dividends used so far and the corresponding index of its\n  // euclidean division by b in the expansion array.\n  d[a] = dlen++\n\n  if (a < b) {\n    exp.push(0)\n    return decexp(a * base, b, base, exp, d, dlen)\n  }\n\n  // euclid's division lemma : a = bq + r\n  const r = a % b\n  const q = (a - r) / b\n\n  // decimal expansion (1st element is the integer part)\n  exp.push(+q.tostring(base))\n\n  if (r === 0) {\n    // got a regular number (division terminates)\n    return [exp[0], exp.slice(1), undefined]\n  }\n\n  // for the next iteration\n  a = r * base\n\n  // check if `a` has already been used as a dividend, in which case it means\n  // the expansion is periodic.\n  if (a in d) {\n    return [exp[0], exp.slice(1), d[a] - 1]\n  }\n\n  return decexp(a, b, base, exp, d, dlen)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"AliquotSum [真因数和]",frontmatter:{title:"AliquotSum [真因数和]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/math/aliquotSum/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/20.AliquotSum.html",relativePath:"20.算法/60.Math 数学/20.AliquotSum.md",key:"v-cbd4108e",path:"/algorithm/math/aliquotSum/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:237},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:244},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1417}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在数论中，整数的真因数和又称真因子和是指该整数的所有真因数之和，即除了自己本身外的所有正因数之和，通常以s(n)s(n)s(n) 来表示：s(n)=∑d∣n,d≠nds(n)=\\sum_{d \\mid n, d \\neq n} ds(n)=∑d∣n,d=n d。真因数和可以用来描述质数、完全数、亏数、过剩数和不可及数，也可以用于定义整数的真因数和数列。\n\n1 是唯一一个真因数和为 0 的正整数。如果一个正整数真因数和为 1 则代表该数是一个质数。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  A program to calculate the Aliquot Sum of a number.\n  The aliquot sum of a number n, is the sum of all the proper divisors of n apart from n itself\n  For example, for the number 6\n  The divisors are 1, 2, 3 (we don't consider 6), so its aliquot sum is 1 + 2 + 3 = 6\n  1 is the only number whose aliquot sum is 0 (since its only divisor is 1 and aliquot sum of a number couldn't have itself)\n  For all prime numbers, the aliquot sum is 1, since their only divisor apart from themselves is 1\n  Article on Aliquot Sum: https://en.wikipedia.org/wiki/Aliquot_sum\n */\n\n/**\n * @param {Number} input The number whose aliquot sum you want to calculate\n */\nfunction aliquotSum (input) {\n  // input can't be negative\n  if (input < 0) throw new TypeError('Input cannot be Negative')\n\n  // input can't be a decimal\n  if (Math.floor(input) !== input) throw new TypeError('Input cannot be a Decimal')\n\n  // Dealing with 1, which isn't a prime\n  if (input === 1) return 0\n\n  let sum = 0\n  for (let i = 1; i <= (input / 2); i++) {\n    if (input % i === 0) sum += i\n  }\n\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 参考\n\n * Aliquot sum - Wikiwand\n * 真因数和 - Wikiwand",normalizedContent:"# 介绍\n\n在数论中，整数的真因数和又称真因子和是指该整数的所有真因数之和，即除了自己本身外的所有正因数之和，通常以s(n)s(n)s(n) 来表示：s(n)=∑d∣n,d=nds(n)=\\sum_{d \\mid n, d \\neq n} ds(n)=∑d∣n,d=n d。真因数和可以用来描述质数、完全数、亏数、过剩数和不可及数，也可以用于定义整数的真因数和数列。\n\n1 是唯一一个真因数和为 0 的正整数。如果一个正整数真因数和为 1 则代表该数是一个质数。\n\n\n# 实现\n\n\n# javascript\n\n/*\n  a program to calculate the aliquot sum of a number.\n  the aliquot sum of a number n, is the sum of all the proper divisors of n apart from n itself\n  for example, for the number 6\n  the divisors are 1, 2, 3 (we don't consider 6), so its aliquot sum is 1 + 2 + 3 = 6\n  1 is the only number whose aliquot sum is 0 (since its only divisor is 1 and aliquot sum of a number couldn't have itself)\n  for all prime numbers, the aliquot sum is 1, since their only divisor apart from themselves is 1\n  article on aliquot sum: https://en.wikipedia.org/wiki/aliquot_sum\n */\n\n/**\n * @param {number} input the number whose aliquot sum you want to calculate\n */\nfunction aliquotsum (input) {\n  // input can't be negative\n  if (input < 0) throw new typeerror('input cannot be negative')\n\n  // input can't be a decimal\n  if (math.floor(input) !== input) throw new typeerror('input cannot be a decimal')\n\n  // dealing with 1, which isn't a prime\n  if (input === 1) return 0\n\n  let sum = 0\n  for (let i = 1; i <= (input / 2); i++) {\n    if (input % i === 0) sum += i\n  }\n\n  return sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 参考\n\n * aliquot sum - wikiwand\n * 真因数和 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 20:15:06",lastUpdatedTimestamp:1666095306e3},{title:"Area [面积]",frontmatter:{title:"Area [面积]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/math/area/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/30.Area.html",relativePath:"20.算法/60.Math 数学/30.Area.md",key:"v-e0ba9d36",path:"/algorithm/math/area/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"面积公式",slug:"面积公式",normalizedTitle:"面积公式",charIndex:182},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:193},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:200},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6217}],headersStr:"介绍 面积公式 实现 JavaScript 参考",content:"# 介绍\n\n面积（英语：Area）是用作表示一个曲面或平面图形所占范围的量，可看成是长度（一维度量）及体积（三维度量）的二维类比。对三维立体图形而言，图形的边界的面积称为表面积。\n\n面积在近代数学中占相当重要的角色。面积除与几何学及微积分有关外，亦与线性代数中的行列式有关。在分析学中，平面的面积通常以勒贝格测度（Lebesgue measure）定义。\n\n\n# 面积公式\n\n\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n  Calculate the area of various shapes\n*/\n\n/**\n * @function surfaceAreaCube\n * @description Calculate the Surface Area of a Cube. 立方体\n * @param {Integer} side - Integer\n * @return {Integer} - 6 * side ** 2\n * @see [surfaceAreaCube](https://en.wikipedia.org/wiki/Area#Surface_area)\n * @example surfaceAreaCube(1) = 6\n */\nconst surfaceAreaCube = (side) => {\n  validateNumericParam(side, 'side')\n  return 6 * side ** 2\n}\n\n/**\n * @function surfaceAreaSphere\n * @description Calculate the Surface Area of a Sphere. 球体\n * @param {Integer} radius - Integer\n * @return {Integer} - 4 * pi * r^2\n * @see [surfaceAreaSphere](https://en.wikipedia.org/wiki/Sphere)\n * @example surfaceAreaSphere(5) = 314.1592653589793\n */\nconst surfaceAreaSphere = (radius) => {\n  validateNumericParam(radius, 'radius')\n  return 4.0 * Math.PI * radius ** 2.0\n}\n\n/**\n * @function areaRectangle\n * @description Calculate the area of a rectangle. 矩形\n * @param {Integer} length - Integer\n * @param {Integer} width - Integer\n * @return {Integer} - width * length\n * @see [areaRectangle](https://en.wikipedia.org/wiki/Area#Quadrilateral_area)\n * @example areaRectangle(4) = 16\n */\nconst areaRectangle = (length, width) => {\n  validateNumericParam(length, 'Length')\n  validateNumericParam(width, 'Width')\n  return width * length\n}\n\n/**\n * @function areaSquare\n * @description Calculate the area of a square. 正方形\n * @param {Integer} side - Integer\n * @return {Integer} - side ** 2.\n * @see [areaSquare](https://en.wikipedia.org/wiki/Square)\n * @example areaSquare(4) = 16\n */\nconst areaSquare = (side) => {\n  validateNumericParam(side, 'square side')\n  return side ** 2\n}\n\n/**\n * @function areaTriangle\n * @description Calculate the area of a triangle. 三角形（底和高）\n * @param {Integer} base - Integer\n * @param {Integer} height - Integer\n * @return {Integer} - base * height / 2.\n * @see [areaTriangle](https://en.wikipedia.org/wiki/Area#Triangle_area)\n * @example areaTriangle(1.66, 3.44) = 2.8552\n */\nconst areaTriangle = (base, height) => {\n  validateNumericParam(base, 'Base')\n  validateNumericParam(height, 'Height')\n  return (base * height) / 2.0\n}\n\n/**\n * @function areaTriangleWithAllThreeSides\n * @description Calculate the area of a triangle with the all three sides given. 长方形（三边）\n * @param {Integer} side1 - Integer\n * @param {Integer} side2 - Integer\n * @param {Integer} side3 - Integer\n * @return {Integer} - area of triangle.\n * @see [areaTriangleWithAllThreeSides](https://en.wikipedia.org/wiki/Heron%27s_formula)\n * @example areaTriangleWithAllThreeSides(5, 6, 7) = 14.7\n */\nconst areaTriangleWithAllThreeSides = (side1, side2, side3) => {\n  validateNumericParam(side1, 'side1')\n  validateNumericParam(side2, 'side2')\n  validateNumericParam(side3, 'side3')\n  if (\n    side1 + side2 <= side3 ||\n    side1 + side3 <= side2 ||\n    side2 + side3 <= side1\n  ) {\n    throw new TypeError('Invalid Triangle sides.')\n  }\n  // Finding Semi perimeter of the triangle using formula\n  const semi = (side1 + side2 + side3) / 2\n\n  // Calculating the area of the triangle\n  const area = Math.sqrt(\n    semi * (semi - side1) * (semi - side2) * (semi - side3)\n  )\n  return Number(area.toFixed(2))\n}\n\n/**\n * @function areaParallelogram\n * @description Calculate the area of a parallelogram. 平行四边形\n * @param {Integer} base - Integer\n * @param {Integer} height - Integer\n * @return {Integer} - base * height\n * @see [areaParallelogram](https://en.wikipedia.org/wiki/Area#Dissection,_parallelograms,_and_triangles)\n * @example areaParallelogram(5, 6) = 24\n */\nconst areaParallelogram = (base, height) => {\n  validateNumericParam(base, 'Base')\n  validateNumericParam(height, 'Height')\n  return base * height\n}\n\n/**\n * @function areaTrapezium\n * @description Calculate the area of a trapezium. 梯形\n * @param {Integer} base1 - Integer\n * @param {Integer} base2 - Integer\n * @param {Integer} height - Integer\n * @return {Integer} - (1 / 2) * (base1 + base2) * height\n * @see [areaTrapezium](https://en.wikipedia.org/wiki/Trapezoid)\n * @example areaTrapezium(5, 12, 10) = 85\n */\nconst areaTrapezium = (base1, base2, height) => {\n  validateNumericParam(base1, 'Base One')\n  validateNumericParam(base2, 'Base Two')\n  validateNumericParam(height, 'Height')\n  return (1 / 2) * (base1 + base2) * height\n}\n\n/**\n * @function areaCircle\n * @description Calculate the area of a circle. 圆形\n * @param {Integer} radius - Integer\n * @return {Integer} - Math.PI * radius ** 2\n * @see [areaCircle](https://en.wikipedia.org/wiki/Area_of_a_circle)\n * @example areaCircle(5, 12, 10) = 85\n */\nconst areaCircle = (radius) => {\n  validateNumericParam(radius, 'Radius')\n  return Math.PI * radius ** 2\n}\n\n/**\n * @function areaRhombus\n * @description Calculate the area of a rhombus.  菱形\n * @param {Integer} diagonal1 - Integer\n * @param {Integer} diagonal2 - Integer\n * @return {Integer} - (1 / 2) * diagonal1 * diagonal2\n * @see [areaRhombus](https://en.wikipedia.org/wiki/Rhombus)\n * @example areaRhombus(12, 10) = 60\n */\nconst areaRhombus = (diagonal1, diagonal2) => {\n  validateNumericParam(diagonal1, 'diagonal one')\n  validateNumericParam(diagonal2, 'diagonal two')\n  return (1 / 2) * diagonal1 * diagonal2\n}\n\nconst validateNumericParam = (param, paramName = 'param') => {\n  if (typeof param !== 'number') {\n    throw new TypeError('The ' + paramName + ' should be type Number')\n  } else if (param < 0) {\n    throw new Error('The ' + paramName + ' only accepts non-negative values')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n\n\n\n# 参考\n\n * 面积 - Wikiwand",normalizedContent:"# 介绍\n\n面积（英语：area）是用作表示一个曲面或平面图形所占范围的量，可看成是长度（一维度量）及体积（三维度量）的二维类比。对三维立体图形而言，图形的边界的面积称为表面积。\n\n面积在近代数学中占相当重要的角色。面积除与几何学及微积分有关外，亦与线性代数中的行列式有关。在分析学中，平面的面积通常以勒贝格测度（lebesgue measure）定义。\n\n\n# 面积公式\n\n\n\n\n# 实现\n\n\n# javascript\n\n/*\n  calculate the area of various shapes\n*/\n\n/**\n * @function surfaceareacube\n * @description calculate the surface area of a cube. 立方体\n * @param {integer} side - integer\n * @return {integer} - 6 * side ** 2\n * @see [surfaceareacube](https://en.wikipedia.org/wiki/area#surface_area)\n * @example surfaceareacube(1) = 6\n */\nconst surfaceareacube = (side) => {\n  validatenumericparam(side, 'side')\n  return 6 * side ** 2\n}\n\n/**\n * @function surfaceareasphere\n * @description calculate the surface area of a sphere. 球体\n * @param {integer} radius - integer\n * @return {integer} - 4 * pi * r^2\n * @see [surfaceareasphere](https://en.wikipedia.org/wiki/sphere)\n * @example surfaceareasphere(5) = 314.1592653589793\n */\nconst surfaceareasphere = (radius) => {\n  validatenumericparam(radius, 'radius')\n  return 4.0 * math.pi * radius ** 2.0\n}\n\n/**\n * @function arearectangle\n * @description calculate the area of a rectangle. 矩形\n * @param {integer} length - integer\n * @param {integer} width - integer\n * @return {integer} - width * length\n * @see [arearectangle](https://en.wikipedia.org/wiki/area#quadrilateral_area)\n * @example arearectangle(4) = 16\n */\nconst arearectangle = (length, width) => {\n  validatenumericparam(length, 'length')\n  validatenumericparam(width, 'width')\n  return width * length\n}\n\n/**\n * @function areasquare\n * @description calculate the area of a square. 正方形\n * @param {integer} side - integer\n * @return {integer} - side ** 2.\n * @see [areasquare](https://en.wikipedia.org/wiki/square)\n * @example areasquare(4) = 16\n */\nconst areasquare = (side) => {\n  validatenumericparam(side, 'square side')\n  return side ** 2\n}\n\n/**\n * @function areatriangle\n * @description calculate the area of a triangle. 三角形（底和高）\n * @param {integer} base - integer\n * @param {integer} height - integer\n * @return {integer} - base * height / 2.\n * @see [areatriangle](https://en.wikipedia.org/wiki/area#triangle_area)\n * @example areatriangle(1.66, 3.44) = 2.8552\n */\nconst areatriangle = (base, height) => {\n  validatenumericparam(base, 'base')\n  validatenumericparam(height, 'height')\n  return (base * height) / 2.0\n}\n\n/**\n * @function areatrianglewithallthreesides\n * @description calculate the area of a triangle with the all three sides given. 长方形（三边）\n * @param {integer} side1 - integer\n * @param {integer} side2 - integer\n * @param {integer} side3 - integer\n * @return {integer} - area of triangle.\n * @see [areatrianglewithallthreesides](https://en.wikipedia.org/wiki/heron%27s_formula)\n * @example areatrianglewithallthreesides(5, 6, 7) = 14.7\n */\nconst areatrianglewithallthreesides = (side1, side2, side3) => {\n  validatenumericparam(side1, 'side1')\n  validatenumericparam(side2, 'side2')\n  validatenumericparam(side3, 'side3')\n  if (\n    side1 + side2 <= side3 ||\n    side1 + side3 <= side2 ||\n    side2 + side3 <= side1\n  ) {\n    throw new typeerror('invalid triangle sides.')\n  }\n  // finding semi perimeter of the triangle using formula\n  const semi = (side1 + side2 + side3) / 2\n\n  // calculating the area of the triangle\n  const area = math.sqrt(\n    semi * (semi - side1) * (semi - side2) * (semi - side3)\n  )\n  return number(area.tofixed(2))\n}\n\n/**\n * @function areaparallelogram\n * @description calculate the area of a parallelogram. 平行四边形\n * @param {integer} base - integer\n * @param {integer} height - integer\n * @return {integer} - base * height\n * @see [areaparallelogram](https://en.wikipedia.org/wiki/area#dissection,_parallelograms,_and_triangles)\n * @example areaparallelogram(5, 6) = 24\n */\nconst areaparallelogram = (base, height) => {\n  validatenumericparam(base, 'base')\n  validatenumericparam(height, 'height')\n  return base * height\n}\n\n/**\n * @function areatrapezium\n * @description calculate the area of a trapezium. 梯形\n * @param {integer} base1 - integer\n * @param {integer} base2 - integer\n * @param {integer} height - integer\n * @return {integer} - (1 / 2) * (base1 + base2) * height\n * @see [areatrapezium](https://en.wikipedia.org/wiki/trapezoid)\n * @example areatrapezium(5, 12, 10) = 85\n */\nconst areatrapezium = (base1, base2, height) => {\n  validatenumericparam(base1, 'base one')\n  validatenumericparam(base2, 'base two')\n  validatenumericparam(height, 'height')\n  return (1 / 2) * (base1 + base2) * height\n}\n\n/**\n * @function areacircle\n * @description calculate the area of a circle. 圆形\n * @param {integer} radius - integer\n * @return {integer} - math.pi * radius ** 2\n * @see [areacircle](https://en.wikipedia.org/wiki/area_of_a_circle)\n * @example areacircle(5, 12, 10) = 85\n */\nconst areacircle = (radius) => {\n  validatenumericparam(radius, 'radius')\n  return math.pi * radius ** 2\n}\n\n/**\n * @function arearhombus\n * @description calculate the area of a rhombus.  菱形\n * @param {integer} diagonal1 - integer\n * @param {integer} diagonal2 - integer\n * @return {integer} - (1 / 2) * diagonal1 * diagonal2\n * @see [arearhombus](https://en.wikipedia.org/wiki/rhombus)\n * @example arearhombus(12, 10) = 60\n */\nconst arearhombus = (diagonal1, diagonal2) => {\n  validatenumericparam(diagonal1, 'diagonal one')\n  validatenumericparam(diagonal2, 'diagonal two')\n  return (1 / 2) * diagonal1 * diagonal2\n}\n\nconst validatenumericparam = (param, paramname = 'param') => {\n  if (typeof param !== 'number') {\n    throw new typeerror('the ' + paramname + ' should be type number')\n  } else if (param < 0) {\n    throw new error('the ' + paramname + ' only accepts non-negative values')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n\n\n\n# 参考\n\n * 面积 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 20:15:06",lastUpdatedTimestamp:1666095306e3},{title:"ArithmeticGeometricMean [算术-几何平均数]",frontmatter:{title:"ArithmeticGeometricMean [算术-几何平均数]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/math/arithmeticGeometricMean/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/40.ArithmeticGeometricMean.html",relativePath:"20.算法/60.Math 数学/40.ArithmeticGeometricMean.md",key:"v-deef02fe",path:"/algorithm/math/arithmeticGeometricMean/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:591},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:598},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2451},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2495}],headersStr:"介绍 实现 JavaScript 扩展 参考",content:'# 介绍\n\n算术 - 几何平均是一种特殊平均，即算术平均与几何平均的合成平均。两个正实数 xxx 和 yyy 的算术 - 几何平均数定义如下:\n\n首先计算 xxx 和 yyy 算术平均数 (相加平均), 称其为 a1a_1a1 。然后计算 xxx 和 yyy 几何平均数 (相乘平均), 称其为 g1g_1g1 ; 这是 xyx yxy 的算术平方根。\n\na1=x+y2g1=xy\\begin{aligned} &a_1=\\frac{x+y}{2} \\\\ &g_1=\\sqrt{x y} \\end{aligned} a1 =2x+y g1 =xy\n\n然后重复这个步骤，这样便得到了两个数列 (an)\\left(a_n\\right)(an ) 和 (gn)\\left(g_n\\right)(gn ) :\n\nan+1=an+gn2gn+1=angn.\\begin{aligned} &a_{n+1}=\\frac{a_n+g_n}{2} \\\\ &g_{n+1}=\\sqrt{a_n g_n} . \\end{aligned} an+1 =2an +gn gn+1 =an gn .\n\n这两个数列收敛于相同的数，这个数称为 xxx 和 yyy 的算术 - 几何平均数，记为 M(x,y)\\mathrm{M}(x, y)M(x,y), 或 agm (x,y)(x, y)(x,y) 。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function agm\n * @description This finds the Arithmetic-Geometric Mean between any 2 numbers.\n * @param {Number} a - 1st number, also used to store Arithmetic Mean.\n * @param {Number} g - 2nd number, also used to store Geometric Mean.\n * @return {Number} - AGM of both numbers.\n * @see [AGM](https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean)\n */\n\nexport const agm = (a, g) => {\n  if (a === Infinity && g === 0) return NaN\n  if (Object.is(a, -0) && !Object.is(g, -0)) return 0\n  if (a === g) return a // avoid rounding errors, and increase efficiency\n  let x // temp var\n  do {\n    [a, g, x] = [(a + g) / 2, Math.sqrt(a * g), a]\n  } while (a !== x && !isNaN(a))\n  /*\n  `x !== a` ensures the return value has full precision,\n  and prevents infinite loops caused by rounding differences between `div` and `sqrt` (no need for "epsilon").\n  If we were to compare `a` with `g`, some input combinations (not all) can cause an infinite loop,\n  because the rounding mode never changes at runtime.\n  Precision is not the same as accuracy, but they\'re related.\n  This function isn\'t always 100% accurate (round-errors), but at least is more than 95% accurate.\n  `!isNaN(x)` prevents infinite loops caused by invalid inputs like: negatives, NaNs and Infinities.\n  `x !== a`确保返回值具有全精度并防止因`div`和`sqrt`之间的四舍五入引起的无限循环（不需要 "epsilon"）。\n  如果我们将`a`与`g`进行比较，一些输入组合（不是全部）会导致无限循环。因为四舍五入的模式在运行时不会改变。\n  精度不等同于准确度，但它们是相关的。这个函数并不总是100%准确（四舍五入错误），但至少是95%以上的准确。\n  `!isNaN(x)`防止由无效输入引起的无限循环，如：负数、NaN和无穷大。\n  */\n  return a\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nObject.is() 方法判断两个值是否是相同的值。这种相等性判断逻辑和传统的 == 运算不同， == 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 "" == false 等于 true 的现象），但 Object.is 不会做这种类型转换。这与 === 运算符的判定方式也不一样。 === 运算符（和 == 运算符）将数字值 -0 和 +0 视为相等，并认为 Number.NaN 不等于 NaN 。\n\n\n# 扩展\n\n * 1 个动画，4 个均值：平方平均、算术平均、几何平均、调和平均：\n\n\n# 参考\n\n * Arithmetic–geometric mean - Wikiwand\n * 算术 - 几何平均数 - Wikiwand\n * 算术几何平均 - 快懂百科\n * Object.is() - JavaScript | MDN',normalizedContent:'# 介绍\n\n算术 - 几何平均是一种特殊平均，即算术平均与几何平均的合成平均。两个正实数 xxx 和 yyy 的算术 - 几何平均数定义如下:\n\n首先计算 xxx 和 yyy 算术平均数 (相加平均), 称其为 a1a_1a1 。然后计算 xxx 和 yyy 几何平均数 (相乘平均), 称其为 g1g_1g1 ; 这是 xyx yxy 的算术平方根。\n\na1=x+y2g1=xy\\begin{aligned} &a_1=\\frac{x+y}{2} \\\\ &g_1=\\sqrt{x y} \\end{aligned} a1 =2x+y g1 =xy\n\n然后重复这个步骤，这样便得到了两个数列 (an)\\left(a_n\\right)(an ) 和 (gn)\\left(g_n\\right)(gn ) :\n\nan+1=an+gn2gn+1=angn.\\begin{aligned} &a_{n+1}=\\frac{a_n+g_n}{2} \\\\ &g_{n+1}=\\sqrt{a_n g_n} . \\end{aligned} an+1 =2an +gn gn+1 =an gn .\n\n这两个数列收敛于相同的数，这个数称为 xxx 和 yyy 的算术 - 几何平均数，记为 m(x,y)\\mathrm{m}(x, y)m(x,y), 或 agm (x,y)(x, y)(x,y) 。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function agm\n * @description this finds the arithmetic-geometric mean between any 2 numbers.\n * @param {number} a - 1st number, also used to store arithmetic mean.\n * @param {number} g - 2nd number, also used to store geometric mean.\n * @return {number} - agm of both numbers.\n * @see [agm](https://en.wikipedia.org/wiki/arithmetic%e2%80%93geometric_mean)\n */\n\nexport const agm = (a, g) => {\n  if (a === infinity && g === 0) return nan\n  if (object.is(a, -0) && !object.is(g, -0)) return 0\n  if (a === g) return a // avoid rounding errors, and increase efficiency\n  let x // temp var\n  do {\n    [a, g, x] = [(a + g) / 2, math.sqrt(a * g), a]\n  } while (a !== x && !isnan(a))\n  /*\n  `x !== a` ensures the return value has full precision,\n  and prevents infinite loops caused by rounding differences between `div` and `sqrt` (no need for "epsilon").\n  if we were to compare `a` with `g`, some input combinations (not all) can cause an infinite loop,\n  because the rounding mode never changes at runtime.\n  precision is not the same as accuracy, but they\'re related.\n  this function isn\'t always 100% accurate (round-errors), but at least is more than 95% accurate.\n  `!isnan(x)` prevents infinite loops caused by invalid inputs like: negatives, nans and infinities.\n  `x !== a`确保返回值具有全精度并防止因`div`和`sqrt`之间的四舍五入引起的无限循环（不需要 "epsilon"）。\n  如果我们将`a`与`g`进行比较，一些输入组合（不是全部）会导致无限循环。因为四舍五入的模式在运行时不会改变。\n  精度不等同于准确度，但它们是相关的。这个函数并不总是100%准确（四舍五入错误），但至少是95%以上的准确。\n  `!isnan(x)`防止由无效输入引起的无限循环，如：负数、nan和无穷大。\n  */\n  return a\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nobject.is() 方法判断两个值是否是相同的值。这种相等性判断逻辑和传统的 == 运算不同， == 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 "" == false 等于 true 的现象），但 object.is 不会做这种类型转换。这与 === 运算符的判定方式也不一样。 === 运算符（和 == 运算符）将数字值 -0 和 +0 视为相等，并认为 number.nan 不等于 nan 。\n\n\n# 扩展\n\n * 1 个动画，4 个均值：平方平均、算术平均、几何平均、调和平均：\n\n\n# 参考\n\n * arithmetic–geometric mean - wikiwand\n * 算术 - 几何平均数 - wikiwand\n * 算术几何平均 - 快懂百科\n * object.is() - javascript | mdn',charsets:{cjk:!0},lastUpdated:"2022/10/18, 20:15:06",lastUpdatedTimestamp:1666095306e3},{title:"ArmstrongNumber [阿姆斯特朗数]",frontmatter:{title:"ArmstrongNumber [阿姆斯特朗数]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/math/armstrongNumber/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/50.ArmstrongNumber.html",relativePath:"20.算法/60.Math 数学/50.ArmstrongNumber.md",key:"v-3b8ac9a1",path:"/algorithm/math/armstrongNumber/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:448},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:455},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2564}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n阿姆斯特朗数，又称自恋者数（narcissist number）。在数字理论中，阿姆斯特朗数的定义是在任何给定的数基中，当它的每个数字被提升到该数字的位数的幂时，形成同一个数字的总数。\n\n例如，使用一个简单的数字 153 和十进制系统，我们看到其中有 3 个数字。如果我们做一个简单的数学运算，把它的每个数字提高到 3 的幂，然后把得到的总和加起来，我们得到 153。也就是 1 到 3 的幂，5 到 3 的幂，3 到 3 的幂。这也可以表示为 1^3+5^3+3^3=153。数字 153 是一个阿姆斯特朗数字的例子，它有一个独特的属性，可以使用任何数字系统。\n\n因此，如果在任何给定的数字系统中，将每个数字提高到该数字位数的幂数，然后相加得到一个数字，得到的总数等于原来的数字，这样的数字就被称为阿姆斯特朗数。\n\n那么，有没有利用阿姆斯特朗数的实际应用呢？实际上，没有，这些数字除了作为验证程序的例子或学习工具，更好地学习概念和探索新编程语言的规则外，没有任何实际用途。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * An Armstrong number is equal to the sum of its own digits each raised to the power of the number of digits.\n * For example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\n * An Armstrong number is often called Narcissistic number.\n */\nconst armstrongNumber = (num) => {\n  if (num < 0 || typeof num !== 'number') return false\n\n  let newSum = 0\n\n  const numArr = num.toString().split('')\n  numArr.forEach((num) => {\n    newSum += parseInt(num) ** numArr.length\n  })\n\n  return newSum === num\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n写一个程序来寻找 0 和 999 范围内的所有阿姆斯特朗数字。\n\n! ---------------------------------------------------------------\n! This program computes all Armstrong numbers in the range of\n! 0 and 999.  An Armstrong number is a number such that the sum\n! of its digits raised to the third power is equal to the number\n! itself.  For example, 371 is an Armstrong number, since\n! 3**3 + 7**3 + 1**3 = 371.\n! ---------------------------------------------------------------\n\nPROGRAM  ArmstrongNumber\n   IMPLICIT  NONE\n\n   INTEGER :: a, b, c                   ! the three digits\n   INTEGER :: abc, a3b3c3               ! the number and its cubic sum\n   INTEGER :: Count                     ! a counter\n\n   Count = 0\n   DO a = 0, 9                          ! for the left most digit\n      DO b = 0, 9                       !   for the middle digit\n         DO c = 0, 9                    !     for the right most digit\n            abc    = a*100 + b*10 + c   !        the number\n            a3b3c3 = a**3 + b**3 + c**3 !        the sum of cubes\n            IF (abc == a3b3c3) THEN     !        if they are equal\n               Count = Count + 1        !           count and display it\n               WRITE(*,*)  'Armstrong number ', Count, ': ', abc\n            END IF\n         END DO\n      END DO\n   END DO\n\n// Armstrong number 1: 0\n// Armstrong number 2: 1\n// Armstrong number 3: 153\n// Armstrong number 4: 370\n// Armstrong number 5: 371\n// Armstrong number 6: 407\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 参考\n\n * What is Armstrong Number? An Interesting Overview (2022)",normalizedContent:"# 介绍\n\n阿姆斯特朗数，又称自恋者数（narcissist number）。在数字理论中，阿姆斯特朗数的定义是在任何给定的数基中，当它的每个数字被提升到该数字的位数的幂时，形成同一个数字的总数。\n\n例如，使用一个简单的数字 153 和十进制系统，我们看到其中有 3 个数字。如果我们做一个简单的数学运算，把它的每个数字提高到 3 的幂，然后把得到的总和加起来，我们得到 153。也就是 1 到 3 的幂，5 到 3 的幂，3 到 3 的幂。这也可以表示为 1^3+5^3+3^3=153。数字 153 是一个阿姆斯特朗数字的例子，它有一个独特的属性，可以使用任何数字系统。\n\n因此，如果在任何给定的数字系统中，将每个数字提高到该数字位数的幂数，然后相加得到一个数字，得到的总数等于原来的数字，这样的数字就被称为阿姆斯特朗数。\n\n那么，有没有利用阿姆斯特朗数的实际应用呢？实际上，没有，这些数字除了作为验证程序的例子或学习工具，更好地学习概念和探索新编程语言的规则外，没有任何实际用途。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * an armstrong number is equal to the sum of its own digits each raised to the power of the number of digits.\n * for example, 370 is an armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\n * an armstrong number is often called narcissistic number.\n */\nconst armstrongnumber = (num) => {\n  if (num < 0 || typeof num !== 'number') return false\n\n  let newsum = 0\n\n  const numarr = num.tostring().split('')\n  numarr.foreach((num) => {\n    newsum += parseint(num) ** numarr.length\n  })\n\n  return newsum === num\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n写一个程序来寻找 0 和 999 范围内的所有阿姆斯特朗数字。\n\n! ---------------------------------------------------------------\n! this program computes all armstrong numbers in the range of\n! 0 and 999.  an armstrong number is a number such that the sum\n! of its digits raised to the third power is equal to the number\n! itself.  for example, 371 is an armstrong number, since\n! 3**3 + 7**3 + 1**3 = 371.\n! ---------------------------------------------------------------\n\nprogram  armstrongnumber\n   implicit  none\n\n   integer :: a, b, c                   ! the three digits\n   integer :: abc, a3b3c3               ! the number and its cubic sum\n   integer :: count                     ! a counter\n\n   count = 0\n   do a = 0, 9                          ! for the left most digit\n      do b = 0, 9                       !   for the middle digit\n         do c = 0, 9                    !     for the right most digit\n            abc    = a*100 + b*10 + c   !        the number\n            a3b3c3 = a**3 + b**3 + c**3 !        the sum of cubes\n            if (abc == a3b3c3) then     !        if they are equal\n               count = count + 1        !           count and display it\n               write(*,*)  'armstrong number ', count, ': ', abc\n            end if\n         end do\n      end do\n   end do\n\n// armstrong number 1: 0\n// armstrong number 2: 1\n// armstrong number 3: 153\n// armstrong number 4: 370\n// armstrong number 5: 371\n// armstrong number 6: 407\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 参考\n\n * what is armstrong number? an interesting overview (2022)",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"AverageMean [平均数]",frontmatter:{title:"AverageMean [平均数]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/math/averageMean/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/60.AverageMean.html",relativePath:"20.算法/60.Math 数学/60.AverageMean.md",key:"v-3c64c701",path:"/algorithm/math/averageMean/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:237},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:244},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:934}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n平均数（英语：Mean, Average，或称平均值）是统计中的一个重要概念。为集中趋势的最常用测度值，目的是确定一组数据的均衡点。\n\n在统计中算术平均数常用于表示统计对象的一般水平，它是描述数据集中程度的一个统计量。我们既可以用它来反映一组数据的一般情况，也可以用它进行不同组数据的比较，以看出组与组之间的差别。用平均数表示一组数据的情况，有直观、简明的特点，所以在日常生活中经常用到，如平均的速度、平均的身高、平均的产量、平均的成绩、平均的气温等。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function mean\n * @description This script will find the mean value of a array of numbers.\n * @param {Integer[]} nums - Array of integer\n * @return {Integer} - mean of nums.\n * @see [Mean](https://en.wikipedia.org/wiki/Mean)\n * @example mean([1, 2, 4, 5]) = 3\n * @example mean([10, 40, 100, 20]) = 42.5\n */\nconst mean = (nums) => {\n  if (!Array.isArray(nums)) {\n    throw new TypeError('Invalid Input')\n  }\n\n  // This loop sums all values in the 'nums' array using forEach loop\n  const sum = nums.reduce((sum, cur) => sum + cur, 0)\n\n  // Divide sum by the length of the 'nums' array.\n  return sum / nums.length\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * Mean - Wikiwand",normalizedContent:"# 介绍\n\n平均数（英语：mean, average，或称平均值）是统计中的一个重要概念。为集中趋势的最常用测度值，目的是确定一组数据的均衡点。\n\n在统计中算术平均数常用于表示统计对象的一般水平，它是描述数据集中程度的一个统计量。我们既可以用它来反映一组数据的一般情况，也可以用它进行不同组数据的比较，以看出组与组之间的差别。用平均数表示一组数据的情况，有直观、简明的特点，所以在日常生活中经常用到，如平均的速度、平均的身高、平均的产量、平均的成绩、平均的气温等。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function mean\n * @description this script will find the mean value of a array of numbers.\n * @param {integer[]} nums - array of integer\n * @return {integer} - mean of nums.\n * @see [mean](https://en.wikipedia.org/wiki/mean)\n * @example mean([1, 2, 4, 5]) = 3\n * @example mean([10, 40, 100, 20]) = 42.5\n */\nconst mean = (nums) => {\n  if (!array.isarray(nums)) {\n    throw new typeerror('invalid input')\n  }\n\n  // this loop sums all values in the 'nums' array using foreach loop\n  const sum = nums.reduce((sum, cur) => sum + cur, 0)\n\n  // divide sum by the length of the 'nums' array.\n  return sum / nums.length\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * mean - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"AverageMedian [中位数]",frontmatter:{title:"AverageMedian [中位数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/averageMedian/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/70.AverageMedian.html",relativePath:"20.算法/60.Math 数学/70.AverageMedian.md",key:"v-d713c7fe",path:"/algorithm/math/averageMedian/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:157},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:164},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1119}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n统计学上，中位数（英语：Median），又称中央值、中值，是一个样本、种群或概率分布中之一个数值，其可将数值集合划分为数量相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，则中位数不唯一，通常取最中间的两个数值的平均数作为中位数。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n * Median: https://en.wikipedia.org/wiki/Median\n *\n * function averageMedian\n * to find the median value of an array of numbers\n * the numbers in an array will be sorted in ascending order by the function sortNumbers\n * if the length of the array is even number, the median value will be the average of the two middle numbers\n * else if the length of the array is odd number, the median value will be the middle number in the array\n */\n\nconst averageMedian = (sourceArrayOfNumbers) => {\n  let numbers = [...sourceArrayOfNumbers]\n  let median = 0\n  const numLength = numbers.length\n  numbers = numbers.sort(sortNumbers)\n\n  if (numLength % 2 === 0) {\n    median = (numbers[numLength / 2 - 1] + numbers[numLength / 2]) / 2\n  } else {\n    median = numbers[(numLength - 1) / 2]\n  }\n\n  return median\n}\n\nconst sortNumbers = (num1, num2) => {\n  return num1 - num2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 参考\n\n * Median - Wikiwand\n * 中位数 - Wikiwand",normalizedContent:"# 介绍\n\n统计学上，中位数（英语：median），又称中央值、中值，是一个样本、种群或概率分布中之一个数值，其可将数值集合划分为数量相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，则中位数不唯一，通常取最中间的两个数值的平均数作为中位数。\n\n\n# 实现\n\n\n# javascript\n\n/*\n * median: https://en.wikipedia.org/wiki/median\n *\n * function averagemedian\n * to find the median value of an array of numbers\n * the numbers in an array will be sorted in ascending order by the function sortnumbers\n * if the length of the array is even number, the median value will be the average of the two middle numbers\n * else if the length of the array is odd number, the median value will be the middle number in the array\n */\n\nconst averagemedian = (sourcearrayofnumbers) => {\n  let numbers = [...sourcearrayofnumbers]\n  let median = 0\n  const numlength = numbers.length\n  numbers = numbers.sort(sortnumbers)\n\n  if (numlength % 2 === 0) {\n    median = (numbers[numlength / 2 - 1] + numbers[numlength / 2]) / 2\n  } else {\n    median = numbers[(numlength - 1) / 2]\n  }\n\n  return median\n}\n\nconst sortnumbers = (num1, num2) => {\n  return num1 - num2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 参考\n\n * median - wikiwand\n * 中位数 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"BinaryExponentiation [二分求幂]",frontmatter:{title:"BinaryExponentiation [二分求幂]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/binaryExponentiation/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/80.BinaryExponentiation.html",relativePath:"20.算法/60.Math 数学/80.BinaryExponentiation.md",key:"v-1d93c406",path:"/algorithm/math/binaryExponentiation/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:179},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:186},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1326}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在数学和程序设计中，平方求幂（英语：exponentiating by squaring）或快速幂是快速计算一个数（或更一般地说，一个半群的元素，如多项式或方阵）的大正整数乘幂的一般方法。这些算法可以非常通用，例如用在模算数或矩阵幂。对于通常使用加性表示法的半群，如密码学中使用的椭圆曲线，这种方法也称为 double-and-add。\n\n\n# 实现\n\n\n# JavaScript\n\n迭代法:\n\n// To calculate x^n i.e. exponent(x, n) in O(log n) time in iterative way\n// n is an integer and n >= 0\n\n// Explanation: https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n\n// Examples:\n// 2^3 = 8\n// 5^0 = 1\n\n// Uses the fact that\n// exponent(x, n)\n//          = exponent(x*x, floor(n/2))   ; if n is even\n//          = x*exponent(x*x, floor(n/2)) ; if n is odd\nconst exponent = (x, n) => {\n  let answer = 1\n  while (n > 0) {\n    if (n % 2 !== 0) answer *= x\n    n = Math.floor(n / 2)\n    if (n > 0) x *= x\n  }\n  return answer\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n递归法:\n\n/*\n  Modified from:\n    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exponentiation.py\n\n  Explanation:\n    https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n*/\n\nconst binaryExponentiation = (a, n) => {\n  // input: a: int, n: int\n  // returns: a^n: int\n  if (n === 0) {\n    return 1\n  } else if (n % 2 === 1) {\n    return binaryExponentiation(a, n - 1) * a\n  } else {\n    const b = binaryExponentiation(a, n / 2)\n    return b * b\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * Exponentiation by squaring - Wikiwand\n * 平方求幂 - Wikiwand",normalizedContent:"# 介绍\n\n在数学和程序设计中，平方求幂（英语：exponentiating by squaring）或快速幂是快速计算一个数（或更一般地说，一个半群的元素，如多项式或方阵）的大正整数乘幂的一般方法。这些算法可以非常通用，例如用在模算数或矩阵幂。对于通常使用加性表示法的半群，如密码学中使用的椭圆曲线，这种方法也称为 double-and-add。\n\n\n# 实现\n\n\n# javascript\n\n迭代法:\n\n// to calculate x^n i.e. exponent(x, n) in o(log n) time in iterative way\n// n is an integer and n >= 0\n\n// explanation: https://en.wikipedia.org/wiki/exponentiation_by_squaring\n\n// examples:\n// 2^3 = 8\n// 5^0 = 1\n\n// uses the fact that\n// exponent(x, n)\n//          = exponent(x*x, floor(n/2))   ; if n is even\n//          = x*exponent(x*x, floor(n/2)) ; if n is odd\nconst exponent = (x, n) => {\n  let answer = 1\n  while (n > 0) {\n    if (n % 2 !== 0) answer *= x\n    n = math.floor(n / 2)\n    if (n > 0) x *= x\n  }\n  return answer\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n递归法:\n\n/*\n  modified from:\n    https://github.com/thealgorithms/python/blob/master/maths/binary_exponentiation.py\n\n  explanation:\n    https://en.wikipedia.org/wiki/exponentiation_by_squaring\n*/\n\nconst binaryexponentiation = (a, n) => {\n  // input: a: int, n: int\n  // returns: a^n: int\n  if (n === 0) {\n    return 1\n  } else if (n % 2 === 1) {\n    return binaryexponentiation(a, n - 1) * a\n  } else {\n    const b = binaryexponentiation(a, n / 2)\n    return b * b\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 参考\n\n * exponentiation by squaring - wikiwand\n * 平方求幂 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/18, 22:58:49",lastUpdatedTimestamp:1666105129e3},{title:"BisectionMethod [二分法]",frontmatter:{title:"BisectionMethod [二分法]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/math/bisectionMethod/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/90.BisectionMethod.html",relativePath:"20.算法/60.Math 数学/90.BisectionMethod.md",key:"v-ecd8ca7e",path:"/algorithm/math/bisectionMethod/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:50},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:371},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:378},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:385},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2187}],headersStr:"介绍 原理 演示 实现 JavaScript 参考",content:"# 介绍\n\n二分法（英语：Bisection method），是一种方程式根的近似值求法。\n\n\n# 原理\n\n若要求已知函数 f(x)=0f(x)=0f(x)=0 的根 (x(x(x 的解 ))), 则:\n\n 1. 先找出一个区间 [a,b][a, b][a,b], 使得 f(a)f(a)f(a) 与 f(b)f(b)f(b) 异号。根据介值定理，这个区间内一定包含著方程式的根。\n 2. 求该区间的中点 m=a+b2m=\\frac{a+b}{2}m=2a+b , 并找出 f(m)f(m)f(m) 的值。\n 3. 若 f(m)f(m)f(m) 与 f(a)f(a)f(a) 正负号相同则取 [m,b][m, b][m,b] 为新的区间，否则取 [a,m][a, m][a,m].\n 4. 重复第 2 和第 3 步至理想精确度为止。\n\n\n# 演示\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n *\n * @brief Find real roots of a function in a specified interval [a, b], where f(a)*f(b) < 0\n *\n * @details Given a function f(x) and an interval [a, b], where f(a) * f(b) < 0, find an approximation of the root\n * by calculating the middle m = (a + b) / 2, checking f(m) * f(a) and f(m) * f(b) and then by choosing the\n * negative product that means Bolzano's theorem is applied,, define the new interval with these points. Repeat until\n * we get the precision we want [Wikipedia](https://en.wikipedia.org/wiki/Bisection_method)\n *\n */\n\nconst findRoot = (a, b, func, numberOfIterations) => {\n  // Check if a given  real value belongs to the function's domain\n  const belongsToDomain = (x, f) => {\n    const res = f(x)\n    return !Number.isNaN(res)\n  }\n  if (!belongsToDomain(a, func) || !belongsToDomain(b, func)) throw Error(\"Given interval is not a valid subset of function's domain\")\n\n  // Bolzano theorem\n  const hasRoot = (a, b, func) => {\n    return func(a) * func(b) < 0\n  }\n  if (hasRoot(a, b, func) === false) { throw Error('Product f(a)*f(b) has to be negative so that Bolzano theorem is applied') }\n\n  // Declare m\n  const m = (a + b) / 2\n\n  // Recursion terminal condition\n  if (numberOfIterations === 0) { return m }\n\n  // Find the products of f(m) and f(a), f(b)\n  const fm = func(m)\n  const prod1 = fm * func(a)\n  const prod2 = fm * func(b)\n\n  // Depending on the sign of the products above, decide which position will m fill (a's or b's)\n  if (prod1 > 0 && prod2 < 0) return findRoot(m, b, func, --numberOfIterations)\n  else if (prod1 < 0 && prod2 > 0) return findRoot(a, m, func, --numberOfIterations)\n  else throw Error('Unexpected behavior')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 参考\n\n * Bisection method - Wikiwand\n * 二分法 (数学) - Wikiwand",normalizedContent:"# 介绍\n\n二分法（英语：bisection method），是一种方程式根的近似值求法。\n\n\n# 原理\n\n若要求已知函数 f(x)=0f(x)=0f(x)=0 的根 (x(x(x 的解 ))), 则:\n\n 1. 先找出一个区间 [a,b][a, b][a,b], 使得 f(a)f(a)f(a) 与 f(b)f(b)f(b) 异号。根据介值定理，这个区间内一定包含著方程式的根。\n 2. 求该区间的中点 m=a+b2m=\\frac{a+b}{2}m=2a+b , 并找出 f(m)f(m)f(m) 的值。\n 3. 若 f(m)f(m)f(m) 与 f(a)f(a)f(a) 正负号相同则取 [m,b][m, b][m,b] 为新的区间，否则取 [a,m][a, m][a,m].\n 4. 重复第 2 和第 3 步至理想精确度为止。\n\n\n# 演示\n\n\n# 实现\n\n\n# javascript\n\n/**\n *\n * @brief find real roots of a function in a specified interval [a, b], where f(a)*f(b) < 0\n *\n * @details given a function f(x) and an interval [a, b], where f(a) * f(b) < 0, find an approximation of the root\n * by calculating the middle m = (a + b) / 2, checking f(m) * f(a) and f(m) * f(b) and then by choosing the\n * negative product that means bolzano's theorem is applied,, define the new interval with these points. repeat until\n * we get the precision we want [wikipedia](https://en.wikipedia.org/wiki/bisection_method)\n *\n */\n\nconst findroot = (a, b, func, numberofiterations) => {\n  // check if a given  real value belongs to the function's domain\n  const belongstodomain = (x, f) => {\n    const res = f(x)\n    return !number.isnan(res)\n  }\n  if (!belongstodomain(a, func) || !belongstodomain(b, func)) throw error(\"given interval is not a valid subset of function's domain\")\n\n  // bolzano theorem\n  const hasroot = (a, b, func) => {\n    return func(a) * func(b) < 0\n  }\n  if (hasroot(a, b, func) === false) { throw error('product f(a)*f(b) has to be negative so that bolzano theorem is applied') }\n\n  // declare m\n  const m = (a + b) / 2\n\n  // recursion terminal condition\n  if (numberofiterations === 0) { return m }\n\n  // find the products of f(m) and f(a), f(b)\n  const fm = func(m)\n  const prod1 = fm * func(a)\n  const prod2 = fm * func(b)\n\n  // depending on the sign of the products above, decide which position will m fill (a's or b's)\n  if (prod1 > 0 && prod2 < 0) return findroot(m, b, func, --numberofiterations)\n  else if (prod1 < 0 && prod2 > 0) return findroot(a, m, func, --numberofiterations)\n  else throw error('unexpected behavior')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 参考\n\n * bisection method - wikiwand\n * 二分法 (数学) - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/19, 17:35:33",lastUpdatedTimestamp:1666172133e3},{title:"Haversine [半正矢公式]",frontmatter:{title:"Haversine [半正矢公式]",date:"2022-09-26T10:05:25.000Z",permalink:"/pages/c3f9cf/",categories:["算法","Math 数学"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/60.Math%20%E6%95%B0%E5%AD%A6/Haversine.html",relativePath:"20.算法/60.Math 数学/Haversine.md",key:"v-41f1b873",path:"/pages/c3f9cf/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1480}],headersStr:"实现 参考",content:"# 实现\n\n/**\n * @function HaversineDistance\n * @description Calculate the distance between two coordinates using the haversine formula\n * @param {Integer} latitude1 - The input integer\n * @param {Integer} latitude2 - The input integer\n * @param {Integer} longitude1 - The input integer\n * @param {Integer} longitude2 - The input integer\n * @return {Integer} Haversine Distance.\n * @see [Haversine_Distance](https://pt.wikipedia.org/wiki/F%C3%B3rmula_de_Haversine)\n */\nconst haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {\n  validateLatOrLong(latitude1)\n  validateLatOrLong(latitude2)\n  validateLatOrLong(longitude1)\n  validateLatOrLong(longitude2)\n  const earthRadius = 6371e3 // 6,371km\n  const pi = Math.PI\n  const cos1 = latitude1 * pi / 180.0\n  const cos2 = latitude2 * pi / 180.0\n  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0\n  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0\n\n  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)\n  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))\n  return earthRadius * constant\n}\n\nconst validateLatOrLong = value => {\n  if (typeof value !== 'number') {\n    throw new TypeError('The value of latitude or longitude should be a number')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * 半正矢公式 - Wikiwand",normalizedContent:"# 实现\n\n/**\n * @function haversinedistance\n * @description calculate the distance between two coordinates using the haversine formula\n * @param {integer} latitude1 - the input integer\n * @param {integer} latitude2 - the input integer\n * @param {integer} longitude1 - the input integer\n * @param {integer} longitude2 - the input integer\n * @return {integer} haversine distance.\n * @see [haversine_distance](https://pt.wikipedia.org/wiki/f%c3%b3rmula_de_haversine)\n */\nconst haversinedistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {\n  validatelatorlong(latitude1)\n  validatelatorlong(latitude2)\n  validatelatorlong(longitude1)\n  validatelatorlong(longitude2)\n  const earthradius = 6371e3 // 6,371km\n  const pi = math.pi\n  const cos1 = latitude1 * pi / 180.0\n  const cos2 = latitude2 * pi / 180.0\n  const deltalatitude = (latitude2 - latitude1) * pi / 180.0\n  const deltalongitude = (longitude2 - longitude1) * pi / 180.0\n\n  const alpha = math.sin(deltalatitude / 2) * math.sin(deltalatitude / 2) + math.cos(cos1) * math.cos(cos2) * math.sin(deltalongitude / 2) * math.sin(deltalongitude / 2)\n  const constant = 2 * math.atan2(math.sqrt(alpha), math.sqrt(1 - alpha))\n  return earthradius * constant\n}\n\nconst validatelatorlong = value => {\n  if (typeof value !== 'number') {\n    throw new typeerror('the value of latitude or longitude should be a number')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * 半正矢公式 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/28, 17:23:56",lastUpdatedTimestamp:1666949036e3},{title:"SHA1 [安全散列算法1]",frontmatter:{title:"SHA1 [安全散列算法1]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/hash/sha1/",categories:["算法","Hash 哈希"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/70.Hash%20%E5%93%88%E5%B8%8C/10.SHA1.html",relativePath:"20.算法/70.Hash 哈希/10.SHA1.md",key:"v-c004732e",path:"/algorithm/hash/sha1/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:700},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:2906},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:428},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:3036},{level:2,title:"资源",slug:"资源",normalizedTitle:"资源",charIndex:8077},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:8255}],headersStr:"介绍 伪代码 演示 实现 JavaScript 资源 参考",content:"# 介绍\n\n散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。\n\nSHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法 1）是一种密码散列函数。SHA-1 可以生成一个被称为消息摘要的 160 位（20 字节）散列值，散列值通常的呈现形式为 40 个十六进制数。2005 年，密码分析人员发现了对 SHA-1 的有效攻击方法，这表明该算法可能不够安全，不能继续使用。2020 年，针对 SHA-1 的选择前缀冲突攻击已经实际可行。\n\n通过散列算法可实现数字签名实现，数字签名的原理是将要传送的明文通过一种函数运算（Hash）转换成报文摘要（不同的明文对应不同的报文摘要），报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较，比较结果一致表示明文未被改动，如果不一致表示明文已被篡改。\n\n密码散列函数\n\n密码散列函数（英语：Cryptographic hash function），又译为加密散列函数、密码散列函数、加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的资料是什么。\n\n\n# 伪代码\n\n以下是 SHA-1 演算法的伪代码：\n\nNote: All variables are unsigned 32 bits and wrap modulo 232 when calculating\nInitial variables:\nh0 := 0x67452301\nh1 := 0xEFCDAB89\nh2 := 0x98BADCFE\nh3 := 0x10325476\nh4 := 0xC3D2E1F0\nPre-processing:\nappend the bit '1' to the message\nappend k bits '0', where k is the minimum number >= 0 such that the resulting message\n    length (in bits) is congruent to 448(mod 512)\nappend length of message (before pre-processing), in bits, as 64-bit big-endian integer\nProcess the message in successive 512-bit chunks:\nbreak message into 512-bit chunks\nfor each chunk\n    break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15\n    Extend the sixteen 32-bit words into eighty 32-bit words:\n    for i from 16 to 79\n        w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1\n    Initialize hash value for this chunk:\n    a := h0\n    b := h1\n    c := h2\n    d := h3\n    e := h4\n    Main loop:\n    for i from 0 to 79\n        if 0 ≤ i ≤ 19 then\n            f := (b and c) or ((not b) and d)\n            k := 0x5A827999\n        else if 20 ≤ i ≤ 39\n            f := b xor c xor d\n            k := 0x6ED9EBA1\n        else if 40 ≤ i ≤ 59\n            f := (b and c) or (b and d) or(c and d)\n            k := 0x8F1BBCDC\n        else if 60 ≤ i ≤ 79\n            f := b xor c xor d\n            k := 0xCA62C1D6\n        temp := (a leftrotate 5) + f + e + k + w[i]\n        e := d\n        d := c\n        c := b leftrotate 30\n        b := a\n        a := temp\n    Add this chunk's hash to result so far:\n    h0 := h0 + a\n    h1 := h1 + b\n    h2 := h2 + c\n    h3 := h3 + d\n    h4 := h4 + e\nProduce the final hash value (big-endian):\ndigest = hash = h0 append h1 append h2 append h3 append h4\n上述关于f运算式列于FIPS PUB 180-1中，以下替代运算式也许也能在主要回圈里计算f：\n\n(0  ≤ i ≤ 19): f := d xor (b and (c xor d))         (alternative)\n \n(40 ≤ i ≤ 59): f := (b and c) or (d and (b or c))   (alternative 1)\n(40 ≤ i ≤ 59): f := (b and c) or (d and (b xor c))  (alternative 2)\n(40 ≤ i ≤ 59): f := (b and c) + (d and (b xor c))   (alternative 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 演示\n\n * 【SHA1 算法】| 哈希算法 | Hash 算法 | 密码学 | 信息安全 | 消息摘要：\n\n * 硬核讲解哈希算法加密原理（ sha-1 哈希算法)：\n\n * Christof Paar 教授在德国波鸿大学的教学视频：\n\n\n# 实现\n\n\n# JavaScript\n\n//= ===============================================================\n// SHA1.js\n//\n// Module that replicates the SHA-1 Cryptographic Hash\n// function in Javascript.\n//= ===============================================================\n\n// main variables\nconst CHAR_SIZE = 8\n\n/**\n * Adds padding to binary/hex string representation\n *\n * @param {string} str - string representation (binary/hex)\n * @param {int} bits - total number of bits wanted\n * @return {string} - string representation padding with empty (0) bits\n *\n * @example\n *      pad(\"10011\", 8); // \"00010011\"\n */\nfunction pad (str, bits) {\n  let res = str\n  while (res.length % bits !== 0) {\n    res = '0' + res\n  }\n  return res\n}\n\n/**\n * Separates string into chunks of the same size\n *\n * @param {string} str - string to separate into chunks\n * @param {int} size - number of characters wanted in each chunk\n * @return {array} - array of original string split into chunks\n *\n * @example\n *      chunkify(\"this is a test\", 2)\n */\nfunction chunkify (str, size) {\n  const chunks = []\n  for (let i = 0; i < str.length; i += size) {\n    chunks.push(str.slice(i, i + size))\n  }\n  return chunks\n}\n\n/**\n * Rotates string representation of bits to the left\n *\n * @param {string} bits - string representation of bits\n * @param {int} turns - number of rotations to make\n * @return {string} - string representation of bits after rotation\n *\n * @example\n *      rotateLeft(\"1011\", 3); // \"1101\"\n */\nfunction rotateLeft (bits, turns) {\n  return bits.substr(turns) + bits.substr(0, turns)\n}\n\n/**\n * Pre-processes message to feed the algorithm loop\n *\n * @param {string} message - message to pre-process\n * @return {string} - processed message\n */\nfunction preProcess (message) {\n  // convert message to binary representation padded to\n  // 8 bits, and add 1\n  let m = message.split('')\n    .map(e => e.charCodeAt(0))\n    .map(e => e.toString(2))\n    .map(e => pad(e, 8))\n    .join('') + '1'\n\n  // extend message by adding empty bits (0)\n  while (m.length % 512 !== 448) {\n    m += '0'\n  }\n\n  // length of message in binary, padded, and extended\n  // to a 64 bit representation\n  let ml = (message.length * CHAR_SIZE).toString(2)\n  ml = pad(ml, 8)\n  ml = '0'.repeat(64 - ml.length) + ml\n\n  return m + ml\n}\n\n/**\n * Hashes message using SHA-1 Cryptographic Hash Function\n *\n * @param {string} message - message to hash\n * @return {string} - message digest (hash value)\n */\nfunction SHA1 (message) {\n  // main variables\n  let H0 = 0x67452301\n  let H1 = 0xEFCDAB89\n  let H2 = 0x98BADCFE\n  let H3 = 0x10325476\n  let H4 = 0xC3D2E1F0\n\n  // pre-process message and split into 512 bit chunks\n  const bits = preProcess(message)\n  const chunks = chunkify(bits, 512)\n\n  chunks.forEach(function (chunk, i) {\n    // break each chunk into 16 32-bit words\n    const words = chunkify(chunk, 32)\n\n    // extend 16 32-bit words to 80 32-bit words\n    for (let i = 16; i < 80; i++) {\n      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]\n        .map(e => parseInt(e, 2))\n        .reduce((acc, curr) => curr ^ acc, 0)\n      const bin = (val >>> 0).toString(2)\n      const paddedBin = pad(bin, 32)\n      const word = rotateLeft(paddedBin, 1)\n      words.push(word)\n    }\n\n    // initialize variables for this chunk\n    let [a, b, c, d, e] = [H0, H1, H2, H3, H4]\n\n    for (let i = 0; i < 80; i++) {\n      let f, k\n      if (i < 20) {\n        f = (b & c) | (~b & d)\n        k = 0x5A827999\n      } else if (i < 40) {\n        f = b ^ c ^ d\n        k = 0x6ED9EBA1\n      } else if (i < 60) {\n        f = (b & c) | (b & d) | (c & d)\n        k = 0x8F1BBCDC\n      } else {\n        f = b ^ c ^ d\n        k = 0xCA62C1D6\n      }\n      // make sure f is unsigned\n      f >>>= 0\n\n      const aRot = rotateLeft(pad(a.toString(2), 32), 5)\n      const aInt = parseInt(aRot, 2) >>> 0\n      const wordInt = parseInt(words[i], 2) >>> 0\n      const t = aInt + f + e + k + wordInt\n      e = d >>> 0\n      d = c >>> 0\n      const bRot = rotateLeft(pad(b.toString(2), 32), 30)\n      c = parseInt(bRot, 2) >>> 0\n      b = a >>> 0\n      a = t >>> 0\n    }\n\n    // add values for this chunk to main hash variables (unsigned)\n    H0 = (H0 + a) >>> 0\n    H1 = (H1 + b) >>> 0\n    H2 = (H2 + c) >>> 0\n    H3 = (H3 + d) >>> 0\n    H4 = (H4 + e) >>> 0\n  })\n\n  // combine hash values of main hash variables and return\n  const HH = [H0, H1, H2, H3, H4]\n    .map(e => e.toString(16))\n    .map(e => pad(e, 8))\n    .join('')\n\n  return HH\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n\n\n\n# 资源\n\n * guyongqiangx/cryptography: 密码编码学算法学习\n * RFC 3174: US Secure Hash Algorithm 1 (SHA1)\n * brix/crypto-js: JavaScript library of crypto standards.\n * SECURE HASH STANDARD\n\n\n# 参考\n\n * SHA-1 - Wikiwand\n * 散列函数 - Wikiwand",normalizedContent:"# 介绍\n\n散列函数（英语：hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。\n\nsha-1（英语：secure hash algorithm 1，中文名：安全散列算法 1）是一种密码散列函数。sha-1 可以生成一个被称为消息摘要的 160 位（20 字节）散列值，散列值通常的呈现形式为 40 个十六进制数。2005 年，密码分析人员发现了对 sha-1 的有效攻击方法，这表明该算法可能不够安全，不能继续使用。2020 年，针对 sha-1 的选择前缀冲突攻击已经实际可行。\n\n通过散列算法可实现数字签名实现，数字签名的原理是将要传送的明文通过一种函数运算（hash）转换成报文摘要（不同的明文对应不同的报文摘要），报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较，比较结果一致表示明文未被改动，如果不一致表示明文已被篡改。\n\n密码散列函数\n\n密码散列函数（英语：cryptographic hash function），又译为加密散列函数、密码散列函数、加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的资料是什么。\n\n\n# 伪代码\n\n以下是 sha-1 演算法的伪代码：\n\nnote: all variables are unsigned 32 bits and wrap modulo 232 when calculating\ninitial variables:\nh0 := 0x67452301\nh1 := 0xefcdab89\nh2 := 0x98badcfe\nh3 := 0x10325476\nh4 := 0xc3d2e1f0\npre-processing:\nappend the bit '1' to the message\nappend k bits '0', where k is the minimum number >= 0 such that the resulting message\n    length (in bits) is congruent to 448(mod 512)\nappend length of message (before pre-processing), in bits, as 64-bit big-endian integer\nprocess the message in successive 512-bit chunks:\nbreak message into 512-bit chunks\nfor each chunk\n    break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15\n    extend the sixteen 32-bit words into eighty 32-bit words:\n    for i from 16 to 79\n        w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1\n    initialize hash value for this chunk:\n    a := h0\n    b := h1\n    c := h2\n    d := h3\n    e := h4\n    main loop:\n    for i from 0 to 79\n        if 0 ≤ i ≤ 19 then\n            f := (b and c) or ((not b) and d)\n            k := 0x5a827999\n        else if 20 ≤ i ≤ 39\n            f := b xor c xor d\n            k := 0x6ed9eba1\n        else if 40 ≤ i ≤ 59\n            f := (b and c) or (b and d) or(c and d)\n            k := 0x8f1bbcdc\n        else if 60 ≤ i ≤ 79\n            f := b xor c xor d\n            k := 0xca62c1d6\n        temp := (a leftrotate 5) + f + e + k + w[i]\n        e := d\n        d := c\n        c := b leftrotate 30\n        b := a\n        a := temp\n    add this chunk's hash to result so far:\n    h0 := h0 + a\n    h1 := h1 + b\n    h2 := h2 + c\n    h3 := h3 + d\n    h4 := h4 + e\nproduce the final hash value (big-endian):\ndigest = hash = h0 append h1 append h2 append h3 append h4\n上述关于f运算式列于fips pub 180-1中，以下替代运算式也许也能在主要回圈里计算f：\n\n(0  ≤ i ≤ 19): f := d xor (b and (c xor d))         (alternative)\n \n(40 ≤ i ≤ 59): f := (b and c) or (d and (b or c))   (alternative 1)\n(40 ≤ i ≤ 59): f := (b and c) or (d and (b xor c))  (alternative 2)\n(40 ≤ i ≤ 59): f := (b and c) + (d and (b xor c))   (alternative 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 演示\n\n * 【sha1 算法】| 哈希算法 | hash 算法 | 密码学 | 信息安全 | 消息摘要：\n\n * 硬核讲解哈希算法加密原理（ sha-1 哈希算法)：\n\n * christof paar 教授在德国波鸿大学的教学视频：\n\n\n# 实现\n\n\n# javascript\n\n//= ===============================================================\n// sha1.js\n//\n// module that replicates the sha-1 cryptographic hash\n// function in javascript.\n//= ===============================================================\n\n// main variables\nconst char_size = 8\n\n/**\n * adds padding to binary/hex string representation\n *\n * @param {string} str - string representation (binary/hex)\n * @param {int} bits - total number of bits wanted\n * @return {string} - string representation padding with empty (0) bits\n *\n * @example\n *      pad(\"10011\", 8); // \"00010011\"\n */\nfunction pad (str, bits) {\n  let res = str\n  while (res.length % bits !== 0) {\n    res = '0' + res\n  }\n  return res\n}\n\n/**\n * separates string into chunks of the same size\n *\n * @param {string} str - string to separate into chunks\n * @param {int} size - number of characters wanted in each chunk\n * @return {array} - array of original string split into chunks\n *\n * @example\n *      chunkify(\"this is a test\", 2)\n */\nfunction chunkify (str, size) {\n  const chunks = []\n  for (let i = 0; i < str.length; i += size) {\n    chunks.push(str.slice(i, i + size))\n  }\n  return chunks\n}\n\n/**\n * rotates string representation of bits to the left\n *\n * @param {string} bits - string representation of bits\n * @param {int} turns - number of rotations to make\n * @return {string} - string representation of bits after rotation\n *\n * @example\n *      rotateleft(\"1011\", 3); // \"1101\"\n */\nfunction rotateleft (bits, turns) {\n  return bits.substr(turns) + bits.substr(0, turns)\n}\n\n/**\n * pre-processes message to feed the algorithm loop\n *\n * @param {string} message - message to pre-process\n * @return {string} - processed message\n */\nfunction preprocess (message) {\n  // convert message to binary representation padded to\n  // 8 bits, and add 1\n  let m = message.split('')\n    .map(e => e.charcodeat(0))\n    .map(e => e.tostring(2))\n    .map(e => pad(e, 8))\n    .join('') + '1'\n\n  // extend message by adding empty bits (0)\n  while (m.length % 512 !== 448) {\n    m += '0'\n  }\n\n  // length of message in binary, padded, and extended\n  // to a 64 bit representation\n  let ml = (message.length * char_size).tostring(2)\n  ml = pad(ml, 8)\n  ml = '0'.repeat(64 - ml.length) + ml\n\n  return m + ml\n}\n\n/**\n * hashes message using sha-1 cryptographic hash function\n *\n * @param {string} message - message to hash\n * @return {string} - message digest (hash value)\n */\nfunction sha1 (message) {\n  // main variables\n  let h0 = 0x67452301\n  let h1 = 0xefcdab89\n  let h2 = 0x98badcfe\n  let h3 = 0x10325476\n  let h4 = 0xc3d2e1f0\n\n  // pre-process message and split into 512 bit chunks\n  const bits = preprocess(message)\n  const chunks = chunkify(bits, 512)\n\n  chunks.foreach(function (chunk, i) {\n    // break each chunk into 16 32-bit words\n    const words = chunkify(chunk, 32)\n\n    // extend 16 32-bit words to 80 32-bit words\n    for (let i = 16; i < 80; i++) {\n      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]\n        .map(e => parseint(e, 2))\n        .reduce((acc, curr) => curr ^ acc, 0)\n      const bin = (val >>> 0).tostring(2)\n      const paddedbin = pad(bin, 32)\n      const word = rotateleft(paddedbin, 1)\n      words.push(word)\n    }\n\n    // initialize variables for this chunk\n    let [a, b, c, d, e] = [h0, h1, h2, h3, h4]\n\n    for (let i = 0; i < 80; i++) {\n      let f, k\n      if (i < 20) {\n        f = (b & c) | (~b & d)\n        k = 0x5a827999\n      } else if (i < 40) {\n        f = b ^ c ^ d\n        k = 0x6ed9eba1\n      } else if (i < 60) {\n        f = (b & c) | (b & d) | (c & d)\n        k = 0x8f1bbcdc\n      } else {\n        f = b ^ c ^ d\n        k = 0xca62c1d6\n      }\n      // make sure f is unsigned\n      f >>>= 0\n\n      const arot = rotateleft(pad(a.tostring(2), 32), 5)\n      const aint = parseint(arot, 2) >>> 0\n      const wordint = parseint(words[i], 2) >>> 0\n      const t = aint + f + e + k + wordint\n      e = d >>> 0\n      d = c >>> 0\n      const brot = rotateleft(pad(b.tostring(2), 32), 30)\n      c = parseint(brot, 2) >>> 0\n      b = a >>> 0\n      a = t >>> 0\n    }\n\n    // add values for this chunk to main hash variables (unsigned)\n    h0 = (h0 + a) >>> 0\n    h1 = (h1 + b) >>> 0\n    h2 = (h2 + c) >>> 0\n    h3 = (h3 + d) >>> 0\n    h4 = (h4 + e) >>> 0\n  })\n\n  // combine hash values of main hash variables and return\n  const hh = [h0, h1, h2, h3, h4]\n    .map(e => e.tostring(16))\n    .map(e => pad(e, 8))\n    .join('')\n\n  return hh\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n\n\n\n# 资源\n\n * guyongqiangx/cryptography: 密码编码学算法学习\n * rfc 3174: us secure hash algorithm 1 (sha1)\n * brix/crypto-js: javascript library of crypto standards.\n * secure hash standard\n\n\n# 参考\n\n * sha-1 - wikiwand\n * 散列函数 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/19, 19:52:42",lastUpdatedTimestamp:1666180362e3},{title:"SHA256 [SHA256算法]",frontmatter:{title:"SHA256 [SHA256算法]",date:"2022-05-01T20:10:59.000Z",permalink:"/algorithm/hash/sha256/",categories:["算法","Hash 哈希"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/70.Hash%20%E5%93%88%E5%B8%8C/20.SHA256.html",relativePath:"20.算法/70.Hash 哈希/20.SHA256.md",key:"v-59ae4823",path:"/algorithm/hash/sha256/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:181},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:205},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:299},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6610}],headersStr:"介绍 演示 实现 JavaScript 参考",content:"# 介绍\n\nSHA-2，名称来自于安全散列演算法 2（英语：Secure Hash Algorithm 2）的缩写，一种密码杂凑函数演算法标准。属于 SHA 演算法之一，是 SHA-1 的后继者。其下又可再分为六个不同的演算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。\n\n\n# 演示\n\n * SHA-256 加密算法讲解及代码实现：\n\n * SHA-256 加密算法讲解及代码实现：\n\n * 256 位加密有多安全？\n\n可视化：\n\n * Sha256 Algorithm Explained\n\n\n# 实现\n\n\n# JavaScript\n\n//= ===============================================================\n// SHA256.js\n//\n// Module that replicates the SHA-256 Cryptographic Hash\n// function in Javascript.\n//= ===============================================================\n\n// main variables\nconst CHAR_SIZE = 8\n\nconst K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]\n\n/**\n * Adds padding to binary/hex string representation\n *\n * @param {string} str - string representation (binary/hex)\n * @param {int} bits - total number of bits wanted\n * @return {string} - string representation padding with empty (0) bits\n *\n * @example\n *      pad(\"10011\", 8); // \"00010011\"\n */\nfunction pad (str, bits) {\n  let res = str\n  while (res.length % bits !== 0) {\n    res = '0' + res\n  }\n  return res\n}\n\n/**\n * Separates string into chunks of the same size\n *\n * @param {string} str - string to separate into chunks\n * @param {int} size - number of characters wanted in each chunk\n * @return {array} - array of original string split into chunks\n *\n * @example\n *      chunkify(\"this is a test\", 2)\n */\nfunction chunkify (str, size) {\n  const chunks = []\n  for (let i = 0; i < str.length; i += size) {\n    chunks.push(str.slice(i, i + size))\n  }\n  return chunks\n}\n\n/**\n * Rotates string representation of bits to th left\n *\n * @param {string} bits - string representation of bits\n * @param {int} turns - number of rotations to make\n * @return {string} - string representation of bits after rotation\n *\n * @example\n *      rotateLeft(\"1011\", 3); // \"1101\"\n */\nfunction rotateRight (bits, turns) {\n  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)\n}\n\n/**\n * Pre-processes message to feed the algorithm loop\n *\n * @param {string} message - message to pre-process\n * @return {string} - processed message\n */\nfunction preProcess (message) {\n  // convert message to binary representation padded to\n  // 8 bits, and add 1\n  let m = message.split('')\n    .map(e => e.charCodeAt(0))\n    .map(e => e.toString(2))\n    .map(e => pad(e, 8))\n    .join('') + '1'\n\n  // extend message by adding empty bits (0)\n  while (m.length % 512 !== 448) {\n    m += '0'\n  }\n\n  // length of message in binary, padded, and extended\n  // to a 64 bit representation\n  let ml = (message.length * CHAR_SIZE).toString(2)\n  ml = pad(ml, 8)\n  ml = '0'.repeat(64 - ml.length) + ml\n\n  return m + ml\n}\n\n/**\n * Hashes message using SHA-256 Cryptographic Hash Function\n *\n * @param {string} message - message to hash\n * @return {string} - message digest (hash value)\n */\nfunction SHA256 (message) {\n  // initial hash variables\n  let H0 = 0x6a09e667\n  let H1 = 0xbb67ae85\n  let H2 = 0x3c6ef372\n  let H3 = 0xa54ff53a\n  let H4 = 0x510e527f\n  let H5 = 0x9b05688c\n  let H6 = 0x1f83d9ab\n  let H7 = 0x5be0cd19\n\n  // pre-process message and split into 512 bit chunks\n  const bits = preProcess(message)\n  const chunks = chunkify(bits, 512)\n\n  chunks.forEach(function (chunk, i) {\n    // break each chunk into 16 32-bit words\n    const words = chunkify(chunk, 32)\n\n    // extend 16 32-bit words to 80 32-bit words\n    for (let i = 16; i < 64; i++) {\n      const W1 = words[i - 15]\n      const W2 = words[i - 2]\n      const R1 = rotateRight(W1, 7)\n      const R2 = rotateRight(W1, 18)\n      const R3 = rotateRight(W2, 17)\n      const R4 = rotateRight(W2, 19)\n      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)\n      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)\n      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1\n      words[i] = pad((val >>> 0).toString(2), 32)\n    }\n\n    // initialize variables for this chunk\n    let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]\n\n    for (let i = 0; i < 64; i++) {\n      const S1 = [6, 11, 25]\n        .map(turns => rotateRight(pad(e.toString(2), 32), turns))\n        .map(bitstring => parseInt(bitstring, 2))\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\n      const CH = ((e & f) ^ (~e & g)) >>> 0\n      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0\n      const S0 = [2, 13, 22]\n        .map(turns => rotateRight(pad(a.toString(2), 32), turns))\n        .map(bitstring => parseInt(bitstring, 2))\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\n      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0\n      const temp2 = (S0 + maj) >>> 0\n\n      h = g\n      g = f\n      f = e\n      e = (d + temp1) >>> 0\n      d = c\n      c = b\n      b = a\n      a = (temp1 + temp2) >>> 0\n    }\n\n    // add values for this chunk to main hash variables (unsigned)\n    H0 = (H0 + a) >>> 0\n    H1 = (H1 + b) >>> 0\n    H2 = (H2 + c) >>> 0\n    H3 = (H3 + d) >>> 0\n    H4 = (H4 + e) >>> 0\n    H5 = (H5 + f) >>> 0\n    H6 = (H6 + g) >>> 0\n    H7 = (H7 + h) >>> 0\n  })\n\n  // combine hash values of main hash variables and return\n  const HH = [H0, H1, H2, H3, H4, H5, H6, H7]\n    .map(e => e.toString(16))\n    .map(e => pad(e, 8))\n    .join('')\n\n  return HH\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n\n\n\n# 参考\n\n * SHA-2 - Wikiwand\n * 一文读懂 SHA256 算法原理及其实现 - 知乎",normalizedContent:"# 介绍\n\nsha-2，名称来自于安全散列演算法 2（英语：secure hash algorithm 2）的缩写，一种密码杂凑函数演算法标准。属于 sha 演算法之一，是 sha-1 的后继者。其下又可再分为六个不同的演算法标准，包括了：sha-224、sha-256、sha-384、sha-512、sha-512/224、sha-512/256。\n\n\n# 演示\n\n * sha-256 加密算法讲解及代码实现：\n\n * sha-256 加密算法讲解及代码实现：\n\n * 256 位加密有多安全？\n\n可视化：\n\n * sha256 algorithm explained\n\n\n# 实现\n\n\n# javascript\n\n//= ===============================================================\n// sha256.js\n//\n// module that replicates the sha-256 cryptographic hash\n// function in javascript.\n//= ===============================================================\n\n// main variables\nconst char_size = 8\n\nconst k = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]\n\n/**\n * adds padding to binary/hex string representation\n *\n * @param {string} str - string representation (binary/hex)\n * @param {int} bits - total number of bits wanted\n * @return {string} - string representation padding with empty (0) bits\n *\n * @example\n *      pad(\"10011\", 8); // \"00010011\"\n */\nfunction pad (str, bits) {\n  let res = str\n  while (res.length % bits !== 0) {\n    res = '0' + res\n  }\n  return res\n}\n\n/**\n * separates string into chunks of the same size\n *\n * @param {string} str - string to separate into chunks\n * @param {int} size - number of characters wanted in each chunk\n * @return {array} - array of original string split into chunks\n *\n * @example\n *      chunkify(\"this is a test\", 2)\n */\nfunction chunkify (str, size) {\n  const chunks = []\n  for (let i = 0; i < str.length; i += size) {\n    chunks.push(str.slice(i, i + size))\n  }\n  return chunks\n}\n\n/**\n * rotates string representation of bits to th left\n *\n * @param {string} bits - string representation of bits\n * @param {int} turns - number of rotations to make\n * @return {string} - string representation of bits after rotation\n *\n * @example\n *      rotateleft(\"1011\", 3); // \"1101\"\n */\nfunction rotateright (bits, turns) {\n  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)\n}\n\n/**\n * pre-processes message to feed the algorithm loop\n *\n * @param {string} message - message to pre-process\n * @return {string} - processed message\n */\nfunction preprocess (message) {\n  // convert message to binary representation padded to\n  // 8 bits, and add 1\n  let m = message.split('')\n    .map(e => e.charcodeat(0))\n    .map(e => e.tostring(2))\n    .map(e => pad(e, 8))\n    .join('') + '1'\n\n  // extend message by adding empty bits (0)\n  while (m.length % 512 !== 448) {\n    m += '0'\n  }\n\n  // length of message in binary, padded, and extended\n  // to a 64 bit representation\n  let ml = (message.length * char_size).tostring(2)\n  ml = pad(ml, 8)\n  ml = '0'.repeat(64 - ml.length) + ml\n\n  return m + ml\n}\n\n/**\n * hashes message using sha-256 cryptographic hash function\n *\n * @param {string} message - message to hash\n * @return {string} - message digest (hash value)\n */\nfunction sha256 (message) {\n  // initial hash variables\n  let h0 = 0x6a09e667\n  let h1 = 0xbb67ae85\n  let h2 = 0x3c6ef372\n  let h3 = 0xa54ff53a\n  let h4 = 0x510e527f\n  let h5 = 0x9b05688c\n  let h6 = 0x1f83d9ab\n  let h7 = 0x5be0cd19\n\n  // pre-process message and split into 512 bit chunks\n  const bits = preprocess(message)\n  const chunks = chunkify(bits, 512)\n\n  chunks.foreach(function (chunk, i) {\n    // break each chunk into 16 32-bit words\n    const words = chunkify(chunk, 32)\n\n    // extend 16 32-bit words to 80 32-bit words\n    for (let i = 16; i < 64; i++) {\n      const w1 = words[i - 15]\n      const w2 = words[i - 2]\n      const r1 = rotateright(w1, 7)\n      const r2 = rotateright(w1, 18)\n      const r3 = rotateright(w2, 17)\n      const r4 = rotateright(w2, 19)\n      const s0 = parseint(r1, 2) ^ parseint(r2, 2) ^ (parseint(w1, 2) >>> 3)\n      const s1 = parseint(r3, 2) ^ parseint(r4, 2) ^ (parseint(w2, 2) >>> 10)\n      const val = parseint(words[i - 16], 2) + s0 + parseint(words[i - 7], 2) + s1\n      words[i] = pad((val >>> 0).tostring(2), 32)\n    }\n\n    // initialize variables for this chunk\n    let [a, b, c, d, e, f, g, h] = [h0, h1, h2, h3, h4, h5, h6, h7]\n\n    for (let i = 0; i < 64; i++) {\n      const s1 = [6, 11, 25]\n        .map(turns => rotateright(pad(e.tostring(2), 32), turns))\n        .map(bitstring => parseint(bitstring, 2))\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\n      const ch = ((e & f) ^ (~e & g)) >>> 0\n      const temp1 = (h + s1 + ch + k[i] + parseint(words[i], 2)) >>> 0\n      const s0 = [2, 13, 22]\n        .map(turns => rotateright(pad(a.tostring(2), 32), turns))\n        .map(bitstring => parseint(bitstring, 2))\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\n      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0\n      const temp2 = (s0 + maj) >>> 0\n\n      h = g\n      g = f\n      f = e\n      e = (d + temp1) >>> 0\n      d = c\n      c = b\n      b = a\n      a = (temp1 + temp2) >>> 0\n    }\n\n    // add values for this chunk to main hash variables (unsigned)\n    h0 = (h0 + a) >>> 0\n    h1 = (h1 + b) >>> 0\n    h2 = (h2 + c) >>> 0\n    h3 = (h3 + d) >>> 0\n    h4 = (h4 + e) >>> 0\n    h5 = (h5 + f) >>> 0\n    h6 = (h6 + g) >>> 0\n    h7 = (h7 + h) >>> 0\n  })\n\n  // combine hash values of main hash variables and return\n  const hh = [h0, h1, h2, h3, h4, h5, h6, h7]\n    .map(e => e.tostring(16))\n    .map(e => pad(e, 8))\n    .join('')\n\n  return hh\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n\n\n\n# 参考\n\n * sha-2 - wikiwand\n * 一文读懂 sha256 算法原理及其实现 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/10/25, 20:46:09",lastUpdatedTimestamp:1666701969e3},{title:"AlphaNumericPalindrome [回文串]",frontmatter:{title:"AlphaNumericPalindrome [回文串]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/alphaNumericPalindrome/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/10.AlphaNumericPalindrome.html",relativePath:"20.算法/80.String 字符串/10.AlphaNumericPalindrome.md",key:"v-55adfde7",path:"/algorithm/string/alphaNumericPalindrome/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:57},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:64},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2033}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n回文，亦称回环，是正读反读都能读通的句子，亦有将文字排列成圆圈者，是一种修辞方式和文字游戏。\n\n\n# 实现\n\n\n# JavaScript\n\n/*****************************************************************************\n * @function alphaNumericPlaindrome\n * @description alphaNumericPlaindrome should return true if the string has alphanumeric characters that are palindrome irrespective of special characters and the letter case.\n * @param {string} str the string to check\n * @returns {Boolean}\n * @see [Factorial](https://en.wikipedia.org/wiki/Palindrome)\n * @example\n * The function alphaNumericPlaindrome() receives a string with varying formats\n * like \"racecar\", \"RaceCar\", and \"race CAR\"\n * The string can also have special characters\n * like \"2A3*3a2\", \"2A3 3a2\", and \"2_A3*3#A2\"\n *\n * But the catch is, we have to check only if the alphanumeric characters\n * are palindrome i.e remove spaces, symbols, punctuations etc\n * and the case of the characters doesn't matter\n *\n ****************************************************************************/\n\nconst alphaNumericPlaindrome = (str) => {\n  // removing all the special characters and turning everything to lowercase\n  const newStr = str.replace(/[^a-zA-Z0-9]*/g, '').toLowerCase()\n\n  for (let i = 0; i < newStr.length; i++) {\n    if (newStr[i] !== newStr[newStr.length - 1 - i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n或者：\n\n// Palindrome check is case sensitive; i.e. Aba is not a palindrome\n// input is a string\nconst checkPalindrome = (str) => {\n  // check that input is a string\n  if (typeof str !== 'string') {\n    return 'Not a string'\n  }\n  if (str.length === 0) {\n    return 'Empty string'\n  }\n  // Reverse only works with array, thus convert the string to array, reverse it and convert back to string\n  // return as palindrome if the reversed string is equal to the input string\n  const reversed = [...str].reverse().join('')\n  return str === reversed ? 'Palindrome' : 'Not a Palindrome'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 参考\n\n * 回文 - Wikiwand",normalizedContent:"# 介绍\n\n回文，亦称回环，是正读反读都能读通的句子，亦有将文字排列成圆圈者，是一种修辞方式和文字游戏。\n\n\n# 实现\n\n\n# javascript\n\n/*****************************************************************************\n * @function alphanumericplaindrome\n * @description alphanumericplaindrome should return true if the string has alphanumeric characters that are palindrome irrespective of special characters and the letter case.\n * @param {string} str the string to check\n * @returns {boolean}\n * @see [factorial](https://en.wikipedia.org/wiki/palindrome)\n * @example\n * the function alphanumericplaindrome() receives a string with varying formats\n * like \"racecar\", \"racecar\", and \"race car\"\n * the string can also have special characters\n * like \"2a3*3a2\", \"2a3 3a2\", and \"2_a3*3#a2\"\n *\n * but the catch is, we have to check only if the alphanumeric characters\n * are palindrome i.e remove spaces, symbols, punctuations etc\n * and the case of the characters doesn't matter\n *\n ****************************************************************************/\n\nconst alphanumericplaindrome = (str) => {\n  // removing all the special characters and turning everything to lowercase\n  const newstr = str.replace(/[^a-za-z0-9]*/g, '').tolowercase()\n\n  for (let i = 0; i < newstr.length; i++) {\n    if (newstr[i] !== newstr[newstr.length - 1 - i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n或者：\n\n// palindrome check is case sensitive; i.e. aba is not a palindrome\n// input is a string\nconst checkpalindrome = (str) => {\n  // check that input is a string\n  if (typeof str !== 'string') {\n    return 'not a string'\n  }\n  if (str.length === 0) {\n    return 'empty string'\n  }\n  // reverse only works with array, thus convert the string to array, reverse it and convert back to string\n  // return as palindrome if the reversed string is equal to the input string\n  const reversed = [...str].reverse().join('')\n  return str === reversed ? 'palindrome' : 'not a palindrome'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 参考\n\n * 回文 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"CreatePermutations [全排列]",frontmatter:{title:"CreatePermutations [全排列]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/createPermutations/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/100.CreatePermutations.html",relativePath:"20.算法/80.String 字符串/100.CreatePermutations.md",key:"v-8efdaeca",path:"/algorithm/string/createPermutations/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:148},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:155},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1479}],headersStr:"介绍 实现 JavaScript 参考",content:'# 介绍\n\n排列（英语：Permutation，置换）是将相异物件或符号根据确定的顺序重排。每个顺序都称作一个排列。例如，从一到六的数字有 720 种排列，对应于由这些数字组成的所有不重复亦不阙漏的序列，例如 "4, 5, 6, 1, 2, 3" 与 1, 3, 5, 2, 4, 6。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\na permutation of a set is, loosely speaking, an arrangement of its members into a sequence or linear order, or if the set is already ordered, a rearrangement of its elements.\nThe word "permutation" also refers to the act or process of changing the linear order of an ordered set\nMore at : https://en.wikipedia.org/wiki/Permutation\n*/\n\nconst createPermutations = (str) => {\n // convert string to array\n const arr = str.split("");\n\n // get array length\n const strLen = arr.length;\n // this will hold all the permutations\n const perms = [];\n let rest;\n let picked;\n let restPerms;\n let next;\n\n // if strLen is zero, return the same string\n if (strLen === 0) {\n  return [str];\n }\n // loop to the length to get all permutations\n for (let i = 0; i < strLen; i++) {\n  rest = Object.create(arr);\n  picked = rest.splice(i, 1);\n\n  restPerms = createPermutations(rest.join(""));\n\n  for (let j = 0, jLen = restPerms.length; j < jLen; j++) {\n   next = picked.concat(restPerms[j]);\n   perms.push(next.join(""));\n  }\n }\n return perms;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n * Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。参见：Object.create ()、new Object () 和 {} 的区别 - 掘金。\n * splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\n\n\n# 参考\n\n * Permutation - Wikiwand',normalizedContent:'# 介绍\n\n排列（英语：permutation，置换）是将相异物件或符号根据确定的顺序重排。每个顺序都称作一个排列。例如，从一到六的数字有 720 种排列，对应于由这些数字组成的所有不重复亦不阙漏的序列，例如 "4, 5, 6, 1, 2, 3" 与 1, 3, 5, 2, 4, 6。\n\n\n# 实现\n\n\n# javascript\n\n/*\na permutation of a set is, loosely speaking, an arrangement of its members into a sequence or linear order, or if the set is already ordered, a rearrangement of its elements.\nthe word "permutation" also refers to the act or process of changing the linear order of an ordered set\nmore at : https://en.wikipedia.org/wiki/permutation\n*/\n\nconst createpermutations = (str) => {\n // convert string to array\n const arr = str.split("");\n\n // get array length\n const strlen = arr.length;\n // this will hold all the permutations\n const perms = [];\n let rest;\n let picked;\n let restperms;\n let next;\n\n // if strlen is zero, return the same string\n if (strlen === 0) {\n  return [str];\n }\n // loop to the length to get all permutations\n for (let i = 0; i < strlen; i++) {\n  rest = object.create(arr);\n  picked = rest.splice(i, 1);\n\n  restperms = createpermutations(rest.join(""));\n\n  for (let j = 0, jlen = restperms.length; j < jlen; j++) {\n   next = picked.concat(restperms[j]);\n   perms.push(next.join(""));\n  }\n }\n return perms;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n * object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。参见：object.create ()、new object () 和 {} 的区别 - 掘金。\n * splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。\n\n\n# 参考\n\n * permutation - wikiwand',charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"DiceCoefficient [Dice系数]",frontmatter:{title:"DiceCoefficient [Dice系数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/diceCoefficient/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/110.DiceCoefficient.html",relativePath:"20.算法/80.String 字符串/110.DiceCoefficient.md",key:"v-681a7687",path:"/algorithm/string/diceCoefficient/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:254},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:261},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2151},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2187}],headersStr:"介绍 实现 JavaScript 扩展 参考",content:"# 介绍\n\n骰子系数（Dice coefficient），也称索伦森 - 骰子系数（Sørensen–Dice coefficient），是一种集合相似度度量函数，通常用于计算两个样本的相似度（也可以度量字符串的相似性）。\n\nDice 系数可以计算两个字符串的相似度： Dice（s1,s2）=2*comm(s1,s2)/(leng(s1)+leng(s2)) 。其中， comm (s1,s2) 是 s1、s2 中相同字符的个数 leng(s1)，leng(s2) 是字符串 s1、s2 的长度。\n\n\n# 实现\n\n\n# JavaScript\n\nDice 系数是通过比较两个字符串的 bigrams 来计算的， 一个 bigrams 是长度为 2 的字符串的一个子串。\n\n/* The Sørensen–Dice coefficient（系数） is a statistic used to （估计） the similarity of two samples.\n * Applied to strings, it can give you a value between 0 and 1 (included) which tells you how similar they are.\n * Dice coefficient is calculated by comparing the bigrams of both strings,\n * a bigram is a substring of the string of length 2.\n * read more: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\n */\n\n// Time complexity: O(m + n), m and n being the sizes of string A and string B\n\n// Find the bistrings of a string and return a hashmap (key => bistring, value => count)\nfunction mapBigrams(string) {\n const bigrams = new Map();\n for (let i = 0; i < string.length - 1; i++) {\n  const bigram = string.substring(i, i + 2);\n  const count = bigrams.get(bigram);\n  bigrams.set(bigram, (count || 0) + 1);\n }\n return bigrams;\n}\n\n// Calculate the number of common bigrams between a map of bigrams and a string\n\nfunction countCommonBigrams(bigrams, string) {\n let count = 0;\n for (let i = 0; i < string.length - 1; i++) {\n  const bigram = string.substring(i, i + 2);\n  if (bigrams.has(bigram)) count++;\n }\n return count;\n}\n\n// Calculate Dice coeff of 2 strings\nfunction diceCoefficient(stringA, stringB) {\n if (stringA === stringB) return 1;\n else if (stringA.length < 2 || stringB.length < 2) return 0;\n\n const bigramsA = mapBigrams(stringA);\n\n const lengthA = stringA.length - 1;\n const lengthB = stringB.length - 1;\n\n let dice = (2 * countCommonBigrams(bigramsA, stringB)) / (lengthA + lengthB);\n\n // cut 0.xxxxxx to 0.xx for simplicity\n dice = Math.floor(dice * 100) / 100;\n\n return dice;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集，或从开始索引直到字符串的末尾的一个子集。\n\n\n# 扩展\n\n * 医学影像分割 ---Dice Loss - 知乎\n\n\n# 参考\n\n * Sørensen–Dice coefficient - Wikiwand\n * Dice 系数 - Wikiwand",normalizedContent:"# 介绍\n\n骰子系数（dice coefficient），也称索伦森 - 骰子系数（sørensen–dice coefficient），是一种集合相似度度量函数，通常用于计算两个样本的相似度（也可以度量字符串的相似性）。\n\ndice 系数可以计算两个字符串的相似度： dice（s1,s2）=2*comm(s1,s2)/(leng(s1)+leng(s2)) 。其中， comm (s1,s2) 是 s1、s2 中相同字符的个数 leng(s1)，leng(s2) 是字符串 s1、s2 的长度。\n\n\n# 实现\n\n\n# javascript\n\ndice 系数是通过比较两个字符串的 bigrams 来计算的， 一个 bigrams 是长度为 2 的字符串的一个子串。\n\n/* the sørensen–dice coefficient（系数） is a statistic used to （估计） the similarity of two samples.\n * applied to strings, it can give you a value between 0 and 1 (included) which tells you how similar they are.\n * dice coefficient is calculated by comparing the bigrams of both strings,\n * a bigram is a substring of the string of length 2.\n * read more: https://en.wikipedia.org/wiki/s%c3%b8rensen%e2%80%93dice_coefficient\n */\n\n// time complexity: o(m + n), m and n being the sizes of string a and string b\n\n// find the bistrings of a string and return a hashmap (key => bistring, value => count)\nfunction mapbigrams(string) {\n const bigrams = new map();\n for (let i = 0; i < string.length - 1; i++) {\n  const bigram = string.substring(i, i + 2);\n  const count = bigrams.get(bigram);\n  bigrams.set(bigram, (count || 0) + 1);\n }\n return bigrams;\n}\n\n// calculate the number of common bigrams between a map of bigrams and a string\n\nfunction countcommonbigrams(bigrams, string) {\n let count = 0;\n for (let i = 0; i < string.length - 1; i++) {\n  const bigram = string.substring(i, i + 2);\n  if (bigrams.has(bigram)) count++;\n }\n return count;\n}\n\n// calculate dice coeff of 2 strings\nfunction dicecoefficient(stringa, stringb) {\n if (stringa === stringb) return 1;\n else if (stringa.length < 2 || stringb.length < 2) return 0;\n\n const bigramsa = mapbigrams(stringa);\n\n const lengtha = stringa.length - 1;\n const lengthb = stringb.length - 1;\n\n let dice = (2 * countcommonbigrams(bigramsa, stringb)) / (lengtha + lengthb);\n\n // cut 0.xxxxxx to 0.xx for simplicity\n dice = math.floor(dice * 100) / 100;\n\n return dice;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集，或从开始索引直到字符串的末尾的一个子集。\n\n\n# 扩展\n\n * 医学影像分割 ---dice loss - 知乎\n\n\n# 参考\n\n * sørensen–dice coefficient - wikiwand\n * dice 系数 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:45:42",lastUpdatedTimestamp:1666269942e3},{title:"FormatPhoneNumber [格式化电话号码]",frontmatter:{title:"FormatPhoneNumber [格式化电话号码]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/formatPhoneNumber/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/120.FormatPhoneNumber.html",relativePath:"20.算法/80.String 字符串/120.FormatPhoneNumber.md",key:"v-4152d2a7",path:"/algorithm/string/formatPhoneNumber/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:49},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:56}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n给定 10 个数字，返回格式化为 (XXX) XXX-XXXX 的电话号码。\n\n\n# 实现\n\n\n# JavaScript\n\n// function that takes 10 digits and returns a string of the formatted phone number\n// e.g.: 1234567890 -> (123) 456-7890\n\nconst formatPhoneNumber = (numbers) => {\n  const numbersString = numbers.toString()\n  if ((numbersString.length !== 10) || isNaN(numbersString)) {\n    // return \"Invalid phone number.\"\n    throw new TypeError('Invalid phone number.')\n  }\n  const arr = '(XXX) XXX-XXXX'.split('')\n  Array.from(numbersString).forEach(n => {\n    arr[arr.indexOf('X')] = n\n  })\n  return arr.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# 介绍\n\n给定 10 个数字，返回格式化为 (xxx) xxx-xxxx 的电话号码。\n\n\n# 实现\n\n\n# javascript\n\n// function that takes 10 digits and returns a string of the formatted phone number\n// e.g.: 1234567890 -> (123) 456-7890\n\nconst formatphonenumber = (numbers) => {\n  const numbersstring = numbers.tostring()\n  if ((numbersstring.length !== 10) || isnan(numbersstring)) {\n    // return \"invalid phone number.\"\n    throw new typeerror('invalid phone number.')\n  }\n  const arr = '(xxx) xxx-xxxx'.split('')\n  array.from(numbersstring).foreach(n => {\n    arr[arr.indexof('x')] = n\n  })\n  return arr.join('')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:45:42",lastUpdatedTimestamp:1666269942e3},{title:"GenerateGUID [生成GUID、UUID]",frontmatter:{title:"GenerateGUID [生成GUID、UUID]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/generateGUID/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/130.GenerateGuid.html",relativePath:"20.算法/80.String 字符串/130.GenerateGuid.md",key:"v-3b9e07eb",path:"/algorithm/string/generateGUID/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"GUID 和 UUID de 区别",slug:"guid-和-uuid-de-区别",normalizedTitle:"guid 和 uuid de 区别",charIndex:159},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:355},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:362},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:279}],headersStr:"介绍 GUID 和 UUID de 区别 实现 JavaScript 参考",content:"# 介绍\n\n通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID）是用于计算机体系中以识别信息的一个 128 位标识符。\n\n根据标准方法生成，不依赖中央机构的注册和分配，UUID 具有唯一性，这与其他大多数编号方案不同。重复 UUID 码概率接近零，可以忽略不计。\n\n\n# GUID 和 UUID de 区别\n\n把它们当作一个 16 字节（128 位）的值，作为一个唯一的值使用。在微软的说法中，它们被称为 GUID，但在不使用微软的说法时，就叫它们 UUID。甚至 UUID 规范的作者和微软都声称它们是同义词。参考：Is there any difference between a GUID and a UUID? - Stack Overflow。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\nGenerates a UUID/GUID in Node.Js.\nThe script uses `Math.random` in combination with the timestamp for better randomness.\nThe function generate an RFC4122 (https://www.ietf.org/rfc/rfc4122.txt) version 4 UUID/GUID\n*/\n\nconst Guid = () => {\n  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  let currentDateMilliseconds = new Date().getTime()\n  return pattern.replace(/[xy]/g, currentChar => {\n    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0\n    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)\n    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)\n  })\n}\n// > Guid()\n// 'edc848db-3478-1760-8b55-7986003d895f'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * | 0 向下取整（负数则向上取整），相当于 ~~n 或者 Math.foloor(n) 。\n\n\n# 参考\n\n * Universally unique identifier - Wikiwand\n * 通用唯一识别码 - Wikiwand",normalizedContent:"# 介绍\n\n通用唯一识别码（英语：universally unique identifier，缩写：uuid）是用于计算机体系中以识别信息的一个 128 位标识符。\n\n根据标准方法生成，不依赖中央机构的注册和分配，uuid 具有唯一性，这与其他大多数编号方案不同。重复 uuid 码概率接近零，可以忽略不计。\n\n\n# guid 和 uuid de 区别\n\n把它们当作一个 16 字节（128 位）的值，作为一个唯一的值使用。在微软的说法中，它们被称为 guid，但在不使用微软的说法时，就叫它们 uuid。甚至 uuid 规范的作者和微软都声称它们是同义词。参考：is there any difference between a guid and a uuid? - stack overflow。\n\n\n# 实现\n\n\n# javascript\n\n/*\ngenerates a uuid/guid in node.js.\nthe script uses `math.random` in combination with the timestamp for better randomness.\nthe function generate an rfc4122 (https://www.ietf.org/rfc/rfc4122.txt) version 4 uuid/guid\n*/\n\nconst guid = () => {\n  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  let currentdatemilliseconds = new date().gettime()\n  return pattern.replace(/[xy]/g, currentchar => {\n    const randomchar = (currentdatemilliseconds + math.random() * 16) % 16 | 0\n    currentdatemilliseconds = math.floor(currentdatemilliseconds / 16)\n    return (currentchar === 'x' ? randomchar : (randomchar & 0x7 | 0x8)).tostring(16)\n  })\n}\n// > guid()\n// 'edc848db-3478-1760-8b55-7986003d895f'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * | 0 向下取整（负数则向上取整），相当于 ~~n 或者 math.foloor(n) 。\n\n\n# 参考\n\n * universally unique identifier - wikiwand\n * 通用唯一识别码 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:45:42",lastUpdatedTimestamp:1666269942e3},{title:"HammingDistance [汉明距离]",frontmatter:{title:"HammingDistance [汉明距离]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/hammingDistance/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/140.HammingDistance.html",relativePath:"20.算法/80.String 字符串/140.HammingDistance.md",key:"v-28aa3f32",path:"/algorithm/string/hammingDistance/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:212},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:219},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1036}],headersStr:"介绍 实现 JavaScript 参考",content:'# 介绍\n\n在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。\n\n汉明重量是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串（binary data strings）来说，就是 1 的个数，所以 11101 的汉明重量是 4。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * Hamming Distance: https://en.wikipedia.org/wiki/Hamming_distance\n *\n *\n * Hamming distance is a metric（公式） for comparing two binary data strings.\n *\n * While comparing two binary strings of equal length, Hamming distance\n * is the number of bit positions in which the two bits are different.\n * The Hamming distance between two strings, a and b is denoted（记为） as d(a,b)\n */\n\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\n\nconst hammingDistance = (a, b) => {\n if (a.length !== b.length) {\n  throw new Error("Strings must be of the same length");\n }\n\n let distance = 0;\n\n for (let i = 0; i < a.length; i += 1) {\n  if (a[i] !== b[i]) {\n   distance += 1;\n  }\n }\n\n return distance;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * Hamming distance - Wikiwand\n * 汉明距离 - Wikiwand',normalizedContent:'# 介绍\n\n在信息论中，两个等长字符串之间的汉明距离（英语：hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。\n\n汉明重量是字符串相对于同样长度的零字符串的汉明距离，也就是说，它是字符串中非零的元素个数：对于二进制字符串（binary data strings）来说，就是 1 的个数，所以 11101 的汉明重量是 4。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * hamming distance: https://en.wikipedia.org/wiki/hamming_distance\n *\n *\n * hamming distance is a metric（公式） for comparing two binary data strings.\n *\n * while comparing two binary strings of equal length, hamming distance\n * is the number of bit positions in which the two bits are different.\n * the hamming distance between two strings, a and b is denoted（记为） as d(a,b)\n */\n\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\n\nconst hammingdistance = (a, b) => {\n if (a.length !== b.length) {\n  throw new error("strings must be of the same length");\n }\n\n let distance = 0;\n\n for (let i = 0; i < a.length; i += 1) {\n  if (a[i] !== b[i]) {\n   distance += 1;\n  }\n }\n\n return distance;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 参考\n\n * hamming distance - wikiwand\n * 汉明距离 - wikiwand',charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:45:42",lastUpdatedTimestamp:1666269942e3},{title:"KMPPatternSearching [KMP字符串匹配]",frontmatter:{title:"KMPPatternSearching [KMP字符串匹配]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/KMPPatternSearching/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/150.KMPPatternSearching.html",relativePath:"20.算法/80.String 字符串/150.KMPPatternSearching.md",key:"v-747281c7",path:"/algorithm/string/KMPPatternSearching/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:140},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:147},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1752}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n在计算机科学中，Knuth-Morris-Pratt 字符串查找算法（简称为 KMP 算法）可在一个字符串 S 内查找一个词 W 的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。\n\n\n# 实现\n\n\n# JavaScript\n\n// Implementing KMP Search Algorithm to search all the instances of pattern in\n// given text\n// Reference Book: Introduction to Algorithms, CLRS\n\n// Explanation: https://www.topcoder.com/community/competitive-programming/tutorials/introduction-to-string-searching-algorithms/\n\nconst computeLPS = (pattern) => {\n  const lps = Array(pattern.length)\n  lps[0] = 0\n  for (let i = 1; i < pattern.length; i++) {\n    let matched = lps[i - 1]\n    while (matched > 0 && pattern[i] !== pattern[matched]) {\n      matched = lps[matched - 1]\n    }\n    if (pattern[i] === pattern[matched]) {\n      matched++\n    }\n    lps[i] = matched\n  }\n  return lps\n}\n\n/**\n * Returns all indices where pattern starts in text\n * @param {*} text a big text in which pattern string is to find\n * @param {*} pattern the string to find\n */\nconst KMPSearch = (text, pattern) => {\n  if (!pattern || !text) {\n    return [] // no results\n  }\n\n  // lps[i] = length of proper prefix of pattern[0]...pattern[i-1]\n  //          which is also proper suffix of it\n  const lps = computeLPS(pattern)\n  const result = []\n\n  let matched = 0\n  for (let i = 0; i < text.length; i++) {\n    while (matched > 0 && text[i] !== pattern[matched]) {\n      matched = lps[matched - 1]\n    }\n    if (text[i] === pattern[matched]) {\n      matched++\n    }\n    if (matched === pattern.length) {\n      result.push(i - pattern.length + 1)\n      matched = lps[matched - 1]\n    }\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 参考\n\n * Knuth–Morris–Pratt algorithm - Wikiwand\n * KMP 算法 - Wikiwand\n * 字符串匹配的 KMP 算法 - 阮一峰的网络日志",normalizedContent:"# 介绍\n\n在计算机科学中，knuth-morris-pratt 字符串查找算法（简称为 kmp 算法）可在一个字符串 s 内查找一个词 w 的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。\n\n\n# 实现\n\n\n# javascript\n\n// implementing kmp search algorithm to search all the instances of pattern in\n// given text\n// reference book: introduction to algorithms, clrs\n\n// explanation: https://www.topcoder.com/community/competitive-programming/tutorials/introduction-to-string-searching-algorithms/\n\nconst computelps = (pattern) => {\n  const lps = array(pattern.length)\n  lps[0] = 0\n  for (let i = 1; i < pattern.length; i++) {\n    let matched = lps[i - 1]\n    while (matched > 0 && pattern[i] !== pattern[matched]) {\n      matched = lps[matched - 1]\n    }\n    if (pattern[i] === pattern[matched]) {\n      matched++\n    }\n    lps[i] = matched\n  }\n  return lps\n}\n\n/**\n * returns all indices where pattern starts in text\n * @param {*} text a big text in which pattern string is to find\n * @param {*} pattern the string to find\n */\nconst kmpsearch = (text, pattern) => {\n  if (!pattern || !text) {\n    return [] // no results\n  }\n\n  // lps[i] = length of proper prefix of pattern[0]...pattern[i-1]\n  //          which is also proper suffix of it\n  const lps = computelps(pattern)\n  const result = []\n\n  let matched = 0\n  for (let i = 0; i < text.length; i++) {\n    while (matched > 0 && text[i] !== pattern[matched]) {\n      matched = lps[matched - 1]\n    }\n    if (text[i] === pattern[matched]) {\n      matched++\n    }\n    if (matched === pattern.length) {\n      result.push(i - pattern.length + 1)\n      matched = lps[matched - 1]\n    }\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 参考\n\n * knuth–morris–pratt algorithm - wikiwand\n * kmp 算法 - wikiwand\n * 字符串匹配的 kmp 算法 - 阮一峰的网络日志",charsets:{cjk:!0},lastUpdated:"2022/10/20, 21:49:42",lastUpdatedTimestamp:1666273782e3},{title:"BoyerMoore [博耶-穆尔字符串搜索算法、BM 算法]",frontmatter:{title:"BoyerMoore [博耶-穆尔字符串搜索算法、BM 算法]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/boyerMoore/",categories:["算法","String 字符串"],tags:[["ReadAgain"]]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/30.BoyerMoore.html",relativePath:"20.算法/80.String 字符串/30.BoyerMoore.md",key:"v-2a0c2c87",path:"/algorithm/string/boyerMoore/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"移动规则",slug:"移动规则",normalizedTitle:"移动规则",charIndex:283},{level:2,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:861},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1022},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1029},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:5050},{level:3,title:"如何计算坏字符表和好后缀表？",slug:"如何计算坏字符表和好后缀表",normalizedTitle:"如何计算坏字符表和好后缀表？",charIndex:5057},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5219}],headersStr:"介绍 移动规则 演示 实现 JavaScript 扩展 如何计算坏字符表和好后缀表？ 参考",content:"# 介绍\n\n在计算机科学里，博耶 - 穆尔字符串搜索算法是一种非常高效的字符串搜索算法。虽然博耶 - 穆尔算法的执行时间同样线性依赖于被搜索字符串的大小，但是通常仅为其它算法的一小部分：它不需要对被搜索的字符串中的字符进行逐一比较，而会跳过其中某些部分。通常搜索关键字越长，算法速度越快。它的效率来自于这样的事实：对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置。\n\n更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。\n\n\n# 移动规则\n\n移动字符数是通过两条规则决定的：坏字符规则和好后缀规则。实际移动为通过这两条规则计算出的最大移动个数。\n\n * 坏字符规则：当 T 中有字符不匹配时，如果 T 中的这个不匹配的字符出现在对应 P 中当前位置的左侧，那么 P 移动位置将这两个在字符对齐。如果 T 中这个不匹配字符不在 P 中当前位置的左侧，那么将当前位置左侧的所有字符均移到该不匹配字符后。\n\n * 好后缀规则：假设有 P 和 T，T 中字串 t 匹配到了 P 的一个后缀，但在比较位置 i 时发生不匹配。设匹配到的好后缀在 T 中为 t，在 P 中为 t'（t = t'）。好后缀规则的实质是，将不匹配位置右侧匹配到的字符串 t 的所有字符后缀组合，用于查找它们在 P 的不匹配位置左侧是否存在。分两种情况来讨论：\n   \n   * 在 P 中 i 位置的左侧最靠近 i 位置查找字串 t' 使得 t'=t（此时 t' 不是 P 的后缀，实际上也就是查找匹配到的字串除了在 P 的后缀中存在，是否在 P 的其他位置存在），若存在，则移动相应的位数将找到的 t' 与 T 中的 t 对齐。\n   * 如果 t' 不存在，那我们继续查找 t 的某一个后缀是否为 P 的前缀，若存在，则移动相应的位将 P 的前缀与 t 的后缀位置对齐。否则，将 P 向后移动 n 个字符。\n\n\n# 演示\n\n可视化\n\n * Visualizing String Matching Algorithms\n * Interactive Demo of the Boyer-Moore String Search Algorithm\n * Boyer-Moore String Search Visualization\n\n\n# 实现\n\n\n# JavaScript\n\n只应用坏字符规则。\n\n/*\n *Implementation of the Boyer-Moore String Search Algorithm.\n *The Boyer–Moore string search algorithm allows linear time in\n *search by skipping indices when searching inside a string for a pattern.\n **/\nconst buildBadMatchTable = (str) => {\n  const tableObj = {}\n  const strLength = str.length\n  for (let i = 0; i < strLength - 1; i++) {\n    tableObj[str[i]] = strLength - 1 - i\n  }\n  if (tableObj[str[strLength - 1]] === undefined) {\n    tableObj[str[strLength - 1]] = strLength\n  }\n  return tableObj\n}\n\nconst boyerMoore = (str, pattern) => {\n  const badMatchTable = buildBadMatchTable(pattern)\n  let offset = 0\n  const patternLastIndex = pattern.length - 1\n  const maxOffset = str.length - pattern.length\n  // if the offset is bigger than maxOffset, cannot be found\n  while (offset <= maxOffset) {\n    let scanIndex = 0\n    while (pattern[scanIndex] === str[scanIndex + offset]) {\n      if (scanIndex === patternLastIndex) {\n        // found at this index\n        return offset\n      }\n      scanIndex++\n    }\n    const badMatchString = str[offset + patternLastIndex]\n    if (badMatchTable[badMatchString]) {\n      // increase the offset if it exists\n      offset += badMatchTable[badMatchString]\n    } else {\n      offset++\n    }\n  }\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n更复杂的实现，同时应用坏字符规则和好后缀规则。\n\n/**\n * Returns the index of the first occurence of given string in the phrase\n * In case of no match, returns -1\n * see https://gist.github.com/Kamilczak020/f8382eef9777e8f07d47be29a4efc04b\n * \n * @param text string to be searched \n * @param pattern string to be found in the text\n */\nfunction boyerMooreSearch(text: string, pattern: string): number {\n    \n    // Handle edge case\n    if (pattern.length === 0) {\n        return -1;\n    }\n\n    let charTable = makeCharTable(pattern);\n    let offsetTable = makeOffsetTable(pattern);\n\n    for (let i = pattern.length - 1, j; i < text.length;) {\n        for (j = pattern.length - 1; pattern[j] == text[i]; i--, j--) {\n            if (j === 0) {\n                return i;\n            }\n        }\n\n        const charCode = text.charCodeAt(i);\n        i+= Math.max(offsetTable[pattern.length - 1 - j], charTable[charCode]);\n    }\n\n    return -1;\n}\n\n/**\n * Creates jump table, based on mismatched character information\n */\nfunction makeCharTable(pattern: string): number[] {\n    let table = [];\n\n    // 65536 being the max value of char + 1\n    for (let i = 0; i < 65536; i++) {\n        table.push(pattern.length);\n    }\n\n    for (let i = 0; i < pattern.length - 1; i++) {\n        const charCode = pattern.charCodeAt(i);\n        table[charCode] = pattern.length - 1 - i;\n    }\n\n    return table;\n}\n\n\nfunction makeOffsetTable(pattern: string): number[] {\n    let table = [];\n    table.length = pattern.length;\n\n    let lastPrefixPosition = pattern.length;\n\n    for (let i = pattern.length; i > 0; i--) {\n        if (isPrefix(pattern, i)) {\n            lastPrefixPosition = i;\n        }\n\n        table[pattern.length - i] = lastPrefixPosition - 1 + pattern.length;\n    }\n\n    for (let i = 0; i < pattern.length - 1; i++) {\n        const slen = suffixLength(pattern, i);\n        table[slen] = pattern.length - 1 - i + slen;\n    }\n\n    return table;\n}\n\nfunction isPrefix(pattern: string, p: number): boolean {\n    for (let i = p, j = 0; i < pattern.length; i++, j++) {\n        if (pattern[i] != pattern[j]) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nfunction suffixLength(pattern: string, p: number) {\n    let len = 0;\n\n    for (let i = p, j = pattern.length - 1; i >= 0 && pattern[i] == pattern[j]; i--, j--) {\n        len += 1;\n    }\n\n    return len;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n\n\n\n# 扩展\n\n\n# 如何计算坏字符表和好后缀表？\n\n参见：\n\n * Calculating Boyer Moore Bad Character Table with examples | by Sulakshana Ranawake | Medium\n * 动画：BM 算法中的坏字符规则与好后缀规则 - 腾讯云开发者社区 - 腾讯云\n\n\n# 参考\n\n * Boyer–Moore string-search algorithm - Wikiwand\n * 博耶 - 穆尔字符串搜索算法 - Wikiwand\n * 字符串匹配的 Boyer-Moore 算法 - 阮一峰的网络日志\n * Boyer-Moore Fast String Searching Example\n * https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf\n * https://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf\n * Boyer-Moore",normalizedContent:"# 介绍\n\n在计算机科学里，博耶 - 穆尔字符串搜索算法是一种非常高效的字符串搜索算法。虽然博耶 - 穆尔算法的执行时间同样线性依赖于被搜索字符串的大小，但是通常仅为其它算法的一小部分：它不需要对被搜索的字符串中的字符进行逐一比较，而会跳过其中某些部分。通常搜索关键字越长，算法速度越快。它的效率来自于这样的事实：对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置。\n\n更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。\n\n\n# 移动规则\n\n移动字符数是通过两条规则决定的：坏字符规则和好后缀规则。实际移动为通过这两条规则计算出的最大移动个数。\n\n * 坏字符规则：当 t 中有字符不匹配时，如果 t 中的这个不匹配的字符出现在对应 p 中当前位置的左侧，那么 p 移动位置将这两个在字符对齐。如果 t 中这个不匹配字符不在 p 中当前位置的左侧，那么将当前位置左侧的所有字符均移到该不匹配字符后。\n\n * 好后缀规则：假设有 p 和 t，t 中字串 t 匹配到了 p 的一个后缀，但在比较位置 i 时发生不匹配。设匹配到的好后缀在 t 中为 t，在 p 中为 t'（t = t'）。好后缀规则的实质是，将不匹配位置右侧匹配到的字符串 t 的所有字符后缀组合，用于查找它们在 p 的不匹配位置左侧是否存在。分两种情况来讨论：\n   \n   * 在 p 中 i 位置的左侧最靠近 i 位置查找字串 t' 使得 t'=t（此时 t' 不是 p 的后缀，实际上也就是查找匹配到的字串除了在 p 的后缀中存在，是否在 p 的其他位置存在），若存在，则移动相应的位数将找到的 t' 与 t 中的 t 对齐。\n   * 如果 t' 不存在，那我们继续查找 t 的某一个后缀是否为 p 的前缀，若存在，则移动相应的位将 p 的前缀与 t 的后缀位置对齐。否则，将 p 向后移动 n 个字符。\n\n\n# 演示\n\n可视化\n\n * visualizing string matching algorithms\n * interactive demo of the boyer-moore string search algorithm\n * boyer-moore string search visualization\n\n\n# 实现\n\n\n# javascript\n\n只应用坏字符规则。\n\n/*\n *implementation of the boyer-moore string search algorithm.\n *the boyer–moore string search algorithm allows linear time in\n *search by skipping indices when searching inside a string for a pattern.\n **/\nconst buildbadmatchtable = (str) => {\n  const tableobj = {}\n  const strlength = str.length\n  for (let i = 0; i < strlength - 1; i++) {\n    tableobj[str[i]] = strlength - 1 - i\n  }\n  if (tableobj[str[strlength - 1]] === undefined) {\n    tableobj[str[strlength - 1]] = strlength\n  }\n  return tableobj\n}\n\nconst boyermoore = (str, pattern) => {\n  const badmatchtable = buildbadmatchtable(pattern)\n  let offset = 0\n  const patternlastindex = pattern.length - 1\n  const maxoffset = str.length - pattern.length\n  // if the offset is bigger than maxoffset, cannot be found\n  while (offset <= maxoffset) {\n    let scanindex = 0\n    while (pattern[scanindex] === str[scanindex + offset]) {\n      if (scanindex === patternlastindex) {\n        // found at this index\n        return offset\n      }\n      scanindex++\n    }\n    const badmatchstring = str[offset + patternlastindex]\n    if (badmatchtable[badmatchstring]) {\n      // increase the offset if it exists\n      offset += badmatchtable[badmatchstring]\n    } else {\n      offset++\n    }\n  }\n  return -1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n更复杂的实现，同时应用坏字符规则和好后缀规则。\n\n/**\n * returns the index of the first occurence of given string in the phrase\n * in case of no match, returns -1\n * see https://gist.github.com/kamilczak020/f8382eef9777e8f07d47be29a4efc04b\n * \n * @param text string to be searched \n * @param pattern string to be found in the text\n */\nfunction boyermooresearch(text: string, pattern: string): number {\n    \n    // handle edge case\n    if (pattern.length === 0) {\n        return -1;\n    }\n\n    let chartable = makechartable(pattern);\n    let offsettable = makeoffsettable(pattern);\n\n    for (let i = pattern.length - 1, j; i < text.length;) {\n        for (j = pattern.length - 1; pattern[j] == text[i]; i--, j--) {\n            if (j === 0) {\n                return i;\n            }\n        }\n\n        const charcode = text.charcodeat(i);\n        i+= math.max(offsettable[pattern.length - 1 - j], chartable[charcode]);\n    }\n\n    return -1;\n}\n\n/**\n * creates jump table, based on mismatched character information\n */\nfunction makechartable(pattern: string): number[] {\n    let table = [];\n\n    // 65536 being the max value of char + 1\n    for (let i = 0; i < 65536; i++) {\n        table.push(pattern.length);\n    }\n\n    for (let i = 0; i < pattern.length - 1; i++) {\n        const charcode = pattern.charcodeat(i);\n        table[charcode] = pattern.length - 1 - i;\n    }\n\n    return table;\n}\n\n\nfunction makeoffsettable(pattern: string): number[] {\n    let table = [];\n    table.length = pattern.length;\n\n    let lastprefixposition = pattern.length;\n\n    for (let i = pattern.length; i > 0; i--) {\n        if (isprefix(pattern, i)) {\n            lastprefixposition = i;\n        }\n\n        table[pattern.length - i] = lastprefixposition - 1 + pattern.length;\n    }\n\n    for (let i = 0; i < pattern.length - 1; i++) {\n        const slen = suffixlength(pattern, i);\n        table[slen] = pattern.length - 1 - i + slen;\n    }\n\n    return table;\n}\n\nfunction isprefix(pattern: string, p: number): boolean {\n    for (let i = p, j = 0; i < pattern.length; i++, j++) {\n        if (pattern[i] != pattern[j]) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nfunction suffixlength(pattern: string, p: number) {\n    let len = 0;\n\n    for (let i = p, j = pattern.length - 1; i >= 0 && pattern[i] == pattern[j]; i--, j--) {\n        len += 1;\n    }\n\n    return len;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n\n\n\n# 扩展\n\n\n# 如何计算坏字符表和好后缀表？\n\n参见：\n\n * calculating boyer moore bad character table with examples | by sulakshana ranawake | medium\n * 动画：bm 算法中的坏字符规则与好后缀规则 - 腾讯云开发者社区 - 腾讯云\n\n\n# 参考\n\n * boyer–moore string-search algorithm - wikiwand\n * 博耶 - 穆尔字符串搜索算法 - wikiwand\n * 字符串匹配的 boyer-moore 算法 - 阮一峰的网络日志\n * boyer-moore fast string searching example\n * https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf\n * https://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf\n * boyer-moore",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"AlternativeStringArrange [交替合并字符串]",frontmatter:{title:"AlternativeStringArrange [交替合并字符串]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/alternativeStringArrange/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/20.AlternativeStringArrange.html",relativePath:"20.算法/80.String 字符串/20.AlternativeStringArrange.md",key:"v-5bb0c3c7",path:"/algorithm/string/alternativeStringArrange/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:137},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:144},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1771}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n给定两个字符串，以另一种方式合并它们，即最终字符串的第一个字符是第一个字符串的第一个字符，最终字符串的第二个字符是第二个字符串的第一个字符，以此类推。如果你达到了一个字符串的末尾，而另一个字符串还在，那么就把这个字符串的剩余部分追加到最后一个字符串中。\n\n\n# 实现\n\n\n# JavaScript\n\n// Alternative arrange the two given strings in one string in O(n) time complexity.\n\n\n// Problem Source & Explanation: https://www.geeksforgeeks.org/alternatively-merge-two-strings-in-java/\n\n/**\n * Alternative arrange the two given strings in one string in O(n) time complexity.\n * @param {String} str1 first input string\n * @param {String} str2 second input string\n * @returns `String` return one alternative arrange string.\n */\nconst AlternativeStringArrange = (str1, str2) => {\n  // firstly, check that both inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    return 'Not string(s)'\n  }\n\n  // output string value.\n  let outStr = ''\n\n  // get first string length.\n  const firstStringLength = str1.length\n  // get second string length.\n  const secondStringLength = str2.length\n  // absolute length for operation.\n  const absLength = firstStringLength > secondStringLength ? firstStringLength : secondStringLength\n\n  // Iterate the character count until the absolute count is reached.\n  for (let charCount = 0; charCount < absLength; charCount++) {\n    // If firstStringLength is lesser than the charCount it means they are able to re-arrange.\n    if (charCount < firstStringLength) {\n      outStr += str1[charCount]\n    }\n\n    // If secondStringLength is lesser than the charCount it means they are able to re-arrange.\n    if (charCount < secondStringLength) {\n      outStr += str2[charCount]\n    }\n  }\n\n  // return the output string.\n  return outStr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * Alternatively Merge two Strings in Java - GeeksforGeeks",normalizedContent:"# 介绍\n\n给定两个字符串，以另一种方式合并它们，即最终字符串的第一个字符是第一个字符串的第一个字符，最终字符串的第二个字符是第二个字符串的第一个字符，以此类推。如果你达到了一个字符串的末尾，而另一个字符串还在，那么就把这个字符串的剩余部分追加到最后一个字符串中。\n\n\n# 实现\n\n\n# javascript\n\n// alternative arrange the two given strings in one string in o(n) time complexity.\n\n\n// problem source & explanation: https://www.geeksforgeeks.org/alternatively-merge-two-strings-in-java/\n\n/**\n * alternative arrange the two given strings in one string in o(n) time complexity.\n * @param {string} str1 first input string\n * @param {string} str2 second input string\n * @returns `string` return one alternative arrange string.\n */\nconst alternativestringarrange = (str1, str2) => {\n  // firstly, check that both inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    return 'not string(s)'\n  }\n\n  // output string value.\n  let outstr = ''\n\n  // get first string length.\n  const firststringlength = str1.length\n  // get second string length.\n  const secondstringlength = str2.length\n  // absolute length for operation.\n  const abslength = firststringlength > secondstringlength ? firststringlength : secondstringlength\n\n  // iterate the character count until the absolute count is reached.\n  for (let charcount = 0; charcount < abslength; charcount++) {\n    // if firststringlength is lesser than the charcount it means they are able to re-arrange.\n    if (charcount < firststringlength) {\n      outstr += str1[charcount]\n    }\n\n    // if secondstringlength is lesser than the charcount it means they are able to re-arrange.\n    if (charcount < secondstringlength) {\n      outstr += str2[charcount]\n    }\n  }\n\n  // return the output string.\n  return outstr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 参考\n\n * alternatively merge two strings in java - geeksforgeeks",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"CheckAnagram [易位构词]",frontmatter:{title:"CheckAnagram [易位构词]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/checkAnagram/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/40.CheckAnagram.html",relativePath:"20.算法/80.String 字符串/40.CheckAnagram.md",key:"v-1d2b4432",path:"/algorithm/string/checkAnagram/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:116},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:123},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2885}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n易位构词游戏的英文词汇是 anagram，易位构词是一类文字游戏（更准确地说是一类 “词语游戏”），是将组成一个词或短句的字母重新排列顺序，原文中所有字母的每次出现都被使用一次，这样构造出另外一些新的词或短句。\n\n\n# 实现\n\n\n# JavaScript\n\n// An [Anagram](https://en.wikipedia.org/wiki/Anagram) is a string that is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Anagram check is not case-sensitive;\n/**\n * @function checkAnagramRegex\n * @param {string} str1\n * @param {string} str2\n * @returns {boolean}\n * @description - check anagram with the help of Regex\n * @example - checkAnagramRegex('node', 'deno') => true\n * @example - checkAnagramRegex('Eleven plus two', 'Twelve plus one') => true\n */\nconst checkAnagramRegex = (str1, str2) => {\n  // check that inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    throw new TypeError('Both arguments should be strings.')\n  }\n\n  // If both strings have not same lengths then they can not be anagram.\n  if (str1.length !== str2.length) {\n    return false\n  }\n\n  /**\n   * str1 converted to an array and traverse each letter of str1 by reduce method\n   * reduce method return string which is empty or not.\n   * if it returns empty string '' -> falsy, with Logical !(NOT) Operator, it's will be converted to boolean and return true else false\n   */\n  return ![...str1].reduce(\n    (str2Acc, cur) => str2Acc.replace(new RegExp(cur, 'i'), ''), // remove the similar letter from str2Acc in case-insensitive\n    str2\n  )\n}\n\n/**\n * @function checkAnagramMap\n * @description - check anagram via using HashMap\n * @param {string} str1\n * @param {string} str2\n * @returns {boolean}\n * @example - checkAnagramMap('node', 'deno') => true\n * @example - checkAnagramMap('Eleven plus two', 'Twelve plus one') => true\n */\nconst checkAnagramMap = (str1, str2) => {\n  // check that inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    throw new TypeError('Both arguments should be strings.')\n  }\n\n  // If both strings have not same lengths then they can not be anagram.\n  if (str1.length !== str2.length) {\n    return false\n  }\n\n  const str1List = Array.from(str1.toUpperCase()) // str1 to array\n\n  // get the occurrences of str1 characters by using HashMap\n  const str1Occurs = str1List.reduce(\n    (map, char) => map.set(char, map.get(char) + 1 || 1),\n    new Map()\n  )\n\n  for (const char of str2.toUpperCase()) {\n    // if char has not exist to the map it's return false\n    if (!str1Occurs.has(char)) {\n      return false\n    }\n\n    let getCharCount = str1Occurs.get(char)\n    str1Occurs.set(char, --getCharCount)\n\n    getCharCount === 0 && str1Occurs.delete(char)\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 参考\n\n * Anagram - Wikiwand\n * 易位构词游戏 - Wikiwand",normalizedContent:"# 介绍\n\n易位构词游戏的英文词汇是 anagram，易位构词是一类文字游戏（更准确地说是一类 “词语游戏”），是将组成一个词或短句的字母重新排列顺序，原文中所有字母的每次出现都被使用一次，这样构造出另外一些新的词或短句。\n\n\n# 实现\n\n\n# javascript\n\n// an [anagram](https://en.wikipedia.org/wiki/anagram) is a string that is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. anagram check is not case-sensitive;\n/**\n * @function checkanagramregex\n * @param {string} str1\n * @param {string} str2\n * @returns {boolean}\n * @description - check anagram with the help of regex\n * @example - checkanagramregex('node', 'deno') => true\n * @example - checkanagramregex('eleven plus two', 'twelve plus one') => true\n */\nconst checkanagramregex = (str1, str2) => {\n  // check that inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    throw new typeerror('both arguments should be strings.')\n  }\n\n  // if both strings have not same lengths then they can not be anagram.\n  if (str1.length !== str2.length) {\n    return false\n  }\n\n  /**\n   * str1 converted to an array and traverse each letter of str1 by reduce method\n   * reduce method return string which is empty or not.\n   * if it returns empty string '' -> falsy, with logical !(not) operator, it's will be converted to boolean and return true else false\n   */\n  return ![...str1].reduce(\n    (str2acc, cur) => str2acc.replace(new regexp(cur, 'i'), ''), // remove the similar letter from str2acc in case-insensitive\n    str2\n  )\n}\n\n/**\n * @function checkanagrammap\n * @description - check anagram via using hashmap\n * @param {string} str1\n * @param {string} str2\n * @returns {boolean}\n * @example - checkanagrammap('node', 'deno') => true\n * @example - checkanagrammap('eleven plus two', 'twelve plus one') => true\n */\nconst checkanagrammap = (str1, str2) => {\n  // check that inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    throw new typeerror('both arguments should be strings.')\n  }\n\n  // if both strings have not same lengths then they can not be anagram.\n  if (str1.length !== str2.length) {\n    return false\n  }\n\n  const str1list = array.from(str1.touppercase()) // str1 to array\n\n  // get the occurrences of str1 characters by using hashmap\n  const str1occurs = str1list.reduce(\n    (map, char) => map.set(char, map.get(char) + 1 || 1),\n    new map()\n  )\n\n  for (const char of str2.touppercase()) {\n    // if char has not exist to the map it's return false\n    if (!str1occurs.has(char)) {\n      return false\n    }\n\n    let getcharcount = str1occurs.get(char)\n    str1occurs.set(char, --getcharcount)\n\n    getcharcount === 0 && str1occurs.delete(char)\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 参考\n\n * anagram - wikiwand\n * 易位构词游戏 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"NamingConvention [命名规则]",frontmatter:{title:"NamingConvention [命名规则]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/namingConvention/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/50.NamingConvention.html",relativePath:"20.算法/80.String 字符串/50.NamingConvention.md",key:"v-893b45f2",path:"/algorithm/string/namingConvention/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"camelCase",slug:"camelcase",normalizedTitle:"camelcase",charIndex:165},{level:2,title:"flatcase",slug:"flatcase",normalizedTitle:"flatcase",charIndex:1019},{level:2,title:"kebab-case",slug:"kebab-case",normalizedTitle:"kebab-case",charIndex:1971},{level:2,title:"snake_case",slug:"snake-case",normalizedTitle:"snake_case",charIndex:1302},{level:2,title:"PascalCase",slug:"pascalcase",normalizedTitle:"pascalcase",charIndex:3485},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4222}],headersStr:"介绍 camelCase flatcase kebab-case snake_case PascalCase 参考",content:"# 介绍\n\n程序设计的中命名规则（naming convention）是电脑程序设计的源代码针对标识符的名称字符串进行定义（即 “命名”）而规定的一系列规则。通常是为了提高源代码的易读性、易认性、程序效率以及可维护性。命名规则根据各个程序语言的规格、内存大小等硬件制约、编辑器以及集成开发环境的功能等等会有各种制约。\n\n\n\n\n# camelCase\n\n检查是否是驼峰写法。驼峰式大小写（Camel-Case，Camel Case，camel case），计算机程序编写时的一套命名规则（惯例）。当变量名和函数名称是由二个或多个单字连结在一起，而构成的唯一识别字时，利用 “驼峰式大小写” 来表示，可以增加变数和函式的可读性。\n\n检查 camelCase：\n\n// CheckCamelCase method checks the given string is in camelCase or not.\n\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Camel_case\n\n/**\n * checkCamelCase method returns true if the string in camelCase, else return the false.\n * @param {String} varName the name of the variable to check.\n * @returns `Boolean` return true if the string is in camelCase, else return false.\n */\nconst checkCamelCase = (varName) => {\n  // firstly, check that input is a string or not.\n  if (typeof varName !== 'string') {\n    throw new TypeError('Argument is not a string.')\n  }\n\n  const pat = /^[a-z][A-Za-z]*$/\n  return pat.test(varName)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# flatcase\n\n检查 flatcase：\n\n// checkFlatCase method checks if the given string is in flatcase or not. Flatcase is a convention\n// where all letters are in lowercase, and there are no spaces between words.\n// thisvariable is an example of flatcase. In camelCase it would be thisVariable, snake_case this_variable and so on.\n\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)\n\n/**\n * checkFlatCase method returns true if the string in flatcase, else return the false.\n * @param {string} varname the name of the variable to check.\n * @returns {boolean} return true if the string is in flatcase, else return false.\n */\nconst checkFlatCase = (varname) => {\n  // firstly, check that input is a string or not.\n  if (typeof varname !== 'string') {\n    return new TypeError('Argument is not a string.')\n  }\n\n  const pat = /^[a-z]*$/\n  return pat.test(varname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# kebab-case\n\n检查 kebab-case：\n\n// CheckKebabCase method checks the given string is in kebab-case or not.\n\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)\n\n/**\n * CheckKebabCase method returns true if the string in kebab-case, else return the false.\n * @param {String} varName the name of the variable to check.\n * @returns `Boolean` return true if the string is in kebab-case, else return false.\n */\nconst CheckKebabCase = (varName) => {\n  // firstly, check that input is a string or not.\n  if (typeof varName !== 'string') {\n    return new TypeError('Argument is not a string.')\n  }\n\n  const pat = /(\\w+)-(\\w)([\\w-]*)/\n  return pat.test(varName) && !varName.includes('_')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# snake_case\n\n检查 snake_case：\n\n// CheckSnakeCase method checks the given string is in snake_case or not.\n\n// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)\n\n/**\n * checkSnakeCase method returns true if the string in snake_case, else return the false.\n * @param {String} varName the name of the variable to check.\n * @returns `Boolean` return true if the string is in snake_case, else return false.\n */\nconst checkSnakeCase = (varName) => {\n  // firstly, check that input is a string or not.\n  if (typeof varName !== 'string') {\n    throw new TypeError('Argument is not a string.')\n  }\n\n  const pat = /(.*?)_([a-zA-Z])*/\n  return pat.test(varName)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# PascalCase\n\n检查 PascalCase：\n\n// CheckPascalCase method checks the given string is in PascalCase or not.\n\n// Problem Source & Explanation: https://www.theserverside.com/definition/Pascal-case\n\n/**\n * CheckPascalCase method returns true if the string in PascalCase, else return the false.\n * @param {String} VarName the name of the variable to check.\n * @returns `Boolean` return true if the string is in PascalCase, else return false.\n */\nconst CheckPascalCase = (VarName) => {\n  // firstly, check that input is a string or not.\n  if (typeof VarName !== 'string') {\n    return new TypeError('Argument is not a string.')\n  }\n\n  const pat = /^[A-Z][A-Za-z]*$/\n  return pat.test(VarName)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参考\n\n * 驼峰式大小写 - Wikiwand\n * Naming convention (programming) - Wikiwand\n * 命名规则 (程序设计) - Wikiwand",normalizedContent:"# 介绍\n\n程序设计的中命名规则（naming convention）是电脑程序设计的源代码针对标识符的名称字符串进行定义（即 “命名”）而规定的一系列规则。通常是为了提高源代码的易读性、易认性、程序效率以及可维护性。命名规则根据各个程序语言的规格、内存大小等硬件制约、编辑器以及集成开发环境的功能等等会有各种制约。\n\n\n\n\n# camelcase\n\n检查是否是驼峰写法。驼峰式大小写（camel-case，camel case，camel case），计算机程序编写时的一套命名规则（惯例）。当变量名和函数名称是由二个或多个单字连结在一起，而构成的唯一识别字时，利用 “驼峰式大小写” 来表示，可以增加变数和函式的可读性。\n\n检查 camelcase：\n\n// checkcamelcase method checks the given string is in camelcase or not.\n\n// problem source & explanation: https://en.wikipedia.org/wiki/camel_case\n\n/**\n * checkcamelcase method returns true if the string in camelcase, else return the false.\n * @param {string} varname the name of the variable to check.\n * @returns `boolean` return true if the string is in camelcase, else return false.\n */\nconst checkcamelcase = (varname) => {\n  // firstly, check that input is a string or not.\n  if (typeof varname !== 'string') {\n    throw new typeerror('argument is not a string.')\n  }\n\n  const pat = /^[a-z][a-za-z]*$/\n  return pat.test(varname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# flatcase\n\n检查 flatcase：\n\n// checkflatcase method checks if the given string is in flatcase or not. flatcase is a convention\n// where all letters are in lowercase, and there are no spaces between words.\n// thisvariable is an example of flatcase. in camelcase it would be thisvariable, snake_case this_variable and so on.\n\n// problem source & explanation: https://en.wikipedia.org/wiki/naming_convention_(programming)\n\n/**\n * checkflatcase method returns true if the string in flatcase, else return the false.\n * @param {string} varname the name of the variable to check.\n * @returns {boolean} return true if the string is in flatcase, else return false.\n */\nconst checkflatcase = (varname) => {\n  // firstly, check that input is a string or not.\n  if (typeof varname !== 'string') {\n    return new typeerror('argument is not a string.')\n  }\n\n  const pat = /^[a-z]*$/\n  return pat.test(varname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# kebab-case\n\n检查 kebab-case：\n\n// checkkebabcase method checks the given string is in kebab-case or not.\n\n// problem source & explanation: https://en.wikipedia.org/wiki/naming_convention_(programming)\n\n/**\n * checkkebabcase method returns true if the string in kebab-case, else return the false.\n * @param {string} varname the name of the variable to check.\n * @returns `boolean` return true if the string is in kebab-case, else return false.\n */\nconst checkkebabcase = (varname) => {\n  // firstly, check that input is a string or not.\n  if (typeof varname !== 'string') {\n    return new typeerror('argument is not a string.')\n  }\n\n  const pat = /(\\w+)-(\\w)([\\w-]*)/\n  return pat.test(varname) && !varname.includes('_')\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# snake_case\n\n检查 snake_case：\n\n// checksnakecase method checks the given string is in snake_case or not.\n\n// problem source & explanation: https://en.wikipedia.org/wiki/naming_convention_(programming)\n\n/**\n * checksnakecase method returns true if the string in snake_case, else return the false.\n * @param {string} varname the name of the variable to check.\n * @returns `boolean` return true if the string is in snake_case, else return false.\n */\nconst checksnakecase = (varname) => {\n  // firstly, check that input is a string or not.\n  if (typeof varname !== 'string') {\n    throw new typeerror('argument is not a string.')\n  }\n\n  const pat = /(.*?)_([a-za-z])*/\n  return pat.test(varname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# pascalcase\n\n检查 pascalcase：\n\n// checkpascalcase method checks the given string is in pascalcase or not.\n\n// problem source & explanation: https://www.theserverside.com/definition/pascal-case\n\n/**\n * checkpascalcase method returns true if the string in pascalcase, else return the false.\n * @param {string} varname the name of the variable to check.\n * @returns `boolean` return true if the string is in pascalcase, else return false.\n */\nconst checkpascalcase = (varname) => {\n  // firstly, check that input is a string or not.\n  if (typeof varname !== 'string') {\n    return new typeerror('argument is not a string.')\n  }\n\n  const pat = /^[a-z][a-za-z]*$/\n  return pat.test(varname)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参考\n\n * 驼峰式大小写 - wikiwand\n * naming convention (programming) - wikiwand\n * 命名规则 (程序设计) - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"CheckExceeding [Exceeding words]",frontmatter:{title:"CheckExceeding [Exceeding words]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/checkExceeding/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/60.CheckExceeding.html",relativePath:"20.算法/80.String 字符串/60.CheckExceeding.md",key:"v-4d5125c7",path:"/algorithm/string/checkExceeding/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:63},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:70}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\nExceeding words 是指相邻两个字符之间的差距在增加的词，差距是指以 ascii 码值的差。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function checkExceeding\n * @description - Exceeding words are words where the gap between two adjacent characters is increasing. The gap is the distance in ascii\n * @param {string} str\n * @returns {boolean}\n * @example - checkExceeding('delete') => true, ascii difference - [1, 7, 7, 15, 15] which is incremental\n * @example - checkExceeding('update') => false, ascii difference - [5, 12, 3, 19, 15] which is not incremental\n */\nconst checkExceeding = (str) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('Argument is not a string')\n  }\n\n  const upperChars = str\n    .toUpperCase()\n    .replace(/[^A-Z]/g, '') // remove all from str except A to Z alphabets\n\n  const adjacentDiffList = []\n\n  for (let i = 0; i < upperChars.length - 1; i++) {\n    // destructuring current char & adjacent char by index, cause in javascript String is an object.\n    const { [i]: char, [i + 1]: adjacentChar } = upperChars\n\n    if (char !== adjacentChar) {\n      adjacentDiffList.push(\n        Math.abs(char.charCodeAt() - adjacentChar.charCodeAt())\n      )\n    }\n  }\n\n  for (let i = 0; i < adjacentDiffList.length - 1; i++) {\n    const { [i]: charDiff, [i + 1]: secondCharDiff } = adjacentDiffList\n\n    if (charDiff > secondCharDiff) {\n      return false\n    }\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",normalizedContent:"# 介绍\n\nexceeding words 是指相邻两个字符之间的差距在增加的词，差距是指以 ascii 码值的差。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function checkexceeding\n * @description - exceeding words are words where the gap between two adjacent characters is increasing. the gap is the distance in ascii\n * @param {string} str\n * @returns {boolean}\n * @example - checkexceeding('delete') => true, ascii difference - [1, 7, 7, 15, 15] which is incremental\n * @example - checkexceeding('update') => false, ascii difference - [5, 12, 3, 19, 15] which is not incremental\n */\nconst checkexceeding = (str) => {\n  if (typeof str !== 'string') {\n    throw new typeerror('argument is not a string')\n  }\n\n  const upperchars = str\n    .touppercase()\n    .replace(/[^a-z]/g, '') // remove all from str except a to z alphabets\n\n  const adjacentdifflist = []\n\n  for (let i = 0; i < upperchars.length - 1; i++) {\n    // destructuring current char & adjacent char by index, cause in javascript string is an object.\n    const { [i]: char, [i + 1]: adjacentchar } = upperchars\n\n    if (char !== adjacentchar) {\n      adjacentdifflist.push(\n        math.abs(char.charcodeat() - adjacentchar.charcodeat())\n      )\n    }\n  }\n\n  for (let i = 0; i < adjacentdifflist.length - 1; i++) {\n    const { [i]: chardiff, [i + 1]: secondchardiff } = adjacentdifflist\n\n    if (chardiff > secondchardiff) {\n      return false\n    }\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"CheckPangram [全字母句]",frontmatter:{title:"CheckPangram [全字母句]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/checkPangram/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/70.CheckPangram.html",relativePath:"20.算法/80.String 字符串/70.CheckPangram.md",key:"v-e1939732",path:"/algorithm/string/checkPangram/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:332},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:339},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2775}],headersStr:"介绍 实现 JavaScript 参考",content:"# 介绍\n\n包含有字母表中所有字母并且言之成义的句子称为全字母句（英语：pangram 或 holoalphabetic sentence，希腊语：pan gramma（意为 “每一个字母”））。全字母句被用于显示字体和测试打字机。英语中最知名的全字母句是 “The quick brown fox jumps over the lazy dog（敏捷的棕色狐狸跳跃过懒惰狗）”。\n\n一般，有趣的全字母句都很短；写出一个包含有最少重复字母的全字母句是一件富有挑战性的工作。长的全字母句在正确的前提下，显著地富有启迪性，或是很幽默，或是很古怪。从某种意义上，全字母句是漏字文（英语：Lipogram）的对立物，因为后者在文章中有意不使用一个或几个特定字母。\n\n\n# 实现\n\n\n# JavaScript\n\n检查是否是回文串：\n\n/**\n * What is Pangram?\n * Pangram is a sentence that contains all the letters in the alphabet https://en.wikipedia.org/wiki/Pangram\n */\n\n/**\n * @function checkPangramRegex\n * @description - This function check pangram with the help of regex pattern\n * @param {string} string\n * @returns {boolean}\n * @example - checkPangramRegex(\"'The quick brown fox jumps over the lazy dog' is a pangram\") => true\n * @example - checkPangramRegex('\"Waltz, bad nymph, for quick jigs vex.\" is a pangram') => true\n */\nconst checkPangramRegex = (string) => {\n  if (typeof string !== 'string') {\n    throw new TypeError('The given value is not a string')\n  }\n\n  /**\n   * Match all 26 alphabets using regex, with the help of:\n   * Capturing group - () -> Groups multiple tokens together and creates a capture group for extracting a substring or using a backreference.\n   * Character set - [a-z] -> Matches a char in the range a to z in case-insensitive for the 'i' flag\n   * Negative lookahead - (?!) -> Specifies a group that can not match after the main expression (if it matches, the result is discarded).\n   * Dot - . -> Matches any character except linebreaks. Equivalent to\n   * Star - * -> Matches 0 or more of the preceding token.\n   * Numeric reference - \\{$n} -> Matches the results of a capture group. E.g. - \\1  matches the results of the first capture group & \\3 matches the third.\n */\n  return string.match(/([a-z])(?!.*\\1)/gi).length === 26\n}\n\n/**\n * @function checkPangramSet\n * @description - This function detect the pangram sentence by HashSet\n * @param {string} string\n * @returns {boolean}\n */\nconst checkPangramSet = (string) => {\n  if (typeof string !== 'string') {\n    throw new TypeError('The given value is not a string')\n  }\n\n  const lettersSet = new Set()\n\n  for (const letter of string.toUpperCase()) {\n    if (/[A-Z]/.test(letter)) {\n      // if the letter is a valid uppercase alphabet then the add method insert the letter to the HashSet\n      lettersSet.add(letter)\n    }\n  }\n\n  return lettersSet.size === 26\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n * (?!pattern) ：正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如 “Windows (?!95|98|NT|2000)\" 能 匹配 “Windows 3.1” 中的 “windows”, 但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。参考：正则表达式大全 - 夏夜・梦无眠\n * Backreferences match the same text as previously matched by a capturing group. The backreference \\1 (backslash one) references the first capturing group. 参见：Regex Tutorial - Backreferences To Match The Same Text Again\n\n检查是否可以调整为回文串：\n\n/**\n  * What is a palindrome? https://en.wikipedia.org/wiki/Palindrome\n  * Receives a string and returns whether it can be rearranged to become a palindrome or not\n  * The string can only be a palindrome if the count of ALL characters is even or if the ONLY ONE character count is odd\n  * Input is a string\n  *\n  **/\n\nexport const palindromeRearranging = (str) => {\n  // check that input is a string\n  if (typeof str !== 'string') {\n    return 'Not a string'\n  }\n  // Check if is a empty string\n  if (str.length === 0) {\n    return 'Empty string'\n  }\n\n  // First obtain the character count for each character in the string and store it in an object.\n  // Filter the object's values to only the odd character counts.\n  const charCounts = [...str].reduce((counts, char) => {\n    counts[char] = counts[char] ? counts[char] + 1 : 1\n    return counts\n  }, {})\n  // If the length of the resulting array is 0 or 1, the string can be a palindrome.\n  return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 参考\n\n * Pangram - Wikiwand\n * 全字母句 - Wikiwand",normalizedContent:"# 介绍\n\n包含有字母表中所有字母并且言之成义的句子称为全字母句（英语：pangram 或 holoalphabetic sentence，希腊语：pan gramma（意为 “每一个字母”））。全字母句被用于显示字体和测试打字机。英语中最知名的全字母句是 “the quick brown fox jumps over the lazy dog（敏捷的棕色狐狸跳跃过懒惰狗）”。\n\n一般，有趣的全字母句都很短；写出一个包含有最少重复字母的全字母句是一件富有挑战性的工作。长的全字母句在正确的前提下，显著地富有启迪性，或是很幽默，或是很古怪。从某种意义上，全字母句是漏字文（英语：lipogram）的对立物，因为后者在文章中有意不使用一个或几个特定字母。\n\n\n# 实现\n\n\n# javascript\n\n检查是否是回文串：\n\n/**\n * what is pangram?\n * pangram is a sentence that contains all the letters in the alphabet https://en.wikipedia.org/wiki/pangram\n */\n\n/**\n * @function checkpangramregex\n * @description - this function check pangram with the help of regex pattern\n * @param {string} string\n * @returns {boolean}\n * @example - checkpangramregex(\"'the quick brown fox jumps over the lazy dog' is a pangram\") => true\n * @example - checkpangramregex('\"waltz, bad nymph, for quick jigs vex.\" is a pangram') => true\n */\nconst checkpangramregex = (string) => {\n  if (typeof string !== 'string') {\n    throw new typeerror('the given value is not a string')\n  }\n\n  /**\n   * match all 26 alphabets using regex, with the help of:\n   * capturing group - () -> groups multiple tokens together and creates a capture group for extracting a substring or using a backreference.\n   * character set - [a-z] -> matches a char in the range a to z in case-insensitive for the 'i' flag\n   * negative lookahead - (?!) -> specifies a group that can not match after the main expression (if it matches, the result is discarded).\n   * dot - . -> matches any character except linebreaks. equivalent to\n   * star - * -> matches 0 or more of the preceding token.\n   * numeric reference - \\{$n} -> matches the results of a capture group. e.g. - \\1  matches the results of the first capture group & \\3 matches the third.\n */\n  return string.match(/([a-z])(?!.*\\1)/gi).length === 26\n}\n\n/**\n * @function checkpangramset\n * @description - this function detect the pangram sentence by hashset\n * @param {string} string\n * @returns {boolean}\n */\nconst checkpangramset = (string) => {\n  if (typeof string !== 'string') {\n    throw new typeerror('the given value is not a string')\n  }\n\n  const lettersset = new set()\n\n  for (const letter of string.touppercase()) {\n    if (/[a-z]/.test(letter)) {\n      // if the letter is a valid uppercase alphabet then the add method insert the letter to the hashset\n      lettersset.add(letter)\n    }\n  }\n\n  return lettersset.size === 26\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n * (?!pattern) ：正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如 “windows (?!95|98|nt|2000)\" 能 匹配 “windows 3.1” 中的 “windows”, 但不能匹配 “windows 2000” 中的 “windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。参考：正则表达式大全 - 夏夜・梦无眠\n * backreferences match the same text as previously matched by a capturing group. the backreference \\1 (backslash one) references the first capturing group. 参见：regex tutorial - backreferences to match the same text again\n\n检查是否可以调整为回文串：\n\n/**\n  * what is a palindrome? https://en.wikipedia.org/wiki/palindrome\n  * receives a string and returns whether it can be rearranged to become a palindrome or not\n  * the string can only be a palindrome if the count of all characters is even or if the only one character count is odd\n  * input is a string\n  *\n  **/\n\nexport const palindromerearranging = (str) => {\n  // check that input is a string\n  if (typeof str !== 'string') {\n    return 'not a string'\n  }\n  // check if is a empty string\n  if (str.length === 0) {\n    return 'empty string'\n  }\n\n  // first obtain the character count for each character in the string and store it in an object.\n  // filter the object's values to only the odd character counts.\n  const charcounts = [...str].reduce((counts, char) => {\n    counts[char] = counts[char] ? counts[char] + 1 : 1\n    return counts\n  }, {})\n  // if the length of the resulting array is 0 or 1, the string can be a palindrome.\n  return object.values(charcounts).filter(count => count % 2 !== 0).length <= 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 参考\n\n * pangram - wikiwand\n * 全字母句 - wikiwand",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"CheckWordOccurrence [单词计数]",frontmatter:{title:"CheckWordOccurrence [单词计数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/checkWordOccurrence/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/80.CheckWordOccurrence.html",relativePath:"20.算法/80.String 字符串/80.CheckWordOccurrence.md",key:"v-2873fe66",path:"/algorithm/string/checkWordOccurrence/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:35},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:42}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n计算一个句子中的所有单词，并返回一个单词计数表。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function checkWordOccurrence\n * @description - this function count all the words in a sentence and return an word occurrence object\n * @param {string} str\n * @param {boolean} isCaseSensitive\n * @returns {Object}\n */\nconst checkWordOccurrence = (str, isCaseSensitive = false) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('The first param should be a string')\n  }\n\n  if (typeof isCaseSensitive !== 'boolean') {\n    throw new TypeError('The second param should be a boolean')\n  }\n\n  const modifiedStr = isCaseSensitive ? str.toLowerCase() : str\n\n  return modifiedStr\n    .split(/\\s+/) // remove all spaces and distribute all word in List\n    .reduce(\n      (occurrence, word) => {\n        occurrence[word] = occurrence[word] + 1 || 1\n        return occurrence\n      },\n      {}\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# 介绍\n\n计算一个句子中的所有单词，并返回一个单词计数表。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function checkwordoccurrence\n * @description - this function count all the words in a sentence and return an word occurrence object\n * @param {string} str\n * @param {boolean} iscasesensitive\n * @returns {object}\n */\nconst checkwordoccurrence = (str, iscasesensitive = false) => {\n  if (typeof str !== 'string') {\n    throw new typeerror('the first param should be a string')\n  }\n\n  if (typeof iscasesensitive !== 'boolean') {\n    throw new typeerror('the second param should be a boolean')\n  }\n\n  const modifiedstr = iscasesensitive ? str.tolowercase() : str\n\n  return modifiedstr\n    .split(/\\s+/) // remove all spaces and distribute all word in list\n    .reduce(\n      (occurrence, word) => {\n        occurrence[word] = occurrence[word] + 1 || 1\n        return occurrence\n      },\n      {}\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"CountVowels [元音字母计数]",frontmatter:{title:"CountVowels [元音字母计数]",date:"2022-09-26T10:05:25.000Z",permalink:"/algorithm/string/countVowels/",categories:["算法","String 字符串"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/80.String%20%E5%AD%97%E7%AC%A6%E4%B8%B2/90.CountVowels.html",relativePath:"20.算法/80.String 字符串/90.CountVowels.md",key:"v-12feff1b",path:"/algorithm/string/countVowels/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:31},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:38}],headersStr:"介绍 实现 JavaScript",content:'# 介绍\n\n给定一串单词或短语，计算元音字母的数量。\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n * @function countVowels\n * @description Given a string of words or phrases, count the number of vowels（元音）.\n * @param {String} str - The input string\n * @return {Number} - The number of vowels\n * @example countVowels("ABCDE") => 2\n * @example countVowels("Hello") => 2\n */\n\nconst countVowels = (str) => {\n if (typeof str !== "string") {\n  throw new TypeError("Input should be a string");\n }\n\n const vowelRegex = /[aeiou]/gi;\n const vowelsArray = str.match(vowelRegex) || [];\n\n return vowelsArray.length;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',normalizedContent:'# 介绍\n\n给定一串单词或短语，计算元音字母的数量。\n\n\n# 实现\n\n\n# javascript\n\n/**\n * @function countvowels\n * @description given a string of words or phrases, count the number of vowels（元音）.\n * @param {string} str - the input string\n * @return {number} - the number of vowels\n * @example countvowels("abcde") => 2\n * @example countvowels("hello") => 2\n */\n\nconst countvowels = (str) => {\n if (typeof str !== "string") {\n  throw new typeerror("input should be a string");\n }\n\n const vowelregex = /[aeiou]/gi;\n const vowelsarray = str.match(vowelregex) || [];\n\n return vowelsarray.length;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',charsets:{cjk:!0},lastUpdated:"2022/10/20, 20:03:22",lastUpdatedTimestamp:1666267402e3},{title:"BinaryCountSetBits [二进制串数1]",frontmatter:{title:"BinaryCountSetBits [二进制串数1]",date:"2022-05-01T20:10:58.000Z",permalink:"/algorithm/bit/binaryCountSetBits/",categories:["算法","Bit-Manipulation 位操纵"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/90.BitManipulation%20%E4%BD%8D%E6%93%8D%E7%BA%B5/10.BinaryCountSetBits.html",relativePath:"20.算法/90.BitManipulation 位操纵/10.BinaryCountSetBits.md",key:"v-67591296",path:"/algorithm/bit/binaryCountSetBits/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:29},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:36}],headersStr:"介绍 实现 JavaScript",content:"# 介绍\n\n计算数字的二进制表示中 1 的个数。\n\n\n# 实现\n\n\n# JavaScript\n\n/* This script will find number of 1's in binary representation of given number */\nfunction BinaryCountSetBits (a) {\n  // convert number into binary representation and return number of set bits in binary representation\n  return a.toString(2).split('1').length - 1\n}\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 介绍\n\n计算数字的二进制表示中 1 的个数。\n\n\n# 实现\n\n\n# javascript\n\n/* this script will find number of 1's in binary representation of given number */\nfunction binarycountsetbits (a) {\n  // convert number into binary representation and return number of set bits in binary representation\n  return a.tostring(2).split('1').length - 1\n}\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/10/20, 21:49:42",lastUpdatedTimestamp:1666273782e3},{title:"PowerOfTwo [2的幂]",frontmatter:{title:"PowerOfTwo [2的幂]",date:"2022-05-01T20:10:58.000Z",permalink:"/algorithm/bit/powerOfTwo/",categories:["算法","Bit-Manipulation 位操纵"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/90.BitManipulation%20%E4%BD%8D%E6%93%8D%E7%BA%B5/20.PowerOfTwo.html",relativePath:"20.算法/90.BitManipulation 位操纵/20.PowerOfTwo.md",key:"v-0eb091a8",path:"/algorithm/bit/powerOfTwo/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:103},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:110},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:1178}],headersStr:"介绍 实现 JavaScript 扩展",content:"# 介绍\n\n如果只有一个 bit 被设置，其余的都没有被设置，那么一个数字将是 2 的幂。如果 n 是 2 的幂，难么 n-1 将会对 n 的所有 bit 进行取反，即 n&(n-1) = 0 。\n\n\n# 实现\n\n\n# JavaScript\n\n/*\n    author: @Aayushi-Mittal\n\n    This script will check whether the given\n    number is a power of two or not.\n\n    A number will be a power of two if only one bit is set and rest are unset.\n    This is true for all the cases except 01 because (2^0 = 1) which is not a power of 2.\n    For eg: 10 (2^1 = 2), 100 (2^2 = 4), 10000 (2^4 = 16)\n\n    Reference Link: https://www.hackerearth.com/practice/notes/round-a-number-to-the-next-power-of-2/\n\n    If we will subtract 1 from a number that is a power of 2 we will get it's 1's complement.\n    And we know that 1's complement is just opp. of that number.\n    So, (n & (n-1)) will be 0.\n\n    For eg:    (1000 & (1000-1))\n                1 0 0 0     // Original Number (8)\n                0 1 1 1     // After Subtracting 1 (8-1 = 7)\n                _______\n                0 0 0 0     // will become 0\n\n*/\n\nexport const IsPowerOfTwo = (n) => {\n  if (n > 0 && (n & (n - 1)) === 0) {\n    return true\n  }\n  return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 扩展\n\n找到下一个大于 n 的 2 的幂。\n\n/**\n *\n *  This script will find next power of two\n *    of given number.\n *  More about it:\n *   https://www.techiedelight.com/round-next-highest-power-2/\n *\n */\nconst nextPowerOfTwo = (n) => {\n  if (n > 0 && (n & (n - 1)) === 0) return n\n  let result = 1\n  while (n > 0) {\n    result = result << 1\n    n = n >> 1\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"# 介绍\n\n如果只有一个 bit 被设置，其余的都没有被设置，那么一个数字将是 2 的幂。如果 n 是 2 的幂，难么 n-1 将会对 n 的所有 bit 进行取反，即 n&(n-1) = 0 。\n\n\n# 实现\n\n\n# javascript\n\n/*\n    author: @aayushi-mittal\n\n    this script will check whether the given\n    number is a power of two or not.\n\n    a number will be a power of two if only one bit is set and rest are unset.\n    this is true for all the cases except 01 because (2^0 = 1) which is not a power of 2.\n    for eg: 10 (2^1 = 2), 100 (2^2 = 4), 10000 (2^4 = 16)\n\n    reference link: https://www.hackerearth.com/practice/notes/round-a-number-to-the-next-power-of-2/\n\n    if we will subtract 1 from a number that is a power of 2 we will get it's 1's complement.\n    and we know that 1's complement is just opp. of that number.\n    so, (n & (n-1)) will be 0.\n\n    for eg:    (1000 & (1000-1))\n                1 0 0 0     // original number (8)\n                0 1 1 1     // after subtracting 1 (8-1 = 7)\n                _______\n                0 0 0 0     // will become 0\n\n*/\n\nexport const ispoweroftwo = (n) => {\n  if (n > 0 && (n & (n - 1)) === 0) {\n    return true\n  }\n  return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 扩展\n\n找到下一个大于 n 的 2 的幂。\n\n/**\n *\n *  this script will find next power of two\n *    of given number.\n *  more about it:\n *   https://www.techiedelight.com/round-next-highest-power-2/\n *\n */\nconst nextpoweroftwo = (n) => {\n  if (n > 0 && (n & (n - 1)) === 0) return n\n  let result = 1\n  while (n > 0) {\n    result = result << 1\n    n = n >> 1\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2022/10/20, 21:51:45",lastUpdatedTimestamp:1666273905e3},{title:"SetBit [位操作]",frontmatter:{title:"SetBit [位操作]",date:"2022-05-01T20:10:58.000Z",permalink:"/algorithm/bit/setBit/",categories:["算法","Bit-Manipulation 位操纵"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/90.BitManipulation%20%E4%BD%8D%E6%93%8D%E7%BA%B5/30.SetBit.html",relativePath:"20.算法/90.BitManipulation 位操纵/30.SetBit.md",key:"v-4fe20720",path:"/algorithm/bit/setBit/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"位运算",slug:"位运算",normalizedTitle:"位运算",charIndex:130},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:572},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:579},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:1571},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2206}],headersStr:"介绍 位运算 实现 JavaScript 扩展 参考",content:"# 介绍\n\n什么是 set bit？一个数字的二进制表示由 0 和 1 组成，这里，1 被称为 set bit。\n\n什么是 mask bit？mask 定义了你想保留哪些位，以及你想清除哪些位。所以，masking 是对一个值应用 masK 的行为。\n\n\n# 位运算\n\n * 与 & ：两位同时为 “1”，结果才为 “1”，否则为 0。\n * 或 | ：两位其中一个为 “1”，结果为 “1”，否则为 0。\n * 非 ~ ：单目运算符。\n\n无符号整数：\n  二进制原码：0000 0000 0000 0000 0000 0000 0000 0101\n  取反操作后：1111 1111 1111 1111 1111 1111 1111 1010\n有符号整数都是用补码来表示，而补码=反码+1。\n  先求反码：1000 0000 0000 0000 0000 0000 0000 0101\n  再求补码：1000 0000 0000 0000 0000 0000 0000 0110\n  最高位代表符号位 1 表示负数，0 表示正数。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 异或 ^ ：两位不同，结果为 “1”，否则为 0。\n * 左移位 << ：将数值向左移动 1 位，用 0 补足。\n * 右移位 >> ：将数值向右移动 1 位。\n\n\n# 实现\n\n\n# JavaScript\n\n给定一个数字 N，任务是置位这个数字 N 的第 K 位。如果第 K 位是 0，则置位为 1，如果是 1 则保持不变。\n\n/*\n * Setting Bit: https://www.geeksforgeeks.org/set-k-th-bit-given-number/\n *\n * To set any bit we use bitwise OR (|) operator.\n *\n * Bitwise OR (|) compares the bits of the 32\n * bit binary representations of the number and\n * returns a number after comparing each bit.\n *\n * 0 | 0 -> 0\n * 0 | 1 -> 1\n * 1 | 0 -> 1\n * 1 | 1 -> 1\n *\n * In-order to set kth bit of a number (where k is the position where bit is to be changed)\n * we need to shift 1 k times to its left and then perform bitwise OR operation with the\n * number and result of left shift performed just before.\n *\n * References:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR\n */\n\n/**\n * @param {number} n\n * @param {number} k - zero based.\n * @return {number}\n */\n\nexport const setBit = (n, k) => {\n  return n | (1 << k)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 扩展\n\nclear K-th bit of a number N：\n\n给定一个数字 N，任务是清除这个数字 N 的第 K 位。如果第 K 位是 1，则清除为 0，如果是 0 则保持不变。\n\n// JavaScript program to clear K-th bit of a number N\n \n// Function to clear the kth bit of n\nfunction clearBit(n, k)\n{\n    return (n & (~(1 << (k - 1))));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在一个给定的位置修改一个位：\n\n给定一个数字 n，一个位置 p 和一个二进制值 b，我们需要将 n 中位置 p 的比特改为 b 值。\n\n// Javascript program to modify a bit\n// at position p in n to b.\n// see https://www.geeksforgeeks.org/modify-bit-given-position/\n \n// Returns modified n.\nfunction modifyBit(n, p, b)\n{\n    let mask = 1 << p;\n    return (n & ~mask) |\n           ((b << p) & mask);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 参考\n\n * c++ - How do I set, clear, and toggle a single bit? - Stack Overflow\n * Position of leftmost set bit in given binary string where all 1s appear at end - GeeksforGeeks\n * Find the leftmost and rightmost set bit of a number - Coding Ninjas CodeStudio",normalizedContent:"# 介绍\n\n什么是 set bit？一个数字的二进制表示由 0 和 1 组成，这里，1 被称为 set bit。\n\n什么是 mask bit？mask 定义了你想保留哪些位，以及你想清除哪些位。所以，masking 是对一个值应用 mask 的行为。\n\n\n# 位运算\n\n * 与 & ：两位同时为 “1”，结果才为 “1”，否则为 0。\n * 或 | ：两位其中一个为 “1”，结果为 “1”，否则为 0。\n * 非 ~ ：单目运算符。\n\n无符号整数：\n  二进制原码：0000 0000 0000 0000 0000 0000 0000 0101\n  取反操作后：1111 1111 1111 1111 1111 1111 1111 1010\n有符号整数都是用补码来表示，而补码=反码+1。\n  先求反码：1000 0000 0000 0000 0000 0000 0000 0101\n  再求补码：1000 0000 0000 0000 0000 0000 0000 0110\n  最高位代表符号位 1 表示负数，0 表示正数。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 异或 ^ ：两位不同，结果为 “1”，否则为 0。\n * 左移位 << ：将数值向左移动 1 位，用 0 补足。\n * 右移位 >> ：将数值向右移动 1 位。\n\n\n# 实现\n\n\n# javascript\n\n给定一个数字 n，任务是置位这个数字 n 的第 k 位。如果第 k 位是 0，则置位为 1，如果是 1 则保持不变。\n\n/*\n * setting bit: https://www.geeksforgeeks.org/set-k-th-bit-given-number/\n *\n * to set any bit we use bitwise or (|) operator.\n *\n * bitwise or (|) compares the bits of the 32\n * bit binary representations of the number and\n * returns a number after comparing each bit.\n *\n * 0 | 0 -> 0\n * 0 | 1 -> 1\n * 1 | 0 -> 1\n * 1 | 1 -> 1\n *\n * in-order to set kth bit of a number (where k is the position where bit is to be changed)\n * we need to shift 1 k times to its left and then perform bitwise or operation with the\n * number and result of left shift performed just before.\n *\n * references:\n * https://developer.mozilla.org/en-us/docs/web/javascript/reference/operators/bitwise_or\n */\n\n/**\n * @param {number} n\n * @param {number} k - zero based.\n * @return {number}\n */\n\nexport const setbit = (n, k) => {\n  return n | (1 << k)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 扩展\n\nclear k-th bit of a number n：\n\n给定一个数字 n，任务是清除这个数字 n 的第 k 位。如果第 k 位是 1，则清除为 0，如果是 0 则保持不变。\n\n// javascript program to clear k-th bit of a number n\n \n// function to clear the kth bit of n\nfunction clearbit(n, k)\n{\n    return (n & (~(1 << (k - 1))));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在一个给定的位置修改一个位：\n\n给定一个数字 n，一个位置 p 和一个二进制值 b，我们需要将 n 中位置 p 的比特改为 b 值。\n\n// javascript program to modify a bit\n// at position p in n to b.\n// see https://www.geeksforgeeks.org/modify-bit-given-position/\n \n// returns modified n.\nfunction modifybit(n, p, b)\n{\n    let mask = 1 << p;\n    return (n & ~mask) |\n           ((b << p) & mask);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 参考\n\n * c++ - how do i set, clear, and toggle a single bit? - stack overflow\n * position of leftmost set bit in given binary string where all 1s appear at end - geeksforgeeks\n * find the leftmost and rightmost set bit of a number - coding ninjas codestudio",charsets:{cjk:!0},lastUpdated:"2022/10/22, 22:03:41",lastUpdatedTimestamp:1666447421e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-16T16:43:23.000Z",permalink:"/leetcode/index/",categories:["LeetCode"],tags:[null]},regularPath:"/30.LeetCode/0.index.html",relativePath:"30.LeetCode/0.index.md",key:"v-24ef5527",path:"/leetcode/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/01, 18:11:55",lastUpdatedTimestamp:1667297515e3},{title:"Plan 计划",frontmatter:{title:"Plan 计划",date:"2022-04-16T16:44:07.000Z",permalink:"/leetcode/plan/",categories:["LeetCode"],tags:[null]},regularPath:"/30.LeetCode/1.plan.html",relativePath:"30.LeetCode/1.plan.md",key:"v-5da85e95",path:"/leetcode/plan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 16:50:00",lastUpdatedTimestamp:1650099e6},{title:"本章导读",frontmatter:{title:"本章导读",date:"2022-10-31T17:14:35.000Z",permalink:"/leetcode/problems/index/",categories:["LeetCode","力扣习题集"],tags:[null]},regularPath:"/30.LeetCode/10.%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98%E9%9B%86/0.index.html",relativePath:"30.LeetCode/10.力扣习题集/0.index.md",key:"v-613274e4",path:"/leetcode/problems/index/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:39},{level:2,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:192},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:269},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:362}],headersStr:"简介 说明 目标 Github 参考",content:"# 简介\n\n本章记录了 Leetcode 中的习题的解题思路和代码。\n\n\n# 说明\n\n * 按照题目顺序记录以便于索引，不能保证题目难度是由易到难。\n * 每篇文章记录 20 到题目，以此类推。\n * 解题语言以 JavaScript 为主，不保证 100% Beat。\n * 题目为英文，如果需要查看中文，将 leetcode.com 换成 leetcode.cn 即可。\n\n\n# 目标\n\n * 练习数据结构与算法的经典习题的解题技巧。\n * 实践数据结构部分和算法部分的知识内容。\n * 扩展实际问题的解决思路，为面试铺路。\n\n\n# Github\n\n * jonsam-ng/fancy-dsa-leetcode: Collection of LeetCode questions for Fancy DSA.\n\n\n# 参考\n\n * Problems - LeetCode\n * 题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台",normalizedContent:"# 简介\n\n本章记录了 leetcode 中的习题的解题思路和代码。\n\n\n# 说明\n\n * 按照题目顺序记录以便于索引，不能保证题目难度是由易到难。\n * 每篇文章记录 20 到题目，以此类推。\n * 解题语言以 javascript 为主，不保证 100% beat。\n * 题目为英文，如果需要查看中文，将 leetcode.com 换成 leetcode.cn 即可。\n\n\n# 目标\n\n * 练习数据结构与算法的经典习题的解题技巧。\n * 实践数据结构部分和算法部分的知识内容。\n * 扩展实际问题的解决思路，为面试铺路。\n\n\n# github\n\n * jonsam-ng/fancy-dsa-leetcode: collection of leetcode questions for fancy dsa.\n\n\n# 参考\n\n * problems - leetcode\n * 题库 - 力扣 (leetcode) 全球极客挚爱的技术成长平台",charsets:{cjk:!0},lastUpdated:"2022/11/01, 18:11:55",lastUpdatedTimestamp:1667297515e3},{title:"0-20题解",frontmatter:{title:"0-20题解",date:"2022-10-31T17:16:18.000Z",permalink:"/leetcode/problems/0/",categories:["LeetCode","力扣习题集"],tags:["TO_REVIEW"]},regularPath:"/30.LeetCode/10.%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98%E9%9B%86/10.0-20.html",relativePath:"30.LeetCode/10.力扣习题集/10.0-20.md",key:"v-71af493c",path:"/leetcode/problems/0/",headers:[{level:2,title:"1.Two Sum",slug:"_1-two-sum",normalizedTitle:"1.two sum",charIndex:2},{level:3,title:"Description",slug:"description",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution",normalizedTitle:"solution",charIndex:988},{level:2,title:"2.Add Two Numbers",slug:"_2-add-two-numbers",normalizedTitle:"2.add two numbers",charIndex:1458},{level:3,title:"Description",slug:"description-2",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-2",normalizedTitle:"solution",charIndex:988},{level:2,title:"3. Longest Substring Without Repeating Characters",slug:"_3-longest-substring-without-repeating-characters",normalizedTitle:"3. longest substring without repeating characters",charIndex:3279},{level:3,title:"Description",slug:"description-3",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-3",normalizedTitle:"solution",charIndex:988},{level:2,title:"4. Median of Two Sorted Arrays",slug:"_4-median-of-two-sorted-arrays",normalizedTitle:"4. median of two sorted arrays",charIndex:4608},{level:3,title:"Description",slug:"description-4",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-4",normalizedTitle:"solution",charIndex:988},{level:2,title:"5. Longest Palindromic Substring",slug:"_5-longest-palindromic-substring",normalizedTitle:"5. longest palindromic substring",charIndex:5975},{level:3,title:"Description",slug:"description-5",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-5",normalizedTitle:"solution",charIndex:988},{level:2,title:"6. Zigzag Conversion",slug:"_6-zigzag-conversion",normalizedTitle:"6. zigzag conversion",charIndex:6946},{level:3,title:"Description",slug:"description-6",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-6",normalizedTitle:"solution",charIndex:988},{level:2,title:"7. Reverse Integer",slug:"_7-reverse-integer",normalizedTitle:"7. reverse integer",charIndex:8485},{level:3,title:"Description",slug:"description-7",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-7",normalizedTitle:"solution",charIndex:988},{level:2,title:"8. String to Integer (atoi)",slug:"_8-string-to-integer-atoi",normalizedTitle:"8. string to integer (atoi)",charIndex:9694},{level:3,title:"Description",slug:"description-8",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-8",normalizedTitle:"solution",charIndex:988},{level:2,title:"9. Palindrome Number",slug:"_9-palindrome-number",normalizedTitle:"9. palindrome number",charIndex:13378},{level:3,title:"Description",slug:"description-9",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-9",normalizedTitle:"solution",charIndex:988},{level:2,title:"10. Regular Expression Matching",slug:"_10-regular-expression-matching",normalizedTitle:"10. regular expression matching",charIndex:14306},{level:3,title:"Description",slug:"description-10",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-10",normalizedTitle:"solution",charIndex:988},{level:2,title:"11. Container With Most Water",slug:"_11-container-with-most-water",normalizedTitle:"11. container with most water",charIndex:16178},{level:3,title:"Description",slug:"description-11",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-11",normalizedTitle:"solution",charIndex:988},{level:2,title:"12. Integer to Roman",slug:"_12-integer-to-roman",normalizedTitle:"12. integer to roman",charIndex:17592},{level:3,title:"Description",slug:"description-12",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-12",normalizedTitle:"solution",charIndex:988},{level:2,title:"13. Roman to Integer",slug:"_13-roman-to-integer",normalizedTitle:"13. roman to integer",charIndex:21120},{level:3,title:"Description",slug:"description-13",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-13",normalizedTitle:"solution",charIndex:988},{level:2,title:"14. Longest Common Prefix",slug:"_14-longest-common-prefix",normalizedTitle:"14. longest common prefix",charIndex:23891},{level:3,title:"Description",slug:"description-14",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-14",normalizedTitle:"solution",charIndex:988},{level:2,title:"15. 3Sum",slug:"_15-3sum",normalizedTitle:"15. 3sum",charIndex:25255},{level:3,title:"Description",slug:"description-15",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-15",normalizedTitle:"solution",charIndex:988},{level:2,title:"16. 3Sum Closest",slug:"_16-3sum-closest",normalizedTitle:"16. 3sum closest",charIndex:27393},{level:3,title:"Description",slug:"description-16",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-16",normalizedTitle:"solution",charIndex:988},{level:2,title:"17. Letter Combinations of a Phone Number",slug:"_17-letter-combinations-of-a-phone-number",normalizedTitle:"17. letter combinations of a phone number",charIndex:29099},{level:3,title:"Description",slug:"description-17",normalizedTitle:"description",charIndex:159},{level:3,title:"Solution",slug:"solution-17",normalizedTitle:"solution",charIndex:988}],headersStr:"1.Two Sum Description Solution 2.Add Two Numbers Description Solution 3. Longest Substring Without Repeating Characters Description Solution 4. Median of Two Sorted Arrays Description Solution 5. Longest Palindromic Substring Description Solution 6. Zigzag Conversion Description Solution 7. Reverse Integer Description Solution 8. String to Integer (atoi) Description Solution 9. Palindrome Number Description Solution 10. Regular Expression Matching Description Solution 11. Container With Most Water Description Solution 12. Integer to Roman Description Solution 13. Roman to Integer Description Solution 14. Longest Common Prefix Description Solution 15. 3Sum Description Solution 16. 3Sum Closest Description Solution 17. Letter Combinations of a Phone Number Description Solution",content:'# 1.Two Sum\n\n两数之和：\n\n给定一个整数数组 nums  和一个整数目标值 target ，请你在该数组中找出 和为目标值 target   的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\n# Description\n\nDifficulty: Easy\n\nRelated Topics: Array, Hash Table\n\nGiven an array of integers nums  and an integer target , return indices of the two numbers such that they add up to target .\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\n1\n2\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n1\n2\n\n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\n\n# Solution\n\nLanguage: JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  const hash = {};\n  const hit = (n) => {\n    const i = hash[target - n];\n    return [i !== undefined, i];\n  };\n​\n  for (let i = 0; i < nums.length; i++) {\n    const n = nums[i],\n      [isHit, i0] = hit(n);\n    if (isHit) return [i0, i];\n    hash[n] = i;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.Add Two Numbers\n\n两数相加：\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Linked List, Math, Recursion\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nExample 1:\n\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\n1\n2\n\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n1\n2\n\n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100] .\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.\n\n\n# Solution\n\nLanguage: JavaScript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  let v1 = null,\n    v2 = null,\n    n = 0,\n    v = 0;\n  (head = new ListNode()), (current = head), l1, l2;\n  while (l1 !== null || l2 !== null || n !== 0) {\n    [v1, v2] = [l1, l2].map((p) => p?.val ?? 0);\n    [l1, l2] = [l1, l2].map((p) => p?.next ?? null);\n    [v, n] = [(v1 + v2 + n) % 10, ((v1 + v2 + n) / 10) | 0];\n    current = current.next = new ListNode(v);\n  }\n  return head.next;\n};\n​\n    v = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 3. Longest Substring Without Repeating Characters\n\n无重复字符的最长子串：\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Hash Table, String, Sliding Window\n\nGiven a string s , find the length of the longest substring without repeating characters.\n\nExample 1:\n\nInput: s = "abcabcbb"\nOutput: 3\nExplanation: The answer is "abc", with the length of 3.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: s = "bbbbb"\nOutput: 1\nExplanation: The answer is "b", with the length of 1.\n\n\n1\n2\n3\n\n\nExample 3:\n\nInput: s = "pwwkew"\nOutput: 3\nExplanation: The answer is "wke", with the length of 3.\nNotice that the answer must be a substring, "pwke" is a subsequence and not a substring.\n\n\n1\n2\n3\n4\n\n\nConstraints:\n\n * 0 <= s.length <= 5 * 104\n * s consists of English letters, digits, symbols and spaces.\n\n\n# Solution\n\nLanguage: JavaScript\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  const len = s.length;\n  if (!len) return 0;\n  let w = "",\n    max = 0,\n    l = 0,\n    r = l;\n​\n  while (l < len) {\n    const c = s.charAt(r),\n      idx = w.indexOf(c);\n    if (idx !== -1) {\n      w = w.slice(idx + 1);\n      l += idx + 1;\n    }\n    w += c;\n    r++;\n    max = Math.max(max, w.length);\n  }\n  return max;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4. Median of Two Sorted Arrays\n\n寻找两个正序数组的中位数：\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组  nums1 和  nums2 。请你找出并返回这两个正序数组的 中位数 。\n\n算法的时间复杂度应该为 O(log (m+n)) 。\n\n\n# Description\n\nDifficulty: Hard\n\nRelated Topics: Array, Binary Search, Divide and Conquer\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)) .\n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n1\n2\n3\n\n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar findMedianSortedArrays = function (nums1, nums2) {\n  let prev,\n      cur,\n      i = 0;\n  const mid = (nums1.length + nums2.length + 1) / 2;\n​\n  while (nums1.length || nums2.length) {\n    prev = cur;\n    i++;\n    const [n1, n2] = [nums1[0], nums2[0]];\n    const [nums, n] = n2 === undefined || n1 <= n2 ? [nums1, n1] : [nums2, n2];\n    nums.shift();\n    cur = n;\n    if (i >= mid) break;\n  }\n​\n  return i === mid ? cur : (prev + cur) / 2;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 5. Longest Palindromic Substring\n\n最长回文子串：\n\n给你一个字符串 s ，找到 s 中最长的回文子串。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: String, Dynamic Programming\n\nGiven a string s , return the longest palindromic substring in s .\n\nExample 1:\n\nInput: s = "babad"\nOutput: "bab"\nExplanation: "aba" is also a valid answer.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: s = "cbbd"\nOutput: "bb"\n\n\n1\n2\n\n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar longestPalindrome = function (s) {\n  const len = s.length,\n        dp = new Array(len).fill(null).map(r => new Array(len).fill(null));\n  let lp = "";\n​\n  for (let i = len - 1; i >= 0; i--) {\n    for (let j = 0; j < len; j++) {\n      const isLP = dp[i][j] = s[i] === s[j] && (j - i <= 2 || dp[i + 1][j - 1]);\n​\n      if (isLP && j - i + 1 >= lp.length) {\n        lp = s.substring(i, j + 1);\n      }\n    }\n  }\n​\n  return lp;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 6. Zigzag Conversion\n\nZ 字形变换：\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: String\n\nThe string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n\n1\n2\n3\n\n\nAnd then read line by line: "PAHNAPLSIIGYIR"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n\n1\n\n\nExample 1:\n\nInput: s = "PAYPALISHIRING", numRows = 3\nOutput: "PAHNAPLSIIGYIR"\n\n\n1\n2\n\n\nExample 2:\n\nInput: s = "PAYPALISHIRING", numRows = 4\nOutput: "PINALSIGYAHRPI"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nExample 3:\n\nInput: s = "A", numRows = 1\nOutput: "A"\n\n\n1\n2\n\n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consists of English letters (lower-case and upper-case), \',\' and \'.\' .\n * 1 <= numRows <= 1000\n\n\n# Solution\n\nLanguage: JavaScript\n\n\n\nvar convert = function (s, numRows) {\n  if (!s || numRows <= 0) return "";\n  if (numRows === 1) return s;\n  const len = s.length,\n        size = 2 * numRows - 2;\n  let rst = "";\n​\n  for (let i = 0; i < numRows; i++) {\n    for (let j = i; j < len; j += size) {\n      rst += s.charAt(j);\n​\n      if (![0, numRows - 1].includes(i)) {\n        const index = size - 2 * i + j;\n        if (index < len) rst += s.charAt(index);\n      }\n    }\n  }\n​\n  return rst;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 7. Reverse Integer\n\n整数反转：\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n\n假设环境不允许存储 64 位整数（有符号或无符号）。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Math\n\nGiven a signed 32-bit integer x , return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0 .\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\nExample 1:\n\nInput: x = 123\nOutput: 321\n\n\n1\n2\n\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\n\n1\n2\n\n\nExample 3:\n\nInput: x = 120\nOutput: 21\n\n\n1\n2\n\n\nConstraints:\n\n * -231 <= x <= 231 - 1\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar reverse = function (x) {\n  let t = 0;\n​\n  while (x !== 0) {\n    t = t * 10 + x % 10;\n    x = ~~(x / 10);\n  }\n​\n  if (t > Math.pow(2, 31) - 1 || t < -Math.pow(2, 31)) return 0;\n  return t;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n或者：\n\nvar reverse = function (x) {\n  const max = Math.pow(2, 31),\n        isMinus = x < 0;\n  if (Math.abs(x) < 10) return x;\n  const n = Number(Math.abs(x).toString().split("").reverse().join(""));\n  if (n < -max || n > max - 1) return 0;\n  return isMinus ? -n : n;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 8. String to Integer (atoi)\n\n字符串转换整数：\n\n请你来实现一个  myAtoi(string s)  函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n\n函数  myAtoi(string s) 的算法如下：\n\n 1. 读入字符串并丢弃无用的前导空格\n 2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n 3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n 4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n 5. 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。\n 6. 返回整数作为最终结果。\n\n注意：\n\n * 本题中的空白字符只包括空格字符 \' \' 。\n * 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: String\n\nImplement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++\'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n\n 1. Read in and ignore any leading whitespace.\n 2. Check if the next character (if not already at the end of the string) is \'-\' or \'+\' . Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n 3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n 4. Convert these digits into an integer (i.e. "123" -> 123 , "0032" -> 32 ). If no digits were read, then the integer is 0 . Change the sign as necessary (from step 2).\n 5. If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n 6. Return the integer as the final result.\n\nNote:\n\n * Only the space character \' \' is considered a whitespace character.\n * Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\nExample 1:\n\nInput: s = "42"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: "42" (no characters read because there is no leading whitespace)\n         ^\nStep 2: "42" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nStep 3: "42" ("42" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nExample 2:\n\nInput: s = "   -42"\nOutput: -42\nExplanation:\nStep 1: "   -42" (leading whitespace is read and ignored)\n            ^\nStep 2: "   -42" (\'-\' is read, so the result should be negative)\n             ^\nStep 3: "   -42" ("42" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nExample 3:\n\nInput: s = "4193 with words"\nOutput: 4193\nExplanation:\nStep 1: "4193 with words" (no characters read because there is no leading whitespace)\n         ^\nStep 2: "4193 with words" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nStep 3: "4193 with words" ("4193" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nConstraints:\n\n * 0 <= s.length <= 200\n * s consists of English letters (lower-case and upper-case), digits ( 0-9 ), \' \' , \'+\' , \'-\' , and \'.\' .\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar myAtoi = function (s) {\n  const max = Math.pow(2, 31);\n  let n = parseInt(s.trim());\n  if (isNaN(n)) n = 0;\n  if (n < -max) return -max;\n  if (n > max - 1) return max - 1;\n  return n;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 9. Palindrome Number\n\n回文数：\n\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n\n# Description\n\nDifficulty: Easy\n\nRelated Topics: Math\n\nGiven an integer x , return true if x is a palindrome, and false otherwise.\n\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121\\. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n1\n2\n3\n\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n1\n2\n3\n\n\nConstraints:\n\n * -231 <= x <= 231 - 1\n\nFollow up: Could you solve it without converting the integer to a string?\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar isPalindrome = function (x) {\n  return String(x).split("").reverse().join("") === String(x);\n};\n​\n\n\n1\n2\n3\n4\n\n\n\n# 10. Regular Expression Matching\n\n正则表达式匹配：\n\n给你一个字符串  s  和一个字符规律  p ，请你来实现一个支持 \'.\'  和  \'*\'  的正则表达式匹配。\n\n * \'.\' 匹配任意单个字符\n * \'*\' 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个字符串  s 的，而不是部分字符串。\n\n\n# Description\n\nDifficulty: Hard\n\nRelated Topics: String, Dynamic Programming, Recursion\n\nGiven an input string s  and a pattern p , implement regular expression matching with support for \'.\' and \'*\' where:\n\n * \'.\' Matches any single character.\n * \'*\' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nExample 1:\n\nInput: s = "aa", p = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: s = "aa", p = "a*"\nOutput: true\nExplanation: \'*\' means zero or more of the preceding element, \'a\'. Therefore, by repeating \'a\' once, it becomes "aa".\n\n\n1\n2\n3\n\n\nExample 3:\n\nInput: s = "ab", p = ".*"\nOutput: true\nExplanation: ".*" means "zero or more (*) of any character (.)".\n\n\n1\n2\n3\n\n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 30\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, \'.\' , and  \'*\' .\n * It is guaranteed for each appearance of the character \'*\' , there will be a previous valid character to match.\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar isMatch = function (s, p) {\n  const m = s.length,\n        n = p.length,\n        dp = new Array(m + 1).fill(null).map(r => new Array(n + 1).fill(false));\n  dp[0][0] = true;\n​\n  for (let i = 0; i <= m; ++i) {\n    for (let j = 1; j <= n; ++j) {\n      if (j > 1 && p[j - 1] === "*") {\n        dp[i][j] = dp[i][j - 2] || i > 0 && (s[i - 1] === p[j - 2] || p[j - 2] === ".") && dp[i - 1][j];\n      } else {\n        dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] === p[j - 1] || p[j - 1] === ".");\n      }\n    }\n  }\n​\n  return dp[m][n];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 11. Container With Most Water\n\n盛最多水的容器：\n\n给定一个长度为 n 的整数数组  height  。有  n  条垂线，第 i 条线的两个端点是  (i, 0)  和  (i, height[i])  。\n\n找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n** 说明：** 你不能倾斜容器。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Array, Two Pointers, Greedy\n\nYou are given an integer array height of length n . There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]) .\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\nExample 1:\n\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\n1\n2\n\n\nConstraints:\n\n * n == height.length\n * 2 <= n <= 105\n * 0 <= height[i] <= 104\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar maxArea = function (height) {\n  if (!height || height.length < 2) return 0;\n  let i = 0,\n      j = height.length - 1,\n      max = 0;\n​\n  while (i < j) {\n    const cur = (j - i) * Math.min(height[i], height[j]);\n    if (cur > max) max = cur;\n    if (height[i] <= height[j]) i++;else j--;\n  }\n​\n  return max;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 12. Integer to Roman\n\n整数转罗马数字：\n\n罗马数字包含以下七种字符：  I ，  V ，  X ，  L ， C ， D  和  M 。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例如， 罗马数字 2 写做  II  ，即为两个并列的 1。12 写做  XII  ，即为  X  +  II  。 27 写做   XXVII , 即为  XX  +  V  +  II  。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  IIII ，而是  IV 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  IX 。这个特殊的规则只适用于以下六种情况：\n\n * I  可以放在  V  (5) 和  X  (10) 的左边，来表示 4 和 9。\n * X  可以放在  L  (50) 和  C  (100) 的左边，来表示 40 和 90。\n * C  可以放在  D  (500) 和  M  (1000) 的左边，来表示 400 和 900。\n\n给你一个整数，将其转为罗马数字。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Hash Table, Math, String\n\nRoman numerals are represented by seven different symbols:  I , V , X , L , C , D and M .\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFor example,  2 is written as II  in Roman numeral, just two one\'s added together. 12 is written as  XII , which is simply X + II . The number 27 is written as XXVII , which is XX + V + II .\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used:\n\n * I can be placed before V (5) and X (10) to make 4 and 9.\n * X can be placed before L (50) and C (100) to make 40 and 90.\n * C can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\nExample 1:\n\nInput: num = 3\nOutput: "III"\nExplanation: 3 is represented as 3 ones.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: num = 58\nOutput: "LVIII"\nExplanation: L = 50, V = 5, III = 3.\n\n\n1\n2\n3\n\n\nExample 3:\n\nInput: num = 1994\nOutput: "MCMXCIV"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n1\n2\n3\n\n\nConstraints:\n\n * 1 <= num <= 3999\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar intToRoman = function (num) {\n  const special = {\n    4: "IV",\n    9: "IX",\n    40: "XL",\n    90: "XC",\n    400: "CD",\n    900: "CM"\n  };\n  const base = [{\n    b: 1,\n    c: "I"\n  }, {\n    b: 5,\n    c: "V"\n  }, {\n    b: 10,\n    c: "X"\n  }, {\n    b: 50,\n    c: "L"\n  }, {\n    b: 100,\n    c: "C"\n  }, {\n    b: 500,\n    c: "D"\n  }, {\n    b: 1000,\n    c: "M"\n  }];\n  if (special[String(num)]) return special[String(num)];\n  return base.reverse().reduce((rst, {\n    b,\n    c\n  }) => {\n    const hb = String(num)[0] + "0".repeat(String(num).length - 1);\n​\n    if (special[hb]) {\n      rst += special[hb];\n      num = num - Number(hb);\n    } else {\n      rst += c.repeat(~~(num / b));\n      num = num % b;\n    }\n​\n    return rst;\n  }, "");\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n或者：\n\nconst values = {\n  M: 1000,\n  CM: 900,\n  D: 500,\n  CD: 400,\n  C: 100,\n  XC: 90,\n  L: 50,\n  XL: 40,\n  X: 10,\n  IX: 9,\n  V: 5,\n  IV: 4,\n  I: 1\n};\nconst orders = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];\n\nvar intToRoman = function (num) {\n  let roman = "";\n\n  for (const symbol of orders) {\n    while (num >= values[symbol]) {\n      roman += symbol;\n      num -= values[symbol];\n    }\n  }\n\n  return roman;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 13. Roman to Integer\n\n罗马数字转整数：\n\n罗马数字包含以下七种字符:  I ，  V ，  X ，  L ， C ， D  和  M 。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例如， 罗马数字 2 写做  II  ，即为两个并列的 1 。 12 写做  XII  ，即为  X  +  II  。 27 写做   XXVII , 即为  XX  +  V  +  II  。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  IIII ，而是  IV 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  IX 。这个特殊的规则只适用于以下六种情况：\n\n * I  可以放在  V  (5) 和  X  (10) 的左边，来表示 4 和 9。\n * X  可以放在  L  (50) 和  C  (100) 的左边，来表示 40 和 90。\n * C  可以放在  D  (500) 和  M  (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。\n\n\n# Description\n\nDifficulty: Easy\n\nRelated Topics: Hash Table, Math, String\n\nRoman numerals are represented by seven different symbols:  I , V , X , L , C , D and M .\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nFor example,  2 is written as II  in Roman numeral, just two ones added together. 12 is written as  XII , which is simply X + II . The number 27 is written as XXVII , which is XX + V + II .\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used:\n\n * I can be placed before V (5) and X (10) to make 4 and 9.\n * X can be placed before L (50) and C (100) to make 40 and 90.\n * C can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\nExample 1:\n\nInput: s = "III"\nOutput: 3\nExplanation: III = 3.\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: s = "LVIII"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\n\n1\n2\n3\n\n\nExample 3:\n\nInput: s = "MCMXCIV"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n1\n2\n3\n\n\nConstraints:\n\n * 1 <= s.length <= 15\n * s contains only the characters (\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\') .\n * It is guaranteed that s is a valid roman numeral in the range [1, 3999] .\n\n\n# Solution\n\nLanguage: JavaScript\n\nconst values = {\n  M: 1000,\n  CM: 900,\n  D: 500,\n  CD: 400,\n  C: 100,\n  XC: 90,\n  L: 50,\n  XL: 40,\n  X: 10,\n  IX: 9,\n  V: 5,\n  IV: 4,\n  I: 1\n};\nconst orders = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];\n​\nvar romanToInt = function (s) {\n  let num = 0;\n​\n  for (let symbol of orders) {\n    while (s.startsWith(symbol)) {\n      num += values[symbol];\n      s = s.replace(symbol, "");\n    }\n  }\n​\n  return num;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 14. Longest Common Prefix\n\n最长公共前缀：\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串  "" 。\n\n\n# Description\n\nDifficulty: Easy\n\nRelated Topics: String\n\nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string "" .\n\nExample 1:\n\nInput: strs = ["flower","flow","flight"]\nOutput: "fl"\n\n\n1\n2\n\n\nExample 2:\n\nInput: strs = ["dog","racecar","car"]\nOutput: ""\nExplanation: There is no common prefix among the input strings.\n\n\n1\n2\n3\n\n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar longestCommonPrefix = function (strs) {\n  const len = strs.length;\n  if (!len) return "";\n  if (len === 1) return strs[0];\n​\n  const findLCP = (s1, s2) => {\n    const s = [...s1].concat([...s2].reverse()),\n          sLen = s.length;\n    let i = 0,\n        j = sLen - 1,\n        lcp = "";\n​\n    while (i < s1.length, j >= s1.length) {\n      if (s[i] !== s[j]) break;\n      i++, j--;\n    }\n​\n    if (i > 0) lcp = s1.substring(0, i);\n    return lcp;\n  };\n​\n  let rst = findLCP(strs[0], strs[1]);\n​\n  for (let i = 2; i < len; i++) {\n    rst = findLCP(rst, strs[i]);\n    if (!rst) break;\n  }\n​\n  return rst;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 15. 3Sum\n\n三数之和：\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j 、 i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n\n你返回所有和为 0 且不重复的三元组。\n\n** 注意：** 答案中不可以包含重复的三元组。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Array, Two Pointers, Sorting\n\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j , i != k , and j != k , and nums[i] + nums[j] + nums[k] == 0 .\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\n\n1\n2\n3\n\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n\n1\n2\n3\n\n\nConstraints:\n\n * 3 <= nums.length <= 3000\n * -105 <= nums[i] <= 105\n\n\n# Solution\n\nLanguage: JavaScript\n\nfunction twoSum(nums, s, sum) {\n  const len = nums.length,\n        r = [];\n  if (len - 2 - s < 0) return r;\n  let i = s,\n      j = len - 1;\n​\n  while (i < j) {\n    const diff = nums[i] + nums[j];\n​\n    if (diff === sum) {\n      r.push([nums[i], nums[j]]);\n​\n      while (nums[i] === nums[i + 1]) i++;\n​\n      while (nums[j] === nums[j - 1]) j--;\n​\n      i++, j--;\n    } else if (diff < sum) i++;else j--;\n  }\n​\n  return r;\n}\n​\nvar threeSum = function (nums) {\n  const sNums = nums.sort((a, b) => a - b),\n        len = sNums.length,\n        r = [];\n  if (len < 3) return r;\n​\n  for (let i = 0; i < len - 2; i++) {\n    if (i !== 0 && nums[i] === nums[i - 1]) continue;\n    const sub = twoSum(sNums, i + 1, -sNums[i]);\n    if (sub.length) r.push(...sub.map(k => [sNums[i], ...k]));\n  }\n​\n  return r;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 16. 3Sum Closest\n\n最接近的三数之和：\n\n给你一个长度为 n 的整数数组  nums 和 一个目标值  target 。请你从 nums 中选出三个整数，使它们的和与  target  最接近。\n\n返回这三个数的和。\n\n假定每组输入只存在恰好一个解。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Array, Two Pointers, Sorting\n\nGiven an integer array nums of length n and an integer target , find three integers in nums such that the sum is closest to target .\n\nReturn the sum of the three integers.\n\nYou may assume that each input would have exactly one solution.\n\nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2\\. (-1 + 2 + 1 = 2).\n\n\n1\n2\n3\n\n\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0\\. (0 + 0 + 0 = 0).\n\n\n1\n2\n3\n\n\nConstraints:\n\n * 3 <= nums.length <= 500\n * -1000 <= nums[i] <= 1000\n * -104 <= target <= 104\n\n\n# Solution\n\nLanguage: JavaScript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function (nums, target) {\n  let sNums = nums.sort((a, b) => a - b),\n    len = sNums.length,\n    c = Number.MAX_SAFE_INTEGER;\n  if (len < 2) return false;\n​\n  for (let i = 0; i < len - 2; i++) {\n    let j = i + 1,\n      k = len - 1;\n    while (j < k) {\n      const sum = sNums[i] + sNums[j] + sNums[k],\n        diff = target - sum,\n        pDiff = target - c;\n      if (Math.abs(diff) < Math.abs(pDiff)) c = sum;\n      if (diff === 0) break;\n      if (diff > 0) {\n        while (sNums[j] === sNums[j + 1]) j++;\n        j++;\n      } else {\n        while (sNums[k] === sNums[k - 1]) k--;\n        k--;\n      }\n    }\n  }\n​\n  return c;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 17. Letter Combinations of a Phone Number\n\n电话号码的字母组合：\n\n给定一个仅包含数字  2-9  的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n# Description\n\nDifficulty: Medium\n\nRelated Topics: Hash Table, String, Backtracking\n\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\nExample 1:\n\nInput: digits = "23"\nOutput: ["ad","ae","af","bd","be","bf","cd","ce","cf"]\n\n\n1\n2\n\n\nExample 2:\n\nInput: digits = ""\nOutput: []\n\n\n1\n2\n\n\nExample 3:\n\nInput: digits = "2"\nOutput: ["a","b","c"]\n\n\n1\n2\n\n\nConstraints:\n\n * 0 <= digits.length <= 4\n * digits[i] is a digit in the range [\'2\', \'9\'] .\n\n\n# Solution\n\nLanguage: JavaScript\n\nvar letterCombinations = function (digits) {\n  const len = digits.length,\n        mapping = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"],\n        r = [];\n​\n  const resolve = (i = 0, s = "") => {\n    if (s.length === len) {\n      !!s && r.push(s);\n      return;\n    }\n​\n    for (let j = i; j < len; j++) {\n      const d = digits.charAt(j),\n            letters = [...mapping[d]];\n​\n      for (letter of letters) {\n        s += letter;\n        resolve(j + 1, s);\n        s = s.slice(0, -1);\n      }\n    }\n  };\n​\n  resolve();\n  return r;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',normalizedContent:'# 1.two sum\n\n两数之和：\n\n给定一个整数数组 nums  和一个整数目标值 target ，请你在该数组中找出 和为目标值 target   的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\n# description\n\ndifficulty: easy\n\nrelated topics: array, hash table\n\ngiven an array of integers nums  and an integer target , return indices of the two numbers such that they add up to target .\n\nyou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nyou can return the answer in any order.\n\nexample 1:\n\ninput: nums = [2,7,11,15], target = 9\noutput: [0,1]\nexplanation: because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: nums = [3,2,4], target = 6\noutput: [1,2]\n\n\n1\n2\n\n\nexample 3:\n\ninput: nums = [3,3], target = 6\noutput: [0,1]\n\n\n1\n2\n\n\nconstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * only one valid answer exists.\n\nfollow-up: can you come up with an algorithm that is less than o(n2) time complexity?\n\n\n# solution\n\nlanguage: javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twosum = function (nums, target) {\n  const hash = {};\n  const hit = (n) => {\n    const i = hash[target - n];\n    return [i !== undefined, i];\n  };\n​\n  for (let i = 0; i < nums.length; i++) {\n    const n = nums[i],\n      [ishit, i0] = hit(n);\n    if (ishit) return [i0, i];\n    hash[n] = i;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.add two numbers\n\n两数相加：\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: linked list, math, recursion\n\nyou are given two non-empty linked lists representing two non-negative integers. the digits are stored in reverse order, and each of their nodes contains a single digit. add the two numbers and return the sum as a linked list.\n\nyou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nexample 1:\n\n\n\ninput: l1 = [2,4,3], l2 = [5,6,4]\noutput: [7,0,8]\nexplanation: 342 + 465 = 807.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: l1 = [0], l2 = [0]\noutput: [0]\n\n\n1\n2\n\n\nexample 3:\n\ninput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\noutput: [8,9,9,9,0,0,0,1]\n\n\n1\n2\n\n\nconstraints:\n\n * the number of nodes in each linked list is in the range [1, 100] .\n * 0 <= node.val <= 9\n * it is guaranteed that the list represents a number that does not have leading zeros.\n\n\n# solution\n\nlanguage: javascript\n\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} l1\n * @param {listnode} l2\n * @return {listnode}\n */\nvar addtwonumbers = function (l1, l2) {\n  let v1 = null,\n    v2 = null,\n    n = 0,\n    v = 0;\n  (head = new listnode()), (current = head), l1, l2;\n  while (l1 !== null || l2 !== null || n !== 0) {\n    [v1, v2] = [l1, l2].map((p) => p?.val ?? 0);\n    [l1, l2] = [l1, l2].map((p) => p?.next ?? null);\n    [v, n] = [(v1 + v2 + n) % 10, ((v1 + v2 + n) / 10) | 0];\n    current = current.next = new listnode(v);\n  }\n  return head.next;\n};\n​\n    v = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 3. longest substring without repeating characters\n\n无重复字符的最长子串：\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: hash table, string, sliding window\n\ngiven a string s , find the length of the longest substring without repeating characters.\n\nexample 1:\n\ninput: s = "abcabcbb"\noutput: 3\nexplanation: the answer is "abc", with the length of 3.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: s = "bbbbb"\noutput: 1\nexplanation: the answer is "b", with the length of 1.\n\n\n1\n2\n3\n\n\nexample 3:\n\ninput: s = "pwwkew"\noutput: 3\nexplanation: the answer is "wke", with the length of 3.\nnotice that the answer must be a substring, "pwke" is a subsequence and not a substring.\n\n\n1\n2\n3\n4\n\n\nconstraints:\n\n * 0 <= s.length <= 5 * 104\n * s consists of english letters, digits, symbols and spaces.\n\n\n# solution\n\nlanguage: javascript\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthoflongestsubstring = function (s) {\n  const len = s.length;\n  if (!len) return 0;\n  let w = "",\n    max = 0,\n    l = 0,\n    r = l;\n​\n  while (l < len) {\n    const c = s.charat(r),\n      idx = w.indexof(c);\n    if (idx !== -1) {\n      w = w.slice(idx + 1);\n      l += idx + 1;\n    }\n    w += c;\n    r++;\n    max = math.max(max, w.length);\n  }\n  return max;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4. median of two sorted arrays\n\n寻找两个正序数组的中位数：\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组  nums1 和  nums2 。请你找出并返回这两个正序数组的 中位数 。\n\n算法的时间复杂度应该为 o(log (m+n)) 。\n\n\n# description\n\ndifficulty: hard\n\nrelated topics: array, binary search, divide and conquer\n\ngiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nthe overall run time complexity should be o(log (m+n)) .\n\nexample 1:\n\ninput: nums1 = [1,3], nums2 = [2]\noutput: 2.00000\nexplanation: merged array = [1,2,3] and median is 2.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: nums1 = [1,2], nums2 = [3,4]\noutput: 2.50000\nexplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n1\n2\n3\n\n\nconstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106\n\n\n# solution\n\nlanguage: javascript\n\nvar findmediansortedarrays = function (nums1, nums2) {\n  let prev,\n      cur,\n      i = 0;\n  const mid = (nums1.length + nums2.length + 1) / 2;\n​\n  while (nums1.length || nums2.length) {\n    prev = cur;\n    i++;\n    const [n1, n2] = [nums1[0], nums2[0]];\n    const [nums, n] = n2 === undefined || n1 <= n2 ? [nums1, n1] : [nums2, n2];\n    nums.shift();\n    cur = n;\n    if (i >= mid) break;\n  }\n​\n  return i === mid ? cur : (prev + cur) / 2;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 5. longest palindromic substring\n\n最长回文子串：\n\n给你一个字符串 s ，找到 s 中最长的回文子串。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: string, dynamic programming\n\ngiven a string s , return the longest palindromic substring in s .\n\nexample 1:\n\ninput: s = "babad"\noutput: "bab"\nexplanation: "aba" is also a valid answer.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: s = "cbbd"\noutput: "bb"\n\n\n1\n2\n\n\nconstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and english letters.\n\n\n# solution\n\nlanguage: javascript\n\nvar longestpalindrome = function (s) {\n  const len = s.length,\n        dp = new array(len).fill(null).map(r => new array(len).fill(null));\n  let lp = "";\n​\n  for (let i = len - 1; i >= 0; i--) {\n    for (let j = 0; j < len; j++) {\n      const islp = dp[i][j] = s[i] === s[j] && (j - i <= 2 || dp[i + 1][j - 1]);\n​\n      if (islp && j - i + 1 >= lp.length) {\n        lp = s.substring(i, j + 1);\n      }\n    }\n  }\n​\n  return lp;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 6. zigzag conversion\n\nz 字形变换：\n\n将一个给定字符串 s 根据给定的行数 numrows ，以从上往下、从左到右进行 z 字形排列。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: string\n\nthe string "paypalishiring" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\np   a   h   n\na p l s i i g\ny   i   r\n\n\n1\n2\n3\n\n\nand then read line by line: "pahnaplsiigyir"\n\nwrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numrows);\n\n\n1\n\n\nexample 1:\n\ninput: s = "paypalishiring", numrows = 3\noutput: "pahnaplsiigyir"\n\n\n1\n2\n\n\nexample 2:\n\ninput: s = "paypalishiring", numrows = 4\noutput: "pinalsigyahrpi"\nexplanation:\np     i    n\na   l s  i g\ny a   h r\np     i\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nexample 3:\n\ninput: s = "a", numrows = 1\noutput: "a"\n\n\n1\n2\n\n\nconstraints:\n\n * 1 <= s.length <= 1000\n * s consists of english letters (lower-case and upper-case), \',\' and \'.\' .\n * 1 <= numrows <= 1000\n\n\n# solution\n\nlanguage: javascript\n\n\n\nvar convert = function (s, numrows) {\n  if (!s || numrows <= 0) return "";\n  if (numrows === 1) return s;\n  const len = s.length,\n        size = 2 * numrows - 2;\n  let rst = "";\n​\n  for (let i = 0; i < numrows; i++) {\n    for (let j = i; j < len; j += size) {\n      rst += s.charat(j);\n​\n      if (![0, numrows - 1].includes(i)) {\n        const index = size - 2 * i + j;\n        if (index < len) rst += s.charat(index);\n      }\n    }\n  }\n​\n  return rst;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 7. reverse integer\n\n整数反转：\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n\n假设环境不允许存储 64 位整数（有符号或无符号）。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: math\n\ngiven a signed 32-bit integer x , return x with its digits reversed. if reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0 .\n\nassume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\nexample 1:\n\ninput: x = 123\noutput: 321\n\n\n1\n2\n\n\nexample 2:\n\ninput: x = -123\noutput: -321\n\n\n1\n2\n\n\nexample 3:\n\ninput: x = 120\noutput: 21\n\n\n1\n2\n\n\nconstraints:\n\n * -231 <= x <= 231 - 1\n\n\n# solution\n\nlanguage: javascript\n\nvar reverse = function (x) {\n  let t = 0;\n​\n  while (x !== 0) {\n    t = t * 10 + x % 10;\n    x = ~~(x / 10);\n  }\n​\n  if (t > math.pow(2, 31) - 1 || t < -math.pow(2, 31)) return 0;\n  return t;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n或者：\n\nvar reverse = function (x) {\n  const max = math.pow(2, 31),\n        isminus = x < 0;\n  if (math.abs(x) < 10) return x;\n  const n = number(math.abs(x).tostring().split("").reverse().join(""));\n  if (n < -max || n > max - 1) return 0;\n  return isminus ? -n : n;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 8. string to integer (atoi)\n\n字符串转换整数：\n\n请你来实现一个  myatoi(string s)  函数，使其能将字符串转换成一个 32 位有符号整数（类似 c/c++ 中的 atoi 函数）。\n\n函数  myatoi(string s) 的算法如下：\n\n 1. 读入字符串并丢弃无用的前导空格\n 2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n 3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n 4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。\n 5. 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。\n 6. 返回整数作为最终结果。\n\n注意：\n\n * 本题中的空白字符只包括空格字符 \' \' 。\n * 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: string\n\nimplement the myatoi(string s) function, which converts a string to a 32-bit signed integer (similar to c/c++\'s atoi function).\n\nthe algorithm for myatoi(string s) is as follows:\n\n 1. read in and ignore any leading whitespace.\n 2. check if the next character (if not already at the end of the string) is \'-\' or \'+\' . read this character in if it is either. this determines if the final result is negative or positive respectively. assume the result is positive if neither is present.\n 3. read in next the characters until the next non-digit character or the end of the input is reached. the rest of the string is ignored.\n 4. convert these digits into an integer (i.e. "123" -> 123 , "0032" -> 32 ). if no digits were read, then the integer is 0 . change the sign as necessary (from step 2).\n 5. if the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n 6. return the integer as the final result.\n\nnote:\n\n * only the space character \' \' is considered a whitespace character.\n * do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\nexample 1:\n\ninput: s = "42"\noutput: 42\nexplanation: the underlined characters are what is read in, the caret is the current reader position.\nstep 1: "42" (no characters read because there is no leading whitespace)\n         ^\nstep 2: "42" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nstep 3: "42" ("42" is read in)\n           ^\nthe parsed integer is 42.\nsince 42 is in the range [-231, 231 - 1], the final result is 42.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexample 2:\n\ninput: s = "   -42"\noutput: -42\nexplanation:\nstep 1: "   -42" (leading whitespace is read and ignored)\n            ^\nstep 2: "   -42" (\'-\' is read, so the result should be negative)\n             ^\nstep 3: "   -42" ("42" is read in)\n               ^\nthe parsed integer is -42.\nsince -42 is in the range [-231, 231 - 1], the final result is -42.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexample 3:\n\ninput: s = "4193 with words"\noutput: 4193\nexplanation:\nstep 1: "4193 with words" (no characters read because there is no leading whitespace)\n         ^\nstep 2: "4193 with words" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nstep 3: "4193 with words" ("4193" is read in; reading stops because the next character is a non-digit)\n             ^\nthe parsed integer is 4193.\nsince 4193 is in the range [-231, 231 - 1], the final result is 4193.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nconstraints:\n\n * 0 <= s.length <= 200\n * s consists of english letters (lower-case and upper-case), digits ( 0-9 ), \' \' , \'+\' , \'-\' , and \'.\' .\n\n\n# solution\n\nlanguage: javascript\n\nvar myatoi = function (s) {\n  const max = math.pow(2, 31);\n  let n = parseint(s.trim());\n  if (isnan(n)) n = 0;\n  if (n < -max) return -max;\n  if (n > max - 1) return max - 1;\n  return n;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 9. palindrome number\n\n回文数：\n\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n\n# description\n\ndifficulty: easy\n\nrelated topics: math\n\ngiven an integer x , return true if x is a palindrome, and false otherwise.\n\nexample 1:\n\ninput: x = 121\noutput: true\nexplanation: 121 reads as 121 from left to right and from right to left.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: x = -121\noutput: false\nexplanation: from left to right, it reads -121\\. from right to left, it becomes 121-. therefore it is not a palindrome.\n\n\n1\n2\n3\n\n\nexample 3:\n\ninput: x = 10\noutput: false\nexplanation: reads 01 from right to left. therefore it is not a palindrome.\n\n\n1\n2\n3\n\n\nconstraints:\n\n * -231 <= x <= 231 - 1\n\nfollow up: could you solve it without converting the integer to a string?\n\n\n# solution\n\nlanguage: javascript\n\nvar ispalindrome = function (x) {\n  return string(x).split("").reverse().join("") === string(x);\n};\n​\n\n\n1\n2\n3\n4\n\n\n\n# 10. regular expression matching\n\n正则表达式匹配：\n\n给你一个字符串  s  和一个字符规律  p ，请你来实现一个支持 \'.\'  和  \'*\'  的正则表达式匹配。\n\n * \'.\' 匹配任意单个字符\n * \'*\' 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个字符串  s 的，而不是部分字符串。\n\n\n# description\n\ndifficulty: hard\n\nrelated topics: string, dynamic programming, recursion\n\ngiven an input string s  and a pattern p , implement regular expression matching with support for \'.\' and \'*\' where:\n\n * \'.\' matches any single character.\n * \'*\' matches zero or more of the preceding element.\n\nthe matching should cover the entire input string (not partial).\n\nexample 1:\n\ninput: s = "aa", p = "a"\noutput: false\nexplanation: "a" does not match the entire string "aa".\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: s = "aa", p = "a*"\noutput: true\nexplanation: \'*\' means zero or more of the preceding element, \'a\'. therefore, by repeating \'a\' once, it becomes "aa".\n\n\n1\n2\n3\n\n\nexample 3:\n\ninput: s = "ab", p = ".*"\noutput: true\nexplanation: ".*" means "zero or more (*) of any character (.)".\n\n\n1\n2\n3\n\n\nconstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 30\n * s contains only lowercase english letters.\n * p contains only lowercase english letters, \'.\' , and  \'*\' .\n * it is guaranteed for each appearance of the character \'*\' , there will be a previous valid character to match.\n\n\n# solution\n\nlanguage: javascript\n\nvar ismatch = function (s, p) {\n  const m = s.length,\n        n = p.length,\n        dp = new array(m + 1).fill(null).map(r => new array(n + 1).fill(false));\n  dp[0][0] = true;\n​\n  for (let i = 0; i <= m; ++i) {\n    for (let j = 1; j <= n; ++j) {\n      if (j > 1 && p[j - 1] === "*") {\n        dp[i][j] = dp[i][j - 2] || i > 0 && (s[i - 1] === p[j - 2] || p[j - 2] === ".") && dp[i - 1][j];\n      } else {\n        dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] === p[j - 1] || p[j - 1] === ".");\n      }\n    }\n  }\n​\n  return dp[m][n];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 11. container with most water\n\n盛最多水的容器：\n\n给定一个长度为 n 的整数数组  height  。有  n  条垂线，第 i 条线的两个端点是  (i, 0)  和  (i, height[i])  。\n\n找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n** 说明：** 你不能倾斜容器。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: array, two pointers, greedy\n\nyou are given an integer array height of length n . there are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]) .\n\nfind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nreturn the maximum amount of water a container can store.\n\nnotice that you may not slant the container.\n\nexample 1:\n\n\n\ninput: height = [1,8,6,2,5,4,8,3,7]\noutput: 49\nexplanation: the above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. in this case, the max area of water (blue section) the container can contain is 49.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: height = [1,1]\noutput: 1\n\n\n1\n2\n\n\nconstraints:\n\n * n == height.length\n * 2 <= n <= 105\n * 0 <= height[i] <= 104\n\n\n# solution\n\nlanguage: javascript\n\nvar maxarea = function (height) {\n  if (!height || height.length < 2) return 0;\n  let i = 0,\n      j = height.length - 1,\n      max = 0;\n​\n  while (i < j) {\n    const cur = (j - i) * math.min(height[i], height[j]);\n    if (cur > max) max = cur;\n    if (height[i] <= height[j]) i++;else j--;\n  }\n​\n  return max;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 12. integer to roman\n\n整数转罗马数字：\n\n罗马数字包含以下七种字符：  i ，  v ，  x ，  l ， c ， d  和  m 。\n\n字符          数值\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例如， 罗马数字 2 写做  ii  ，即为两个并列的 1。12 写做  xii  ，即为  x  +  ii  。 27 写做   xxvii , 即为  xx  +  v  +  ii  。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  iiii ，而是  iv 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  ix 。这个特殊的规则只适用于以下六种情况：\n\n * i  可以放在  v  (5) 和  x  (10) 的左边，来表示 4 和 9。\n * x  可以放在  l  (50) 和  c  (100) 的左边，来表示 40 和 90。\n * c  可以放在  d  (500) 和  m  (1000) 的左边，来表示 400 和 900。\n\n给你一个整数，将其转为罗马数字。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: hash table, math, string\n\nroman numerals are represented by seven different symbols:  i , v , x , l , c , d and m .\n\nsymbol       value\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor example,  2 is written as ii  in roman numeral, just two one\'s added together. 12 is written as  xii , which is simply x + ii . the number 27 is written as xxvii , which is xx + v + ii .\n\nroman numerals are usually written largest to smallest from left to right. however, the numeral for four is not iiii . instead, the number four is written as iv . because the one is before the five we subtract it making four. the same principle applies to the number nine, which is written as ix . there are six instances where subtraction is used:\n\n * i can be placed before v (5) and x (10) to make 4 and 9.\n * x can be placed before l (50) and c (100) to make 40 and 90.\n * c can be placed before d (500) and m (1000) to make 400 and 900.\n\ngiven an integer, convert it to a roman numeral.\n\nexample 1:\n\ninput: num = 3\noutput: "iii"\nexplanation: 3 is represented as 3 ones.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: num = 58\noutput: "lviii"\nexplanation: l = 50, v = 5, iii = 3.\n\n\n1\n2\n3\n\n\nexample 3:\n\ninput: num = 1994\noutput: "mcmxciv"\nexplanation: m = 1000, cm = 900, xc = 90 and iv = 4.\n\n\n1\n2\n3\n\n\nconstraints:\n\n * 1 <= num <= 3999\n\n\n# solution\n\nlanguage: javascript\n\nvar inttoroman = function (num) {\n  const special = {\n    4: "iv",\n    9: "ix",\n    40: "xl",\n    90: "xc",\n    400: "cd",\n    900: "cm"\n  };\n  const base = [{\n    b: 1,\n    c: "i"\n  }, {\n    b: 5,\n    c: "v"\n  }, {\n    b: 10,\n    c: "x"\n  }, {\n    b: 50,\n    c: "l"\n  }, {\n    b: 100,\n    c: "c"\n  }, {\n    b: 500,\n    c: "d"\n  }, {\n    b: 1000,\n    c: "m"\n  }];\n  if (special[string(num)]) return special[string(num)];\n  return base.reverse().reduce((rst, {\n    b,\n    c\n  }) => {\n    const hb = string(num)[0] + "0".repeat(string(num).length - 1);\n​\n    if (special[hb]) {\n      rst += special[hb];\n      num = num - number(hb);\n    } else {\n      rst += c.repeat(~~(num / b));\n      num = num % b;\n    }\n​\n    return rst;\n  }, "");\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n或者：\n\nconst values = {\n  m: 1000,\n  cm: 900,\n  d: 500,\n  cd: 400,\n  c: 100,\n  xc: 90,\n  l: 50,\n  xl: 40,\n  x: 10,\n  ix: 9,\n  v: 5,\n  iv: 4,\n  i: 1\n};\nconst orders = ["m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"];\n\nvar inttoroman = function (num) {\n  let roman = "";\n\n  for (const symbol of orders) {\n    while (num >= values[symbol]) {\n      roman += symbol;\n      num -= values[symbol];\n    }\n  }\n\n  return roman;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 13. roman to integer\n\n罗马数字转整数：\n\n罗马数字包含以下七种字符:  i ，  v ，  x ，  l ， c ， d  和  m 。\n\n字符          数值\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n例如， 罗马数字 2 写做  ii  ，即为两个并列的 1 。 12 写做  xii  ，即为  x  +  ii  。 27 写做   xxvii , 即为  xx  +  v  +  ii  。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  iiii ，而是  iv 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  ix 。这个特殊的规则只适用于以下六种情况：\n\n * i  可以放在  v  (5) 和  x  (10) 的左边，来表示 4 和 9。\n * x  可以放在  l  (50) 和  c  (100) 的左边，来表示 40 和 90。\n * c  可以放在  d  (500) 和  m  (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。\n\n\n# description\n\ndifficulty: easy\n\nrelated topics: hash table, math, string\n\nroman numerals are represented by seven different symbols:  i , v , x , l , c , d and m .\n\nsymbol       value\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor example,  2 is written as ii  in roman numeral, just two ones added together. 12 is written as  xii , which is simply x + ii . the number 27 is written as xxvii , which is xx + v + ii .\n\nroman numerals are usually written largest to smallest from left to right. however, the numeral for four is not iiii . instead, the number four is written as iv . because the one is before the five we subtract it making four. the same principle applies to the number nine, which is written as ix . there are six instances where subtraction is used:\n\n * i can be placed before v (5) and x (10) to make 4 and 9.\n * x can be placed before l (50) and c (100) to make 40 and 90.\n * c can be placed before d (500) and m (1000) to make 400 and 900.\n\ngiven a roman numeral, convert it to an integer.\n\nexample 1:\n\ninput: s = "iii"\noutput: 3\nexplanation: iii = 3.\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: s = "lviii"\noutput: 58\nexplanation: l = 50, v= 5, iii = 3.\n\n\n1\n2\n3\n\n\nexample 3:\n\ninput: s = "mcmxciv"\noutput: 1994\nexplanation: m = 1000, cm = 900, xc = 90 and iv = 4.\n\n\n1\n2\n3\n\n\nconstraints:\n\n * 1 <= s.length <= 15\n * s contains only the characters (\'i\', \'v\', \'x\', \'l\', \'c\', \'d\', \'m\') .\n * it is guaranteed that s is a valid roman numeral in the range [1, 3999] .\n\n\n# solution\n\nlanguage: javascript\n\nconst values = {\n  m: 1000,\n  cm: 900,\n  d: 500,\n  cd: 400,\n  c: 100,\n  xc: 90,\n  l: 50,\n  xl: 40,\n  x: 10,\n  ix: 9,\n  v: 5,\n  iv: 4,\n  i: 1\n};\nconst orders = ["m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"];\n​\nvar romantoint = function (s) {\n  let num = 0;\n​\n  for (let symbol of orders) {\n    while (s.startswith(symbol)) {\n      num += values[symbol];\n      s = s.replace(symbol, "");\n    }\n  }\n​\n  return num;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 14. longest common prefix\n\n最长公共前缀：\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串  "" 。\n\n\n# description\n\ndifficulty: easy\n\nrelated topics: string\n\nwrite a function to find the longest common prefix string amongst an array of strings.\n\nif there is no common prefix, return an empty string "" .\n\nexample 1:\n\ninput: strs = ["flower","flow","flight"]\noutput: "fl"\n\n\n1\n2\n\n\nexample 2:\n\ninput: strs = ["dog","racecar","car"]\noutput: ""\nexplanation: there is no common prefix among the input strings.\n\n\n1\n2\n3\n\n\nconstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase english letters.\n\n\n# solution\n\nlanguage: javascript\n\nvar longestcommonprefix = function (strs) {\n  const len = strs.length;\n  if (!len) return "";\n  if (len === 1) return strs[0];\n​\n  const findlcp = (s1, s2) => {\n    const s = [...s1].concat([...s2].reverse()),\n          slen = s.length;\n    let i = 0,\n        j = slen - 1,\n        lcp = "";\n​\n    while (i < s1.length, j >= s1.length) {\n      if (s[i] !== s[j]) break;\n      i++, j--;\n    }\n​\n    if (i > 0) lcp = s1.substring(0, i);\n    return lcp;\n  };\n​\n  let rst = findlcp(strs[0], strs[1]);\n​\n  for (let i = 2; i < len; i++) {\n    rst = findlcp(rst, strs[i]);\n    if (!rst) break;\n  }\n​\n  return rst;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 15. 3sum\n\n三数之和：\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j 、 i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n\n你返回所有和为 0 且不重复的三元组。\n\n** 注意：** 答案中不可以包含重复的三元组。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: array, two pointers, sorting\n\ngiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j , i != k , and j != k , and nums[i] + nums[j] + nums[k] == 0 .\n\nnotice that the solution set must not contain duplicate triplets.\n\nexample 1:\n\ninput: nums = [-1,0,1,2,-1,-4]\noutput: [[-1,-1,2],[-1,0,1]]\nexplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nthe distinct triplets are [-1,0,1] and [-1,-1,2].\nnotice that the order of the output and the order of the triplets does not matter.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexample 2:\n\ninput: nums = [0,1,1]\noutput: []\nexplanation: the only possible triplet does not sum up to 0.\n\n\n1\n2\n3\n\n\nexample 3:\n\ninput: nums = [0,0,0]\noutput: [[0,0,0]]\nexplanation: the only possible triplet sums up to 0.\n\n\n1\n2\n3\n\n\nconstraints:\n\n * 3 <= nums.length <= 3000\n * -105 <= nums[i] <= 105\n\n\n# solution\n\nlanguage: javascript\n\nfunction twosum(nums, s, sum) {\n  const len = nums.length,\n        r = [];\n  if (len - 2 - s < 0) return r;\n  let i = s,\n      j = len - 1;\n​\n  while (i < j) {\n    const diff = nums[i] + nums[j];\n​\n    if (diff === sum) {\n      r.push([nums[i], nums[j]]);\n​\n      while (nums[i] === nums[i + 1]) i++;\n​\n      while (nums[j] === nums[j - 1]) j--;\n​\n      i++, j--;\n    } else if (diff < sum) i++;else j--;\n  }\n​\n  return r;\n}\n​\nvar threesum = function (nums) {\n  const snums = nums.sort((a, b) => a - b),\n        len = snums.length,\n        r = [];\n  if (len < 3) return r;\n​\n  for (let i = 0; i < len - 2; i++) {\n    if (i !== 0 && nums[i] === nums[i - 1]) continue;\n    const sub = twosum(snums, i + 1, -snums[i]);\n    if (sub.length) r.push(...sub.map(k => [snums[i], ...k]));\n  }\n​\n  return r;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 16. 3sum closest\n\n最接近的三数之和：\n\n给你一个长度为 n 的整数数组  nums 和 一个目标值  target 。请你从 nums 中选出三个整数，使它们的和与  target  最接近。\n\n返回这三个数的和。\n\n假定每组输入只存在恰好一个解。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: array, two pointers, sorting\n\ngiven an integer array nums of length n and an integer target , find three integers in nums such that the sum is closest to target .\n\nreturn the sum of the three integers.\n\nyou may assume that each input would have exactly one solution.\n\nexample 1:\n\ninput: nums = [-1,2,1,-4], target = 1\noutput: 2\nexplanation: the sum that is closest to the target is 2\\. (-1 + 2 + 1 = 2).\n\n\n1\n2\n3\n\n\nexample 2:\n\ninput: nums = [0,0,0], target = 1\noutput: 0\nexplanation: the sum that is closest to the target is 0\\. (0 + 0 + 0 = 0).\n\n\n1\n2\n3\n\n\nconstraints:\n\n * 3 <= nums.length <= 500\n * -1000 <= nums[i] <= 1000\n * -104 <= target <= 104\n\n\n# solution\n\nlanguage: javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threesumclosest = function (nums, target) {\n  let snums = nums.sort((a, b) => a - b),\n    len = snums.length,\n    c = number.max_safe_integer;\n  if (len < 2) return false;\n​\n  for (let i = 0; i < len - 2; i++) {\n    let j = i + 1,\n      k = len - 1;\n    while (j < k) {\n      const sum = snums[i] + snums[j] + snums[k],\n        diff = target - sum,\n        pdiff = target - c;\n      if (math.abs(diff) < math.abs(pdiff)) c = sum;\n      if (diff === 0) break;\n      if (diff > 0) {\n        while (snums[j] === snums[j + 1]) j++;\n        j++;\n      } else {\n        while (snums[k] === snums[k - 1]) k--;\n        k--;\n      }\n    }\n  }\n​\n  return c;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 17. letter combinations of a phone number\n\n电话号码的字母组合：\n\n给定一个仅包含数字  2-9  的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n# description\n\ndifficulty: medium\n\nrelated topics: hash table, string, backtracking\n\ngiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. return the answer in any order.\n\na mapping of digits to letters (just like on the telephone buttons) is given below. note that 1 does not map to any letters.\n\n\n\nexample 1:\n\ninput: digits = "23"\noutput: ["ad","ae","af","bd","be","bf","cd","ce","cf"]\n\n\n1\n2\n\n\nexample 2:\n\ninput: digits = ""\noutput: []\n\n\n1\n2\n\n\nexample 3:\n\ninput: digits = "2"\noutput: ["a","b","c"]\n\n\n1\n2\n\n\nconstraints:\n\n * 0 <= digits.length <= 4\n * digits[i] is a digit in the range [\'2\', \'9\'] .\n\n\n# solution\n\nlanguage: javascript\n\nvar lettercombinations = function (digits) {\n  const len = digits.length,\n        mapping = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"],\n        r = [];\n​\n  const resolve = (i = 0, s = "") => {\n    if (s.length === len) {\n      !!s && r.push(s);\n      return;\n    }\n​\n    for (let j = i; j < len; j++) {\n      const d = digits.charat(j),\n            letters = [...mapping[d]];\n​\n      for (letter of letters) {\n        s += letter;\n        resolve(j + 1, s);\n        s = s.slice(0, -1);\n      }\n    }\n  };\n​\n  resolve();\n  return r;\n};\n​\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',charsets:{cjk:!0},lastUpdated:"2022/11/03, 19:39:28",lastUpdatedTimestamp:1667475568e3},{title:"Roadmap 路线",frontmatter:{title:"Roadmap 路线",date:"2022-04-16T16:44:46.000Z",permalink:"/leetcode/roadmap/",categories:["LeetCode"],tags:[null]},regularPath:"/30.LeetCode/2.roadmap.html",relativePath:"30.LeetCode/2.roadmap.md",key:"v-9f87cf32",path:"/leetcode/roadmap/",headers:[{level:2,title:"资源",slug:"资源",normalizedTitle:"资源",charIndex:2},{level:3,title:"LeetCode101",slug:"leetcode101",normalizedTitle:"leetcode101",charIndex:9},{level:3,title:"labuladong 的算法小抄",slug:"labuladong-的算法小抄",normalizedTitle:"labuladong 的算法小抄",charIndex:81},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:130}],headersStr:"资源 LeetCode101 labuladong 的算法小抄 参考",content:"# 资源\n\n\n# LeetCode101\n\nLeetCode 101 - A LeetCode Grinding Guide (C++ Version)\n\n\n# labuladong 的算法小抄\n\n参见：labuladong 刷题全家桶 | 氧气空间\n\n\n# 参考\n\n * leetcode/README-CN.md at master · grandyang/leetcode\n * CYBYOB/algorithm-leetcode: algorithm-leetcode。标签：算法、LeetCode、前端、面试、JS、JavaScript 等。\n * LeetCode Cookbook\n * labuladong/fucking-algorithm: 刷算法全靠套路，认准 labuladong 就够了！English version supported! Crack LeetCode, not only how, but also why.",normalizedContent:"# 资源\n\n\n# leetcode101\n\nleetcode 101 - a leetcode grinding guide (c++ version)\n\n\n# labuladong 的算法小抄\n\n参见：labuladong 刷题全家桶 | 氧气空间\n\n\n# 参考\n\n * leetcode/readme-cn.md at master · grandyang/leetcode\n * cybyob/algorithm-leetcode: algorithm-leetcode。标签：算法、leetcode、前端、面试、js、javascript 等。\n * leetcode cookbook\n * labuladong/fucking-algorithm: 刷算法全靠套路，认准 labuladong 就够了！english version supported! crack leetcode, not only how, but also why.",charsets:{cjk:!0},lastUpdated:"2022/11/20, 14:59:04",lastUpdatedTimestamp:1668927544e3},{title:"数据结构",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"10.数据结构",imgUrl:"/img/ds.png",description:"队列、堆、链表、栈、图、树......"}},title:"数据结构",date:"2020-03-11T21:50:53.000Z",permalink:"/ds/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"999.目录/10.数据结构.md",key:"v-5e4325fb",path:"/ds/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:07:23",lastUpdatedTimestamp:1651158443e3},{title:"算法",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"20.算法",imgUrl:"/img/algorithm.png",description:"搜索算法、排序算法......"}},title:"算法",date:"2020-03-11T21:50:53.000Z",permalink:"/algorithm/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/20.%E7%AE%97%E6%B3%95.html",relativePath:"999.目录/20.算法.md",key:"v-503fa995",path:"/algorithm/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:07:23",lastUpdatedTimestamp:1651158443e3},{title:"LeetCode",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"30.LeetCode",imgUrl:"/img/leetcode.png",description:"LeetCode..."}},title:"LeetCode",date:"2020-03-11T21:50:53.000Z",permalink:"/leetcode/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/30.LeetCode.html",relativePath:"999.目录/30.LeetCode.md",key:"v-5d3b6f37",path:"/leetcode/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:07:23",lastUpdatedTimestamp:1651158443e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-7efc0d27",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 16:01:01",lastUpdatedTimestamp:1650096061e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-725b30f2",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 16:01:01",lastUpdatedTimestamp:1650096061e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-79f396b2",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 16:01:01",lastUpdatedTimestamp:1650096061e3},{title:"关于",frontmatter:{title:"关于",date:"2022-01-11T14:03:46.000Z",permalink:"/about/",categories:[null],tags:[null]},regularPath:"/about.html",relativePath:"about.md",key:"v-4b1f61a7",path:"/about/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 16:41:30",lastUpdatedTimestamp:165009849e4},{title:"Home",frontmatter:{home:!0,heroText:"Fancy Data Structures and Algorithms",tagline:"数据结构与算法，LeetCode刷题笔记。",actionText:"开始上手 →",actionLink:"/ds/index",bannerBg:"auto",features:[{title:"数据结构",details:"经典数据结构、进阶数据结构...",link:"/ds/index/",imgUrl:"/img/ds.png"},{title:"算法",details:"排序算法、搜索算法、进阶算法...",link:"/algorithm/index/",imgUrl:"/img/algorithm.png"},{title:"LeetCode",details:"LeetCode 成长之路...",link:"/technology/",imgUrl:"/img/leetcode.png"}],postList:"simple"},regularPath:"/",relativePath:"index.md",key:"v-bba02680",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 22:42:49",lastUpdatedTimestamp:1651156969e3},{title:"StringSearch",frontmatter:{title:"StringSearch",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/stringSearch/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/90.StringSearch.html",relativePath:"20.算法/20.Search 搜索/90.StringSearch.md",key:"v-7912cf1b",path:"/algorithm/search/stringSearch/",headers:[{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:2},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:9}],headersStr:"实现 JavaScript",content:"# 实现\n\n\n# JavaScript\n\n/*\n * String Search\n */\n\nfunction makeTable (str) {\n  // create a table of size equal to the length of `str`\n  // table[i] will store the prefix of the longest prefix of the substring str[0..i]\n  const table = new Array(str.length)\n  let maxPrefix = 0\n  // the longest prefix of the substring str[0] has length\n  table[0] = 0\n\n  // for the substrings the following substrings, we have two cases\n  for (let i = 1; i < str.length; i++) {\n    // case 1. the current character doesn't match the last character of the longest prefix\n    while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {\n      // if that is the case, we have to backtrack, and try find a character  that will be equal to the current character\n      // if we reach 0, then we couldn't find a character\n      maxPrefix = table[maxPrefix - 1]\n    }\n    // case 2. The last character of the longest prefix matches the current character in `str`\n    if (str.charAt(maxPrefix) === str.charAt(i)) {\n      // if that is the case, we know that the longest prefix at position i has one more character.\n      // for example consider `.` be any character not contained in the set [a.c]\n      // str = abc....abc\n      // consider `i` to be the last character `c` in `str`\n      // maxPrefix = will be 2 (the first `c` in `str`)\n      // maxPrefix now will be 3\n      maxPrefix++\n      // so the max prefix for table[9] is 3\n    }\n    table[i] = maxPrefix\n  }\n  return table\n}\n\n// Find all the words that matches in a given string `str`\nexport function stringSearch (str, word) {\n  // find the prefix table in O(n)\n  const prefixes = makeTable(word)\n  const matches = []\n\n  // `j` is the index in `P`\n  let j = 0\n  // `i` is the index in `S`\n  let i = 0\n  while (i < str.length) {\n    // Case 1.  S[i] == P[j] so we move to the next index in `S` and `P`\n    if (str.charAt(i) === word.charAt(j)) {\n      i++\n      j++\n    }\n    // Case 2.  `j` is equal to the length of `P`\n    // that means that we reached the end of `P` and thus we found a match\n    // Next we have to update `j` because we want to save some time\n    // instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.\n    // j-1 means the last character of `P` because j is actually `P.length`\n    // e.g.\n    // S =  a b a b d e\n    // P = `a b`a b\n    // we will jump to `a b` and we will compare d and a in the next iteration\n    // a b a b `d` e\n    //     a b `a` b\n    if (j === word.length) {\n      matches.push(i - j)\n      j = prefixes[j - 1]\n      // Case 3.\n      // S[i] != P[j] There's a mismatch!\n    } else if (str.charAt(i) !== word.charAt(j)) {\n      // if we  found at least a character in common, do the same thing as in case 2\n      if (j !== 0) {\n        j = prefixes[j - 1]\n      } else {\n        // else j = 0, and we can move to the next character S[i+1]\n        i++\n      }\n    }\n  }\n\n  return matches\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n",normalizedContent:"# 实现\n\n\n# javascript\n\n/*\n * string search\n */\n\nfunction maketable (str) {\n  // create a table of size equal to the length of `str`\n  // table[i] will store the prefix of the longest prefix of the substring str[0..i]\n  const table = new array(str.length)\n  let maxprefix = 0\n  // the longest prefix of the substring str[0] has length\n  table[0] = 0\n\n  // for the substrings the following substrings, we have two cases\n  for (let i = 1; i < str.length; i++) {\n    // case 1. the current character doesn't match the last character of the longest prefix\n    while (maxprefix > 0 && str.charat(i) !== str.charat(maxprefix)) {\n      // if that is the case, we have to backtrack, and try find a character  that will be equal to the current character\n      // if we reach 0, then we couldn't find a character\n      maxprefix = table[maxprefix - 1]\n    }\n    // case 2. the last character of the longest prefix matches the current character in `str`\n    if (str.charat(maxprefix) === str.charat(i)) {\n      // if that is the case, we know that the longest prefix at position i has one more character.\n      // for example consider `.` be any character not contained in the set [a.c]\n      // str = abc....abc\n      // consider `i` to be the last character `c` in `str`\n      // maxprefix = will be 2 (the first `c` in `str`)\n      // maxprefix now will be 3\n      maxprefix++\n      // so the max prefix for table[9] is 3\n    }\n    table[i] = maxprefix\n  }\n  return table\n}\n\n// find all the words that matches in a given string `str`\nexport function stringsearch (str, word) {\n  // find the prefix table in o(n)\n  const prefixes = maketable(word)\n  const matches = []\n\n  // `j` is the index in `p`\n  let j = 0\n  // `i` is the index in `s`\n  let i = 0\n  while (i < str.length) {\n    // case 1.  s[i] == p[j] so we move to the next index in `s` and `p`\n    if (str.charat(i) === word.charat(j)) {\n      i++\n      j++\n    }\n    // case 2.  `j` is equal to the length of `p`\n    // that means that we reached the end of `p` and thus we found a match\n    // next we have to update `j` because we want to save some time\n    // instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.\n    // j-1 means the last character of `p` because j is actually `p.length`\n    // e.g.\n    // s =  a b a b d e\n    // p = `a b`a b\n    // we will jump to `a b` and we will compare d and a in the next iteration\n    // a b a b `d` e\n    //     a b `a` b\n    if (j === word.length) {\n      matches.push(i - j)\n      j = prefixes[j - 1]\n      // case 3.\n      // s[i] != p[j] there's a mismatch!\n    } else if (str.charat(i) !== word.charat(j)) {\n      // if we  found at least a character in common, do the same thing as in case 2\n      if (j !== 0) {\n        j = prefixes[j - 1]\n      } else {\n        // else j = 0, and we can move to the next character s[i+1]\n        i++\n      }\n    }\n  }\n\n  return matches\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3},{title:"SlidingWindow [滑窗算法]",frontmatter:{title:"SlidingWindow [滑窗算法]",date:"2022-05-01T19:42:37.000Z",permalink:"/algorithm/search/slidingWindow/",categories:["算法","Search 搜索"],tags:[null]},regularPath:"/20.%E7%AE%97%E6%B3%95/20.Search%20%E6%90%9C%E7%B4%A2/80.SlidingWindow.html",relativePath:"20.算法/20.Search 搜索/80.SlidingWindow.md",key:"v-7d885782",path:"/algorithm/search/slidingWindow/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:299},{level:2,title:"伪代码",slug:"伪代码",normalizedTitle:"伪代码",charIndex:306},{level:3,title:"固定窗口",slug:"固定窗口",normalizedTitle:"固定窗口",charIndex:314},{level:3,title:"弹性窗口",slug:"弹性窗口",normalizedTitle:"弹性窗口",charIndex:634},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:1020},{level:3,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:1027},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2770}],headersStr:"介绍 原理 伪代码 固定窗口 弹性窗口 实现 JavaScript 参考",content:"# 介绍\n\n滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。\n\n滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。 滑动窗口主要应用在数组和字符串上。\n\n\n\n可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。\n\n滑动窗口算法更多的是一种 思想 ，而非某种数据结构的使用。\n\n\n# 原理\n\n\n# 伪代码\n\n\n# 固定窗口\n\n//固定窗口大小为 k\nstring s;\n//在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数\nint right = 0;\nwhile(right <s.size()) {\n  window.add(s[right]);\n  right++;\n  //如果符合要求，说明窗口构造完成，\n  if (right>=k) {\n     //这是已经是一个窗口了，根据条件做一些事情\n     //... 可以计算窗口最大值等 \n    //最后不要忘记把 right -k 位置元素从窗口里面移除\n  }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 弹性窗口\n\nstring s, t;\n//在 s 中寻找 t 的「最小覆盖子串」\nint left = 0, right = 0;\nstring res =s;\n\nwhile(right <s.size()) {\n    window.add(s[right]);\n    right++;\n    //如果符合要求，说明窗口构造完成，移动 left 缩小窗口\n    while(window 符合要求) {\n        //如果这个窗口的子串更短，则更新 res\n        res=minLen(res, window);\n        window.remove(s[left]);\n        left++;\n    }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 实现\n\n\n# JavaScript\n\n/**\n* Sliding Window:\n* This pattern involve creating a window which can either be\n* an array or numbers from one position to another.\n*\n* Depending on a certain condition, the window either increases\n* or closes (and a new window is created).\n*\n* Very useful for keeping track of a subset of data in an\n* array/string etc.\n*\n* Time Complexity: Best - O(n);\n*\n* Examples:\n* maxSubarraySum([1,2,5,2,8,1,5],2) // returns 10\n* maxSubarraySum([1,2,5,2,8,1,5],15) // returns null\n* maxSubarraySum([5,2,6,9],3) // returns 17\n * @param {[Int]} arr - An array of integers on which we will perform the test.\n * @param {Int} num - An integer that displays the size of the window you want to check.\n * @returns {Int / Null} - Returns a total of N consecutive numbers or null\n */\n\nfunction slidingWindow (arr, num) {\n  // Edge Case:\n  // If the length of the array shorter than the window size (num) return null.\n  if (arr.length < num) return null\n  // The highest amount of consecutive numbers\n  let maxSum = 0\n  // Temp amount of consecutive numbers - For comparative purposes\n  let tempSum = 0\n  // loop over the array {num} times and save their total amount in {maxSum}\n  for (let i = 0; i < num; i++) {\n    maxSum += arr[i]\n  }\n  // initialize {tempSum} to {maxSum}.\n  tempSum = maxSum\n  // loop over the array n times\n  for (let i = num; i < arr.length; i++) {\n    // Add the next num in the array and remove the first one\n    tempSum = tempSum - arr[i - num] + arr[i]\n    // save the largest number between {maxNum} and {tempNum} in maxSum.\n    maxSum = Math.max(maxSum, tempSum)\n  }\n  return maxSum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 参考\n\n * 滑动窗口算法基本原理与实践",normalizedContent:"# 介绍\n\n滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。\n\n滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。 滑动窗口主要应用在数组和字符串上。\n\n\n\n可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。\n\n滑动窗口算法更多的是一种 思想 ，而非某种数据结构的使用。\n\n\n# 原理\n\n\n# 伪代码\n\n\n# 固定窗口\n\n//固定窗口大小为 k\nstring s;\n//在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数\nint right = 0;\nwhile(right <s.size()) {\n  window.add(s[right]);\n  right++;\n  //如果符合要求，说明窗口构造完成，\n  if (right>=k) {\n     //这是已经是一个窗口了，根据条件做一些事情\n     //... 可以计算窗口最大值等 \n    //最后不要忘记把 right -k 位置元素从窗口里面移除\n  }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 弹性窗口\n\nstring s, t;\n//在 s 中寻找 t 的「最小覆盖子串」\nint left = 0, right = 0;\nstring res =s;\n\nwhile(right <s.size()) {\n    window.add(s[right]);\n    right++;\n    //如果符合要求，说明窗口构造完成，移动 left 缩小窗口\n    while(window 符合要求) {\n        //如果这个窗口的子串更短，则更新 res\n        res=minlen(res, window);\n        window.remove(s[left]);\n        left++;\n    }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 实现\n\n\n# javascript\n\n/**\n* sliding window:\n* this pattern involve creating a window which can either be\n* an array or numbers from one position to another.\n*\n* depending on a certain condition, the window either increases\n* or closes (and a new window is created).\n*\n* very useful for keeping track of a subset of data in an\n* array/string etc.\n*\n* time complexity: best - o(n);\n*\n* examples:\n* maxsubarraysum([1,2,5,2,8,1,5],2) // returns 10\n* maxsubarraysum([1,2,5,2,8,1,5],15) // returns null\n* maxsubarraysum([5,2,6,9],3) // returns 17\n * @param {[int]} arr - an array of integers on which we will perform the test.\n * @param {int} num - an integer that displays the size of the window you want to check.\n * @returns {int / null} - returns a total of n consecutive numbers or null\n */\n\nfunction slidingwindow (arr, num) {\n  // edge case:\n  // if the length of the array shorter than the window size (num) return null.\n  if (arr.length < num) return null\n  // the highest amount of consecutive numbers\n  let maxsum = 0\n  // temp amount of consecutive numbers - for comparative purposes\n  let tempsum = 0\n  // loop over the array {num} times and save their total amount in {maxsum}\n  for (let i = 0; i < num; i++) {\n    maxsum += arr[i]\n  }\n  // initialize {tempsum} to {maxsum}.\n  tempsum = maxsum\n  // loop over the array n times\n  for (let i = num; i < arr.length; i++) {\n    // add the next num in the array and remove the first one\n    tempsum = tempsum - arr[i - num] + arr[i]\n    // save the largest number between {maxnum} and {tempnum} in maxsum.\n    maxsum = math.max(maxsum, tempsum)\n  }\n  return maxsum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 参考\n\n * 滑动窗口算法基本原理与实践",charsets:{cjk:!0},lastUpdated:"2022/06/20, 20:15:04",lastUpdatedTimestamp:1655727304e3}],themeConfig:{nav:[{text:"数据结构",link:"/ds/"},{text:"算法",link:"/algorithm/"},{text:"LeetCode",link:"/leetcode/"},{text:"更多",items:[{text:"关于",link:"/about/"},{text:"导航",link:"https://source.jonsam.site/nav/"}]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]},{text:"设计模式",link:"http://docs.jonsam.site/project-5/"},{text:"博客",link:"https://www.jonsam.site"}],sidebarDepth:1,logo:"/img/logo.png",repo:"jonsam-ng/fancy-dsa",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",category:!0,tag:!0,archive:!0,categoryText:"随笔",titleBadge:!0,contentBgStyle:6,updateBar:{showToArticle:!0,moreArticle:"/archives"},rightMenuBar:!0,sidebarOpen:!0,pageButton:!0,sidebar:{"/10.数据结构/":[["0.index.md","开始上手","/ds/index/"],["1.plan.md","Plan 计划","/ds/plan/"],["3.roadmap.md","Roadmap 路线","/ds/roadmap/"],["4.术语表.md","术语表","/ds/term/"],["5.introduction.md","数据结构简介","/ds/introduction/"],{title:"queue 队列",collapsable:!0,children:[["10.queue 队列/10.queue.md","Queue [队列]","/ds/queue/queue/"],["10.queue 队列/20.priorityQueue.md","PriorityQueue [优先队列]","/ds/queue/priorityQueue/"],["10.queue 队列/30.minPriorityQueue.md","MinPriorityQueue [最小优先队列]","/ds/queue/minPriorityQueue/"],["10.queue 队列/40.maxPriorityQueue.md","MaxPriorityQueue [最大优先队列]","/ds/queue/maxPriorityQueue/"],["10.queue 队列/50.deque.md","Deque(double-ended queue) [双端队列]","/ds/queue/deque/"],["10.queue 队列/60.CircularQueue.md","CircularQueue [循环队列]","/pages/694de4/"]]},{title:"heap 堆",collapsable:!0,children:[["20.heap 堆/10.heap.md","Heap [堆]","/ds/heap/heap/"],["20.heap 堆/20.minHeap.md","MinHeap [最小堆]","/ds/heap/minHeap/"],["20.heap 堆/30.maxHeap.md","MaxHeap [最大堆]","/ds/heap/maxHeap/"]]},{title:"linked-list 链表",collapsable:!0,children:[["30.linked-list 链表/10.linkedList.md","LinkedList [链表]","/ds/linked-list/linkedList/"],["30.linked-list 链表/20.doublyLinkedList.md","DoublyLinkedList [双向链表]","/ds/linked-list/doublyLinkedList"],["30.linked-list 链表/30.SinglyCircularLinkedList.md","SinglyCircularLinkedList [单项循环链表]","/pages/c35641/"]]},{title:"stack 栈",collapsable:!0,children:[["40.stack 栈/10.stack.md","Stack [栈]","/ds/stack/stack/"]]},{title:"set 集合",collapsable:!0,children:[["50.set 集合/10.enhancedSet.md","EnhancedSet [集合]","/ds/set/enhancedSet/"]]},{title:"graph 图",collapsable:!0,children:[["60.graph 图/10.graph.md","Graph [图]","/ds/graph/graph/"],["60.graph 图/20.directedGraph.md","DirectedGraph [有向图]","/ds/graph/directedGraph/"]]},{title:"tree 树",collapsable:!0,children:[["80.tree 树/10.binarySearchTree.md","BinarySearchTree [二叉搜索树]","/ds/tree/binarySearchTree/"],["80.tree 树/20.avlTree.md","AvlTree [AVL树]","/ds/tree/avlTree/"],["80.tree 树/30.trie.md","Trie [前缀树]","/ds/tree/trie/"]]},{title:"vectors 矢量",collapsable:!0,children:[["90.vectors 矢量/10.vector.md","vector [矢量]","/pages/44805c/"]]}],catalogue:{"数据结构":"/ds/","算法":"/algorithm/",LeetCode:"/leetcode/"},"/20.算法/":[["0.index.md","开始上手","/algorithm/index/"],["1.plan.md","Plan 计划","/algorithm/plan/"],["3.roadmap.md","Roadmap 路线","/algorithm/roadmap/"],["4.intro.md","算法简介","/algorithm/introduction/"],{title:"Sort 排序",collapsable:!0,children:[["10.Sort 排序/0.index.md","章节概要","/algorithm/sort/index/"],["10.Sort 排序/10.alphaNumericalSort.md","AlphaNumericalSort [字母顺序排序]","/algorithm/sort/alphaNumericalSort/"],["10.Sort 排序/20.beadSort.md","BeadSort [珠排序]","/algorithm/sort/beadSort/"],["10.Sort 排序/30.bogoSort.md","BogoSort [Bogo 排序]","/algorithm/sort/bogoSort/"],["10.Sort 排序/40.bubbleSort.md","BubbleSort [冒泡排序]","/algorithm/sort/bubbleSort/"],["10.Sort 排序/50.bucketSort.md","BucketSort [桶排序]","/algorithm/sort/bucketSort/"],["10.Sort 排序/60.cocktailShakerSort.md","CocktailShakerSort [鸡尾酒排序]","/algorithm/sort/cocktailShakerSort/"],["10.Sort 排序/70.combSort.md","CombSort [梳排序]","/algorithm/sort/combSort/"],["10.Sort 排序/80.countingSort.md","CountingSort [计数排序]","/algorithm/sort/countingSort/"],["10.Sort 排序/90.cycleSort.md","CycleSort [圈排序]","/algorithm/sort/cycleSort/"],["10.Sort 排序/100.fisherYatesShuffle.md","FisherYatesShuffle [洗牌算法]","/algorithm/sort/fisherYatesShuffle/"],["10.Sort 排序/110.flashSort.md","FlashSort [闪电排序]","/algorithm/sort/flashSort/"],["10.Sort 排序/120.gnomeSort.md","GnomeSort [侏儒排序]","/algorithm/sort/gnomeSort/"],["10.Sort 排序/130.heapSort.md","HeapSort [堆排序]","/algorithm/sort/heapSort/"],["10.Sort 排序/150.insertionSort.md","InsertionSort [插入排序]","/algorithm/sort/insertionSort/"],["10.Sort 排序/160.introSort.md","IntroSort [内省排序]","/algorithm/sort/introSort/"],["10.Sort 排序/170.mergeSort.md","MergeSort [归并排序]","/algorithm/sort/mergeSort/"],["10.Sort 排序/180.oddEvenSort.md","OddEvenSort [奇偶排序]","/algorithm/sort/oddEvenSort/"],["10.Sort 排序/190.pancakeSort.md","PancakeSort [煎饼排序]","/algorithm/sort/pancakeSort/"],["10.Sort 排序/200.pigeonHoleSort.md","PigeonHoleSort [鸽巢排序]","/algorithm/sort/pigeonHoleSort/"],["10.Sort 排序/210.quickSort.md","QuickSort [快速排序]","/algorithm/sort/quickSort/"],["10.Sort 排序/230.radixSort.md","RadixSort [基数排序]","/algorithm/sort/radixSort/"],["10.Sort 排序/240.selectionSort.md","SelectionSort [选择排序]","/algorithm/sort/selectionSort/"],["10.Sort 排序/250.shellSort.md","ShellSort [希尔排序]","/algorithm/sort/shellSort/"],["10.Sort 排序/260.timSort.md","TimSort [Tim 排序]","/algorithm/sort/timSort/"],["10.Sort 排序/270.topologicalSorter.md","TopologicalSorter [拓扑排序器]","/algorithm/sort/topologicalSorter/"],["10.Sort 排序/280.wiggleSort.md","WiggleSort [摆动排序]","/algorithm/sort/wiggleSort/"]]},{title:"Search 搜索",collapsable:!0,children:[["20.Search 搜索/10.BinarySearch.md","BinarySearch [二分搜索]","/algorithm/search/binarySearch/"],["20.Search 搜索/20.ExponentialSearch.md","ExponentialSearch [指数搜索]","/algorithm/search/exponentialSearch/"],["20.Search 搜索/30.FibonacciSearch.md","FibonacciSearch [斐波那契搜索]","/algorithm/search/fibonacciSearch/"],["20.Search 搜索/40.InterpolationSearch.md","InterpolationSearch [插值搜索]","/algorithm/search/interpolationSearch/"],["20.Search 搜索/50.JumpSearch.md","JumpSearch [跳跃搜索]","/algorithm/search/jumpSearch/"],["20.Search 搜索/60.LinearSearch.md","LinearSearch [线性搜索]","/algorithm/search/linearSearch/"],["20.Search 搜索/70.QuickSelectSearch.md","QuickSelectSearch [快速选择搜索]","/algorithm/search/quickSelectSearch/"],["20.Search 搜索/80.SlidingWindow.md","SlidingWindow [滑窗算法]","/algorithm/search/slidingWindow/"],["20.Search 搜索/90.StringSearch.md","StringSearch","/algorithm/search/stringSearch/"],["20.Search 搜索/100.TernarySearch.md","TernarySearch [三元搜索]","/algorithm/search/ternarySearch/"],["20.Search 搜索/110.UnionSearch.md","UnionSearch [合并搜索]","/algorithm/search/unionSearch/"]]},{title:"Recursive 递归",collapsable:!0,children:[["30.Recursive 递归/10.BinaryEquivalent.md","BinaryEquivalent [二进制转化]","/algorithm/recursive/binaryEquivalent/"],["30.Recursive 递归/20.BinarySearch.md","BinarySearch [二分搜索]","/algorithm/recursive/binarySearch/"],["30.Recursive 递归/30.EucledianGCD.md","EuclideanGCD [辗转相除法]","/algorithm/recursive/euclideanGCD/"],["30.Recursive 递归/40.Factorial.md","Factorial [阶乘]","/algorithm/recursive/factorial/"],["30.Recursive 递归/50.FibonacciNumberRecursive.md","FibonacciNumberRecursive [斐波那契数]","/algorithm/recursive/fibonacci/"],["30.Recursive 递归/60.FloodFill.md","FloodFill [Flood Fill算法]","/algorithm/recursive/floodFill/"],["30.Recursive 递归/80.KochSnowflake.md","KochSnowflake [科赫雪花算法]","/algorithm/recursive/kochSnowflake/"],["30.Recursive 递归/90.Palindrome.md","Palindrome [回文]","/algorithm/recursive/palindrome/"],["30.Recursive 递归/110.TowerOfHanoi.md","TowerOfHanoi [汉诺塔]","/algorithm/recursive/towerOfHanoi/"]]},{title:"Graph 图",collapsable:!0,children:[["40.Graph 图/10.BellmanFord.md","BellmanFord [贝尔曼-福特算法]","/algorithm/graph/bellmanFord/"],["40.Graph 图/20.BreadthFirstSearch.md","BreadthFirstSearch [广度优先搜索/BFS]","/algorithm/graph/breadthFirstSearch/"],["40.Graph 图/30.BreadthFirstShortestPath.md","BreadthFirstShortestPath [广度优先寻最短路径]","/algorithm/graph/breadthFirstShortestPath/"],["40.Graph 图/40.ConnectedComponents.md","ConnectedComponents [连通元件]","/algorithm/graph/connectedComponents/"],["40.Graph 图/50.Density.md","Density [图的密度]","/algorithm/graph/density/"],["40.Graph 图/60.DepthFirstSearch.md","DepthFirstSearch [深度优先搜索]","/algorithm/graph/depthFirstSearch/"],["40.Graph 图/80.Dijkstra.md","Dijkstra [迪杰斯特拉算法]","/algorithm/graph/dijkstra/"],["40.Graph 图/100.FloydWarshall.md","FloydWarshall [弗洛伊德算法]","/algorithm/graph/floydWarshall/"],["40.Graph 图/110.KruskalMST.md","KruskalMST [克鲁斯克尔算法]","/algorithm/graph/kruskalMST/"],["40.Graph 图/120.NodeNeighbors.md","NodeNeighbors [节点邻域]","/algorithm/graph/nodeNeighbors/"],["40.Graph 图/130.NumberOfIslands.md","NumberOfIslands [岛屿数量]","/algorithm/graph/numberOfIslands/"],["40.Graph 图/140.PrimMST.md","PrimMST [普林姆算法]","/algorithm/graph/primMST/"]]},{title:"Tree 树",collapsable:!0,children:[["50.Tree 树/10.BreadthFirstTreeTraversal.md","BreadthFirstTreeTraversal [二叉树的广度优先遍历、层序遍历]","/algorithm/tree/breadthFirstTreeTraversal/"],["50.Tree 树/20.DepthFirstSearch.md","DepthFirstSearch [二叉树的深度优先遍历]","/algorithm/tree/depthFirstSearch/"],["50.Tree 树/30.FenwickTree.md","FenwickTree [二叉索引树]","/algorithm/tree/fenwickTree/"]]},{title:"Math 数学",collapsable:!0,children:[["60.Math 数学/10.Abs.md","Abs [绝对值]","/algorithm/math/abs/"],["60.Math 数学/20.AliquotSum.md","AliquotSum [真因数和]","/algorithm/math/aliquotSum/"],["60.Math 数学/30.Area.md","Area [面积]","/algorithm/math/area/"],["60.Math 数学/40.ArithmeticGeometricMean.md","ArithmeticGeometricMean [算术-几何平均数]","/algorithm/math/arithmeticGeometricMean/"],["60.Math 数学/50.ArmstrongNumber.md","ArmstrongNumber [阿姆斯特朗数]","/algorithm/math/armstrongNumber/"],["60.Math 数学/60.AverageMean.md","AverageMean [平均数]","/algorithm/math/averageMean/"],["60.Math 数学/70.AverageMedian.md","AverageMedian [中位数]","/algorithm/math/averageMedian/"],["60.Math 数学/80.BinaryExponentiation.md","BinaryExponentiation [二分求幂]","/algorithm/math/binaryExponentiation/"],["60.Math 数学/90.BisectionMethod.md","BisectionMethod [二分法]","/algorithm/math/bisectionMethod/"],["60.Math 数学/100.BinaryConvert.md","BinaryConvert [二进制转换]","/algorithm/math/binaryConvert/"],["60.Math 数学/120.CheckKishnamurthyNumber.md","CheckKishnamurthyNumber [克里希纳穆尔西数]","/algorithm/math/checkKishnamurthyNumber/"],["60.Math 数学/130.Coordinate.md","Coordinate","/algorithm/math/coordinate/"],["60.Math 数学/140.CoPrimeCheck.md","CoPrimeCheck","/algorithm/math/coPrimeCheck/"],["60.Math 数学/150.DecimalIsolate.md","DecimalIsolate","/algorithm/math/decimalIsolate/"],["60.Math 数学/160.DegreeToRadian.md","DegreeToRadian","/algorithm/math/degreeToRadian/"],["60.Math 数学/170.DecimalExpansion.md","DecimalExpansion","/algorithm/math/decimalExpansion/"]]},{title:"Hash 哈希",collapsable:!0,children:[["70.Hash 哈希/10.SHA1.md","SHA1 [安全散列算法1]","/algorithm/hash/sha1/"],["70.Hash 哈希/20.SHA256.md","SHA256 [SHA256算法]","/algorithm/hash/sha256/"]]},{title:"String 字符串",collapsable:!0,children:[["80.String 字符串/10.AlphaNumericPalindrome.md","AlphaNumericPalindrome [回文串]","/algorithm/string/alphaNumericPalindrome/"],["80.String 字符串/20.AlternativeStringArrange.md","AlternativeStringArrange [交替合并字符串]","/algorithm/string/alternativeStringArrange/"],["80.String 字符串/30.BoyerMoore.md","BoyerMoore [博耶-穆尔字符串搜索算法、BM 算法]","/algorithm/string/boyerMoore/"],["80.String 字符串/40.CheckAnagram.md","CheckAnagram [易位构词]","/algorithm/string/checkAnagram/"],["80.String 字符串/50.NamingConvention.md","NamingConvention [命名规则]","/algorithm/string/namingConvention/"],["80.String 字符串/60.CheckExceeding.md","CheckExceeding [Exceeding words]","/algorithm/string/checkExceeding/"],["80.String 字符串/70.CheckPangram.md","CheckPangram [全字母句]","/algorithm/string/checkPangram/"],["80.String 字符串/80.CheckWordOccurrence.md","CheckWordOccurrence [单词计数]","/algorithm/string/checkWordOccurrence/"],["80.String 字符串/90.CountVowels.md","CountVowels [元音字母计数]","/algorithm/string/countVowels/"],["80.String 字符串/100.CreatePermutations.md","CreatePermutations [全排列]","/algorithm/string/createPermutations/"],["80.String 字符串/110.DiceCoefficient.md","DiceCoefficient [Dice系数]","/algorithm/string/diceCoefficient/"],["80.String 字符串/120.FormatPhoneNumber.md","FormatPhoneNumber [格式化电话号码]","/algorithm/string/formatPhoneNumber/"],["80.String 字符串/130.GenerateGuid.md","GenerateGUID [生成GUID、UUID]","/algorithm/string/generateGUID/"],["80.String 字符串/140.HammingDistance.md","HammingDistance [汉明距离]","/algorithm/string/hammingDistance/"],["80.String 字符串/150.KMPPatternSearching.md","KMPPatternSearching [KMP字符串匹配]","/algorithm/string/KMPPatternSearching/"]]},{title:"BitManipulation 位操纵",collapsable:!0,children:[["90.BitManipulation 位操纵/10.BinaryCountSetBits.md","BinaryCountSetBits [二进制串数1]","/algorithm/bit/binaryCountSetBits/"],["90.BitManipulation 位操纵/20.PowerOfTwo.md","PowerOfTwo [2的幂]","/algorithm/bit/powerOfTwo/"],["90.BitManipulation 位操纵/30.SetBit.md","SetBit [位操作]","/algorithm/bit/setBit/"]]},{title:"Backtracking 回溯",collapsable:!0,children:[["100.Backtracking 回溯/10.AllCombinationsOfSizeK.md","AllCombinationsOfSizeK [全组合]","/algorithm/backtracking/allCombinationsOfSizeK/"],["100.Backtracking 回溯/20.GeneratePermutations.md","GeneratePermutations [排列]","/algorithm/backtracking/generatePermutations/"],["100.Backtracking 回溯/30.KnightTour.md","KnightTour [骑士巡逻]","/algorithm/backtracking/knightTour/"],["100.Backtracking 回溯/40.NQueen.md","NQueens [N皇后问题]","/algorithm/backtracking/nQueens/"],["100.Backtracking 回溯/50.RatInAMaze.md","RatInAMaze [迷宫之鼠]","/algorithm/backtracking/ratInAMaze/"],["100.Backtracking 回溯/60.Sudoku.md","Sudoku [数独]","/algorithm/backtracking/sudoku/"],["100.Backtracking 回溯/70.SumOfSubset.md","SumOfSubset [子集之和]","/algorithm/backtracking/sumOfSubset/"]]},{title:"DynamicProgramming 动态规划",collapsable:!0,children:[["110.DynamicProgramming 动态规划/10.ClimbingStairs.md","ClimbingStairs [爬楼梯]","/algorithm/dp/climbingStairs/"],["110.DynamicProgramming 动态规划/20.CoinChange.md","CoinChange [钱币兑换]","/algorithm/dp/coinChange/"],["110.DynamicProgramming 动态规划/30.EditDistance.md","EditDistance [编辑距离]","/algorithm/dp/editDistance/"],["110.DynamicProgramming 动态规划/40.FibonacciNumber.md","FibonacciNumber [斐波那契数]","/algorithm/dp/fibonacciNumber/"],["110.DynamicProgramming 动态规划/50.FindMonthCalendar.md","FindMonthCalendar [月历]","/algorithm/dp/findMonthCalendar/"],["110.DynamicProgramming 动态规划/60.KadaneAlgo.md","KadaneAlgo [最大连续子数组和之Kadane算法]","/algorithm/dp/kadaneAlgo/"],["110.DynamicProgramming 动态规划/70.LevenshteinDistance.md","LevenshteinDistance [莱文斯坦距离]","/algorithm/dp/levenshteinDistance/"],["110.DynamicProgramming 动态规划/80.LongestCommonSubsequence.md","LongestCommonSubsequence [最长公共子序列]","/algorithm/dp/longestCommonSubsequence/"],["110.DynamicProgramming 动态规划/90.LongestIncreasingSubsequence.md","LongestIncreasingSubsequence [最长递增子序列]","/algorithm/dp/longestIncreasingSubsequence/"],["110.DynamicProgramming 动态规划/100.LongestPalindromicSubsequence.md","LongestPalindromicSubsequence [最长回文子序列]","/algorithm/dp/longestPalindromicSubsequence/"],["110.DynamicProgramming 动态规划/110.LongestValidParentheses.md","LongestValidParentheses [最长合法括号]","/algorithm/dp/longestValidParentheses/"],["110.DynamicProgramming 动态规划/120.MaxNonAdjacentSum.md","MaxNonAdjacentSum [最大非连接子集和]","/algorithm/dp/maxNonAdjacentSum/"],["110.DynamicProgramming 动态规划/130.MaxProductOfThree.md","MaxProductOfThree [最大三数积]","/algorithm/dp/maxProductOfThree/"],["110.DynamicProgramming 动态规划/140.MinimumCostPath.md","MinimumCostPath [最小代价路径]","/algorithm/dp/minimumCostPath/"],["110.DynamicProgramming 动态规划/150.NumberOfSubsetEqualToGivenSum.md","NumberOfSubsetEqualToGivenSum [等和子集]","/algorithm/dp/numberOfSubsetEqualToGivenSum/"],["110.DynamicProgramming 动态规划/160.RodCutting.md","RodCutting [棒材切割问题]","/algorithm/dp/rodCutting/"],["110.DynamicProgramming 动态规划/170.Shuf.md","Shuf [随机样本]","/algorithm/dp/shuf/"],["110.DynamicProgramming 动态规划/180.SieveOfEratosthenes.md","SieveOfEratosthenes [埃拉托斯特尼筛法]","/algorithm/dp/180SieveOfEratosthenes/"],["110.DynamicProgramming 动态规划/190.SlidingWindow.md","SlidingWindow [滑窗]","/algorithm/dp/slidingWindow/"],["110.DynamicProgramming 动态规划/200.SudokuSolver.md","SudokuSolver [数独]","/algorithm/dp/sudokuSolver/"],["110.DynamicProgramming 动态规划/210.TrappingRainWater.md","TrappingRainWater [接住雨水]","/algorithm/dp/trappingRainWater/"],["110.DynamicProgramming 动态规划/220.TribonacciNumber.md","TribonacciNumber [翠波那契数]","/algorithm/dp/tribonacciNumber/"],["110.DynamicProgramming 动态规划/230.ZeroOneKnapsack.md","ZeroOneKnapsack  [零一背包]","/algorithm/dp/zeroOneKnapsack/"]]},{title:"Cache 缓存",collapsable:!0,children:[["120.Cache 缓存/10.LFUCache.md","LFUCache [最近最少使用缓存]","/algorithm/cache/LFUCache/"],["120.Cache 缓存/20.LRUCache.md","LRUCache [最近最久未使用缓存]","/algorithm/cache/LRUCache/"],["120.Cache 缓存/30.Memoize.md","Memoize [缓存函数]","/algorithm/cache/memoize/"]]},{title:"Array 数组",collapsable:!0,children:[["130.Array 数组/10.LocalMaxPoint.md","LocalMaxPoint [局部最值]","/algorithm/array/localMaxPoint/"],["130.Array 数组/140.QuickSelect.md","QuickSelect [快速选择]","/algorithm/array/quickSelect/"]]},{title:"Ciphers 密码学",collapsable:!0,children:[["140.Ciphers 密码学/10.Atbash.md","Atbash","/algorithm/cipher/atbash/"],["140.Ciphers 密码学/20.CaesarsCipher.md","CaesarsCipher","/algorithm/cipher/caesarsCipher/"],["140.Ciphers 密码学/30.KeyFinder.md","KeyFinder","/algorithm/cipher/keyFinder/"],["140.Ciphers 密码学/40.KeywordShiftedAlphabet.md","KeywordShiftedAlphabet","/algorithm/cipher/keywordShiftedAlphabet/"],["140.Ciphers 密码学/50.ROT13.md","ROT13","/algorithm/cipher/ROT13/"],["140.Ciphers 密码学/60.VigenereCipher.md","VigenereCipher","/algorithm/cipher/vigenereCipher/"],["140.Ciphers 密码学/70.XORCipher.md","XORCipher","/algorithm/cipher/XORCipher/"]]},{title:"Conversions 转换",collapsable:!0,children:[["150.Conversions 转换/10.Part1.md","算法与转换：Part1","/algorithm/conversion/p1/"]]},{title:"ProjectEuler 欧拉计划",collapsable:!0,children:[["160.ProjectEuler 欧拉计划/0.index.md","欧拉计划","/algorithm/euler/index/"]]},{title:"其他",collapsable:!0,children:[["200.其他/10.ConwaysGameOfLife.md","ConwaysGameOfLife [康威生命游戏]","/algorithm/more/conwaysGameOfLife/"]]}],"/30.LeetCode/":[["0.index.md","开始上手","/leetcode/index/"],["1.plan.md","Plan 计划","/leetcode/plan/"],["2.roadmap.md","Roadmap 路线","/leetcode/roadmap/"],{title:"力扣习题集",collapsable:!0,children:[["10.力扣习题集/0.index.md","本章导读","/leetcode/problems/index/"],["10.力扣习题集/10.0-20.md","0-20题解","/leetcode/problems/0/"]]}],"/999.目录/":[["10.数据结构.md","数据结构","/ds/"],["20.算法.md","算法","/algorithm/"],["30.LeetCode.md","LeetCode","/leetcode/"]]},author:{name:"jonsam",link:"https://github.com/jonsam-ng"},blogger:{avatar:"https://www.jonsam.site/wp-content/uploads/2019/10/c1fbc401c64937aaec6cb53359e7c57eabd8e477-e1570649725791.gif",name:"Jonsam NG",slogan:"想的更多，也要想的更远"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:jonsam.ng@foxmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/jonsam-ng"},{iconClass:"icon-mao",title:"博客",link:"https://www.jonsam.site"},{iconClass:"icon-shuben",title:"文档",link:"http://docs.jonsam.site"},{iconClass:"icon-code",title:"源码",link:"https://source.jonsam.site"}]},footer:{createYear:2022,copyrightInfo:'Fancy DSA | Made by <a href="https://www.jonsam.site" target="_blank">Jonsam</a> by ❤'},htmlModules:{}},locales:{"/":{lang:"zh-CN",title:"Fancy DSA",description:"数据结构与算法，LeetCode刷题笔记，算法成长之路",path:"/"}}};var jt=t(50),_t=t(103);let Tt=!1;var Et={data:()=>({qr:null}),updated(){if(!Tt||!this.qr)return;const n=document.querySelector(".nav-links"),e=document.querySelector(".qrcodeBtn");null!=n&&null==e&&this.$nextTick(()=>{const e=document.createElement("DIV");e.className+="nav-item",e.appendChild(this.qr.$el),n.appendChild(e)})},mounted(){if(this.qr||Tt)return;Tt=!0;const n=new(r.default.extend(_t.default));n.$mount(),this.qr=n}};let Ct=!1;var It={mounted(){Ct||(window.addEventListener("unload",this.saveLastReading),Ct=!0)},methods:{saveLastReading(){localStorage.setItem("lastReading",JSON.stringify({path:this.$route.path,scrollTop:document.documentElement.scrollTop,timestamp:(new Date).getTime()}))}}};let zt=!1;var At={mounted(){zt||(t.e(200).then(t.t.bind(null,360,7)).then((function(n){r.default.use(n.default,{lang:"zh-CN"})})),zt=!0)}},Pt=t(49),Ot=t(104),qt=t(105),Lt=t(12);var Nt={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(Lt.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(Lt.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Lt.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object(Lt.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(Lt.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};r.default.component(Ot.default),r.default.component(qt.default);function Dt(n){return n.toString().padStart(2,"0")}t(255);r.default.component("Bilibili",()=>Promise.resolve().then(t.bind(null,49))),r.default.component("BlockToggle",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,366))),r.default.component("Card",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,367))),r.default.component("GlobalTip",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,368))),r.default.component("LastReadingPopup",()=>Promise.resolve().then(t.bind(null,50))),r.default.component("Pdf",()=>Promise.all([t.e(0),t.e(3),t.e(7)]).then(t.bind(null,369))),r.default.component("QrCode",()=>Promise.resolve().then(t.bind(null,103))),r.default.component("VideoPlayer",()=>t.e(10).then(t.bind(null,370))),r.default.component("Badge",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,557))),r.default.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,104))),r.default.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,105)));t(256),t(257);var Bt=t(102),Mt=t.n(Bt),Rt=t(30);let Ft,Ut;var Vt;"valine"===(Vt="gitalk")?t.e(199).then(t.t.bind(null,361,7)).then(n=>Ut=n.default):"gitalk"===Vt&&Promise.all([t.e(0),t.e(198)]).then(t.t.bind(null,362,7)).then(()=>t.e(197).then(t.t.bind(null,363,7))).then(n=>Ft=n.default);function Jt(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=Mt.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Rt.name}@v${Rt.version}:`,Rt.homepage);const Ht={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Ft(Jt({clientID:"9f6676a82c6134301680",clientSecret:"4bbf7178807c1a1d2c7b91080e0bd25bcb72a089",repo:"fancy-machine-learnning",owner:"jonsam-ng",admin:["jonsam-ng"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Ut({...Jt({clientID:"9f6676a82c6134301680",clientSecret:"4bbf7178807c1a1d2c7b91080e0bd25bcb72a089",repo:"fancy-machine-learnning",owner:"jonsam-ng",admin:["jonsam-ng"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},$t="vuepress-plugin-comment";let Gt=null;function Wt(n){return Ht.gitalk.clear($t)}function Kt(n){return!1!==n.comment&&!1!==n.comments}function Qt(n){clearTimeout(Gt);if(document.querySelector("main.page"))return Ht.gitalk.render(n,$t);Gt=setTimeout(()=>Qt(n),200)}var Zt={mounted(){Gt=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Wt()&&Kt(n)&&Qt(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Wt()&&Kt(t)&&Qt(t)})}},Xt=Object(wt.a)(Zt,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Yt=(t(263),t(264),!0),nr="lazy",er="200px",tr=[({Vue:n,options:e,router:t,siteData:r,isServer:i})=>{n.component(jt.default.name,jt.default),n.component(Pt.default.name,Pt.default),n.mixin(It),n.mixin(Et),n.mixin(At)},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Dt(n.getUTCMonth()+1)}-${Dt(n.getUTCDate())} ${Dt(n.getUTCHours())}:${Dt(n.getUTCMinutes())}:${Dt(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Nt)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?7063d9cab573593f52f061c7858ce6bd";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Xt)},{},({Vue:n})=>{n.mixin({data:()=>({$io:void 0}),mounted(){const n=document.querySelectorAll("img."+nr);Yt&&"loading"in HTMLImageElement.prototype?n.forEach(n=>{!n.getAttribute("src")&&n.setAttribute("src",n.getAttribute("data-src"))}):(this.setObserver(),n.forEach(n=>{this.$io.observe(n)}))},methods:{setObserver(){this.$io=new IntersectionObserver(n=>{n.forEach(n=>{if(n.isIntersecting){const e=this.getSrc(n.target);e&&(n.target.src=e),this.$io.unobserve(n.target)}})},{rootMargin:er})},getSrc(n){if(n.dataset)return n.dataset.src;{const e=n.attributes.find(n=>"data-src"===n.nodeName);return e&&e.nodeValue}}}})}],rr=["Comment","LastReadingPopup","GlobalTip","BlockToggle"];class ir extends class{constructor(){this.store=new r.default({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){r.default.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(ir.prototype,{getPageAsyncComponent:ce,getLayoutAsyncComponent:he,getAsyncComponent:ue,getVueComponent:de});var ar={install(n){const e=new ir;n.$vuepress=e,n.prototype.$vuepress=e}};function or(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var sr={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return me("pageKey",e),r.default.component(e)||r.default.component(e,ce(e)),r.default.component(e)?n(e):n("")}},lr={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},cr={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},hr=(t(265),t(266),Object(wt.a)(cr,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),ur={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};r.default.config.productionTip=!1,r.default.use(Gn),r.default.use(ar),r.default.mixin(function(n,e,t=r.default){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const i=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},St)),r.default.component("Content",sr),r.default.component("ContentSlotsDistributor",lr),r.default.component("OutboundLink",hr),r.default.component("ClientOnly",ur),r.default.component("Layout",he("Layout")),r.default.component("NotFound",he("NotFound")),r.default.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"c5538cc"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:St.routerBase||St.base,t=new Gn({base:e,mode:"history",fallback:!1,routes:kt,scrollBehavior:(n,e,t)=>t||(n.hash?!r.default.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(or(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";or(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";or(n,i)?r(i):or(n,t)?r(t):r()}})}(t);const i={};try{await Promise.all(tr.filter(n=>"function"==typeof n).map(e=>e({Vue:r.default,options:i,router:t,siteData:St,isServer:n})))}catch(n){console.error(n)}return{app:new r.default(Object.assign(i,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},rr.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);