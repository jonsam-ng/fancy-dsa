---
title: 0-20题解
date: 2022-10-31 17:16:18
permalink: /leetcode/problems/0/
categories:
  - LeetCode
  - 力扣习题集
tags:
  - 
---

<!-- markdownlint-disable no-duplicate-header -->

## [1.Two Sum](https://leetcode.com/problems/two-sum/)

两数之和：

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

### Description

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/)

Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.

You can return the answer in any order.

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

**Constraints:**

* 2 <= nums.length <= 10<sup>4</sup>
* -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>
* -10<sup>9</sup> <= target <= 10<sup>9</sup>
* **Only one valid answer exists.**

**Follow-up:** Can you come up with an algorithm that is less than O(n<sup>2</sup>) time complexity?

### Solution

Language: **JavaScript**

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  const hash = {};
  const hit = (n) => {
    const i = hash[target - n];
    return [i !== undefined, i];
  };
​
  for (let i = 0; i < nums.length; i++) {
    const n = nums[i],
      [isHit, i0] = hit(n);
    if (isHit) return [i0, i];
    hash[n] = i;
  }
};
```

## [2.Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)

两数相加：

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

### Description

Difficulty: **Medium**  

Related Topics: [Linked List](https://leetcode.com/tag/linked-list/), [Math](https://leetcode.com/tag/math/), [Recursion](https://leetcode.com/tag/recursion/)

You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:**

![image](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

**Example 2:**

```
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:**

```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

**Constraints:**

* The number of nodes in each linked list is in the range `[1, 100]`.
* `0 <= Node.val <= 9`
* It is guaranteed that the list represents a number that does not have leading zeros.

### Solution

Language: **JavaScript**

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
  let v1 = null,
    v2 = null,
    n = 0,
    v = 0;
  (head = new ListNode()), (current = head), l1, l2;
  while (l1 !== null || l2 !== null || n !== 0) {
    [v1, v2] = [l1, l2].map((p) => p?.val ?? 0);
    [l1, l2] = [l1, l2].map((p) => p?.next ?? null);
    [v, n] = [(v1 + v2 + n) % 10, ((v1 + v2 + n) / 10) | 0];
    current = current.next = new ListNode(v);
  }
  return head.next;
};
​
    v = 0;
```

## [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/submissions/)

无重复字符的最长子串：

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串**的长度。

### Description

Difficulty: **Medium**  

Related Topics: [Hash Table](https://leetcode.com/tag/hash-table/), [String](https://leetcode.com/tag/string/), [Sliding Window](https://leetcode.com/tag/sliding-window/)

Given a string `s`, find the length of the **longest** <span data-keyword="substring-nonempty">**substring**</span> without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

* 0 <= s.length <= 5 * 10<sup>4</sup>
* `s` consists of English letters, digits, symbols and spaces.

### Solution

Language: **JavaScript**

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  const len = s.length;
  if (!len) return 0;
  let w = "",
    max = 0,
    l = 0,
    r = l;
​
  while (l < len) {
    const c = s.charAt(r),
      idx = w.indexOf(c);
    if (idx !== -1) {
      w = w.slice(idx + 1);
      l += idx + 1;
    }
    w += c;
    r++;
    max = Math.max(max, w.length);
  }
  return max;
};
​
```

## [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/)

寻找两个正序数组的中位数：

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

### Description

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Binary Search](https://leetcode.com/tag/binary-search/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/)

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

**Example 1:**

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**

```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Constraints:**

* `nums1.length == m`
* `nums2.length == n`
* `0 <= m <= 1000`
* `0 <= n <= 1000`
* `1 <= m + n <= 2000`
* -10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup>

### Solution

Language: **JavaScript**

```javascript
var findMedianSortedArrays = function (nums1, nums2) {
  let prev,
      cur,
      i = 0;
  const mid = (nums1.length + nums2.length + 1) / 2;
​
  while (nums1.length || nums2.length) {
    prev = cur;
    i++;
    const [n1, n2] = [nums1[0], nums2[0]];
    const [nums, n] = n2 === undefined || n1 <= n2 ? [nums1, n1] : [nums2, n2];
    nums.shift();
    cur = n;
    if (i >= mid) break;
  }
​
  return i === mid ? cur : (prev + cur) / 2;
};
​
```

## [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/submissions/)

最长回文子串：

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

### Description

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)

Given a string `s`, return _the longest_ <span data-keyword="palindromic-string">_palindromic_</span> <span data-keyword="substring-nonempty">_substring_</span> in `s`.

**Example 1:**

```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```

**Example 2:**

```
Input: s = "cbbd"
Output: "bb"
```

**Constraints:**

* `1 <= s.length <= 1000`
* `s` consist of only digits and English letters.

### Solution

Language: **JavaScript**

```javascript
var longestPalindrome = function (s) {
  const len = s.length,
        dp = new Array(len).fill(null).map(r => new Array(len).fill(null));
  let lp = "";
​
  for (let i = len - 1; i >= 0; i--) {
    for (let j = 0; j < len; j++) {
      const isLP = dp[i][j] = s[i] === s[j] && (j - i <= 2 || dp[i + 1][j - 1]);
​
      if (isLP && j - i + 1 >= lp.length) {
        lp = s.substring(i, j + 1);
      }
    }
  }
​
  return lp;
};
```

## [6. Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/submissions/)

Z 字形变换：

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

### Description

Difficulty: **Medium**  

Related Topics: [String](https://leetcode.com/tag/string/)

The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

```
P   A   H   N
A P L S I I G
Y   I   R
```

And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:

```
string convert(string s, int numRows);
```

**Example 1:**

```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```

**Example 2:**

```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
```

**Example 3:**

```
Input: s = "A", numRows = 1
Output: "A"
```

**Constraints:**

* `1 <= s.length <= 1000`
* `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.
* `1 <= numRows <= 1000`

### Solution

Language: **JavaScript**

![image](https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/2022/image.57iif1zsjrk0.webp)

```javascript
var convert = function (s, numRows) {
  if (!s || numRows <= 0) return "";
  if (numRows === 1) return s;
  const len = s.length,
        size = 2 * numRows - 2;
  let rst = "";
​
  for (let i = 0; i < numRows; i++) {
    for (let j = i; j < len; j += size) {
      rst += s.charAt(j);
​
      if (![0, numRows - 1].includes(i)) {
        const index = size - 2 * i + j;
        if (index < len) rst += s.charAt(index);
      }
    }
  }
​
  return rst;
};
​
```

## [7. Reverse Integer](https://leetcode.com/problems/reverse-integer/submissions/)

整数反转：

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2<sup>31</sup>,  2<sup>31 </sup>− 1] ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

### Description

Difficulty: **Medium**  

Related Topics: [Math](https://leetcode.com/tag/math/)

Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then return `0`.

**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**

**Example 1:**

```
Input: x = 123
Output: 321
```

**Example 2:**

```
Input: x = -123
Output: -321
```

**Example 3:**

```
Input: x = 120
Output: 21
```

**Constraints:**

* -2<sup>31</sup> <= x <= 2<sup>31</sup> - 1

### Solution

Language: **JavaScript**

```javascript
var reverse = function (x) {
  let t = 0;
​
  while (x !== 0) {
    t = t * 10 + x % 10;
    x = ~~(x / 10);
  }
​
  if (t > Math.pow(2, 31) - 1 || t < -Math.pow(2, 31)) return 0;
  return t;
};
​
```

或者：

```js
var reverse = function (x) {
  const max = Math.pow(2, 31),
        isMinus = x < 0;
  if (Math.abs(x) < 10) return x;
  const n = Number(Math.abs(x).toString().split("").reverse().join(""));
  if (n < -max || n > max - 1) return 0;
  return isMinus ? -n : n;
};
```
